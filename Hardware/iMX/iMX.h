/***********************************************************************
    Mark Butcher    Bsc (Hons) MPhil MIET

    M.J.Butcher Consulting
    Birchstrasse 20f,    CH-5406, RÃ¼tihof
    Switzerland

    www.uTasker.com    Skype: M_J_Butcher

    ---------------------------------------------------------------------
    File:      iMX.h
    Project:   Single Chip Embedded Internet
    ---------------------------------------------------------------------
    Copyright (C) M.J.Butcher Consulting 2004..2020
    *********************************************************************

*/

#if defined _WINDOWS
    #define _SIM_PORT_CHANGE(port) fnSimPorts(port)
    #define _SIM_PER_CHANGE      fnSimPers()
    #define _EXCEPTION(x)        *(unsigned char *)0 = 0                 // generate exception when simulating
    #define _SIM_PORTS           fnSimPorts(-1)

    extern unsigned char *fnGetIMX_OPTstart(void);
    extern unsigned long fnGetIMX_OPTsize(void);
    extern void fnGetSW_GP2(unsigned char ucKey[16]);
    extern void fnProgramOTP(void);
    extern void fnUpdateShadowRegisters(void);
    #define PROGRAM_OTP()             fnProgramOTP()
    #define UPDATE_SHADIW_REGISTERS() fnUpdateShadowRegisters()
#else
    #if defined _COMPILE_IAR
        #include <intrinsics.h>                                          // for __disable_interrupt(), __enable_interrupt() and __sleep_mode(), etc.
    #endif
    #define _SIM_PORT_CHANGE(x)
    #define _SIM_PER_CHANGE
    #define _EXCEPTION(x)                                                // ignore on target
    #define _SIM_PORTS
    #define PROGRAM_OTP()
    #define UPDATE_SHADIW_REGISTERS()
#endif

extern void _fnSetClock1Output(unsigned long ulClockSource, unsigned char ucDivide);
extern void _fnSetClock2Output(unsigned long ulClockSource, unsigned char ucDivide);
extern unsigned char *fnGetPersistentMemory(void);
extern void fnGetFlexRAM_banks(unsigned char *ptr_ucInstructionBanks, unsigned char *ptr_ucDataBanks);
extern void fnGetDecryptionKey(unsigned long *ptrScrambler);
extern void fnDecryptKey(unsigned long *ptrKeys, unsigned long *ptrScrambler);
extern int OCOTP_WriteFuseShadowRegister(unsigned long ulAddress, unsigned long *ulData, int iNumber);
extern void OCOTP_ReadFuseShadowRegister(unsigned long ulAddress, unsigned long *ptr_ulData, int iNumber);
#if defined iMX_RT1011
    extern unsigned char fnSynchronisedByteRead(const unsigned char *ptrByte);
#endif
extern void fnCommandCache(unsigned char ucCommands);
    #define INSTRUCTION_CACHE_ENABLE           0x01
    #define INSTRUCTION_CACHE_DISABLE          0x02
    #define DATA_CACHE_ENABLE                  0x04
    #define DATA_CACHE_DISABLE                 0x08
    #define INSTRUCTION_CACHE_INVALIDATE       0x10
    #define DATA_CACHE_INVALIDATE              0x20





/* =================================================================== */
/*                           struct packing control                    */
/* =================================================================== */

#if defined _GNU
    #define _PACK      __attribute__((__packed__))
#else
    #define _PACK
#endif
#if defined _CODE_WARRIOR_CF  
    #define __PACK_ON  #pragma pack(1) 
    #define __PACK_OFF #pragma pack() 
#elif defined _COMPILE_GHS
    #define __PACK_ON
    #define __PACK_OFF
#else
    #define __PACK_ON 
    #define __PACK_OFF 
#endif


#define _MALLOC_ALIGN                                                    // support malloc with align option since LAN memory should be on specific boundary
#define _ALIGN_HEAP_4                                                    // ensure long word alignment
#define _LITTLE_ENDIAN                                                   // compile project in LITTLE ENDIAN mode since the iMX is fixed in this mode

#define DEVICE_WITHOUT_INTERNAL_FLASH                                    // although hthe i.MX RT 1064 has internal flash it is an on-chip QSPI flash rather than being internal to the processor
#define SAVE_COMPLETE_FLASH                                              // when simulating, save complete flash contents and not just the file system contents

#define CAST_POINTER_ARITHMETIC unsigned long                            // iMX uses 32 bit pointers

// Mask/errata management  
//
#include "iMX_errata.h"                                                  // include erratas for the mask being used

#define ARM_MATH_CM7                                                     // cortex-M7


// Fast GPIO cnfiguration
//
#if defined iMX_RT106X
    #define FAST_GPIO_AVAILABLE                                          // GPIO1,2,3 pads can be optionally connected to GPIO6,7,8 for faster operation
#endif

// CAN configuration
//
#if defined iMX_RT106X
    #define NUMBER_OF_CAN_INTERFACES    3
#elif defined iMX_RT102X || defined iMX_RT105X
    #define NUMBER_OF_CAN_INTERFACES    2
#else
    #define NUMBER_OF_CAN_INTERFACES    0
#endif

// SEMC (Smart External Memory Controller)
//
#if !defined iMX_RT1011 && !defined iMX_RT1015
    #define SEMC_AVAILABLE
#endif
#if !defined iMX_RT1011
    #define SEMC_CLK_AVAILABLE
#endif

#if _EXTERNAL_CLOCK != 24000000
    #error "The i.MX RT external crystal /oscillator frequency must be 24MHz!!"
#endif

// LCD configuration
//
#if defined iMX_RT1052 || defined iMX_RT1062 || defined iMX_RT1064
    #define ENHANCED_LCD_INTERFACE
#endif


// i.MX RT 101X, 102X
//
#if defined iMX_RT105X || defined iMX_RT106X
    #define ARM_PLL_AVAILABLE
    #define iMX_PLL1             ((_EXTERNAL_CLOCK/2) * ARM_PLL_MULTIPLIER)
#endif

#if defined PLL2_FREQUENCY && (PLL2_FREQUENCY != 528000000)
    #define iMX_PLL2             PLL2_FREQUENCY
    #if (PLL2_FREQUENCY < 528000000) || (PLL2_FREQUENCY > 552000000)
        #error "PLL2 frequency invalid!!"
    #endif
#else
    #define iMX_PLL2             528000000                               // fixed 528MHz
#endif
#define iMX_PLL3                 480000000

#if defined VIDEO_PLL_LOOP_DIVIDER
    #if VIDEO_PLL_LOOP_DIVIDER < 27 || VIDEO_PLL_LOOP_DIVIDER > 54
        #error "Video PLL loop divide value must be between 27 and 54!!"
    #endif
    #if VIDEO_PLL_LOOP_DENOMINATOR < VIDEO_PLL_LOOP_NUMERATOR
        #error "Video denominator may not be smaller than the nominator!!"
    #endif
    #if (VIDEO_PLL_LOOP_NUMERATOR == 0) || ((VIDEO_PLL_LOOP_DENOMINATOR/1000) == 0)
        #define iMX_PLL5         ((_EXTERNAL_CLOCK * (VIDEO_PLL_LOOP_DIVIDER))/PLL5_POST_DIVIDE) // video PLL
    #else
        #if VIDEO_PLL_LOOP_NUMERATOR > 0x3fffffff
            #error "VIDEO_PLL_LOOP_NUMERATOR range is 0..0x3fffffff"
        #endif
        #if VIDEO_PLL_LOOP_DENOMINATOR > 0x3fffffff
            #error "VIDEO_PLL_LOOP_DENOMINATOR range is 0..0x3fffffff"
        #endif
        #define iMX_PLL5         ((((_EXTERNAL_CLOCK/1000000) * ((VIDEO_PLL_LOOP_DIVIDER * 1000) + (VIDEO_PLL_LOOP_NUMERATOR/(VIDEO_PLL_LOOP_DENOMINATOR/1000)))) * 1000)/PLL5_POST_DIVIDE) // video PLL
    #endif
#endif




#define iMX_PLL6                 500000000
#define SYSTEM_PLL         iMX_PLL2
#define SYSTEM_PLL_FREQUENCY     (SYSTEM_PLL)
#define USB1_PLL           iMX_PLL3                                      // 480MHz
#define USB1_PLL_FREQUENCY       iMX_PLL3                                // this must be operated at this frequency only
#define AUDIO_PLL          iMX_PLL4
#define AUDIO_PLL_FREQUENCY_LOW  650000000
#define AUDIO_PLL_FREQUENCY_HIGH 1300000000
#define ENET_PLL           iMX_PLL6                                      // also used as ARM reference clock (programmable to 25MHz, 50MHz, 100MHz or 125MHz)

#if !defined PLL2_PFD0_FRACTION
    #define PLL2_PFD0_FRACTION     27                                    // PLL2-PFD0 default is 352MHz
#endif
#if !defined PLL2_PFD1_FRACTION
    #define PLL2_PFD1_FRACTION     16                                    // PLL2-PFD1 default is 594MHz
#endif
#if !defined PLL2_PFD2_FRACTION
    #define PLL2_PFD2_FRACTION     24                                    // PLL2-PFD2 default is 396MHz
#endif
#if !defined PLL2_PFD3_FRACTION
    #define PLL2_PFD3_FRACTION     32                                    // PLL2-PFD3 default is 297MHz
#endif

#if !defined PLL3_PFD0_FRACTION
    #define PLL3_PFD0_FRACTION     12                                    // PLL3-PFD0 default is 720MHz
#endif
#if !defined PLL3_PFD1_FRACTION
    #define PLL3_PFD1_FRACTION     13                                    // PLL3-PFD1 default is 664.62MHz
#endif
#if !defined PLL3_PFD2_FRACTION
    #define PLL3_PFD2_FRACTION     17                                    // PLL3-PFD2 default is 508.24MHz
#endif
#if !defined PLL3_PFD3_FRACTION
    #define PLL3_PFD3_FRACTION     19                                    // PLL3-PFD3 default is 454.74MHz
#endif

#if defined iMX_RT1011 || !defined PERIPH_CLK_SOURCE_OSC_DIVIDE
    #define PERIPH_CLK_SOURCE_OSC_DIVIDE 1
#endif
#if defined PERIPH_CLK_SOURCE_OSC && ((PERIPH_CLK_SOURCE_OSC_DIVIDE > 8) || (PERIPH_CLK_SOURCE_OSC_DIVIDE == 0))
    #error "PERIPH_CLK sourced from OSC_CLK must have a division value between 1 and 8"
#endif
#if defined iMX_RT1011 || !defined PERIPH_CLK_SOURCE_PLL_SW_DIVIDE
    #define PERIPH_CLK_SOURCE_PLL_SW_DIVIDE 1
#endif
#if defined PERIPH_CLK_SOURCE_PLL3_SW_CLK && ((PERIPH_CLK_SOURCE_PLL_SW_DIVIDE > 8) || (PERIPH_CLK_SOURCE_PLL_SW_DIVIDE == 0))
    #error "PERIPH_CLK sourced from PLL3 SW must have a division value between 1 and 8"
#endif
#if defined iMX_RT1011 || !defined PERIPH_CLK_SOURCE_PLL6_DIVIDE
    #define PERIPH_CLK_SOURCE_PLL6_DIVIDE 1
#endif
#if defined PERIPH_CLK_SOURCE_PLL6_500M && ((PERIPH_CLK_SOURCE_PLL6_DIVIDE > 8) || (PERIPH_CLK_SOURCE_PLL6_DIVIDE == 0))
    #error "PERIPH_CLK sourced from 500MHz PLL6 must have a division value between 1 and 8"
#endif
#if defined ARM_PLL_AVAILABLE
    #if !defined ARM_PLL_MULTIPLIER
        #define ARM_PLL_MULTIPLIER     72
    #elif (ARM_PLL_MULTIPLIER < 54) || (ARM_PLL_MULTIPLIER > 108)
        #error "ARM_PLL_MULTIPLIER must be an integer value between 54 and 108"
    #endif
    #if !defined PERIPH_CLK_SOURCE_ARM_PLL_DIVIDE
        #define PERIPH_CLK_SOURCE_ARM_PLL_DIVIDE 1
    #elif (PERIPH_CLK_SOURCE_ARM_PLL_DIVIDE < 1) || (PERIPH_CLK_SOURCE_ARM_PLL_DIVIDE > 8)
        #error "PERIPH_CLK sourced from the ARM PLL (PLL1) must have a division value between 1 and 8"
    #endif
#endif
#if defined PERIPH_CLK_SOURCE_PLL6_500M && ((PERIPH_CLK_SOURCE_PLL6_DIVIDE > 8) || (PERIPH_CLK_SOURCE_PLL6_DIVIDE == 0))
#error "PERIPH_CLK sourced from 500MHz PLL6 must have a division value between 1 and 8"
#endif

#if !defined IPG_CLK_ROOT_DIVIDE
    #define IPG_CLK_ROOT_DIVIDE 1
#elif ((IPG_CLK_ROOT_DIVIDE == 0) || (IPG_CLK_ROOT_DIVIDE > 4))
    #error "IPG_CLK_ROOT_DIVIDE must be 1,2,3 or 4!!"
#endif

#if !defined PLL2_PFD3_FRACTION
    #define PLL2_PFD3_FRACTION     16                                    // default PLL3-PFD3 = 528 x 18 / 16 = 594MHz (range 12..35)
#elif PLL2_PFD3_FRACTION < 12 || PLL2_PFD3_FRACTION > 35
    #error "PLL2_PFD3_FRACTION must be between 12 and 35!!"
#endif

#if !defined PLL3_PFD3_FRACTION
    #define PLL3_PFD3_FRACTION     35                                    // default PLL3-PFD3 = 480 x 18 / 35 = 246.8571429MHz (range 12..35)
#elif PLL3_PFD3_FRACTION < 12 || PLL3_PFD3_FRACTION > 35
    #error "PLL3_PFD3_FRACTION must be between 12 and 35!!"
#endif


#if defined RUN_FROM_DEFAULT_CLOCK
    #define PERIPH_CLK_FREQUENCY   (_EXTERNAL_CLOCK)
#elif defined PERIPH_CLK_SOURCE_OSC
    #define PERIPH_CLK_FREQUENCY   (_EXTERNAL_CLOCK/PERIPH_CLK_SOURCE_OSC_DIVIDE)
#elif defined ARM_PLL_AVAILABLE && defined PERIPH_CLK_SOURCE_ARM_PLL
    #define PERIPH_CLK_FREQUENCY   (iMX_PLL1/PERIPH_CLK_SOURCE_ARM_PLL_DIVIDE)
#else
    #if defined PERIPH_CLK_SOURCE_PLL6_500M
        #define PERIPH_CLK_FREQUENCY   (iMX_PLL6/PERIPH_CLK_SOURCE_PLL6_DIVIDE)
    #elif defined PERIPH_CLK_SOURCE_PLL3_SW_CLK
        #define PERIPH_CLK_FREQUENCY   (iMX_PLL3/PERIPH_CLK_SOURCE_PLL_SW_DIVIDE)
    #elif defined PERIPH_CLK_SOURCE_PLL2_528M
        #define PERIPH_CLK_FREQUENCY   (iMX_PLL2)
    #elif defined PERIPH_CLK_SOURCE_PLL2_PFD3
        #define PERIPH_CLK_FREQUENCY   ((((iMX_PLL2/10) * 18) / PLL2_PFD3_FRACTION) * 10)
    #elif defined PERIPH_CLK_SOURCE_PLL3_PFD3
        #define PERIPH_CLK_FREQUENCY   ((((iMX_PLL3/10) * 18) / PLL3_PFD3_FRACTION) * 10)
    #endif
#endif

// Default and maximum frequencies according to user's manual
//
#define AHB_CLK_ROOT_DEFAULT       12000000
#define IPG_CLK_ROOT_DEFAULT        3000000
#define PERCLK_CLK_ROOT_DEFAULT     6000000
#define USDHC1_CLK_ROOT_DEFAULT    12000000
#define USDHC2_CLK_ROOT_DEFAULT    12000000
#define SEMC_CLK_ROOT_DEFAULT       8000000
#define CSI_CLK_ROOT_DEFAULT       12000000
#define FLEXSPI_CLK_ROOT_DEFAULT    2000000
#define LPSPI_CLK_ROOT_DEFAULT      6000000
#define TRACE_CLK_ROOT_DEFAULT      6000000
#define SAI1_CLK_ROOT_DEFAULT       3000000
#define SAI2_CLK_ROOT_DEFAULT       3000000
#define SAI3_CLK_ROOT_DEFAULT       3000000
#define LPI2C_CLK_ROOT_DEFAULT     24000000
#define CAN_CLK_ROOT_DEFAULT              0
#define UART_CLK_ROOT_DEFAULT       4000000
#define LCDIF_CLK_ROOT_DEFAULT      3000000
#define SPDIF0_CLK_ROOT_DEFAULT     1500000
#define FLEXIO1_CLK_ROOT_DEFAULT    1500000
#define FLEXIO2_CLK_ROOT_DEFAULT    1500000

#if defined iMX_RT1011
    #define AHB_CLK_ROOT_MAX           500000000                         // maximum core frequency
    #if defined LOW_POWER_RUN || defined LOW_POWER_IDLE                  // 0.925V min
        #define IPG_CLK_ROOT_MAX        24000000
        #define PERCLK_CLK_ROOT_MAX     24000000
        #define FLEXSPI_CLK_ROOT_MAX    24000000
        #define LPSPI_CLK_ROOT_MAX      24000000
        #define TRACE_CLK_ROOT_MAX      24000000
        #define SAI1_CLK_ROOT_MAX       24000000
        #define SAI3_CLK_ROOT_MAX       24000000
        #define LPI2C_CLK_ROOT_MAX      24000000
        #define UART_CLK_ROOT_MAX       24000000
        #define SPDIF0_CLK_ROOT_MAX     24000000
        #define FLEXIO1_CLK_ROOT_MAX    24000000
    #elif defined FULL_SPEED_RUN || defined SYSTEM_IDLE                  // 1.15V min
        #define IPG_CLK_ROOT_MAX       132000000
        #define PERCLK_CLK_ROOT_MAX     75000000
        #define FLEXSPI_CLK_ROOT_MAX   322000000
        #define LPSPI_CLK_ROOT_MAX     132000000
        #define TRACE_CLK_ROOT_MAX     132000000
        #define SAI1_CLK_ROOT_MAX       66000000
        #define SAI3_CLK_ROOT_MAX       66000000
        #define LPI2C_CLK_ROOT_MAX      66000000
        #define UART_CLK_ROOT_MAX       80000000
        #define SPDIF0_CLK_ROOT_MAX     66000000
        #define FLEXIO1_CLK_ROOT_MAX   120000000
    #else                                                                // overdrive run - min.1.25V
        #define IPG_CLK_ROOT_MAX       150000000
        #define PERCLK_CLK_ROOT_MAX     75000000
        #define FLEXSPI_CLK_ROOT_MAX   322000000
        #define LPSPI_CLK_ROOT_MAX     132000000
        #define TRACE_CLK_ROOT_MAX     132000000
        #define SAI1_CLK_ROOT_MAX       66000000
        #define SAI3_CLK_ROOT_MAX       66000000
        #define LPI2C_CLK_ROOT_MAX      66000000
        #define UART_CLK_ROOT_MAX       80000000
        #define SPDIF0_CLK_ROOT_MAX     66000000
        #define FLEXIO1_CLK_ROOT_MAX   120000000
    #endif
#elif defined iMX_RT105X || defined iMX_RT106X
    #define AHB_CLK_ROOT_MAX           600000000                         // maximum core frequency
    #define IPG_CLK_ROOT_MAX           150000000
    #define PERCLK_CLK_ROOT_MAX         75000000
    #if defined iMX_RT106X
        #define USDHC1_CLK_ROOT_MAX    200000000
        #define USDHC2_CLK_ROOT_MAX    200000000
        #define FLEXSPI2_CLK_ROOT_MAX  322000000
        #define TRACE_CLK_ROOT_MAX     150000000
        #define CAN_CLK_ROOT_MAX        80000000
    #else
        #define USDHC1_CLK_ROOT_MAX    198000000
        #define USDHC2_CLK_ROOT_MAX    198000000
        #define TRACE_CLK_ROOT_MAX     132000000
        #define CAN_CLK_ROOT_MAX        60000000
    #endif
    #define SEMC_CLK_ROOT_MAX          166000000
    #define CSI_CLK_ROOT_MAX            80000000
    #define FLEXSPI_CLK_ROOT_MAX       322000000
    #define LPSPI_CLK_ROOT_MAX         132000000
    #define SAI1_CLK_ROOT_MAX           66000000
    #define SAI2_CLK_ROOT_MAX           66000000
    #define SAI3_CLK_ROOT_MAX           66000000
    #define LPI2C_CLK_ROOT_MAX          66000000
    #define UART_CLK_ROOT_MAX           80000000
    #define LCDIF_CLK_ROOT_MAX          75000000
    #define SPDIF0_CLK_ROOT_MAX         66000000
    #define FLEXIO1_CLK_ROOT_MAX       120000000
    #define FLEXIO2_CLK_ROOT_MAX       120000000
#else
    #define AHB_CLK_ROOT_MAX           500000000                         // maximum core frequency
    #define IPG_CLK_ROOT_MAX           150000000
    #define PERCLK_CLK_ROOT_MAX         75000000
    #define USDHC1_CLK_ROOT_MAX        198000000
    #define USDHC2_CLK_ROOT_MAX        198000000
    #define SEMC_CLK_ROOT_MAX          166000000
    #define FLEXSPI_CLK_ROOT_MAX       322000000
    #define LPSPI_CLK_ROOT_MAX         132000000
    #define TRACE_CLK_ROOT_MAX         132000000
    #define SAI1_CLK_ROOT_MAX           66000000
    #define SAI2_CLK_ROOT_MAX           66000000
    #define SAI3_CLK_ROOT_MAX           66000000
    #define LPI2C_CLK_ROOT_MAX          66000000
    #define CAN_CLK_ROOT_MAX            60000000
    #define UART_CLK_ROOT_MAX           80000000
    #define SPDIF0_CLK_ROOT_MAX         66000000
    #define FLEXIO1_CLK_ROOT_MAX       120000000
#endif

#define AHB_CLK_ROOT_FREQUENCY     (PERIPH_CLK_FREQUENCY / AHB_CLK_ROOT_DIVIDE)
#define SYSTEM_CLOCK               AHB_CLK_ROOT_FREQUENCY               // for compatibility
#define CORE_CLOCK                 AHB_CLK_ROOT_FREQUENCY               // for compatibility
#define PLL_OUTPUT_FREQ            AHB_CLK_ROOT_FREQUENCY               // this is for simulation compatibility and is set to the core/system clock frequency which is not necessarily equal to the real PLL frequency

#if AHB_CLK_ROOT_FREQUENCY > AHB_CLK_ROOT_MAX 
    #error "AHB_CLK_ROOT (core frequency) is too high - increase AHB_CLK_ROOT_DIVIDE accordingly!!"
#endif
#define IPG_CLK_ROOT_FREQUENCY      (AHB_CLK_ROOT_FREQUENCY/IPG_CLK_ROOT_DIVIDE)
#if IPG_CLK_ROOT_FREQUENCY > IPG_CLK_ROOT_MAX 
    #error "IPG_CLK_ROOT is too high - increase IPG_CLK_ROOT_DIVIDE accordingly!!"
#endif

#if !defined PERCLK_CLK_ROOT_DIVIDE
    #define PERCLK_CLK_ROOT_DIVIDE 1
#elif ((PERCLK_CLK_ROOT_DIVIDE > 64) || (PERCLK_CLK_ROOT_DIVIDE == 0))
    #error "PERCLK must have a division value between 1 and 64"
#endif
#if defined PERCLK_CLK_ROOT_SOURCE_IPG_CLK
    #define PERCLK_CLK_ROOT_FREQUENCY (IPG_CLK_ROOT_FREQUENCY/PERCLK_CLK_ROOT_DIVIDE)
#else
    #define PERCLK_CLK_ROOT_FREQUENCY (_EXTERNAL_CLOCK/PERCLK_CLK_ROOT_DIVIDE)
#endif

#if PERCLK_CLK_ROOT_FREQUENCY > PERCLK_CLK_ROOT_MAX
    #error "PERCLK_CLK_ROOT is too high - increase PERCLK_CLK_ROOT_DIVIDE accordingly!!"
#endif

#define OSC_CLK                    (_EXTERNAL_CLOCK)

#if defined PLL3_CLOCK_OSC_CLK
    #define PLL3_SW_CLK            OSC_CLK
#else
    #define PLL3_SW_CLK            iMX_PLL3
#endif


// LPUART clock
//
#if !defined UART_CLK_ROOT_FROM_PLL3_SW_CLK_6 || defined PLL3_CLOCK_OSC_CLK // select the OSC_CLK source for the UART clock root
    #define LPUART_CLK_ROOT_SOURCE (OSC_CLK)                             // 24MHz
#else
    #define LPUART_CLK_ROOT_SOURCE (PLL3_SW_CLK/6)                       // 80MHz
#endif
#if !defined UART_CLK_ROOT_DIVIDER
    #define UART_CLK_ROOT_DIVIDER 1
#endif
#if (UART_CLK_ROOT_DIVIDER == 0) || (UART_CLK_ROOT_DIVIDER > 64)
    #error "UART_CLK_ROOT_DIVIDER must be between 1 and 64"
#endif
#define UART_CLK_ROOT_FREQUENCY (LPUART_CLK_ROOT_SOURCE/UART_CLK_ROOT_DIVIDER)
#if UART_CLK_ROOT_FREQUENCY > UART_CLK_ROOT_MAX
    #error "UART_CLK_ROOT is too high - increase UART_CLK_ROOT_DIVIDE accordingly!!"
#endif
#define LPUART_CLK_ROOTFREQUENCY   UART_CLK_ROOT_FREQUENCY

// LPI2C clock
//
#if !defined LPI2C_CLK_ROOT_FROM_PLL3_SW_CLK_8 || defined PLL3_CLOCK_OSC_CLK // select the OSC_CLK source for the LPI2C clock root
    #define LPI2C_CLK_ROOT_SOURCE (OSC_CLK)                             // 24MHz
#else
    #define LPI2C_CLK_ROOT_SOURCE (PLL3_SW_CLK/8)                       // 60MHz
#endif

#if !defined LPI2C_CLK_ROOT_DIVIDER
    #define LPI2C_CLK_ROOT_DIVIDER 1
#endif
#if (LPI2C_CLK_ROOT_DIVIDER == 0) || (LPI2C_CLK_ROOT_DIVIDER > 64)
    #error "LPI2C_CLK_ROOT_DIVIDER must be between 1 and 64"
#endif
#define LPI2C_CLK_ROOT_FREQUENCY (LPI2C_CLK_ROOT_SOURCE/LPI2C_CLK_ROOT_DIVIDER)
#if LPI2C_CLK_ROOT_FREQUENCY > LPI2C_CLK_ROOT_MAX
    #error "LPI2C_CLK_ROOT is too high - increase LPI2C_CLK_ROOT_DIVIDE accordingly!!"
#endif

// FLEXCAN clock
//
#if (!defined CAN_CLK_ROOT_FROM_PLL3_SW_CLK_6 && !defined CAN_CLK_ROOT_FROM_PLL3_SW_CLK_8) || defined PLL3_CLOCK_OSC_CLK // select the OSC_CLK source for the CAN clock root
    #define CAN_CLK_ROOT_SOURCE (OSC_CLK)                               // 24MHz
#elif defined CAN_CLK_ROOT_FROM_PLL3_SW_CLK_6
    #define CAN_CLK_ROOT_SOURCE (PLL3_SW_CLK/6)                         // 80MHz
#else
    #define CAN_CLK_ROOT_SOURCE (PLL3_SW_CLK/8)                         // 60MHz
#endif

#if NUMBER_OF_CAN_INTERFACES > 0
    #if !defined CAN_CLK_ROOT_DIVIDER
        #define CAN_CLK_ROOT_DIVIDER 2
    #endif
    #if (CAN_CLK_ROOT_DIVIDER == 0) || (CAN_CLK_ROOT_DIVIDER > 64)
        #error "CAN_CLK_ROOT_DIVIDER must be between 1 and 64"
    #endif
    #define CAN_CLK_ROOT_FREQUENCY (CAN_CLK_ROOT_SOURCE/CAN_CLK_ROOT_DIVIDER)
    #if CAN_CLK_ROOT_FREQUENCY > CAN_CLK_ROOT_MAX
        #error "CAN_CLK_ROOT is too high - increase CAN_CLK_ROOT_DIVIDE accordingly!!"
    #endif
#endif

#if defined ENHANCED_LCD_INTERFACE && defined SUPPORT_GLCD
    // LCDIF clock
    //
    #if defined LCDIF_CLK_SOURCE_PLL2
        #define LCDIF_CLK_ROOT_FREQUENCY (iMX_PLL2/LCDIF_CLK_SOURCE_DIVIDE/LDCIF_CLK_PRESCALER)
    #elif defined LCDIF_CLK_SOURCE_PLL3_PFD3
        #define LCDIF_CLK_ROOT_FREQUENCY (((((iMX_PLL3 / 10) * 18) / PLL3_PFD3_FRACTION) * 10)LCDIF_CLK_SOURCE_DIVIDE/LDCIF_CLK_PRESCALER)
    #elif defined LCDIF_CLK_SOURCE_PLL5
        #define LCDIF_CLK_ROOT_FREQUENCY (iMX_PLL5/LCDIF_CLK_SOURCE_DIVIDE/LDCIF_CLK_PRESCALER)
    #elif defined LCDIF_CLK_SOURCE_PLL2_PFD0
        #define LCDIF_CLK_ROOT_FREQUENCY (((((iMX_PLL2 / 10) * 18) / PLL2_PFD0_FRACTION) * 10)LCDIF_CLK_SOURCE_DIVIDE/LDCIF_CLK_PRESCALER)
    #elif defined LCDIF_CLK_SOURCE_PLL2_PFD1
        #define LCDIF_CLK_ROOT_FREQUENCY (((((iMX_PLL2 / 10) * 18) / PLL2_PFD1_FRACTION) * 10)LCDIF_CLK_SOURCE_DIVIDE/LDCIF_CLK_PRESCALER)
    #elif defined LCDIF_CLK_SOURCE_PLL3_PFD1
        #define LCDIF_CLK_ROOT_FREQUENCY (((((iMX_PLL3 / 10) * 18) / PLL3_PFD1_FRACTION) * 10)LCDIF_CLK_SOURCE_DIVIDE/LDCIF_CLK_PRESCALER)
    #endif

    #if (LDCIF_CLK_PRESCALER < 1) || (LDCIF_CLK_PRESCALER > 8)
        #error "LDCIF_CLK_PRESCALER must be between 1 and 8"
    #endif
        #if (LCDIF_CLK_SOURCE_DIVIDE < 1) || (LCDIF_CLK_SOURCE_DIVIDE > 4)
        #error "LCDIF_CLK_SOURCE_DIVIDE must be between 1 and 4"
    #endif

    #if LCDIF_CLK_ROOT_FREQUENCY > LCDIF_CLK_ROOT_MAX 
        #error "LCDIF_CLK_ROOT is too high - increase LDCIF_CLK_PRESCALER and/or LCDIF_CLK_SOURCE_DIVIDE accordingly!!"
    #endif
#endif

#if defined SEMC_CLK_AVAILABLE
    #if !defined SEMC_CLK_ROOT_DIVIDE
        #define SEMC_CLK_ROOT_DIVIDE 1
    #elif ((SEMC_CLK_ROOT_DIVIDE > 8) || (SEMC_CLK_ROOT_DIVIDE == 0))
        #error "SEMC CLK must have a division value between 1 and 8"
    #endif
    #if defined SEMC_CLK_FROM_PLL2_PFD2
        #define SEMC_CLK_ROOT_FREQUENCY   (((((iMX_PLL2/10) * 18) / PLL2_PFD2_FRACTION) * 10)/SEMC_CLK_ROOT_DIVIDE)
    #elif defined SEMC_CLK_FROM_PLL3_PFD1
        #define SEMC_CLK_ROOT_FREQUENCY   (((((iMX_PLL3/10) * 18) / PLL3_PFD1_FRACTION) * 10)/SEMC_CLK_ROOT_DIVIDE)
    #else                                                                // SEMC_CLK_FROM_PERIPH_CLK
        #define SEMC_CLK_ROOT_FREQUENCY  (PERIPH_CLK_FREQUENCY/SEMC_CLK_ROOT_DIVIDE)
    #endif
    #if SEMC_CLK_ROOT_FREQUENCY > SEMC_CLK_ROOT_MAX
        #error "SEMC_CLK_ROOT is too high - increase SEMC_CLK_ROOT_DIVIDE accordingly!!"
    #endif
#endif

#if defined SDCARD_SUPPORT
    #if defined USDHC1_CLK_SOURCE_PLL2_PFD2                              // USDHC1_CLK_ROOT sourced from pll2.pfd2
        #define USDHC1_CLK_ROOT_FREQUENCY      (((((iMX_PLL2/10) * 18) / PLL2_PFD2_FRACTION) * 10)/USDHC1_CLK_ROOT_DIVIDE)
    #else                                                                // USDHC1_CLK_ROOT sourced from pll2.pfd0
        #define USDHC1_CLK_ROOT_FREQUENCY      (((((iMX_PLL2/10) * 18) / PLL2_PFD0_FRACTION) * 10)/USDHC1_CLK_ROOT_DIVIDE)
    #endif
    #if USDHC1_CLK_ROOT_FREQUENCY > USDHC1_CLK_ROOT_MAX
        #error "USDHC1_CLK_ROOT_FREQUENCY is too high - increase USDHC1_CLK_ROOT_DIVIDE accordingly!!"
    #endif

    #if defined USDHC2_CLK_SOURCE_PLL2_PFD2                              // USDHC1_CLK_ROOT sourced from pll2.pfd2
        #define USDHC2_CLK_ROOT_FREQUENCY      (((((iMX_PLL2/10) * 18) / PLL2_PFD2_FRACTION) * 10)/USDHC2_CLK_ROOT_DIVIDE)
    #else                                                                // USDHC1_CLK_ROOT sourced from pll2.pfd0
        #define USDHC2_CLK_ROOT_FREQUENCY      (((((iMX_PLL2/10) * 18) / PLL2_PFD0_FRACTION) * 10)/USDHC2_CLK_ROOT_DIVIDE)
    #endif
    #if USDHC2_CLK_ROOT_FREQUENCY > USDHC2_CLK_ROOT_MAX
        #error "USDHC2_CLK_ROOT_FREQUENCY is too high - increase USDHC2_CLK_ROOT_DIVIDE accordingly!!"
    #endif
#endif

typedef struct stRESET_VECTOR
{
    void  *ptrResetSP;                                                   // initial stack pointer
    void  (*ptrResetPC)(void);                                           // initial program counter
#if defined NMI_IN_FLASH
    void  (*ptrNMI)(void);
#endif
} RESET_VECTOR;

#if defined BOOT_HYPER_FLASH
typedef struct stFLEXSPI_LUT_ENTRY
{
    unsigned long ulReference;
    unsigned long ulEntrySequence[4];                                    // use all 4 sequence entries
} FLEXSPI_LUT_ENTRY;
#else
typedef struct stFLEXSPI_LUT_ENTRY
{
    unsigned long ulReference;
    unsigned long ulEntrySequence[2];                                    // use just 2 sequence entries
} FLEXSPI_LUT_ENTRY;
#endif

// 16 entries possible
//
#define NOR_CMD_LUT_SEQ_IDX_READ_FAST           0                        // the first entry is used by XiP and so needs to be a read entry
#define NOR_CMD_LUT_SEQ_IDX_READ_FAST_QUAD      0
#define NOR_CMD_LUT_SEQ_IDX_READ_FAST_OCTAL     0
#define NOR_CMD_LUT_SEQ_IDX_READSTATUS          1
#define NOR_CMD_LUT_SEQ_IDX_READSTATUSREG_QUAD  1
#define NOR_CMD_LUT_SEQ_IDX_READSTATUSREG_OCTAL 1
#define NOR_CMD_LUT_SEQ_IDX_WRITEENABLE         2
#define NOR_CMD_LUT_SEQ_IDX_ERASESECTOR         3
#define NOR_CMD_LUT_SEQ_IDX_PAGEPROGRAM_QUAD    4
#define NOR_CMD_LUT_SEQ_IDX_PAGEPROGRAM_OCTAL   4
#define NOR_CMD_LUT_SEQ_IDX_PAGEPROGRAM_SINGLE  4
#define NOR_CMD_LUT_SEQ_IDX_UNPROTECT_SECTORS   5
#define NOR_CMD_LUT_SEQ_IDX_READ_NORMAL         6
#define NOR_CMD_LUT_SEQ_IDX_ERASECHIP           7
#define NOR_CMD_LUT_SEQ_IDX_WRITESTATUSREG      8
#define NOR_CMD_LUT_SEQ_IDX_WRITE_STATUS_CONTROL_REGS 8
#define NOR_CMD_LUT_SEQ_IDX_READSTATUSREG       9
#define NOR_CMD_LUT_SEQ_IDX_READSTATUSREG2      10
#define NOR_CMD_LUT_SEQ_IDX_ENTERQPI            11
#define NOR_CMD_LUT_SEQ_IDX_READ_STATUS_CONTROL_REGS 12
#define NOR_CMD_LUT_SEQ_IDX_ERASE_HALF_BLOCK    13
#define NOR_CMD_LUT_SEQ_IDX_ERASE_BLOCK         14
#define NOR_CMD_LUT_SEQ_IDX_WRITEDISABLE        15

#define NOR_CMD_LUT_SEQ_IDX_END_OF_TABLE        32

// Functions used only during initialisation (overlap with operating function references)
//
#define NOR_CMD_LUT_SEQ_IDX_READFUNCTION       (NOR_CMD_LUT_SEQ_IDX_ERASESECTOR + 16)
#define NOR_CMD_LUT_SEQ_IDX_READID             (NOR_CMD_LUT_SEQ_IDX_ERASECHIP + 16)
#define NOR_CMD_LUT_SEQ_IDX_WRITEFUNCTION      (NOR_CMD_LUT_SEQ_IDX_ERASE_HALF_BLOCK + 16)
#define NOR_CMD_LUT_SEQ_IDX_EXITQPI            (NOR_CMD_LUT_SEQ_IDX_ERASE_BLOCK + 16)


#define HYPERFLASH_CMD_LUT_SEQ_IDX_READDATA       0
#define HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEDATA      1
#define HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS     2
#define HYPERFLASH_CMD_LUT_SEQ_IDX_READSTATUS_1   3
#define HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE    4
#define HYPERFLASH_CMD_LUT_SEQ_IDX_WRITEENABLE_1  5
#define HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR    6
#define HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR_1  7
#define HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR_2  8
#define HYPERFLASH_CMD_LUT_SEQ_IDX_ERASESECTOR_3  9
#define HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM    10
#define HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM_1  11
#define HYPERFLASH_CMD_LUT_SEQ_IDX_PAGEPROGRAM_2  12
#define HYPERFLASH_CMD_LUT_SEQ_IDX_DEVICE_ID      13

#define FLEXSPI_SEQUENCE_LENGTH(len)     ((len - 1) << 24)

#define WRITEENABLE_SEQUENCE_LENGTH      FLEXSPI_SEQUENCE_LENGTH(2)
#define WRITEDATA_SEQUENCE_LENGTH        FLEXSPI_SEQUENCE_LENGTH(2)
#define ERASESECTOR_SEQUENCE_LENGTH      FLEXSPI_SEQUENCE_LENGTH(4)


// QSPI flash configuration
//
#define FLEXSPI_CFG_BLK_TAG                            (0x42464346)      // ascii "FCFB" big endian
#define FLEXSPI_CFG_BLK_VERSION                        (0x56010400)      // V1.4.0

#define kFlexSPIReadSampleClk_LoopbackInternally       0
#define kFlexSPIReadSampleClk_LoopbackFromDqsPad       1
#define kFlexSPIReadSampleClk_LoopbackFromSckPad       2
#define kFlexSPIReadSampleClk_ExternalInputFromDqsPad  3

#define kSerialNOR                                     1
#define kSerialNAND                                    2

#define kFlexSpiMiscOffset_DiffClkEnable               0                 // bit for differential clock enable
#define kFlexSpiMiscOffset_Ck2Enable                   1                 // CK2 enable
#define kFlexSpiMiscOffset_ParallelEnable              2                 // parallel mode enable
#define kFlexSpiMiscOffset_WordAddressableEnable       3                 // word addressable enable
#define kFlexSpiMiscOffset_SafeConfigFreqEnable        4                 // safe configuration frequency enable
#define kFlexSpiMiscOffset_PadSettingOverrideEnable    5                 // pad setting override enable
#define kFlexSpiMiscOffset_DdrModeEnable               6                 // DDR clock confiuration indication.

#define kSerialFlash_1Pad                              1
#define kSerialFlash_2Pads                             2
#define kSerialFlash_4Pads                             4
#define kSerialFlash_8Pads                             8

#define kFlexSpiSerialClk_30MHz                        1
#define kFlexSpiSerialClk_50MHz                        2
#define kFlexSpiSerialClk_60MHz                        3
#define kFlexSpiSerialClk_75MHz                        4
#define kFlexSpiSerialClk_80MHz                        5
#define kFlexSpiSerialClk_100MHz                       6
#define kFlexSpiSerialClk_133MHz                       7
#define kFlexSpiSerialClk_166MHz                       8
#define kFlexSpiSerialClk_200MHz                       9


#define FLEXSPI_LUT_OPERAND0_MASK                (0xffU)
#define FLEXSPI_LUT_OPERAND0_SHIFT               (0U)
#define FLEXSPI_LUT_OPERAND0(x)                  (((unsigned long)(((unsigned long)(x)) << FLEXSPI_LUT_OPERAND0_SHIFT)) & FLEXSPI_LUT_OPERAND0_MASK)
#define FLEXSPI_LUT_NUM_PADS0_MASK               (0x300U)
#define FLEXSPI_LUT_NUM_PADS0_SHIFT              (8U)
#define FLEXSPI_LUT_NUM_PADS0(x)                 (((unsigned long)(((unsigned long)(x)) << FLEXSPI_LUT_NUM_PADS0_SHIFT)) & FLEXSPI_LUT_NUM_PADS0_MASK)
#define FLEXSPI_LUT_OPCODE0_MASK                 (0xfc00U)
#define FLEXSPI_LUT_OPCODE0_SHIFT                (10U)
#define FLEXSPI_LUT_OPCODE0(x)                   (((unsigned long)(((unsigned long)(x)) << FLEXSPI_LUT_OPCODE0_SHIFT)) & FLEXSPI_LUT_OPCODE0_MASK)
#define FLEXSPI_LUT_OPERAND1_MASK                (0xff0000U)
#define FLEXSPI_LUT_OPERAND1_SHIFT               (16U)
#define FLEXSPI_LUT_OPERAND1(x)                  (((unsigned long)(((unsigned long)(x)) << FLEXSPI_LUT_OPERAND1_SHIFT)) & FLEXSPI_LUT_OPERAND1_MASK)
#define FLEXSPI_LUT_NUM_PADS1_MASK               (0x3000000U)
#define FLEXSPI_LUT_NUM_PADS1_SHIFT              (24U)
#define FLEXSPI_LUT_NUM_PADS1(x)                 (((unsigned long)(((unsigned long)(x)) << FLEXSPI_LUT_NUM_PADS1_SHIFT)) & FLEXSPI_LUT_NUM_PADS1_MASK)
#define FLEXSPI_LUT_OPCODE1_MASK                 (0xfc000000U)
#define FLEXSPI_LUT_OPCODE1_SHIFT                (26U)
#define FLEXSPI_LUT_OPCODE1(x)                   (((unsigned long)(((unsigned long)(x)) << FLEXSPI_LUT_OPCODE1_SHIFT)) & FLEXSPI_LUT_OPCODE1_MASK)

#define FLEXSPI_LUT_SEQ(cmd0, pad0, op0, cmd1, pad1, op1)  (FLEXSPI_LUT_OPERAND0(op0) | FLEXSPI_LUT_NUM_PADS0(pad0) | FLEXSPI_LUT_OPCODE0(cmd0) | FLEXSPI_LUT_OPERAND1(op1) | FLEXSPI_LUT_NUM_PADS1(pad1) | FLEXSPI_LUT_OPCODE1(cmd1))



#define FLEXSPI_LUT_1PAD_SEQ_1(cmd0, op0)      ((cmd0 << FLEX_SPI_LUT_OPCODE0_SHIFT) | (FLEXSPI_1PAD << FLEX_SPI_LUT_NUM_PADS0_SHIFT) | op0)
#define FLEXSPI_LUT_1PAD_SEQ_2(cmd1, op1)      (FLEXSPI_LUT_1PAD_SEQ_1(cmd1, op1) << 16)
#define FLEXSPI_LUT_4PAD_SEQ_1(cmd0, op0)      ((cmd0 << FLEX_SPI_LUT_OPCODE0_SHIFT) | (FLEXSPI_4PAD << FLEX_SPI_LUT_NUM_PADS0_SHIFT) | op0)
#define FLEXSPI_LUT_4PAD_SEQ_2(cmd1, op1)      (FLEXSPI_LUT_4PAD_SEQ_1(cmd1, op1) << 16)
#define FLEXSPI_LUT_8PAD_SEQ_1(cmd0, op0)      ((cmd0 << FLEX_SPI_LUT_OPCODE0_SHIFT) | (FLEXSPI_8PAD << FLEX_SPI_LUT_NUM_PADS0_SHIFT) | op0)
#define FLEXSPI_LUT_8PAD_SEQ_2(cmd1, op1)      (FLEXSPI_LUT_8PAD_SEQ_1(cmd1, op1) << 16)

// FlexSPI instruction set for progrmmable sequence engine
//

// SDR - single data rate commands
//
#define FLEXSPI_Command_STOP           0x00                              // stop execution, deassert CS
#define FLEXSPI_Command_SDR            0x01                              // transmit command code to flash, using SDR mode
#define FLEXSPI_Command_RADDR_SDR      0x02                              // transmit row address to flash, using SDR mode
#define FLEXSPI_Command_CADDR_SDR      0x03                              // transmit column address to flash, using SDR mode
#define FLEXSPI_Command_MODE1_SDR      0x04                              // transmit 1-bit mode bits to flash, using SDR mode
#define FLEXSPI_Command_MODE2_SDR      0x05                              // transmit 2-bit mode bits to flash, using SDR mode
#define FLEXSPI_Command_MODE4_SDR      0x06                              // transmit 4-bit mode bits to flash, using SDR mode
#define FLEXSPI_Command_MODE8_SDR      0x07                              // transmit 8-bit mode bits to flash, using SDR mode
#define FLEXSPI_Command_WRITE_SDR      0x08                              // transmit programming data to flash, using SDR mode
#define FLEXSPI_Command_READ_SDR       0x09                              // receive read data from flash, using SDR mode
#define FLEXSPI_Command_LEARN_SDR      0x0a                              // receive read data or preamble bit from flash, SDR mode
#define FLEXSPI_Command_DATSZ_SDR      0x0b                              // transmit read/program data size (byte) to flash, SDR mode
#define FLEXSPI_Command_DUMMY_SDR      0x0c                              // leave data lines undriven by FlexSPI controller
#define FLEXSPI_Command_DUMMY_RWDS_SDR 0x0d                              // leave data lines undriven by FlexSPI controller, dummy cycles decided by RWDS
                                                                         
#define FLEXSPI_Command_JUMP_ON_CS     0x1f                              // stop execution, deassert CS and save operand[7:0] as the instruction start pointer for next sequence
        
// DDR - double data rate commands
//
#define FLEXSPI_Command_DDR            0x21                              // transmit command code to flash, using DDR mode
#define FLEXSPI_Command_RADDR_DDR      0x22                              // transmit row address to flash, using DDR mode
#define FLEXSPI_Command_CADDR_DDR      0x23                              // transmit column address to flash, using DDR mode
#define FLEXSPI_Command_MODE1_DDR      0x24                              // transmit 1-bit mode bits to flash, using DDR mode
#define FLEXSPI_Command_MODE2_DDR      0x25                              // transmit 2-bit mode bits to flash, using DDR mode
#define FLEXSPI_Command_MODE4_DDR      0x26                              // transmit 4-bit Mode bits to flash, using DDR mode
#define FLEXSPI_Command_MODE8_DDR      0x27                              // transmit 8-bit Mode bits to flash, using DDR mode
#define FLEXSPI_Command_WRITE_DDR      0x28                              // transmit programming data to flash, using DDR mode
#define FLEXSPI_Command_READ_DDR       0x29                              // receive read data from flash, using DDR mode
#define FLEXSPI_Command_LEARN_DDR      0x2a                              // receive read data or preamble bit from flash, DDR mode
#define FLEXSPI_Command_DATSZ_DDR      0x2b                              // transmit read/program data size (byte) to flash, DDR mode
#define FLEXSPI_Command_DUMMY_DDR      0x2c                              // leave data lines undriven by FlexSPI controller
#define FLEXSPI_Command_DUMMY_RWDS_DDR 0x2d                              // leave data lines undriven by FlexSPI controller, dummy cycles decided by RWDS                                  


#define FLEXSPI_1PAD   0
#define FLEXSPI_2PAD   1
#define FLEXSPI_4PAD   2
#define FLEXSPI_8PAD   3

#define ADDRESS_LENGTH_8BITS              8
#define ADDRESS_LENGTH_16BITS             16
#define ADDRESS_LENGTH_24BITS             24
#define ADDRESS_LENGTH_32BITS             32

#define HYPTER_PROTOCOL_CA0_READ          0x80
#define HYPTER_PROTOCOL_CA0_WRITE         0x00
#define HYPTER_PROTOCOL_CA0_TARGET_REG    0x40
#define HYPTER_PROTOCOL_CA0_TARGET_MEM    0x00
#define HYPTER_PROTOCOL_CA0_LINEAR_BURST  0x20
#define HYPTER_PROTOCOL_CA0_WRAPPED_BURST 0x00

typedef struct _lut_sequence
{
    unsigned char seqNum;                                                // sequence number, valid number: 1-16
    unsigned char seqId;                                                 // sequence index, valid number: 0-15
    unsigned char reserved[2];
} flexspi_lut_seq_t;

typedef struct _FlexSPIConfig
{
    unsigned long tag;                                                   // [0x000-0x003] Tag, fixed value 0x42464346UL
    unsigned long version;                                               // [0x004-0x007] Version,[31:24] -'V', [23:16] - Major, [15:8] - Minor, [7:0] - bugfix
    unsigned long reserved0;                                             // [0x008-0x00b] reserved for future use
    unsigned char readSampleClkSrc;                                      // [0x00c-0x00c] read sample clock source, valid value: 0/1/3
    unsigned char csHoldTime;                                            // [0x00d-0x00d] CS hold time, default value: 3
    unsigned char csSetupTime;                                           // [0x00e-0x00e] CS setup time, default value: 3
    unsigned char columnAddressWidth;                                    // [0x00f-0x00f] column address width, for HyperBus protocol, it is fixed to 3, for serial NAND refer to datasheet
    unsigned char deviceModeCfgEnable;                                   // [0x010-0x010] device mode configure enable flag, 1 - Enable, 0 - Disable
#if defined iMX_RT101X
    unsigned char reserveda;                                             // [0x011-0x011] reserved
#else
    unsigned char deviceModeType;                                        // [0x011-0x011] specify the configuration command type: Quad Enable, DPI/QPI/OPI switch, generic configuration, etc.
#endif
    unsigned short waitTimeCfgCommands;                                  // [0x012-0x013] wait time for all configuration commands, unit: 100us, Used for DPI/QPI/OPI switch or reset command
    flexspi_lut_seq_t deviceModeSeq;                                     // [0x014-0x017] device mode sequence info, [7:0] - LUT sequence id, [15:8] - LUT sequence number, [31:16] Reserved
    unsigned long deviceModeArg;                                         // [0x018-0x01b] argument/parameter for device configuration
    unsigned char configCmdEnable;                                       // [0x01c-0x01c] configure command enable flag, 1 - Enable, 0 - Disable
#if defined iMX_RT101X
    unsigned char reservedb[3];                                          // [0x01d-0x01f] reserved
#else
    unsigned char configModeType[3];                                     // [0x01d-0x01f] configure mode type, similar to deviceModeTpe
#endif
    flexspi_lut_seq_t configCmdSeqs[3];                                  // [0x020-0x02b] sequence info for device configuration command, similar to deviceModeSeq
    unsigned long reserved1;                                             // [0x02c-0x02f] reserved for future use
    unsigned long configCmdArgs[3];                                      // [0x030-0x03b] arguments/parameters for device configuration commands
    unsigned long reserved2;                                             // [0x03c-0x03f] reserved for future use
    unsigned long controllerMiscOption;                                  // [0x040-0x043] controller misc options, see misc feature bit definitions for more details
    unsigned char deviceType;                                            // [0x044-0x044] device Type: see flash type definition for more details
    unsigned char sflashPadType;                                         // [0x045-0x045] serial flash pad type: 1 - single, 2 - dual, 4 - quad, 8 - octal
    unsigned char serialClkFreq;                                         // [0x046-0x046] serial flash frequency - device specific definitions; see system boot chapter for more details
    unsigned char lutCustomSeqEnable;                                    // [0x047-0x047] LUT customization enable, it is required if the program/erase cannot be performed using 1 LUT sequence, currently only applicable to HyperFLASH
    unsigned long reserved3[2];                                          // [0x048-0x04f] reserved for future use
    unsigned long sflashA1Size;                                          // [0x050-0x053] size of flash connected to A1
    unsigned long sflashA2Size;                                          // [0x054-0x057] size of flash connected to A2
    unsigned long sflashB1Size;                                          // [0x058-0x05b] size of flash connected to B1
    unsigned long sflashB2Size;                                          // [0x05c-0x05f] size of flash connected to B2
    unsigned long csPadSettingOverride;                                  // [0x060-0x063] CS pad setting override value
    unsigned long sclkPadSettingOverride;                                // [0x064-0x067] SCK pad setting override value
    unsigned long dataPadSettingOverride;                                // [0x068-0x06b] data pad setting override value
    unsigned long dqsPadSettingOverride;                                 // [0x06c-0x06f] DQS pad setting override value
    unsigned long timeoutInMs;                                           // [0x070-0x073] timeout threshold for read status command
    unsigned long commandInterval;                                       // [0x074-0x077] CS deselect interval between two commands
    unsigned short dataValidTime[2];                                     // [0x078-0x07b] CLK edge to data valid time for PORT A and PORT B, in terms of 0.1ns
    unsigned short busyOffset;                                           // [0x07c-0x07d] busy offset, valid value: 0-31
    unsigned short busyBitPolarity;                                      // [0x07e-0x07f] busy flag polarity, 0 - busy flag is 1 when flash device is busy, 1 - busy flag is 0 when flash device is busy
    unsigned long lookupTable[64];                                       // [0x080-0x17f] lookup table holds flash command sequences
    flexspi_lut_seq_t lutCustomSeq[12];                                  // [0x180-0x1af] customisable LUT sequences
    unsigned long reserved4[4];                                          // [0x1b0-0x1bf] reserved for future use
} flexspi_mem_config_t;

typedef struct stFLEXSPI_NOR_BOOT_CONFIGURATION
{
#if defined iMX_RT1011
    unsigned long ulFill1[0x100 / sizeof(unsigned long)];                // OTFAD keyblob (when present)
    unsigned long ulFill2[0x300 / sizeof(unsigned long)];                // reserved
#endif
    flexspi_mem_config_t memConfig;                                      // common memory configuration info via FlexSPI
    unsigned long pageSize;                                              // [0x1c0] page size of serial NOR
    unsigned long sectorSize;                                            // [0x1c4]sector size of Serial NOR
    unsigned char ipcmdSerialClkFreq;                                    // [0x1c8] clock frequency for IP command
#if defined iMX_RT101X
    unsigned char reserved0[55];                                         // reserved for future use
#else
    unsigned char isUniformBlockSize;                                    // sector/block size is the same
    unsigned char reserved0[2];                                          // reserved for future use
    unsigned char serialNorType;                                         // serial NOR flash type: 0/1/2/3
    unsigned char needExitNoCmdMode;                                     // need to exit NoCmd mode before other IP command
    unsigned char halfClkForNonReadCmd;                                  // half the serial clock for non-read command: true/false
    unsigned char needRestoreNoCmdMode;                                  // need to restore NoCmd mode after IP commmand execution
    unsigned long blockSize;                                             // block size
    unsigned long reserve2[11];                                          // reserved for future use
#endif
} FLEXSPI_NOR_BOOT_CONFIGURATION;

typedef struct stBOOT_DATA
{
    unsigned long start;                                                 // boot start location 
    unsigned long size;                                                  // size 
    unsigned long plugin;                                                // plugin flag - 1 if downloaded application is plugin
    unsigned long placeholder;		                                     // placehoder to make even 0x10 size
} BOOT_DATA;

#define PLUGIN_FLAG           (unsigned long)0                           // don't return execution to ROM

#define IVT_MAJOR_VERSION           0x4
#define IVT_MAJOR_VERSION_SHIFT     0x4
#define IVT_MAJOR_VERSION_MASK      0xf
#define IVT_MINOR_VERSION           0x1
#define IVT_MINOR_VERSION_SHIFT     0x0
#define IVT_MINOR_VERSION_MASK      0xf

#define IVT_VERSION(major, minor)   ((((major) & IVT_MAJOR_VERSION_MASK) << IVT_MAJOR_VERSION_SHIFT) | (((minor) & IVT_MINOR_VERSION_MASK) << IVT_MINOR_VERSION_SHIFT))

#define IVT_TAG_HEADER        0xd1                                       // image vector table
#define IVT_SIZE              0x2000
#define IVT_PAR               IVT_VERSION(IVT_MAJOR_VERSION, IVT_MINOR_VERSION)
#define IVT_HEADER           (IVT_TAG_HEADER | (IVT_SIZE << 8) | (IVT_PAR << 24))

typedef struct stIMAGE_VECTOR_TABLE {
    unsigned long hdr;                                                   // header tag that must be IVT_HEADER
    unsigned long entry;                                                 // absolute address of the first instruction to execute from the
    unsigned long reserved1;                                             // reserved in this version of HAB (high assurance boot): should be NULL
    unsigned long dcd;                                                   // absolute address of the image DCD: may be NULL
    unsigned long boot_data;                                             // absolute address of the boot data: may be NULL, but not interpreted any further by HAB
    unsigned long self;                                                  // absolute address of the IVT
    unsigned long csf;                                                   // absolute address of the image CSF
    unsigned long reserved2;                                             // reserved in this version of HAB: should be zero
} IMAGE_VECTOR_TABLE;

// DCD
//
#define DCD_TAG                               0xd2
#define DCD_VERSION                           0x41
#define DCD_WAIT_SET_LONG_WORD                0xcf00001c
#define DCD_LONG_WORD_WRITE_GROUP             0xcc000004

#define ADDRESS_MARKER                        0x55aa7799                 // used only by simulator for checking the DCD table

// Device configuration data
//                                            this is a copy of the macros in driver.h, which is not accessible when the DCD configuration is created by app_hw_iMX.h
#define BIG_SHORT_WORD_BYTES(x)               (unsigned char)((unsigned short)(x) >> 8), (unsigned char)((unsigned short)(x))
#define BIG_LONG_WORD_BYTES(x)                (unsigned char)(((unsigned long)(x) >> 24)), (unsigned char)(((unsigned long)(x) >> 16)), (unsigned char)(((unsigned long)(x) >> 8)), (unsigned char)(((unsigned long)(x)))

#define DCD_WAIT_SIZE                         12
#if defined _WINDOWS
    #define _DCD_WRITE_LONG_WORD(reg, value)  BIG_LONG_WORD_BYTES(ADDRESS_MARKER), BIG_LONG_WORD_BYTES(value)
    #define _BCD_WAIT_SET(reg, value)         BIG_LONG_WORD_BYTES(DCD_WAIT_SET_LONG_WORD | (DCD_WAIT_SIZE << 8)), BIG_LONG_WORD_BYTES(ADDRESS_MARKER), BIG_LONG_WORD_BYTES(value)
#else
    #define _DCD_WRITE_LONG_WORD(reg, value)  BIG_LONG_WORD_BYTES(reg##_ADD), BIG_LONG_WORD_BYTES(value)
    #define _BCD_WAIT_SET(reg, value)         BIG_LONG_WORD_BYTES(DCD_WAIT_SET_LONG_WORD | (DCD_WAIT_SIZE << 8)), BIG_LONG_WORD_BYTES(reg##_ADD), BIG_LONG_WORD_BYTES(value)
#endif
#define GROUP_SIZE(entries)                   ((entries * 8) + 4)
#define _DCD_WRITE_LONG_WORD_GROUP(entries)   BIG_LONG_WORD_BYTES(DCD_LONG_WORD_WRITE_GROUP | (GROUP_SIZE(entries) << 8))


typedef struct _PACK stDCD_HEADER {
    unsigned char ucTag;
    unsigned char ucLength[2];                                           // absolute address of the first instruction to execute from the
    unsigned char ucVersion;                                             // reserved in this version of HAB (high assurance boot): should be NULL
} DCD_HEADER;

#if defined iMX_RT105X || defined iMX_RT106X
    #define SDRAM_CONTROLLER_AVAILABLE
#endif

// Flex SPI
//
#if defined iMX_RT106X || defined iMX_RT1024
    #define FLEX_SPI_INTERFACES    2
#else
    #define FLEX_SPI_INTERFACES    1
#endif

// ROM
//
#define BOOT_ROM_START_ADDRESS      0x00200000
#define BOOT_ROM_SIZE               0x00020000                           // 128k

// SPI Flash
//
#if defined iMX_RT1024 || defined iMX_RT1064
    #define FLEXSPI1_FLASH_BASE     0x60000000
    #define FLEXSPI2_FLASH_BASE     0x70000000
    #define FLEXSPI_FLASH_BASE      (FLEXSPI2_FLASH_BASE)
    #define FLEXSPI2_FLASH_SIZE     (4 * 1024 * 1024)
#else
    #define FLEXSPI_FLASH_BASE      0x60000000
#endif

// Internal Flash
//
#define SIZE_OF_FLASH               (0 * 1024)                           // no on-chip flash FLASH

// SRAM (CM7)
//
#if defined iMX_RT106X || defined MIMXRT1170
    #define RAM_START_ADDRESS_OCR   0x20280000                           // OCRAM (FlexRAM)
    #define RAM_START_ADDRESS_OCR2  0x20200000                           // OCRAM2 (SRAM - not FlexRAM)
    #define SIZE_OF_RAM_OCR2        (512 * 1024)                         // general purpose fixed SRAM size
#else
    #define RAM_START_ADDRESS_OCR   0x20200000                           // OCRAM
#endif
#define RAM_START_ADDRESS_ITC       0x00000000                           // ITCM
#define RAM_START_ADDRESS_DTC       0x20000000                           // DTCM

#if defined SEMC_AVAILABLE
    #define SDRAM_ADDR              0x80000000
#endif

// Default sizes ater a reset
//
#if defined iMX_RT1011/* || defined iMX_RT1015*/                         // 128k flex ram size [the iMX RT 1015 is advertised to have 128k RAM but practically has 256k]
    #define SIZE_OF_RAM_OCR         (64 * 1024)                          // default OCRAM size
    #define SIZE_OF_RAM_ITC         (32 * 1024)                          // default ITC size
    #define SIZE_OF_RAM_DTC         (32 * 1024)                          // default DTC size
    #define SIZE_OF_FLEX_RAM        (128 * 1024)                         // sum of all banks
#elif defined iMX_RT105X || defined iMX_RT106X || defined MIMXRT1170     // 512k flex ram size
    #define SIZE_OF_RAM_OCR         (256 * 1024)                         // default OCRAM size
    #define SIZE_OF_RAM_ITC         (128 * 1024)                         // default ITC size
    #define SIZE_OF_RAM_DTC         (128 * 1024)                         // default DTC size
    #define SIZE_OF_FLEX_RAM        (512 * 1024)                         // sum of all banks
#else                                                                    // 256k flex ram size
    #define SIZE_OF_RAM_OCR         (128 * 1024)                         // default OCRAM size
    #define SIZE_OF_RAM_ITC         (64 * 1024)                          // default ITC size
    #define SIZE_OF_RAM_DTC         (64 * 1024)                          // default DTC size
    #define SIZE_OF_FLEX_RAM        (256 * 1024)                         // sum of all banks
#endif
#define FLEX_RAM_GRANULARITY        (32 * 1024)
#define FLEX_RAM_BANKS              (SIZE_OF_FLEX_RAM / FLEX_RAM_GRANULARITY)

#if defined iMX_BOOTLOADER
    #if defined iMX_RT1011
        #define RAM_START_ADDRESS   (RAM_START_ADDRESS_ITC)              // initial stack pointer towards the top of ITC 
        #define SIZE_OF_RAM         (SIZE_OF_RAM_ITC)
    #else
        #define RAM_START_ADDRESS   (RAM_START_ADDRESS_OCR)              // initial stack pointer towards the top of OCRAM 
        #define SIZE_OF_RAM         (SIZE_OF_RAM_OCR)
    #endif
#else
    #define RAM_START_ADDRESS       (RAM_START_ADDRESS_DTC)              // initial stack pointer in DTC
    #define SIZE_OF_RAM             (SIZE_OF_RAM_DTC)
#endif

#define INTERRUPT_RAM_AREA_SIZE     0x300                                // this area at the start of ITC is reserved for locating interrupt vectors to (the size being lareg enough for the maximum interrupt vector size)
#define BOOT_CONFIG_AREA_SIZE       (4 * 1024)

#define MPU_AVAILABLE


#define BOOT_MAIL_BOX           (volatile unsigned short *)fnGetPersistentMemory()
#define RANDOM_SEED_LOCATION    (volatile unsigned short *)(fnGetPersistentMemory() - 2)
#define BOOT_RESET_CAUSE        (volatile unsigned short *)(fnGetPersistentMemory() - 4) // the reason for the last reset (not counting commanded resets during booting/firmware upload phase)
#define BOOT_RESET_COUNTER      (volatile unsigned short *)(fnGetPersistentMemory() - 6) // the number of resets (neither counting watchdog resets nor commanded resets during booting/firmware upload phase)
#define BOOT_WDOG_COUNTER       (volatile unsigned short *)(fnGetPersistentMemory() - 8) // the number of watchdog resets
#define RTC_VALID_LOCATION      (volatile unsigned short *)(fnGetPersistentMemory() - 10)
#define LOCATION_RESERVED       (volatile unsigned short *)(fnGetPersistentMemory() - 12)
#define RTC_SECONDS_LOCATION    (volatile unsigned long *)(fnGetPersistentMemory() - 14) // long word aligned
#define RTC_ALARM_LOCATION      (volatile unsigned long *)(fnGetPersistentMemory() - 18)
#define SECRET_KEY_0            (volatile unsigned long *)(fnGetPersistentMemory() - 22) // the secret key that was programmed to SW_GP2 by the serial loader will be written here to that the application can read it out (for test or monitoring purposes)
#define SECRET_KEY_1            (volatile unsigned long *)(fnGetPersistentMemory() - 26) // and will be deleted after the next power cycle
#define SECRET_KEY_2            (volatile unsigned long *)(fnGetPersistentMemory() - 30)
#define SECRET_KEY_3            (volatile unsigned long *)(fnGetPersistentMemory() - 34)


#define BOOT_RESET_CAUSE_RESTART         0
#define BOOT_RESET_CAUSE_GOTO_APP        1


#if !defined PERSISTENT_RAM_SIZE                                         // the user can define additional space that will be preserved
    #define PERSISTENT_RAM_SIZE          0
#endif

#define NON_INITIALISED_RAM_SIZE         (38 + PERSISTENT_RAM_SIZE)      // reserve space at the end of SRAM for use by random number, serial loader mailbox and other persistent information

#if defined _WINDOWS
    extern unsigned char uninitialisedRAM[NON_INITIALISED_RAM_SIZE];
#endif

#if defined iMX_BOOTLOADER || defined iMX_SERIAL_LOADER
    #define _NON_INITIALISED_RAM_SIZE    (16 * 1024)                     // leave a large amount of space to ensure room for expansion of persistent parameters if used by the application
#else
    #define _NON_INITIALISED_RAM_SIZE    NON_INITIALISED_RAM_SIZE
#endif

#define BOOT_LOADER_TYPE_MASK                    0xf000
#define BOOT_LOADER_TYPE_PLAIN_XiP_RESET_VECTOR  0x0000                  // execute in QSPi flash (execute in place) starting with reset vector
#define BOOT_LOADER_TYPE_PLAIN_RAM_EXECUTION     0x1000                  // copy plain code to ITC and execute there
#define BOOT_LOADER_TYPE_PLAIN_XiP_CONFIG_TABLE  0x2000                  // execute in QSPi flash (execute in place) starting with configuration table
#define BOOT_LOADER_TYPE_PLAIN_SDRAM_EXECUTION   0x3000                  // copy plain code to SDRAM and execute there
#define BOOT_LOADER_TYPE_AES256_SDRAM_EXECUTION  0x4000                  // decrypt AES256 encrypted code to SDRAM and execute there
#define BOOT_LOADER_TYPE_AES128_XiP_RESET_VECTOR 0x5000                  // execute in QSPI flash (execute in place) starting with reset vector using on-the-fly decryption
#define BOOT_LOADER_TYPE_AES128_XiP_CONFIG_TABLE 0x6000                  // execute in QSPI flash (execute in place) starting with configuration table using on-the-fly decryption
#define BOOT_LOADER_TYPE_AES256_RAM_EXECUTION    0x9000                  // decrypt AES256 encrypted code to ITC and execute there

typedef struct _PACK stiMX_BOOT_HEADER                                   // note that this struct should always be a multiple of long words in size (so that an aligned reset vector can follow it) in memory
{
    unsigned long  ulCodeLength;
    unsigned short usMagicNumber;
    unsigned short usCRC;
} iMX_BOOT_HEADER;

extern void fniMXHeaderToLittleEndian(iMX_BOOT_HEADER *file_header);
extern unsigned long fnCheckValidApplication(iMX_BOOT_HEADER *ptrApplicationHeader, const unsigned char *ptrCode);

#define iMX_LOADER_AES256_STORAGE_AREA_SIZE 48                           // space for 32 byte AES256 key string and terminator, plus 15 bytes reserve
#define iMX_LOADER_VECTOR_STORAGE_AREA_SIZE 32                           // space for 16 byte AES256 initial seed string and terminator, plus 15 bytes reserve
#define iMX_LOADER_KEY_STORAGE_AREA_SIZE  (iMX_LOADER_AES256_STORAGE_AREA_SIZE + iMX_LOADER_VECTOR_STORAGE_AREA_SIZE) // 80 bytes in total

#if defined SPI_FLASH_S26KL
    #define BM_FLASH_AREA_SIZE            (256 * 1024)                   // first block in QSPI flash reserved for the boot loader (and fall-back serial loader)
#else
    #define BM_FLASH_AREA_SIZE            (64 * 1024)                    // first block in QSPI flash reserved for the boot loader (and fall-back serial loader)
#endif
#define FALL_BACK_SERIAL_LOADER_OFFSET    (16 * 1024)
#define SERIAL_LOADER_FLASH_AREA_SIZE     (BM_FLASH_AREA_SIZE)           // second area in QSPI flash reserved for a serial loader
#define APPLICATION_FLASH_AREA_SIZE       (512 * 1024)                   // third area in QSPI flash reserved for firmware upload area
#define FLASH_BOOT_PROGRAM_AREA_SIZE      (BM_FLASH_AREA_SIZE + SERIAL_LOADER_FLASH_AREA_SIZE + APPLICATION_FLASH_AREA_SIZE)

#define iMX_FILE_OBJECT_SIZE              0x100
#define iMX_FALLBACK_LOADER_LOCATION      (FLEXSPI_FLASH_BASE + FALL_BACK_SERIAL_LOADER_OFFSET)
#define iMX_SERIAL_LOADER_LOCATION        (FLEXSPI_FLASH_BASE + BM_FLASH_AREA_SIZE)
#define iMX_APPLICATION_LOCATION          (FLEXSPI_FLASH_BASE + BM_FLASH_AREA_SIZE + SERIAL_LOADER_FLASH_AREA_SIZE)

#define MAXIMUM_ITC_CODE_SIZE             (SIZE_OF_FLEX_RAM - FLEX_RAM_GRANULARITY) // the maximum size of code operating in ITC is the size of the FlexRAM minus one bak which is assumed to be used for DTC)
#define MAXIMUM_XiP_CODE_SIZE             (FLEXSPI_FLASH_SIZE - (BM_FLASH_AREA_SIZE + SERIAL_LOADER_FLASH_AREA_SIZE)) // maximum code size that fits into QSPI flash (after loaders and assuming no file or parameter systems are present)

#if defined MIMXRT1024 || defined MIMXRT1064
    #define ORIGINAL_KEYS_ADDRESS  (unsigned char *)(FLEXSPI2_FLASH_BASE + 0x2000 - iMX_LOADER_KEY_STORAGE_AREA_SIZE)
    #define ENCRYPTED_KEYS_ADDRESS (unsigned char *)(FLEXSPI2_FLASH_BASE + FALL_BACK_SERIAL_LOADER_OFFSET - iMX_LOADER_KEY_STORAGE_AREA_SIZE)
#else
    #define ORIGINAL_KEYS_ADDRESS  (unsigned char *)(FLEXSPI_FLASH_BASE + 0x2000 - iMX_LOADER_KEY_STORAGE_AREA_SIZE)
    #define ENCRYPTED_KEYS_ADDRESS (unsigned char *)(FLEXSPI_FLASH_BASE + FALL_BACK_SERIAL_LOADER_OFFSET - iMX_LOADER_KEY_STORAGE_AREA_SIZE)
#endif

// FlexCAN
//
typedef struct stKINETIS_CAN_BUF
{
    volatile unsigned long ulCode_Len_TimeStamp;
    volatile unsigned long ulID;
    volatile unsigned long ulData[2];
} KINETIS_CAN_BUF;


// Ethernet configuration
//
#if !defined iMX_RT101X
    #define ETHERNET_AVAILABLE
    #if defined iMX_RT106X
        #define ETHERNET_COUNT    2
    #else
        #define ETHERNET_COUNT    1
    #endif
#else
    #define ETHERNET_COUNT        0
#endif


#if defined iMX_RT101X
    #define ACMPS_AVAILABLE    0
#else
    #define ACMPS_AVAILABLE    4
#endif

#if defined iMX_RT1015
    #define ENCS_AVAILABLE    1
#elif defined iMX_RT101X
    #define ENCS_AVAILABLE    0
#else
    #define ENCS_AVAILABLE    2
#endif

// HSUART configuration
//
#define USB_HS_INTERFACE
#if defined iMX_RT105X || defined iMX_RT106X
    #define HSUSB_CONTROLLERS   2
#else
    #define HSUSB_CONTROLLERS   1
#endif
#define iMX_USUSB_1             0
#define iMX_USUSB_2             1
#define USBS_AVAILABLE          HSUSB_CONTROLLERS


// UART configuration
//
#define UARTS_AVAILABLE         0

// LPUART configuration
//
#if defined iMX_RT101X
    #define LPUARTS_AVAILABLE       4                                    // LPUARTs 1..4
#else
    #define LPUARTS_AVAILABLE       8                                    // LPUARTs 1..8
#endif

#define iMX_LPUART_1          0
#define iMX_LPUART_2          1
#define iMX_LPUART_3          2
#define iMX_LPUART_4          3
#if LPUARTS_AVAILABLE > 4
    #define iMX_LPUART_5      4
    #define iMX_LPUART_6      5
    #define iMX_LPUART_7      6
    #define iMX_LPUART_8      7
#endif

// SPI configuration
//
#if defined iMX_RT101X
    #define LPSPI_AVAILABLE          2
    #define SPI0_FIFO_DEPTH          16                                  // LPSPI1 has 16 deep rx/tx FIFO
    #define SPI1_FIFO_DEPTH          16                                  // LPSPI2 has 16 deep rx/tx FIFO
#else
    #define LPSPI_AVAILABLE          4                                   // low power SPI
    #define SPI1_FIFO_DEPTH          16                                  // LPSPI1 has 16 deep rx/tx FIFO
    #define SPI2_FIFO_DEPTH          16                                  // LPSPI2 has 16 deep rx/tx FIFO
    #define SPI3_FIFO_DEPTH          16                                  // LPSPI3 has 16 deep rx/tx FIFO
    #define SPI4_FIFO_DEPTH          16                                  // LPSPI4 has 16 deep rx/tx FIFO
#endif

#define iMX_LPSPI_1                  0
#define iMX_LPSPI_2                  1
#define iMX_LPSPI_3                  2
#define iMX_LPSPI_4                  3

#define SPI_AVAILABLE              (SPI_AVAILABLE)



#define SPI_CHIP_SELECTS            6

#define QSPI_AVAILABLE              1

// I2C configuration
//
#define I2C_AVAILABLE                0
#if defined iMX_RT101X
    #define LPI2C_AVAILABLE          2
#else
    #define LPI2C_AVAILABLE          4
#endif

#define iMX_LPI2C_1                  0
#define iMX_LPI2C_2                  1
#define iMX_LPI2C_3                  2
#define iMX_LPI2C_4                  3


// I2S configuration
//
#define I2S_AVAILABLE                1


// PIT configuration
//
#define PITS_AVAILABLE               4
#define PIT_SINGLE_INTERRUPT

#define iMX_FLEXCAN_1                0
#define iMX_FLEXCAN_2                1

// GPT configuration
//
#define GPT_AVAILABLE                2

#define iMX_GPT_1                    0
#define iMX_GPT_2                    1

// Quad Timer configuration
//
#if defined iMX_RT1011
    #define QUAD_TIMER_AVAILABLE     0
#elif defined iMX_RT1015
    #define QUAD_TIMER_AVAILABLE     1
#elif defined iMX_RT102X
    #define QUAD_TIMER_AVAILABLE     2
#else
    #define QUAD_TIMER_AVAILABLE     4
#endif

// XBARA configuration
//
#if defined iMX_RT1011
    #define XBARA_AVAILABLE          1
#elif defined iMX_RT105X
    #define XBARA_AVAILABLE          2
#else
    #define XBARA_AVAILABLE          3
#endif

#if defined iMX_RT1011
    #define FLEXPWM_AVAILABLE        1
#elif defined iMX_RT102X
    #define FLEXPWM_AVAILABLE        2
#else
    #define FLEXPWM_AVAILABLE        4
#endif
#define FLEXPWM_CHANNELS             4


// ADC configuration
//
#if defined iMX_RT102X || defined iMX_RT105X || defined iMX_RT106X
    #define ADC_CONTROLLERS         2
#else
    #define ADC_CONTROLLERS         1
#endif


#define VTEMP_25_MV                 716                                  // typical internal temperature sensor reference voltage (in mV) (3.3V VDD/VREF and < 3MHz ADC clock speed)
#define TEMP_SENSOR_SLOPE_UV        1620                                 // typical internal temperature sensor slope uV/Â°C (3.3V VDD/VREF and < 3MHz ADC clock speed)

#define HIGH_SPEED_ADC_AVAILABLE

// DAC configuration
//
#define DAC_CONTROLLERS         0


// Comparator configuration
//
#if defined iMX_RT102X || defined iMX_RT105X || defined iMX_RT106X
    #define NUMBER_OF_COMPARATORS 4
#else
    #define NUMBER_OF_COMPARATORS 0
#endif


// SDHC configuration
//
#if defined iMX_RT102X || defined iMX_RT105X || defined iMX_RT106X
    #define NUMBER_OF_SDHC        2
#else
    #define NUMBER_OF_SDHC        0
#endif



// RNG configuration
//
#define RNG_AVAILABLE                                                    // hardware based random number generator available
#if /*!defined iMX_RT105X &&*/ !defined iMX_RT1011                       // the standard TRNG initialisation code doesn't work on the i.MX RT 105X so we disable it until solved
    #define TRUE_RANDOM_NUMBER_GENERATOR                                 // true random number generator is available
#endif


// FlexIO configuration
//
#define CHIP_HAS_FLEXIO


// Define the number of ports that the processor has
//
#define PORT1                0
#define PORT2                1
#if !defined iMX_RT1011
    #define PORT3            2
#endif
#if defined iMX_RT105X || defined iMX_RT106X
    #define PORT4            3
#endif
#define PORT5                4
#if defined iMX_RT106X
    #define PORT6            5
    #define PORT7            6
    #define PORT8            7
    #define PORT9            8
    #define PORTS_AVAILABLE  9
#else
    #define PORTS_AVAILABLE  5
#endif


// DMA configuration
//
#define DEVICE_WITH_TWO_DMA_GROUPS
#define eDMA_SHARES_INTERRUPTS                                           // DMA channel 16 shares an interrupt vector with channel 0, 16 with 1, 17 with 2 and 18 with 3, etc.
#define DMA_CHANNEL_COUNT        32



// i.MX RT interrupts
//
typedef struct stPROCESSOR_IRQ
{
    void  (*irq_DMA0)(void);                                             // 0  - shared with DMA16
    void  (*irq_DMA1)(void);                                             // 1  - shared with DMA17
    void  (*irq_DMA2)(void);                                             // 2  - shared with DMA18
    void  (*irq_DMA3)(void);                                             // 3  - shared with DMA19
    void  (*irq_DMA4)(void);                                             // 4  - shared with DMA20
    void  (*irq_DMA5)(void);                                             // 5  - shared with DMA21
    void  (*irq_DMA6)(void);                                             // 6  - shared with DMA22
    void  (*irq_DMA7)(void);                                             // 7  - shared with DMA23
    void  (*irq_DMA8)(void);                                             // 8  - shared with DMA24
    void  (*irq_DMA9)(void);                                             // 9  - shared with DMA25
    void  (*irq_DMA10)(void);                                            // 10 - shared with DMA26
    void  (*irq_DMA11)(void);                                            // 11 - shared with DMA27
    void  (*irq_DMA12)(void);                                            // 12 - shared with DMA28
    void  (*irq_DMA13)(void);                                            // 13 - shared with DMA29
    void  (*irq_DMA14)(void);                                            // 14 - shared with DMA30
    void  (*irq_DMA15)(void);                                            // 15 - shared with DMA31
    void  (*irq_DMA_ERROR)(void);                                        // 16
    void  (*irq_CM7_CTIIRQ0)(void);                                      // 17
    void  (*irq_CM7_CTIIRQ1)(void);                                      // 18
    void  (*irq_CM7_IRQ)(void);                                          // 19
    void  (*irq_LPUART0)(void);                                          // 20 tx/rx
    void  (*irq_LPUART1)(void);                                          // 21 tx/rx
    void  (*irq_LPUART2)(void);                                          // 22 tx/rx
    void  (*irq_LPUART3)(void);                                          // 23 tx/rx
#if defined iMX_RT1011
    void  (*irq_PIT)(void);                                              // 24
    void  (*irq_USB_OTG0)(void);                                         // 25
    void  (*irq_FLEXSPI0)(void);                                         // 26
    void  (*irq_CM7_FlexRAM)(void);                                      // 27
#else
    #if LPUARTS_AVAILABLE > 4
    void  (*irq_LPUART4)(void);                                          // 24 tx/rx
    void  (*irq_LPUART5)(void);                                          // 25 tx/rx
    void  (*irq_LPUART6)(void);                                          // 26 tx/rx
    void  (*irq_LPUART7)(void);                                          // 27 tx/rx
    #else
    void  (*reserved24)(void);                                           // 24
    void  (*reserved25)(void);                                           // 25
    void  (*reserved26)(void);                                           // 26
    void  (*reserved27)(void);                                           // 27
    #endif
#endif
    void  (*irq_LPI2C0)(void);                                           // 28
    void  (*irq_LPI2C1)(void);                                           // 29
#if defined iMX_RT1011
    void  (*irq_GPT1)(void);                                             // 30
    void  (*irq_GPT2)(void);                                             // 31
#else
    #if LPI2C_AVAILABLE > 2
    void  (*irq_LPI2C2)(void);                                           // 30
    void  (*irq_LPI2C3)(void);                                           // 31
    #else
    void  (*reserved30)(void);                                           // 30
    void  (*reserved31)(void);                                           // 31
    #endif
#endif
    void  (*irq_LPSPI0)(void);                                           // 32
    void  (*irq_LPSPI1)(void);                                           // 33
#if defined iMX_RT1011
    void  (*irq_FLEXPWM1_0)(void);                                       // 34
    void  (*irq_FLEXPWM1_1)(void);                                       // 35
    void  (*irq_FLEXPWM1_2)(void);                                       // 36
    void  (*irq_FLEXPWM1_3)(void);                                       // 37
    void  (*irq_FLEXPWM1_Fault)(void);                                   // 38
#else
    #if LPSPI_AVAILABLE > 2
    void  (*irq_LPSPI2)(void);                                           // 34
    void  (*irq_LPSPI3)(void);                                           // 35
    #else
    void  (*reserved34)(void);                                           // 34
    void  (*reserved35)(void);                                           // 35
    #endif
    #if NUMBER_OF_CAN_INTERFACES > 0
    void  (*irq_CAN0)(void);                                             // 36
    void  (*irq_CAN1)(void);                                             // 37
    #else
    void  (*reserved36)(void);                                           // 36
    void  (*reserved37)(void);                                           // 37
    #endif
    void  (*irq_CM7_FlexRAM)(void);                                      // 38
#endif
    void  (*irq_KPP)(void);                                              // 39
#if defined iMX_RT1011
    void  (*irq_SRC)(void);                                              // 40
#elif defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_TSC_DIG)(void);                                          // 40
#else
    void  (*reserved40)(void);                                           // 40
#endif
    void  (*irq_GPR_IRQ)(void);                                          // 41
#if defined iMX_RT1011
    void  (*irq_CCM1)(void);                                             // 42
    void  (*irq_CCM2)(void);                                             // 43
    void  (*irq_EWM)(void);                                              // 44
#elif defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_LCDIF)(void);                                            // 42
    void  (*irq_CSI)(void);                                              // 43
    void  (*irq_PXP)(void);                                              // 44
#else
    void  (*reserved42)(void);                                           // 42
    void  (*reserved43)(void);                                           // 43
    void  (*reserved44)(void);                                           // 44
#endif
    void  (*irq_WDOG2)(void);                                            // 45
    void  (*irq_SNVS_Func)(void);                                        // 46
    void  (*irq_SNVS_Security)(void);                                    // 47
    void  (*irq_SNVS_OnOff)(void);                                       // 48
    void  (*irq_CSU)(void);                                              // 49
    void  (*irq_DCP)(void);                                              // 50
    void  (*irq_DCP_CH0)(void);                                          // 51
    void  (*reserved52)(void);
    void  (*irq_TRNG0)(void);                                            // 53
#if defined iMX_RT1011
    void  (*reserved54)(void);                                           // 54
    void  (*reserved55)(void);                                           // 55
#else
    #if defined iMX_RT1015
    void  (*reserved54)(void);                                           // 54
    #else
    void  (*irq_SJC)(void);                                              // 54
    #endif
    void  (*irq_BEE)(void);                                              // 55
#endif
    void  (*irq_SAI0)(void);                                             // 56
#if defined iMX_RT1011
    void  (*irq_RTWDOG)(void);                                           // 57
#else
    void  (*irq_SAI1)(void);                                             // 57
#endif
    void  (*irq_SAI2_Rx)(void);                                          // 58
    void  (*irq_SAI2_Tx)(void);                                          // 59
    void  (*irq_SPDIF)(void);                                            // 60
    void  (*irq_PMU)(void);                                              // 61
#if defined iMX_RT1011
    void  (*irq_XBAR1_0_1_2_3)(void);                                    // 62
#else
    void  (*reserved62)(void);
#endif
    void  (*irq_Temperature_Hi_Lo)(void);                                // 63
    void  (*irq_Temperature_Panic)(void);                                // 64
    void  (*irq_USB_PHY)(void);                                          // 65
#if defined iMX_RT1011
    void  (*irq_GPC)(void);                                              // 66
#else
    void  (*reserved66)(void);                                           // 66
#endif
    void  (*irq_ADC0)(void);                                             // 67
#if defined iMX_RT1011
    void  (*irq_FlexIO1)(void);                                          // 68
#else
    #if ADC_CONTROLLERS > 1
    void  (*irq_ADC1)(void);                                             // 68
    #else
    void  (*reserved68)(void);                                           // 68
    #endif
#endif
    void  (*irq_DCDC)(void);                                             // 69
#if defined iMX_RT1011
    void  (*irq_GPIO1_0_15)(void);                                       // 70
    void  (*irq_GPIO1_16_31)(void);                                      // 71
    void  (*irq_GPIO2_0_15)(void);                                       // 72
    void  (*irq_GPIO5_0_15)(void);                                       // 73
    void  (*irq_WDOG1)(void);                                            // 74
    void  (*irq_ADC_ETC_0)(void);                                        // 75
    void  (*irq_ADC_ETC_1)(void);                                        // 76
    void  (*irq_ADC_ETC_2)(void);                                        // 77
    void  (*irq_ADC_ETC_3)(void);                                        // 78
    void  (*irq_ADC_ETC_Err)(void);                                      // 79
#else
    void  (*reserved70)(void);
    void  (*reserved71)(void);
    void  (*irq_GPIO1_Hi_0)(void);                                       // 72
    void  (*irq_GPIO1_Hi_1)(void);                                       // 73
    void  (*irq_GPIO1_Hi_2)(void);                                       // 74
    void  (*irq_GPIO1_Hi_3)(void);                                       // 75
    void  (*irq_GPIO1_Hi_4)(void);                                       // 76
    void  (*irq_GPIO1_Hi_5)(void);                                       // 77
    void  (*irq_GPIO1_Hi_6)(void);                                       // 78
    void  (*irq_GPIO1_Hi_7)(void);                                       // 79
    void  (*irq_GPIO1_0_15)(void);                                       // 80
    void  (*irq_GPIO1_16_31)(void);                                      // 81
    void  (*irq_GPIO2_0_15)(void);                                       // 82
    void  (*irq_GPIO2_16_31)(void);                                      // 83
    void  (*irq_GPIO3_0_15)(void);                                       // 84
    void  (*irq_GPIO3_16_31)(void);                                      // 85
    #if defined PORT4
    void  (*irq_GPIO4_0_15)(void);                                       // 86
    void  (*irq_GPIO4_16_31)(void);                                      // 87
    #else
    void  (*reserved86)(void);
    void  (*reserved87)(void);
    #endif
    void  (*irq_GPIO5_0_15)(void);                                       // 88
    void  (*irq_GPIO5_16_31)(void);                                      // 89
    void  (*irq_FlexIO1)(void);                                          // 90
    #if defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_FlexIO2)(void);                                          // 91
    #else
    void  (*reserved91)(void);                                           // 91
    #endif
    void  (*irq_WDOG1)(void);                                            // 92
    void  (*irq_RTWDOG)(void);                                           // 93
    void  (*irq_EWM)(void);                                              // 94
    void  (*irq_CCM1)(void);                                             // 95
    void  (*irq_CCM2)(void);                                             // 96
    void  (*irq_GPC)(void);                                              // 97
    void  (*irq_SRC)(void);                                              // 98
    void  (*reserved99)(void);                                           // 99
    void  (*irq_GPT1)(void);                                             // 100
    void  (*irq_GPT2)(void);                                             // 101
    void  (*irq_FLEXPWM1_0)(void);                                       // 102
    void  (*irq_FLEXPWM1_1)(void);                                       // 103
    void  (*irq_FLEXPWM1_2)(void);                                       // 104
    void  (*irq_FLEXPWM1_3)(void);                                       // 105
    void  (*irq_FLEXPWM1_Fault)(void);                                   // 106
    #if defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_FLEXSPI1)(void);                                         // 107
    #else
    void  (*reserved107)(void);                                          // 107
    #endif
    void  (*irq_FLEXSPI)(void);                                          // 108
    void  (*irq_SEMC)(void);                                             // 109
    #if NUMBER_OF_SDHC > 0
    void  (*irq_USDHC1)(void);                                           // 110
    #else
    void  (*reserved110)(void);                                          // 110
    #endif
    #if NUMBER_OF_SDHC > 1
    void  (*irq_USDHC2)(void);                                           // 111
    #else
    void  (*reserved111)(void);                                          // 111
    #endif
    #if HSUSB_CONTROLLERS > 1
    void  (*irq_USB_OTG1)(void);                                         // 112
    #else
    void  (*reserved112)(void);
    #endif
    void  (*irq_USB_OTG0)(void);                                         // 113
    void  (*irq_ETH)(void);                                              // 114
    void  (*irq_ETH_1588)(void);                                         // 115
    void  (*irq_XBAR1_0_1)(void);                                        // 116
    void  (*irq_XBAR1_2_3)(void);                                        // 117
    void  (*irq_ADC_ETC_0)(void);                                        // 118
    void  (*irq_ADC_ETC_1)(void);                                        // 119
    void  (*irq_ADC_ETC_2)(void);                                        // 120
    void  (*irq_ADC_ETC_Err)(void);                                      // 121
    void  (*irq_PIT)(void);                                              // 122
    #if ACMPS_AVAILABLE > 0
    void  (*irq_ACMP_1)(void);                                           // 123
    void  (*irq_ACMP_2)(void);                                           // 124
    void  (*irq_ACMP_3)(void);                                           // 125
    void  (*irq_ACMP_4)(void);                                           // 126
    #else
    void  (*reserved123)(void);                                          // 123
    void  (*reserved124)(void);                                          // 124
    void  (*reserved125)(void);                                          // 125
    void  (*reserved126)(void);                                          // 126
    #endif
    void  (*reserved127)(void);                                          // 127
    void  (*reserved128)(void);                                          // 128
    void  (*irq_ENC1)(void);                                             // 129
    #if ENCS_AVAILABLE > 1
    void  (*irq_ENC2)(void);                                             // 130
    #else
    void  (*reserved130)(void);                                          // 130
    #endif
    #if defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_ENC3)(void);                                             // 131
    void  (*irq_ENC4)(void);                                             // 132
    #else
    void  (*reserved131)(void);
    void  (*reserved132)(void);
    #endif
    void  (*irq_QTIMER1)(void);                                          // 133
    #if !defined iMX_RT1015
    void  (*irq_QTIMER2)(void);                                          // 134
        #if defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_QTIMER3)(void);                                          // 135
    void  (*irq_QTIMER4)(void);                                          // 136
        #else
    void  (*reserved135)(void);                                          // 135
    void  (*reserved136)(void);                                          // 136
        #endif
    void  (*irq_FLEXPWM2_0)(void);                                       // 137
    void  (*irq_FLEXPWM2_1)(void);                                       // 138
    void  (*irq_FLEXPWM2_2)(void);                                       // 139
    void  (*irq_FLEXPWM2_3)(void);                                       // 140
    void  (*irq_FLEXPWM2_Fault)(void);                                   // 141
        #if defined iMX_RT105X || defined iMX_RT106X
    void  (*irq_FLEXPWM3_0)(void);                                       // 142
    void  (*irq_FLEXPWM3_1)(void);                                       // 143
    void  (*irq_FLEXPWM3_2)(void);                                       // 144
    void  (*irq_FLEXPWM3_3)(void);                                       // 145
    void  (*irq_FLEXPWM3_Fault)(void);                                   // 146
    void  (*irq_FLEXPWM4_0)(void);                                       // 147
    void  (*irq_FLEXPWM4_1)(void);                                       // 148
    void  (*irq_FLEXPWM4_2)(void);                                       // 149
    void  (*irq_FLEXPWM4_3)(void);                                       // 150
    void  (*irq_FLEXPWM4_Fault)(void);                                   // 151
        #endif
        #if defined iMX_RT106X
    void  (*irq_ETH1)(void);                                             // 152
    void  (*irq_ETH1_1588)(void);                                        // 153
    void  (*irq_CAN3)(void);                                             // 154
    void  (*reserved155)(void);                                          // 155
    void  (*irq_FlexIO3)(void);                                          // 156
    void  (*irq_GPIO6_7_8_9)(void);                                      // 157
        #endif
    #endif
#endif
} PROCESSOR_IRQ;


typedef struct stVECTOR_TABLE
{
    RESET_VECTOR  reset_vect;
    void  (*ptrNMI)(void);
    void  (*ptrHardFault)(void);
    void  (*ptrMemManagement)(void);
    void  (*ptrBusFault)(void);
    void  (*ptrUsageFault)(void);
    unsigned long ptrReserved0;
    unsigned long ptrReserved1;
    unsigned long ptrReserved2;
    unsigned long ptrReserved3;
    void  (*ptrSVCall)(void);
    void  (*ptrDebugMonitor)(void);
    unsigned long ptrReserved4;
    void  (*ptrPendSV)(void);
    void  (*ptrSysTick)(void);
    PROCESSOR_IRQ processor_interrupts;                                  // length is processor specific
} VECTOR_TABLE;


// Interrupt sources
//
    #define irq_DMA0_ID                   0                              // shared with DMA16
    #define irq_DMA1_ID                   1                              // shared with DMA17
    #define irq_DMA2_ID                   2                              // shared with DMA18
    #define irq_DMA3_ID                   3                              // shared with DMA19
    #define irq_DMA4_ID                   4                              // shared with DMA20
    #define irq_DMA5_ID                   5                              // shared with DMA21
    #define irq_DMA6_ID                   6                              // shared with DMA22
    #define irq_DMA7_ID                   7                              // shared with DMA23
    #define irq_DMA8_ID                   8                              // shared with DMA24
    #define irq_DMA9_ID                   9                              // shared with DMA25
    #define irq_DMA10_ID                  10                             // shared with DMA26
    #define irq_DMA11_ID                  11                             // shared with DMA27
    #define irq_DMA12_ID                  12                             // shared with DMA28
    #define irq_DMA13_ID                  13                             // shared with DMA29
    #define irq_DMA14_ID                  14                             // shared with DMA30
    #define irq_DMA15_ID                  15                             // shared with DMA31
    #define irq_DMA_ERROR_ID              16
    #define irq_CM7_CTIIRQ0_ID            17
    #define irq_CM7_CTIIRQ1_ID            18
    #define irq_CM7_IRQ_ID                19
    #define irq_LPUART0_ID                20                             // LPUART1 - interrupt vector numbering for general compatibility
    #define irq_LPUART1_ID                21                             // LPUART2 - interrupt vector numbering for general compatibility
    #define irq_LPUART2_ID                22                             // LPUART3 - interrupt vector numbering for general compatibility
    #define irq_LPUART3_ID                23                             // LPUART4 - interrupt vector numbering for general compatibility
#if defined iMX_RT1011
    #define irq_PIT_ID                    24
    #define irq_USB_OTG0_ID               25
    #define irq_FLEXSPI0_ID               26
    #define irq_CM7_FlexRAM_ID            27
#elif LPUARTS_AVAILABLE > 4
    #define irq_LPUART4_ID                24                             // LPUART5 - interrupt vector numbering for general compatibility
    #define irq_LPUART5_ID                25                             // LPUART6 - interrupt vector numbering for general compatibility
    #define irq_LPUART6_ID                26                             // LPUART7 - interrupt vector numbering for general compatibility
    #define irq_LPUART7_ID                27                             // LPUART8 - interrupt vector numbering for general compatibility
#endif
    #define irq_LPI2C0_ID                 28                             // LPI2C1 - interrupt vector numbering for general compatibility
    #define irq_LPI2C1_ID                 29                             // LPI2C2 - interrupt vector numbering for general compatibility
#if defined iMX_RT1011
    #define irq_GPT1_ID                   30
    #define irq_GPT2_ID                   31
#elif LPI2C_AVAILABLE > 2
    #define irq_LPI2C2_ID                 30                             // LPI2C3 - interrupt vector numbering for general compatibility
    #define irq_LPI2C3_ID                 31                             // LPI2C4 - interrupt vector numbering for general compatibility
#endif
    #define irq_LPSPI0_ID                 32                             // LPSPI1 - interrupt vector numbering for general compatibility
    #define irq_LPSPI1_ID                 33                             // LPSPI2 - interrupt vector numbering for general compatibility
#if defined iMX_RT1011
    #define irq_FLEXPWM1_0_ID             34
    #define irq_FLEXPWM1_1_ID             35
    #define irq_FLEXPWM1_2_ID             36
    #define irq_FLEXPWM1_3_ID             37
    #define irq_FLEXPWM1_Fault_ID         38
#else
    #if LPSPI_AVAILABLE > 2
        #define irq_LPSPI2_ID             34                             // LPSPI3 - interrupt vector numbering for general compatibility
        #define irq_LPSPI3_ID             35                             // LPSPI4 - interrupt vector numbering for general compatibility
    #endif
    #if NUMBER_OF_CAN_INTERFACES > 0
        #define irq_CAN0_MESSAGE_ID       36
        #define irq_CAN1_MESSAGE_ID       37
    #endif
    #define irq_CM7_FlexRAM_ID            38
#endif
    #define irq_KPP_ID                    39
#if defined iMX_RT1011
    #define irq_SRC_ID                    40
#elif defined iMX_RT105X || defined iMX_RT106X
    #define irq_TSC_DIG_ID                40
#endif
    #define irq_GPR_IRQ_ID                41
#if defined iMX_RT1011
    #define irq_CCM1_ID                   42
    #define irq_CCM2_ID                   43
    #define irq_EWM_ID                    44
#elif defined iMX_RT105X || defined iMX_RT106X
    #define irq_LCDIF_ID                  42
    #define irq_CSI_ID                    43
    #define irq_PXP_ID                    44
#endif
    #define irq_WDOG2_ID                  45
    #define irq_SNVS_Func_ID              46
    #define irq_SNVS_Security_ID          47
    #define irq_SNVS_OnOff_ID             48
    #define irq_CSU_ID                    49
    #define irq_DCP_ID                    50
    #define irq_DCP_CH0_ID                51

    #define irq_TRNG0_ID                  53
#if !defined iMX_RT101X
    #define irq_SJC_ID                    54
#endif
#if !defined iMX_RT1011
    #define irq_BEE_ID                    55
#endif
    #define irq_SAI0_ID                   56
#if defined iMX_RT1011
    #define irq_RTWDOG_ID                 57
#else
    #define irq_SAI1_ID                   57
#endif
    #define irq_SAI2_Rx_ID                58
    #define irq_SAI2_Tx_ID                59
    #define irq_SPDIF_ID                  60
    #define irq_PMU_ID                    61
#if defined iMX_RT1011
    #define irq_XBAR1_0_1_2_3_ID          62
#endif
    #define irq_Temperature_Hi_Lo_ID      63
    #define irq_Temperature_Panic_ID      64
    #define irq_USB_PHY_ID                65
#if defined iMX_RT1011
    #define irq_GPC_ID                    66
#endif
    #define irq_ADC1_ID                   67
#if defined iMX_RT1011
    #define irq_FlexIO1_ID                68
#elif ADC_CONTROLLERS > 1
    #define irq_ADC2_ID                   68
#endif
    #define irq_DCDC_ID                   69
   
#if defined iMX_RT1011
    #define irq_GPIO1_0_15_ID             70
    #define irq_GPIO1_16_31_ID            71
    #define irq_GPIO2_0_15_ID             72
    #define irq_GPIO5_0_15_ID             73
    #define irq_WDOG1_ID                  74
    #define irq_ADC_ETC_0_ID              75
    #define irq_ADC_ETC_1_ID              76
    #define irq_ADC_ETC_2_ID              77
    #define irq_ADC_ETC_3_ID              78
    #define irq_ADC_ETC_Err_ID            79
#else
    #define irq_GPIO1_Hi_0_ID             72
    #define irq_GPIO1_Hi_1_ID             73
    #define irq_GPIO1_Hi_2_ID             74
    #define irq_GPIO1_Hi_3_ID             75
    #define irq_GPIO1_Hi_4_ID             76
    #define irq_GPIO1_Hi_5_ID             77
    #define irq_GPIO1_Hi_6_ID             78
    #define irq_GPIO1_Hi_7_ID             79
    #define irq_GPIO1_0_15_ID             80
    #define irq_GPIO1_16_31_ID            81
    #define irq_GPIO2_0_15_ID             82
    #define irq_GPIO2_16_31_ID            83
    #define irq_GPIO3_0_15_ID             84
    #define irq_GPIO3_16_31_ID            85
    #if defined PORT4
        #define irq_GPIO4_0_15_ID         86
        #define irq_GPIO4_16_31_ID        87
    #endif
    #define irq_GPIO5_0_15_ID             88
    #define irq_GPIO5_16_31_ID            89
    #define irq_FlexIO1_ID                90
    #if defined iMX_RT105X || defined iMX_RT106X
        #define irq_FlexIO2_ID            91
    #endif
    #define irq_WDOG1_ID                  92
    #define irq_RTWDOG_ID                 93
    #define irq_EWM_ID                    94
    #define irq_CCM1_ID                   95
    #define irq_CCM2_ID                   96
    #define irq_GPC_ID                    97
    #define irq_SRC_ID                    98

    #define irq_GPT1_ID                   100
    #define irq_GPT2_ID                   101
    #define irq_FLEXPWM1_0_ID             102
    #define irq_FLEXPWM1_1_ID             103
    #define irq_FLEXPWM1_2_ID             104
    #define irq_FLEXPWM1_3_ID             105
    #define irq_FLEXPWM1_Fault_ID         106
    #if defined iMX_RT105X || defined iMX_RT106X
        #define irq_FLEXSPI1_ID           107
    #endif
    #define irq_FLEXSPI0_ID               108
    #if !defined iMX_RT1015
        #define irq_SEMC_ID               109
        #define irq_USDHC1_ID             110
        #define irq_USDHC2_ID             111
    #endif
    #if defined iMX_RT105X || defined iMX_RT106X
        #define irq_USB_OTG1_ID           112
    #endif
    #define irq_USB_OTG0_ID               113
    #define irq_ETH0_ID                   114
    #define irq_ETH0_1588_ID              115
    #define irq_XBAR1_0_1_ID              116
    #define irq_XBAR1_2_3_ID              117
    #define irq_ADC_ETC_0_ID              118
    #define irq_ADC_ETC_1_ID              119
    #define irq_ADC_ETC_2_ID              120
    #define irq_ADC_ETC_Err_ID            121
    #define irq_PIT_ID                    122
    #define irq_ACMP_1_ID                 123
    #define irq_ACMP_2_ID                 124
    #define irq_ACMP_3_ID                 125
    #define irq_ACMP_4_ID                 126

    #define irq_ENC1_ID                   129
    #define irq_ENC2_ID                   130
    #if defined iMX_RT105X || defined iMX_RT106X
        #define irq_ENC3_ID               131
        #define irq_ENC4_ID               132
    #endif
    #define irq_QTIMER1_ID                133
    #define irq_QTIMER2_ID                134
    #if defined iMX_RT105X || defined iMX_RT106X
        #define irq_QTIMER3_ID            135
        #define irq_QTIMER4_ID            136
    #endif
    #define irq_FLEXPWM2_0_ID             137
    #define irq_FLEXPWM2_1_ID             138
    #define irq_FLEXPWM2_2_ID             139
    #define irq_FLEXPWM2_3_ID             140
    #define irq_FLEXPWM2_Fault_ID         141
    #if defined iMX_RT105X || defined iMX_RT106X
        #define irq_FLEXPWM3_0_ID         142
        #define irq_FLEXPWM3_1_ID         143
        #define irq_FLEXPWM3_2_ID         144
        #define irq_FLEXPWM3_3_ID         145
        #define irq_FLEXPWM3_Fault_ID     146
        #define irq_FLEXPWM4_0_ID         147
        #define irq_FLEXPWM4_1_ID         148
        #define irq_FLEXPWM4_2_ID         149
        #define irq_FLEXPWM4_3_ID         150
        #define irq_FLEXPWM4_Fault_ID     151
    #endif
    #if defined iMX_RT106X
        #define irq_ETH1_ID               152
        #define irq_ETH1_1588_ID          153
        #define irq_CAN2_MESSAGE_ID       154

        #define irq_FlexIO3_ID            156
        #define irq_GPIO6_7_8_9_ID        157
    #endif
#endif

#define irq_USB_HS_ID                     irq_USB_OTG0_ID                // for compatibility

#define VECTOR_SIZE                       (sizeof(VECTOR_TABLE))

#if defined iMX_RT1011
    #define LAST_PROCESSOR_IRQ            irq_ADC_ETC_Err
    #define CHECK_VECTOR_SIZE             384                            // (16 + 79 + 1) = 96) * 4 - adequate for this processor [0x180]
#elif defined iMX_RT1015
    #define LAST_PROCESSOR_IRQ            irq_QTIMER1
    #define CHECK_VECTOR_SIZE             600                            // (16 + 133 + 1) = 150) * 4 - adequate for this processor [0x258]
#elif defined iMX_RT105X
    #define LAST_PROCESSOR_IRQ            irq_FLEXPWM4_Fault
    #define CHECK_VECTOR_SIZE             672                            // (16 + 151 + 1) = 168) * 4 - adequate for this processor [0x2a0]
#elif defined iMX_RT106X
    #define LAST_PROCESSOR_IRQ            irq_GPIO6_7_8_9
    #define CHECK_VECTOR_SIZE             696                            // (16 + 157 + 1) = 174) * 4 - adequate for this processor [0x2b8]
#else
    #define LAST_PROCESSOR_IRQ            irq_FLEXPWM2_Fault
    #define CHECK_VECTOR_SIZE             632                            // (16 + 141 + 1) = 158) * 4 - adequate for this processor [0x278]
#endif



typedef struct st_iMX_GPIO
{
    volatile unsigned long GPIO_DR;
    volatile unsigned long GPIO_GDIR;
    volatile unsigned long GPIO_PSR;
    volatile unsigned long GPIO_ICR1;
    volatile unsigned long GPIO_ICR2;
    volatile unsigned long GPIO_IMR;
    volatile unsigned long GPIO_ISR;
    volatile unsigned long GPIO_EDGE_SEL;
    volatile unsigned long ulRes[25];
    volatile unsigned long GPIO_DR_SET;
    volatile unsigned long GPIO_DR_CLEAR;
    volatile unsigned long GPIO_DR_TOGGLE;
} iMX_GPIO;


#if defined _WINDOWS
    #include "sim_iMX.h"
#endif

// Peripheral Register Blocks
//
#if defined _WINDOWS
    #define DCDC_BLOCK                         ((unsigned char *)(&iMX.DCDC)) // DCDC block

    #if defined iMX_RT1011
        #define OTFAD_BLOCK                    ((unsigned char *)(&iMX.OTFAD)) // OTFAD block
    #else
        #define BEE_BLOCK                      ((unsigned char *)(&iMX.BEE)) // BEE block
    #endif

    #define XBARA1_BLOCK                       ((unsigned char *)(&iMX.XBARA)) // XBARA1 block
    #if XBARA_AVAILABLE > 1
        #define XBARB2_BLOCK                   ((unsigned char *)(&iMX.XBARB[0])) // XBARA1 block
    #endif
    #if XBARA_AVAILABLE > 2
        #define XBARB3_BLOCK                   ((unsigned char *)(&iMX.XBARB[1])) // XBARA1 block
    #endif
    #define FLEXPWM1_BLOCK                     ((unsigned char *)(&iMX.FLEXPWM[0])) // enhanced FlexPWM1 block
    #if FLEXPWM_AVAILABLE > 1
        #define FLEXPWM2_BLOCK                 ((unsigned char *)(&iMX.FLEXPWM[1])) // enhanced FlexPWM2 block
    #endif
    #if FLEXPWM_AVAILABLE > 2
        #define FLEXPWM3_BLOCK                 ((unsigned char *)(&iMX.FLEXPWM[2])) // enhanced FlexPWM3 block
    #endif
    #if FLEXPWM_AVAILABLE > 3
        #define FLEXPWM4_BLOCK                 ((unsigned char *)(&iMX.FLEXPWM[3])) // enhanced FlexPWM4 block
    #endif
    #define AOI1_BLOCK                         ((unsigned char *)(&iMX.AOI)) // And-Or-Inverter block

    #define IOMUXC_SNVS_GPR_BLOCK              ((unsigned char *)(&iMX.IOMUXC_SNVS_GPR)) // IOMUX controller SNVS GPR
    #define IOMUXC_SNVS_BLOCK                  ((unsigned char *)(&iMX.IOMUXC_SNVS)) // IOMUX controller SNVS
    #define IOMUXC_BLOCK                       ((unsigned char *)(&iMX.IOMUXC)) // IOMUX controller
    #define IOMUXC_SW_BLOCK                    ((unsigned char *)(&iMX.IOMUXC_SW)) // IOMUXC SW control
    #if defined SEMC_AVAILABLE
        #define SEMC_BLOCK                     ((unsigned char *)(&iMX.SEMC)) // SEMC
    #endif
    #define GPIO1_BLOCK                        ((unsigned char *)(&iMX.GPIO[PORT1])) // GPIO
    #define GPIO2_BLOCK                        ((unsigned char *)(&iMX.GPIO[PORT2])) // GPIO
    #if defined PORT3
        #define GPIO3_BLOCK                    ((unsigned char *)(&iMX.GPIO[PORT3])) // GPIO
    #endif
    #if defined PORT4
        #define GPIO4_BLOCK                    ((unsigned char *)(&iMX.GPIO[PORT4])) // GPIO
    #endif
    #define GPIO5_BLOCK                        ((unsigned char *)(&iMX.GPIO[PORT5])) // GPIO
    #if PORTS_AVAILABLE > 5
        #define GPIO6_BLOCK                    ((unsigned char *)(&iMX.GPIO[PORT6])) // GPIO
    #endif
    #if PORTS_AVAILABLE > 6
        #define GPIO7_BLOCK                    ((unsigned char *)(&iMX.GPIO[PORT7])) // GPIO
    #endif
    #if PORTS_AVAILABLE > 7
        #define GPIO8_BLOCK                    ((unsigned char *)(&iMX.GPIO[PORT8])) // GPIO
    #endif
    #if PORTS_AVAILABLE > 8
        #define GPIO9_BLOCK                    ((unsigned char *)(&iMX.GPIO[PORT9])) // GPIO
    #endif

    #if LPUARTS_AVAILABLE > 0
        #define LPUART0_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_1])) // LPUART1
    #endif
    #if LPUARTS_AVAILABLE > 1
        #define LPUART1_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_2])) // LPUART2
    #endif
    #if LPUARTS_AVAILABLE > 2
        #define LPUART2_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_3])) // LPUART3
    #endif
    #if LPUARTS_AVAILABLE > 3
        #define LPUART3_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_4])) // LPUART4
    #endif
    #if LPUARTS_AVAILABLE > 4
        #define LPUART4_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_5])) // LPUART5
    #endif
    #if LPUARTS_AVAILABLE > 5
        #define LPUART5_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_6])) // LPUART6
    #endif
    #if LPUARTS_AVAILABLE > 6
        #define LPUART6_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_7])) // LPUART7
    #endif
    #if LPUARTS_AVAILABLE > 7
        #define LPUART7_BLOCK                  ((unsigned char *)(&iMX.LPUART[iMX_LPUART_8])) // LPUART8
    #endif

    #define OCOTP_BLOCK                        ((unsigned char *)(&iMX.OCOTP)) // on-chip OTP controller

    #if LPI2C_AVAILABLE > 0
        #define LPI2C0_BLOCK                   ((unsigned char *)(&iMX.LPI2C[iMX_LPI2C_1])) // LPI2C1
    #endif
    #if LPI2C_AVAILABLE > 1
        #define LPI2C1_BLOCK                   ((unsigned char *)(&iMX.LPI2C[iMX_LPI2C_2])) // LPI2C2
    #endif
    #if LPI2C_AVAILABLE > 2
        #define LPI2C2_BLOCK                   ((unsigned char *)(&iMX.LPI2C[iMX_LPI2C_3])) // LPI2C3
    #endif
    #if LPI2C_AVAILABLE > 2
        #define LPI2C3_BLOCK                   ((unsigned char *)(&iMX.LPI2C[iMX_LPI2C_4])) // LPI2C4
    #endif

    #define LPSPI1_BLOCK                       ((unsigned char *)(&iMX.LPSPI[iMX_LPSPI_1])) // LPSPI1
    #define LPSPI2_BLOCK                       ((unsigned char *)(&iMX.LPSPI[iMX_LPSPI_2])) // LPSPI2
    #if LPSPI_AVAILABLE > 2
        #define LPSPI3_BLOCK                   ((unsigned char *)(&iMX.LPSPI[iMX_LPSPI_3])) // LPSPI3
        #define LPSPI4_BLOCK                   ((unsigned char *)(&iMX.LPSPI[iMX_LPSPI_4])) // LPSPI4
    #endif

    #define eDMA_BLOCK                         ((unsigned char *)(&iMX.eDMA)) // eDMA Controller
    #define eDMA_DESCRIPTORS                   ((unsigned char *)(&iMX.eDMADES)) // eDMA Descriptor Memory

    #define FLEX_SPI_BLOCK                     ((unsigned char *)(&iMX.FLEX_SPI[0])) // flex SPI
    #if FLEX_SPI_INTERFACES > 1
        #define FLEX_SPI2_BLOCK                ((unsigned char *)(&iMX.FLEX_SPI[1])) // flex SPI
    #endif
    #define SRC_BLOCK                          ((unsigned char *)(&iMX.SRC)) // system reset controller
    #define CCM_BLOCK                          ((unsigned char *)(&iMX.CCM)) // clock control module
    #define SNVS_BLOCK                         ((unsigned char *)(&iMX.SNVS)) // secure non-volatile storage module
    #define CCM_ANALOG_BLOCK                   ((unsigned char *)(&iMX.CCM_ANALOG)) // clock control module analog

    #if ADC_CONTROLLERS > 0
        #define ADC1_BLOCK                     ((unsigned char *)(&iMX.ADC[0])) // ADC2
    #endif
    #if ADC_CONTROLLERS > 1
        #define ADC2_BLOCK                     ((unsigned char *)(&iMX.ADC[1])) // ADC2
    #endif

    #define USBHS_BASE1_ADD                    ((unsigned char *)(&iMX.USBHS[0])) // USBHS1
    #define USBHS_NON_CORE_BASE1_ADD            ((unsigned char *)(&iMX.USBHSNON_CORE)) // USBHS non-core registers
    #define USBHS_BASE_ADD                     USBHS_BASE1_ADD
    #define USBHS_PHY1_ADD                     ((unsigned char *)(&iMX.USBHSPHY[0])) // integrated HS USB2.0 PHY 1
    #if HSUSB_CONTROLLERS > 1
        #define USBHS_BASE2_ADD                ((unsigned char *)(&iMX.USBHS[1])) // USBHS2
        #define USBHS_PHY2_ADD                 ((unsigned char *)(&iMX.USBHSPHY[1])) // integrated HS USB2.0 PHY 2
    #endif
    #if NUMBER_OF_SDHC > 0
        #define SDHC_BLOCK_1                   ((unsigned char *)(&iMX.SDHC[0])) // SDHC1
    #endif
    #if NUMBER_OF_SDHC > 1
        #define SDHC_BLOCK_2                   ((unsigned char *)(&iMX.SDHC[1])) // SDHC2
    #endif

    #if defined TRUE_RANDOM_NUMBER_GENERATOR
        #define TRNG0_BASE_ADD                 ((unsigned char *)(&iMX.TRNG)) // True Random Number Generator
    #endif

    #define CAN0_BASE_ADD                      ((unsigned char *)(&iMX.CAN[0])) // FLEXCAN module 0
    #if NUMBER_OF_CAN_INTERFACES > 1
        #define CAN1_BASE_ADD                  ((unsigned char *)(&iMX.CAN[1])) // FLEXCAN module 1
    #endif
    #if NUMBER_OF_CAN_INTERFACES > 2
        #define CAN2_BASE_ADD                  ((unsigned char *)(&iMX.CAN[2])) // FLEXCAN module 2
    #endif

    #if defined ETHERNET_AVAILABLE
        #define EMAC_BASE_ADD                  ((unsigned char *)(&iMX.EMAC[0])) // Ethernet Controller 
        #if ETHERNET_COUNT > 1
            #define EMAC2_BASE_ADD             ((unsigned char *)(&iMX.EMAC[1])) // Ethernet Controller 2
        #endif
    #endif
    #if !defined IMX_WITHOUT_PIT
        #define PIT_BLOCK                      ((unsigned char *)(&iMX.PIT)) // PITs
    #endif
    #define GPT1_BLOCK                         ((unsigned char *)(&iMX.GPT[0])) // GPT1
    #define GPT2_BLOCK                         ((unsigned char *)(&iMX.GPT[1])) // GPT2
    #define WDOG1_BLOCK                        ((unsigned char *)(&iMX.WDOG[0])) // WDOG1
    #define WDOG2_BLOCK                        ((unsigned char *)(&iMX.WDOG[1])) // WDOG2
    #define WDOG3_BLOCK                        ((unsigned char *)(&iMX.WDOG3)) // WDOG3

    #if QUAD_TIMER_AVAILABLE > 0
        #define QUAD_TIMER1_BLOCK              ((unsigned char *)(&iMX.TMR[0])) // Quad Timer 1
    #endif
    #if QUAD_TIMER_AVAILABLE > 1
        #define QUAD_TIMER2_BLOCK              ((unsigned char *)(&iMX.TMR[1])) // Quad Timer 2
    #endif
    #if QUAD_TIMER_AVAILABLE > 2
        #define QUAD_TIMER3_BLOCK              ((unsigned char *)(&iMX.TMR[2])) // Quad Timer 3
    #endif
    #if QUAD_TIMER_AVAILABLE > 3
        #define QUAD_TIMER4_BLOCK              ((unsigned char *)(&iMX.TMR[3])) // Quad Timer 4
    #endif

    #define FLEXRAM_BLOCK                      ((unsigned char *)(&iMX.FLEXRAM)) // FlexRAM

    #if defined ENHANCED_LCD_INTERFACE
        #define LCDC_BLOCK                     ((unsigned char *)(&iMX.LCD)) // enhanced LCD controller (eLCDIF)
    #endif

    #define CORTEX_M7_BLOCK                    ((unsigned char *)(&iMX.CORTEX_M7))
    #define CORTEX_M7_DEBUG                    ((unsigned char *)(&iMX.CORTEX_M7_DEBUG))
    #define CORTEX_M7_DWT                      ((unsigned char *)(&iMX.CORTEX_M7_TRACE)) // data watch and trace unit


    #if !defined DEVICE_WITHOUT_DMA
        #define DMAMUX0_BLOCK                  ((unsigned char *)(&kinetis.DMAMUX[0])) // DMAMUX0
        #if defined KINETIS_KM
            #define DMAMUX1_BLOCK              ((unsigned char *)(&kinetis.DMAMUX[1])) // DMAMUX1
            #define DMAMUX2_BLOCK              ((unsigned char *)(&kinetis.DMAMUX[2])) // DMAMUX2
            #define DMAMUX3_BLOCK              ((unsigned char *)(&kinetis.DMAMUX[3])) // DMAMUX3
        #elif defined DMAMUX1_AVAILABLE
            #define DMAMUX1_BLOCK              ((unsigned char *)(&kinetis.DMAMUX[1])) // DMAMUX1
        #endif
    #endif
    #if defined I2S_AVAILABLE
        #define I2S0_BLOCK                     ((unsigned char *)(&kinetis.I2S_SAI[0])) // I2S0
    #endif
    #if defined KINETIS_KE
        #define IRQ_BLOCK                      ((unsigned char *)(&kinetis.IRQ)) // external IRQ
    #endif

    #define CRC_BLOCK                          ((unsigned char *)(&kinetis.CRC)) // CRC 

    #define PMC_BLOCK                          ((unsigned char *)(&kinetis.PMC)) // Power Management Controller
    #define FTM_BLOCK_0                        ((unsigned char *)(&kinetis.FTM[0])) // FlexTimer 0 (TPM0 in KL/KE)
    #define FTM_BLOCK_1                        ((unsigned char *)(&kinetis.FTM[1])) // FlexTimer 1 (TPM1 in KL/KE)
    #if defined KINETIS_KL || defined KINETIS_KE
        #define FTM_BLOCK_2                    ((unsigned char *)(&kinetis.FTM[2])) // FlexTimer 2 (TPM2 in KL/KE)
    #endif
    #if defined CHIP_HAS_FLEXIO
        #define FLEXIO_BLOCK                   ((unsigned char *)(&kinetis.FLEXIO)) // FlexIO
    #endif
    #if defined LTC_AVAILABLE
        #define LTC_BLOCK                      ((unsigned char *)(&kinetis.LTC)) // LTC
    #endif
    #if defined KINETIS_K80
        #define QSPI_BLOCK                     ((unsigned char *)(&kinetis.QSPI)) // QuadSPI
    #endif
    #if !defined KINETIS_KL && !defined KINETIS_KE
        #define EWM_BLOCK                      ((unsigned char *)(&kinetis.EWM)) // external watchdog monitor
    #endif
    #if defined KINETIS_WITH_SCG
        #define SCG_BLOCK                      ((unsigned char *)(&kinetis.SCG)) // system clock generator
    #elif defined KINETIS_KE
        #define INTERNAL_CLOCK_BLOCK           ((unsigned char *)(&kinetis.ICS)) // internal clock source
    #else
        #define MCG_BLOCK                      ((unsigned char *)(&kinetis.MCG)) // Multi-purpose Clock Generator
    #endif
    #if defined TPMS_AVAILABLE_TOO
        #define FTM_BLOCK_4                    ((unsigned char *)(&kinetis.FTM[4])) // TPM1
        #define FTM_BLOCK_5                    ((unsigned char *)(&kinetis.FTM[5])) // TPM2
    #endif
    #if DAC_CONTROLLERS > 0
        #define DAC0_BASE_ADD                  ((unsigned char *)(&kinetis.DAC[0])) // DAC0
    #endif
    #if DAC_CONTROLLERS > 1
        #define DAC1_BASE_ADD                  ((unsigned char *)(&kinetis.DAC[1])) // DAC1
    #endif
#else
    #define DCDC_BLOCK                         0x40080000                // DCDC block
    #if defined iMX_RT1011
        #define OTFAD_BLOCK                    0x400a0c00                // OTFAD block
    #else
        #define BEE_BLOCK                      0x403ec000                // BEE block
    #endif

    #if defined iMX_RT1011
        #define XBARA1_BLOCK                   0x40098000                // XBARA1 block
        #define AOI1_BLOCK                     0x40094000                // And-Or-Inverter block
    #else
        #define XBARA1_BLOCK                   0x403bc000                // XBARA1 block
        #define AOI1_BLOCK                     0x403b4000                // And-Or-Inverter block
    #endif
    #if XBARA_AVAILABLE > 1
        #define XBARB2_BLOCK                   0x403c0000                // XBARB2 block
    #endif
    #if XBARA_AVAILABLE > 2
        #define XBARB3_BLOCK                   0x403c4000                // XBARB3 block
    #endif
    #if defined iMX_RT1011
        #define FLEXPWM1_BLOCK                 0x401c0000                // enhanced FlexPWM1 block
    #else
        #define FLEXPWM1_BLOCK                 0x403dc000                // enhanced FlexPWM1 block
    #endif
    #if FLEXPWM_AVAILABLE > 1
        #define FLEXPWM2_BLOCK                 0x403e0000                // enhanced FlexPWM2 block
    #endif
    #if FLEXPWM_AVAILABLE > 2
        #define FLEXPWM3_BLOCK                 0x403e4000                // enhanced FlexPWM3 block
    #endif
    #if FLEXPWM_AVAILABLE > 3
        #define FLEXPWM4_BLOCK                 0x403e8000                // enhanced FlexPWM4 block
    #endif
    #define IOMUXC_SNVS_GPR_BLOCK              0x400a4000                // IOMUX controller SNVS GPR
    #define IOMUXC_SNVS_BLOCK                  0x400a8000                // IOMUX controller SNVS
    #define IOMUXC_BLOCK                       0x400ac000                // IOMUX controller
    #define IOMUXC_SW_BLOCK                    0x401f8000                // IOMUXC SW control
    #if defined SEMC_AVAILABLE
        #define SEMC_BLOCK                     0x402f0000                // SEMC
    #endif
    #define GPIO1_BLOCK                        0x401b8000                // GPIO 1
    #if defined iMX_RT1011
        #define GPIO2_BLOCK                    0x42000000                // GPIO 2
    #else
        #define GPIO2_BLOCK                    0x401bc000                // GPIO 2
    #endif
    #if defined PORT3
        #define GPIO3_BLOCK                    0x401c0000                // GPIO 3
    #endif
    #if defined PORT4
        #define GPIO4_BLOCK                    0x401c4000                // GPIO 4
    #endif
    #define GPIO5_BLOCK                        0x400c0000                // GPIO 5
    #if PORTS_AVAILABLE > 5
        #define GPIO6_BLOCK                    0x42000000                // GPIO 6
    #endif
    #if PORTS_AVAILABLE > 6
        #define GPIO7_BLOCK                    0x42004000                // GPIO 7
    #endif
    #if PORTS_AVAILABLE > 7
        #define GPIO8_BLOCK                    0x42008000                // GPIO 8
    #endif
    #if PORTS_AVAILABLE > 8
        #define GPIO9_BLOCK                    0x4200c000                // GPIO 9
    #endif

    #if LPUARTS_AVAILABLE > 0
        #define LPUART0_BLOCK                  0x40184000                // LPUART1
    #endif
    #if LPUARTS_AVAILABLE > 1
        #define LPUART1_BLOCK                  0x40188000                // LPUART2
    #endif
    #if LPUARTS_AVAILABLE > 2
        #define LPUART2_BLOCK                  0x4018c000                // LPUART3
    #endif
    #if LPUARTS_AVAILABLE > 3
        #define LPUART3_BLOCK                  0x40190000                // LPUART4
    #endif
    #if LPUARTS_AVAILABLE > 4
        #define LPUART4_BLOCK                  0x40194000                // LPUART5
    #endif
    #if LPUARTS_AVAILABLE > 5
        #define LPUART5_BLOCK                  0x40198000                // LPUART6
    #endif
    #if LPUARTS_AVAILABLE > 6
        #define LPUART6_BLOCK                  0x4019c000                // LPUART7
    #endif
    #if LPUARTS_AVAILABLE > 7
        #define LPUART7_BLOCK                  0x401a0000                // LPUART8
    #endif

    #define OCOTP_BLOCK                        0x401f4000                // on-chip OTP controller

    #if LPI2C_AVAILABLE > 0
        #define LPI2C0_BLOCK                   0x403f0000                // LPI2C1
    #endif
    #if LPI2C_AVAILABLE > 1
        #define LPI2C1_BLOCK                   0x403f4000                // LPI2C2
    #endif
    #if LPI2C_AVAILABLE > 2
        #define LPI2C2_BLOCK                   0x403f8000                // LPI2C3
    #endif
    #if LPI2C_AVAILABLE > 3
        #define LPI2C3_BLOCK                   0x403fc000                // LPI2C4
    #endif

    #define LPSPI1_BLOCK                       0x40394000                // LPSPI1
    #define LPSPI2_BLOCK                       0x40398000                // LPSPI2
    #if LPSPI_AVAILABLE > 2
        #define LPSPI3_BLOCK                   0x4039c000                // LPSPI3
        #define LPSPI4_BLOCK                   0x403a0000                // LPSPI4
    #endif

    #if FLEX_SPI_INTERFACES > 1
        #define FLEX_SPI2_BLOCK                0x402a4000                // flex SPI2
    #endif
    #if defined iMX_RT1011
        #define FLEX_SPI_BLOCK                 0x400a0000                // flex SPI
    #else
        #define FLEX_SPI_BLOCK                 0x402a8000                // flex SPI
    #endif

    #define SRC_BLOCK                          0x400f8000                // system reset controller
    #define CCM_BLOCK                          0x400fc000                // clock control module
    #define SNVS_BLOCK                         0x400d4000                // secure non-volatile storage module
    #define CCM_ANALOG_BLOCK                   0x400d8000                // clock control module analog

    #define ADC1_BLOCK                         0x400c4000                // ADC1
    #define ADC2_BLOCK                         0x400c8000                // ADC2

    #if defined iMX_RT1011
        #define USBHS_BASE1_ADD                0x400e4000                // USBHS1
        #define USBHS_NON_CORE_BASE1_ADD       0x400e4800                // USBHS1 non-core registers
    #else
        #define USBHS_BASE1_ADD                0x402e0000                // USBHS1
        #define USBHS_NON_CORE_BASE1_ADD       0x402e0800                // USBHS1 non-core registers
    #endif
    #define USBHS_BASE_ADD                     USBHS_BASE1_ADD
    #define USBHS_PHY1_ADD                     0x400d9000                // integrated HS USB2.0 PHY 1
    #if HSUSB_CONTROLLERS > 1
        #define USBHS_BASE2_ADD                0x402e0200                // USBHS2
        #define USBHS_PHY2_ADD                 0x400da000                // integrated HS USB2.0 PHY 2
    #endif
    #if NUMBER_OF_SDHC > 0
        #define SDHC_BLOCK_1                   0x402c0000                // SDHC1
    #endif
    #if NUMBER_OF_SDHC > 1
        #define SDHC_BLOCK_2                   0x402c4000                // SDHC2
    #endif

    #if defined TRUE_RANDOM_NUMBER_GENERATOR
        #define TRNG0_BASE_ADD                 0x400cc000                // True Random Number Generator
    #endif

    #define CAN0_BASE_ADD                      0x401d0000                // FLEXCAN module 1
    #if NUMBER_OF_CAN_INTERFACES > 1
        #define CAN1_BASE_ADD                  0x401d4000                // FLEXCAN module 2
    #endif
    #if NUMBER_OF_CAN_INTERFACES > 2
        #define CAN2_BASE_ADD                  0x401d8000                // FLEXCAN module 3
    #endif

    #if defined ETHERNET_AVAILABLE
        #define EMAC_BASE_ADD                  0x402d8000                // Ethernet Controller 1
        #define EMAC2_BASE_ADD                 0x402d4000                // Ethernet Controller 2
    #endif

    #if !defined IMX_WITHOUT_PIT
        #define PIT_BLOCK                      0x40084000                // PITs
    #endif
    #define GPT1_BLOCK                         0x401ec000                // GPT1
    #define GPT2_BLOCK                         0x401f0000                // GPT2
    #define WDOG1_BLOCK                        0x400b8000                // WDOG1
    #define WDOG2_BLOCK                        0x400d0000                // WDOG2
    #define WDOG3_BLOCK                        0x400bc000                // WDOG3

    #if QUAD_TIMER_AVAILABLE > 0
        #define QUAD_TIMER1_BLOCK              0x401dc000                // Quad Timer 1
    #endif
    #if QUAD_TIMER_AVAILABLE > 1
        #define QUAD_TIMER2_BLOCK              0x401e0000                // Quad Timer 2
    #endif
    #if QUAD_TIMER_AVAILABLE > 2
        #define QUAD_TIMER3_BLOCK              0x401e4000                // Quad Timer 3
    #endif
    #if QUAD_TIMER_AVAILABLE > 3
        #define QUAD_TIMER4_BLOCK              0x401e8000                // Quad Timer 4
    #endif

    #define FLEXRAM_BLOCK                      0x400b8000                // FlexRAM

    #if defined ENHANCED_LCD_INTERFACE
        #define LCDC_BLOCK                     0x402b8000                // enhanced LCD controller (eLCDIF)
    #endif

    #define eDMA_BLOCK                         0x400e8000                // eDMA Controller
    #define eDMA_DESCRIPTORS                   0x400e9000                // eDMA Descriptor Memory

    #define DMAMUX0_BLOCK                      0x400ec000                // DMAMUX0

    #define CORTEX_M7_BLOCK                    0xe000e000
    #define CORTEX_M7_DEBUG                    0xe000edf0
    #define CORTEX_M7_DWT                      0xe0001000                // data watch and trace unit
#endif



// Extended DMA Controller
//
#define DMA_CR              *(volatile unsigned long *)(eDMA_BLOCK + 0x000) // DMA Control Register
  #define DMA_CR_EDBG       0x00000002                                   // enable debug
  #define DMA_CR_ERCA       0x00000004                                   // enable round robin channel arbitration
  #define DMA_CR_HOE        0x00000010                                   // halt on error
  #define DMA_CR_HALT       0x00000020                                   // halt DMA operations
  #define DMA_CR_CLM        0x00000040                                   // continuous link mode
  #define DMA_CR_EMLM       0x00000080                                   // enable minor loop mapping
#if defined DEVICE_WITH_TWO_DMA_GROUPS
  #define DMA_CR_GRP0PRI_0  0x00000000                                   // group 0 priority level - 0
  #define DMA_CR_GRP0PRI_1  0x00000100                                   // group 0 priority level - 1
  #define DMA_CR_GRP0PRI_2  0x00000200                                   // group 0 priority level - 2
  #define DMA_CR_GRP0PRI_3  0x00000300                                   // group 0 priority level - 3
  #define DMA_CR_GRP1PRI_0  0x00000000                                   // group 1 priority level - 0
  #define DMA_CR_GRP1PRI_1  0x00000400                                   // group 1 priority level - 1
  #define DMA_CR_GRP1PRI_2  0x00000800                                   // group 1 priority level - 2
  #define DMA_CR_GRP1PRI_3  0x00000c00                                   // group 1 priority level - 3
#endif
  #define DMA_CR_ECX        0x00010000                                   // error cancel transfer (self clearing)
  #define DMA_CR_CX         0x00020000                                   // cancel transfer (self clearing)
#define DMA_ES              *(volatile unsigned long *)(eDMA_BLOCK + 0x004) // DMA Error Request Register
  #define DMA_ES_DBE        0x00000001                                   // bus error on destination write
  #define DMA_ES_SBE        0x00000002                                   // bus error on source read
  #define DMA_ES_SGE        0x00000004                                   // scatter/gather configuration error
  #define DMA_ES_NCE        0x00000008                                   // NBYTES/CITER configuration error
  #define DMA_ES_DOE        0x00000010                                   // destination offset error
  #define DMA_ES_DAE        0x00000020                                   // destination address error
  #define DMA_ES_SOE        0x00000040                                   // source offset error
  #define DMA_ES_SAE        0x00000080                                   // source address error
  #define DMA_ES_ERRCHN_MASK 0x00001f00                                  // last error channel
  #define DMA_ES_GPE        0x00008000                                   // group priority error
  #define DMA_ES_CPE        0x00004000                                   // channel priority error
  #define DMA_ES_ECX        0x00010000                                   // transfer cancelled
  #define DMA_ES_VLD        0x80000000                                   // at least one error bit is set

#define DMA_ERQ_ADDR        (volatile unsigned long *)(eDMA_BLOCK + 0x00c)
#define DMA_ERQ             *(volatile unsigned long *)(eDMA_BLOCK + 0x00c) // DMA Enable Request Register
    #define DMA_ERQ_BME_OR  (volatile unsigned long *)(eDMA_BLOCK + 0x00c + BME_OR_OFFSET)
    #define DMA_ERQ_BME_AND (volatile unsigned long *)(eDMA_BLOCK + 0x00c + BME_AND_OFFSET)
    #define DMA_ERQ_BME_XOR (volatile unsigned long *)(eDMA_BLOCK + 0x00c + BME_XOR_OFFSET)
  #define DMA_ERQ_ERQ0      0x00000001                                   // enable DMA request on channel 0
  #define DMA_ERQ_ERQ1      0x00000002                                   // enable DMA request on channel 1
  #define DMA_ERQ_ERQ2      0x00000004                                   // enable DMA request on channel 2
  #define DMA_ERQ_ERQ3      0x00000008                                   // enable DMA request on channel 3
  #define DMA_ERQ_ERQ4      0x00000010                                   // enable DMA request on channel 4
  #define DMA_ERQ_ERQ5      0x00000020                                   // enable DMA request on channel 5
  #define DMA_ERQ_ERQ6      0x00000040                                   // enable DMA request on channel 6
  #define DMA_ERQ_ERQ7      0x00000080                                   // enable DMA request on channel 7
  #define DMA_ERQ_ERQ8      0x00000100                                   // enable DMA request on channel 8
  #define DMA_ERQ_ERQ9      0x00000200                                   // enable DMA request on channel 9
  #define DMA_ERQ_ERQ10     0x00000400                                   // enable DMA request on channel 10
  #define DMA_ERQ_ERQ11     0x00000800                                   // enable DMA request on channel 11
  #define DMA_ERQ_ERQ12     0x00001000                                   // enable DMA request on channel 12
  #define DMA_ERQ_ERQ13     0x00002000                                   // enable DMA request on channel 13
  #define DMA_ERQ_ERQ14     0x00004000                                   // enable DMA request on channel 14
  #define DMA_ERQ_ERQ15     0x00008000                                   // enable DMA request on channel 15
  #define DMA_ERQ_ERQ16     0x00010000                                   // enable DMA request on channel 16
  #define DMA_ERQ_ERQ17     0x00020000                                   // enable DMA request on channel 17
  #define DMA_ERQ_ERQ18     0x00040000                                   // enable DMA request on channel 18
  #define DMA_ERQ_ERQ19     0x00080000                                   // enable DMA request on channel 19
  #define DMA_ERQ_ERQ20     0x00100000                                   // enable DMA request on channel 20
  #define DMA_ERQ_ERQ21     0x00200000                                   // enable DMA request on channel 21
  #define DMA_ERQ_ERQ22     0x00400000                                   // enable DMA request on channel 22
  #define DMA_ERQ_ERQ23     0x00800000                                   // enable DMA request on channel 23
  #define DMA_ERQ_ERQ24     0x01000000                                   // enable DMA request on channel 24
  #define DMA_ERQ_ERQ25     0x02000000                                   // enable DMA request on channel 25
  #define DMA_ERQ_ERQ26     0x04000000                                   // enable DMA request on channel 26
  #define DMA_ERQ_ERQ27     0x08000000                                   // enable DMA request on channel 27
  #define DMA_ERQ_ERQ28     0x10000000                                   // enable DMA request on channel 28
  #define DMA_ERQ_ERQ29     0x20000000                                   // enable DMA request on channel 29
  #define DMA_ERQ_ERQ30     0x40000000                                   // enable DMA request on channel 30
  #define DMA_ERQ_ERQ31     0x80000000                                   // enable DMA request on channel 31

#define DMA_EEI             *(unsigned long *)(eDMA_BLOCK + 0x014)       // DMA Error Interrupt Register
#define DMA_CEEI            *(volatile unsigned char *)(eDMA_BLOCK + 0x018) // DMA Clear Enable Error Interrupt Register (write-only, always reads zero)
#define DMA_SEEI            *(volatile unsigned char *)(eDMA_BLOCK + 0x019) // DMA Set Enable Error Interrupt Register (write-only, always reads zero)
#define DMA_CERQ            *(volatile unsigned char *)(eDMA_BLOCK + 0x01a) // DMA Clear Enable Request Register (write-only, always reads zero)
#define DMA_SERQ            *(volatile unsigned char *)(eDMA_BLOCK + 0x01b) // DMA Set Enable Request Register (write-only, always reads zero)
#define DMA_CDNE            *(volatile unsigned char *)(eDMA_BLOCK + 0x01c) // DMA Clear DONE Bit Status Register (write-only, always reads zero)
#define DMA_SSRT            *(volatile unsigned char *)(eDMA_BLOCK + 0x01d) // DMA Set START Bit Status Register (write-only, always reads zero)
#define DMA_CERR            *(volatile unsigned char *)(eDMA_BLOCK + 0x01e) // DMA Clear Error Register (write-only, always reads zero)
#define DMA_CINT            *(volatile unsigned char *)(eDMA_BLOCK + 0x01f) // DMA Clear Interrupt Request Register (write-only, always reads zero)

#define DMA_INT             *(volatile unsigned long *)(eDMA_BLOCK + 0x024) // DMA Interrupt Request Register (write '1 to clear)
  #define DMA_INT_INT0      0x00000001                                   // DMA interrupts request on channel 0
  #define DMA_INT_INT1      0x00000002                                   // DMA interrupts request on channel 1
  #define DMA_INT_INT2      0x00000004                                   // DMA interrupts request on channel 2
  #define DMA_INT_INT3      0x00000008                                   // DMA interrupts request on channel 3
  #define DMA_INT_INT4      0x00000010                                   // DMA interrupts request on channel 4
  #define DMA_INT_INT5      0x00000020                                   // DMA interrupts request on channel 5
  #define DMA_INT_INT6      0x00000040                                   // DMA interrupts request on channel 6
  #define DMA_INT_INT7      0x00000080                                   // DMA interrupts request on channel 7
  #define DMA_INT_INT8      0x00000100                                   // DMA interrupts request on channel 8
  #define DMA_INT_INT9      0x00000200                                   // DMA interrupts request on channel 9
  #define DMA_INT_INT10     0x00000400                                   // DMA interrupts request on channel 10
  #define DMA_INT_INT11     0x00000800                                   // DMA interrupts request on channel 11
  #define DMA_INT_INT12     0x00001000                                   // DMA interrupts request on channel 12
  #define DMA_INT_INT13     0x00002000                                   // DMA interrupts request on channel 13
  #define DMA_INT_INT14     0x00004000                                   // DMA interrupts request on channel 14
  #define DMA_INT_INT15     0x00008000                                   // DMA interrupts request on channel 15
  #define DMA_INT_INT16     0x00010000                                   // DMA interrupts request on channel 16
  #define DMA_INT_INT17     0x00020000                                   // DMA interrupts request on channel 17
  #define DMA_INT_INT18     0x00040000                                   // DMA interrupts request on channel 18
  #define DMA_INT_INT19     0x00080000                                   // DMA interrupts request on channel 19
  #define DMA_INT_INT20     0x00100000                                   // DMA interrupts request on channel 20
  #define DMA_INT_INT21     0x00200000                                   // DMA interrupts request on channel 21
  #define DMA_INT_INT22     0x00400000                                   // DMA interrupts request on channel 22
  #define DMA_INT_INT23     0x00800000                                   // DMA interrupts request on channel 23
  #define DMA_INT_INT24     0x01000000                                   // DMA interrupts request on channel 24
  #define DMA_INT_INT25     0x02000000                                   // DMA interrupts request on channel 25
  #define DMA_INT_INT26     0x04000000                                   // DMA interrupts request on channel 26
  #define DMA_INT_INT27     0x08000000                                   // DMA interrupts request on channel 27
  #define DMA_INT_INT28     0x10000000                                   // DMA interrupts request on channel 28
  #define DMA_INT_INT29     0x20000000                                   // DMA interrupts request on channel 29
  #define DMA_INT_INT30     0x40000000                                   // DMA interrupts request on channel 30
  #define DMA_INT_INT31     0x80000000                                   // DMA interrupts request on channel 31

#define DMA_ERR             *(volatile unsigned long *)(eDMA_BLOCK + 0x02c) // DMA Error Register (write '1' to clear)
  #define DMA_ERR_ERR0      0x00000001                                   // DMA channel 0 encoutered an error
  #define DMA_ERR_ERR1      0x00000002                                   // DMA channel 1 encoutered an error
  #define DMA_ERR_ERR2      0x00000004                                   // DMA channel 2 encoutered an error
  #define DMA_ERR_ERR3      0x00000008                                   // DMA channel 3 encoutered an error
  #define DMA_ERR_ERR4      0x00000010                                   // DMA channel 4 encoutered an error
  #define DMA_ERR_ERR5      0x00000020                                   // DMA channel 5 encoutered an error
  #define DMA_ERR_ERR6      0x00000040                                   // DMA channel 6 encoutered an error
  #define DMA_ERR_ERR7      0x00000080                                   // DMA channel 7 encoutered an error
  #define DMA_ERR_ERR8      0x00000100                                   // DMA channel 8 encoutered an error
  #define DMA_ERR_ERR9      0x00000200                                   // DMA channel 9 encoutered an error
  #define DMA_ERR_ERR10     0x00000400                                   // DMA channel 10 encoutered an error
  #define DMA_ERR_ERR11     0x00000800                                   // DMA channel 11 encoutered an error
  #define DMA_ERR_ERR12     0x00001000                                   // DMA channel 12 encoutered an error
  #define DMA_ERR_ERR13     0x00002000                                   // DMA channel 13 encoutered an error
  #define DMA_ERR_ERR14     0x00004000                                   // DMA channel 14 encoutered an error
  #define DMA_ERR_ERR15     0x00008000                                   // DMA channel 15 encoutered an error
  #define DMA_ERR_ERR16     0x00010000                                   // DMA channel 0 encoutered an error
  #define DMA_ERR_ERR17     0x00020000                                   // DMA channel 1 encoutered an error
  #define DMA_ERR_ERR18     0x00040000                                   // DMA channel 2 encoutered an error
  #define DMA_ERR_ERR19     0x00080000                                   // DMA channel 3 encoutered an error
  #define DMA_ERR_ERR20     0x00100000                                   // DMA channel 4 encoutered an error
  #define DMA_ERR_ERR21     0x00200000                                   // DMA channel 5 encoutered an error
  #define DMA_ERR_ERR22     0x00400000                                   // DMA channel 6 encoutered an error
  #define DMA_ERR_ERR23     0x00800000                                   // DMA channel 7 encoutered an error
  #define DMA_ERR_ERR24     0x01000000                                   // DMA channel 8 encoutered an error
  #define DMA_ERR_ERR25     0x02000000                                   // DMA channel 9 encoutered an error
  #define DMA_ERR_ERR26     0x04000000                                   // DMA channel 10 encoutered an error
  #define DMA_ERR_ERR27     0x08000000                                   // DMA channel 11 encoutered an error
  #define DMA_ERR_ERR28     0x10000000                                   // DMA channel 12 encoutered an error
  #define DMA_ERR_ERR29     0x20000000                                   // DMA channel 13 encoutered an error
  #define DMA_ERR_ERR30     0x40000000                                   // DMA channel 14 encoutered an error
  #define DMA_ERR_ERR31     0x80000000                                   // DMA channel 15 encoutered an error

#define DMA_HRS             *(unsigned long *)(eDMA_BLOCK + 0x034)       // DMA Hardware Request Status Register

#define DMA_EARS            *(unsigned long *)(eDMA_BLOCK + 0x044)       // DMA enable asynchronous request in stop register

#define DMA_DCHPRI3         *(unsigned char *)(eDMA_BLOCK + 0x100)       // DMA Channel 3 Priority Register
  #define DMA_DCHPRI_DPA    0x40                                         // disable preempt ability
  #define DMA_DCHPRI_ECP    0x80                                         // enable channel preemption
#define DMA_DCHPRI2         *(unsigned char *)(eDMA_BLOCK + 0x101)       // DMA Channel 2 Priority Register
#define DMA_DCHPRI1         *(unsigned char *)(eDMA_BLOCK + 0x102)       // DMA Channel 1 Priority Register
#define DMA_DCHPRI0_ADD     (unsigned char *)(eDMA_BLOCK + 0x103)
#define DMA_DCHPRI0         *(unsigned char *)(eDMA_BLOCK + 0x103)       // DMA Channel 0 Priority Register
#define DMA_DCHPRI7         *(unsigned char *)(eDMA_BLOCK + 0x104)       // DMA Channel 7 Priority Register
#define DMA_DCHPRI6         *(unsigned char *)(eDMA_BLOCK + 0x105)       // DMA Channel 6 Priority Register
#define DMA_DCHPRI5         *(unsigned char *)(eDMA_BLOCK + 0x106)       // DMA Channel 5 Priority Register
#define DMA_DCHPRI4         *(unsigned char *)(eDMA_BLOCK + 0x107)       // DMA Channel 4 Priority Register
#define DMA_DCHPRI11        *(unsigned char *)(eDMA_BLOCK + 0x108)       // DMA Channel 11 Priority Register
#define DMA_DCHPRI10        *(unsigned char *)(eDMA_BLOCK + 0x109)       // DMA Channel 10 Priority Register
#define DMA_DCHPRI9         *(unsigned char *)(eDMA_BLOCK + 0x10a)       // DMA Channel 9 Priority Register
#define DMA_DCHPRI8         *(unsigned char *)(eDMA_BLOCK + 0x10b)       // DMA Channel 8 Priority Register
#define DMA_DCHPRI15        *(unsigned char *)(eDMA_BLOCK + 0x10c)       // DMA Channel 15 Priority Register
#define DMA_DCHPRI14        *(unsigned char *)(eDMA_BLOCK + 0x10d)       // DMA Channel 14 Priority Register
#define DMA_DCHPRI13        *(unsigned char *)(eDMA_BLOCK + 0x10e)       // DMA Channel 13 Priority Register
#define DMA_DCHPRI12        *(unsigned char *)(eDMA_BLOCK + 0x10f)       // DMA Channel 12 Priority Register
#define DMA_DCHPRI19        *(unsigned char *)(eDMA_BLOCK + 0x110)       // DMA Channel 19 Priority Register
#define DMA_DCHPRI18        *(unsigned char *)(eDMA_BLOCK + 0x111)       // DMA Channel 18 Priority Register
#define DMA_DCHPRI17        *(unsigned char *)(eDMA_BLOCK + 0x112)       // DMA Channel 17 Priority Register
#define DMA_DCHPRI16        *(unsigned char *)(eDMA_BLOCK + 0x113)       // DMA Channel 16 Priority Register
#define DMA_DCHPRI23        *(unsigned char *)(eDMA_BLOCK + 0x114)       // DMA Channel 23 Priority Register
#define DMA_DCHPRI22        *(unsigned char *)(eDMA_BLOCK + 0x115)       // DMA Channel 22 Priority Register
#define DMA_DCHPRI21        *(unsigned char *)(eDMA_BLOCK + 0x116)       // DMA Channel 21 Priority Register
#define DMA_DCHPRI20        *(unsigned char *)(eDMA_BLOCK + 0x117)       // DMA Channel 20 Priority Register
#define DMA_DCHPRI27        *(unsigned char *)(eDMA_BLOCK + 0x118)       // DMA Channel 27 Priority Register
#define DMA_DCHPRI26        *(unsigned char *)(eDMA_BLOCK + 0x119)       // DMA Channel 26 Priority Register
#define DMA_DCHPRI25        *(unsigned char *)(eDMA_BLOCK + 0x11a)       // DMA Channel 25 Priority Register
#define DMA_DCHPRI24        *(unsigned char *)(eDMA_BLOCK + 0x11b)       // DMA Channel 24 Priority Register
#define DMA_DCHPRI31        *(unsigned char *)(eDMA_BLOCK + 0x11c)       // DMA Channel 31 Priority Register
#define DMA_DCHPRI30        *(unsigned char *)(eDMA_BLOCK + 0x11d)       // DMA Channel 30 Priority Register
#define DMA_DCHPRI29        *(unsigned char *)(eDMA_BLOCK + 0x11e)       // DMA Channel 29 Priority Register
#define DMA_DCHPRI28        *(unsigned char *)(eDMA_BLOCK + 0x11f)       // DMA Channel 28 Priority Register

// eDMA Descriptor Memory
//
#define DMA_TCD0_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x000) // DMA TCD0 Source Address
#define DMA_TCD0_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x004)  // DMA TCD0 Signed Source Address Offset
#define DMA_TCD0_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x006)// DMA TCD0 Transfer Attributes
  #define DMA_TCD_ATTR_DSIZE_8   0x0000
  #define DMA_TCD_ATTR_DSIZE_16  0x0001
  #define DMA_TCD_ATTR_DSIZE_32  0x0002
  #define DMA_TCD_ATTR_DSIZE_64  0x0003
  #define DMA_TCD_ATTR_DSIZE_32_BURST  0x0005                            // 32 byte burst (4 beats of 64 bits)
  #define DMA_TCD_ATTR_DMOD_MASK 0x00f8
  #define DMA_TCD_ATTR_SSIZE_8   0x0000
  #define DMA_TCD_ATTR_SSIZE_16  0x0100
  #define DMA_TCD_ATTR_SSIZE_32  0x0200
  #define DMA_TCD_ATTR_SSIZE_64  0x0300
  #define DMA_TCD_ATTR_SSIZE_32_BURST  0x0500                            // 32 byte burst (4 beats of 64 bits)
  #define DMA_TCD_ATTR_SMOD_MASK 0xf800
#define DMA_TCD0_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x008) // DMA TCD0 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD0_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x008) // DMA TCD0 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD0_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x008) // DMA TCD0 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD0_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x00c) // DMA TCD0 Last Source Address Adjustment
#define DMA_TCD0_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x010) // DMA TCD0 Destination Address
#define DMA_TCD0_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x014)  // DMA TCD0 Signed Destination Address Offset
#define DMA_TCD0_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x016) // DMA TCD0 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD0_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x016) // DMA TCD0 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD0_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x018) // DMA TCD0 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD0_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x01c) // DMA TCD0 Control and Status
  #define DMA_TCD_CSR_START              0x0001                          // start by software request (self-clearing)
  #define DMA_TCD_CSR_INTMAJOR           0x0002                          // enable interrupt when major iteration count completes
  #define DMA_TCD_CSR_INTHALF            0x0004                          // enable interrupt on half-point
  #define DMA_TCD_CSR_DREQ               0x0008                          // clear ERQ bit when major iteration count reaches zero
  #define DMA_TCD_CSR_ESQ                0x0010                          // enable scatter-gather processing
  #define DMA_TCD_CSR_MAJORELINK         0x0020                          // enable channel-to-channel linking on major loop complete
  #define DMA_TCD_CSR_ACTIVE             0x0040                          // channel active
  #define DMA_TCD_CSR_DONE               0x0080                          // channel done (major loop completed)
  #define DMA_TCD_CSR_MAJORLINKCH_MASK   0x0f00                          // major link channel number - zero is disabled
  #define DMA_TCD_CSR_BWC_NO_STALLS      0x0000                          // no eDMA engine stalls
  #define DMA_TCD_CSR_BWC_4_CYCLE_STALLS 0x8000                          // eDMA engine stalls for 4 cycles after each r/w
  #define DMA_TCD_CSR_BWC_8_CYCLE_STALLS 0xc000                          // eDMA engine stalls for 8 cycles after each r/w
#define DMA_TCD0_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x01e) // DMA TCD0 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD0_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x01e) // DMA TCD0 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
  #define DMA_TCD_BITER_ELINK_EN 0x8000                                  // enable channel-to-channel linking on minor loop complete
#define DMA_TCD1_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x020) // DMA TCD1 Source Address
#define DMA_TCD1_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x024)  // DMA TCD1 Signed Source Address Offset
#define DMA_TCD1_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x026)// DMA TCD1 Transfer Attributes
#define DMA_TCD1_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x028) // DMA TCD1 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD1_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x028) // DMA TCD1 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD1_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x028) // DMA TCD1 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD1_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x02c) // DMA TCD1 Last Source Address Adjustment
#define DMA_TCD1_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x030) // DMA TCD1 Destination Address
#define DMA_TCD1_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x034)  // DMA TCD1 Signed Destination Address Offset
#define DMA_TCD1_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x036) // DMA TCD1 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD1_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x036) // DMA TCD1 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD1_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x038) // DMA TCD1 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD1_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x03c) // DMA TCD1 Control and Status
#define DMA_TCD1_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x03e) // DMA TCD1 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD1_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x03e) // DMA TCD1 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD2_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x040) // DMA TCD2 Source Address
#define DMA_TCD2_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x044)  // DMA TCD2 Signed Source Address Offset
#define DMA_TCD2_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x046)// DMA TCD2 Transfer Attributes
#define DMA_TCD2_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x048) // DMA TCD2 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD2_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x048) // DMA TCD2 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD2_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x048) // DMA TCD2 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD2_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x04c) // DMA TCD2 Last Source Address Adjustment
#define DMA_TCD2_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x050) // DMA TCD2 Destination Address
#define DMA_TCD2_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x054)  // DMA TCD2 Signed Destination Address Offset
#define DMA_TCD2_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x056) // DMA TCD2 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD2_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x056) // DMA TCD2 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD2_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x058) // DMA TCD2 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD2_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x05c) // DMA TCD2 Control and Status
#define DMA_TCD2_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x05e) // DMA TCD2 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD2_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x05e) // DMA TCD2 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD3_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x060) // DMA TCD3 Source Address
#define DMA_TCD3_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x064)  // DMA TCD3 Signed Source Address Offset
#define DMA_TCD3_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x066)// DMA TCD3 Transfer Attributes
#define DMA_TCD3_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x068) // DMA TCD3 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD3_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x068) // DMA TCD3 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD3_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x068) // DMA TCD3 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD3_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x06c) // DMA TCD3 Last Source Address Adjustment
#define DMA_TCD3_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x070) // DMA TCD3 Destination Address
#define DMA_TCD3_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x074)  // DMA TCD3 Signed Destination Address Offset
#define DMA_TCD3_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x076) // DMA TCD3 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD3_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x076) // DMA TCD3 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD3_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x078) // DMA TCD3 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD3_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x07c) // DMA TCD3 Control and Status
#define DMA_TCD3_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x07e) // DMA TCD3 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD3_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x07e) // DMA TCD3 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD4_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x080) // DMA TCD4 Source Address
#define DMA_TCD4_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x084)  // DMA TCD4 Signed Source Address Offset
#define DMA_TCD4_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x086)// DMA TCD4 Transfer Attributes
#define DMA_TCD4_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x088) // DMA TCD4 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD4_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x088) // DMA TCD4 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD4_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x088) // DMA TCD4 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD4_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x08c) // DMA TCD4 Last Source Address Adjustment
#define DMA_TCD4_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x090) // DMA TCD4 Destination Address
#define DMA_TCD4_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x094)  // DMA TCD4 Signed Destination Address Offset
#define DMA_TCD4_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x096) // DMA TCD4 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD4_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x096) // DMA TCD4 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD4_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x098) // DMA TCD4 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD4_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x09c) // DMA TCD4 Control and Status
#define DMA_TCD4_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x09e) // DMA TCD4 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD4_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x09e) // DMA TCD4 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD5_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0a0) // DMA TCD5 Source Address
#define DMA_TCD5_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0a4)  // DMA TCD5 Signed Source Address Offset
#define DMA_TCD5_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x0a6)// DMA TCD5 Transfer Attributes
#define DMA_TCD5_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0a8) // DMA TCD5 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD5_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0a8) // DMA TCD5 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD5_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0a8) // DMA TCD5 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD5_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0ac) // DMA TCD5 Last Source Address Adjustment
#define DMA_TCD5_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0b0) // DMA TCD5 Destination Address
#define DMA_TCD5_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0b4)  // DMA TCD5 Signed Destination Address Offset
#define DMA_TCD5_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0b6) // DMA TCD5 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD5_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0b6) // DMA TCD5 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD5_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0b8) // DMA TCD5 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD5_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x0bc) // DMA TCD5 Control and Status
#define DMA_TCD5_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x0be) // DMA TCD5 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD5_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x0be) // DMA TCD5 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD6_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0c0) // DMA TCD6 Source Address
#define DMA_TCD6_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0c4)  // DMA TCD6 Signed Source Address Offset
#define DMA_TCD6_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x0c6)// DMA TCD6 Transfer Attributes
#define DMA_TCD6_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0c8) // DMA TCD6 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD6_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0c8) // DMA TCD6 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD6_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0c8) // DMA TCD6 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD6_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0cc) // DMA TCD6 Last Source Address Adjustment
#define DMA_TCD6_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0d0) // DMA TCD6 Destination Address
#define DMA_TCD6_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0d4)  // DMA TCD6 Signed Destination Address Offset
#define DMA_TCD6_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0d6) // DMA TCD6 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD6_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0d6) // DMA TCD6 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD6_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0d8) // DMA TCD6 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD6_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x0dc) // DMA TCD6 Control and Status
#define DMA_TCD6_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x0de) // DMA TCD6 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD6_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x0de) // DMA TCD6 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD7_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0e0) // DMA TCD7 Source Address
#define DMA_TCD7_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0e4)  // DMA TCD7 Signed Source Address Offset
#define DMA_TCD7_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x0e6)// DMA TCD7 Transfer Attributes
#define DMA_TCD7_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0e8) // DMA TCD7 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD7_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0e8) // DMA TCD7 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD7_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0e8) // DMA TCD7 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD7_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0ec) // DMA TCD7 Last Source Address Adjustment
#define DMA_TCD7_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x0f0) // DMA TCD7 Destination Address
#define DMA_TCD7_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x0f4)  // DMA TCD7 Signed Destination Address Offset
#define DMA_TCD7_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0f6) // DMA TCD7 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD7_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x0f6) // DMA TCD7 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD7_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x0f8) // DMA TCD7 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD7_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x0fc) // DMA TCD7 Control and Status
#define DMA_TCD7_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x0fe) // DMA TCD7 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD7_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x0fe) // DMA TCD7 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD8_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x100) // DMA TCD8 Source Address
#define DMA_TCD8_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x104)  // DMA TCD8 Signed Source Address Offset
#define DMA_TCD8_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x106)// DMA TCD8 Transfer Attributes
#define DMA_TCD8_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x108) // DMA TCD8 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD8_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x108) // DMA TCD8 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD8_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x108) // DMA TCD8 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD8_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x10c) // DMA TCD8 Last Source Address Adjustment
#define DMA_TCD8_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x110) // DMA TCD8 Destination Address
#define DMA_TCD8_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x114)  // DMA TCD8 Signed Destination Address Offset
#define DMA_TCD8_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x116) // DMA TCD8 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD8_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x116) // DMA TCD8 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD8_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x118) // DMA TCD8 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD8_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x11c) // DMA TCD8 Control and Status
#define DMA_TCD8_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x11e) // DMA TCD8 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD8_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x11e) // DMA TCD8 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD9_SADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x120) // DMA TCD9 Source Address
#define DMA_TCD9_SOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x124)  // DMA TCD9 Signed Source Address Offset
#define DMA_TCD9_ATTR       *(unsigned short *)(eDMA_DESCRIPTORS + 0x126)// DMA TCD9 Transfer Attributes
#define DMA_TCD9_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x128) // DMA TCD9 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD9_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x128) // DMA TCD9 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD9_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x128) // DMA TCD9 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD9_SLAST      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x12c) // DMA TCD9 Last Source Address Adjustment
#define DMA_TCD9_DADDR      *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x130) // DMA TCD9 Destination Address
#define DMA_TCD9_DOFF       *(signed short *)(eDMA_DESCRIPTORS + 0x134)  // DMA TCD9 Signed Destination Address Offset
#define DMA_TCD9_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x136) // DMA TCD9 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD9_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x136) // DMA TCD9 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD9_DLASTSGA   *(volatile signed long *)(eDMA_DESCRIPTORS + 0x138) // DMA TCD9 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD9_CSR        *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x13c) // DMA TCD9 Control and Status
#define DMA_TCD9_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x13e) // DMA TCD9 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD9_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x13e) // DMA TCD9 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD10_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x140) // DMA TCD10 Source Address
#define DMA_TCD10_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x144)  // DMA TCD10 Signed Source Address Offset
#define DMA_TCD10_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x146)// DMA TCD10 Transfer Attributes
#define DMA_TCD10_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x148) // DMA TCD10 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD10_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x148) // DMA TCD10 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD10_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x148) // DMA TCD10 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD10_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x14c) // DMA TCD10 Last Source Address Adjustment
#define DMA_TCD10_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x150) // DMA TCD10 Destination Address
#define DMA_TCD10_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x154)  // DMA TCD10 Signed Destination Address Offset
#define DMA_TCD10_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x156) // DMA TCD10 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD10_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x156) // DMA TCD10 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD10_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x158) // DMA TCD10 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD10_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x15c) // DMA TCD10 Control and Status
#define DMA_TCD10_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x15e) // DMA TCD10 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD10_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x15e) // DMA TCD10 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD11_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x160) // DMA TCD11 Source Address
#define DMA_TCD11_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x164)  // DMA TCD11 Signed Source Address Offset
#define DMA_TCD11_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x166)// DMA TCD11 Transfer Attributes
#define DMA_TCD11_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x168) // DMA TCD11 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD11_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x168) // DMA TCD11 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD11_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x168) // DMA TCD11 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD11_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x16c) // DMA TCD11 Last Source Address Adjustment
#define DMA_TCD11_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x170) // DMA TCD11 Destination Address
#define DMA_TCD11_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x174)  // DMA TCD11 Signed Destination Address Offset
#define DMA_TCD11_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x176) // DMA TCD11 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD11_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x176) // DMA TCD11 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD11_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x178) // DMA TCD11 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD11_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x17c) // DMA TCD11 Control and Status
#define DMA_TCD11_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x17e) // DMA TCD11 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD11_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x17e) // DMA TCD11 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD12_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x180) // DMA TCD12 Source Address
#define DMA_TCD12_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x184)  // DMA TCD12 Signed Source Address Offset
#define DMA_TCD12_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x186)// DMA TCD12 Transfer Attributes
#define DMA_TCD12_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x188) // DMA TCD12 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD12_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x188) // DMA TCD12 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD12_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x188) // DMA TCD12 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD12_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x18c) // DMA TCD12 Last Source Address Adjustment
#define DMA_TCD12_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x190) // DMA TCD12 Destination Address
#define DMA_TCD12_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x194)  // DMA TCD12 Signed Destination Address Offset
#define DMA_TCD12_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x196) // DMA TCD12 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD12_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x196) // DMA TCD12 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD12_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x198) // DMA TCD12 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD12_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x19c) // DMA TCD12 Control and Status
#define DMA_TCD12_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x19e) // DMA TCD12 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD12_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x19e) // DMA TCD12 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD13_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1a0) // DMA TCD13 Source Address
#define DMA_TCD13_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1a4)  // DMA TCD13 Signed Source Address Offset
#define DMA_TCD13_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x1a6)// DMA TCD13 Transfer Attributes
#define DMA_TCD13_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1a8) // DMA TCD13 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD13_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1a8) // DMA TCD13 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD13_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1a8) // DMA TCD13 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD13_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1ac) // DMA TCD13 Last Source Address Adjustment
#define DMA_TCD13_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1b0) // DMA TCD13 Destination Address
#define DMA_TCD13_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1b4)  // DMA TCD13 Signed Destination Address Offset
#define DMA_TCD13_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1b6) // DMA TCD13 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD13_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1b6) // DMA TCD13 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD13_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1b8) // DMA TCD13 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD13_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x1bc) // DMA TCD13 Control and Status
#define DMA_TCD13_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x1be) // DMA TCD13 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD13_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x1be) // DMA TCD13 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD14_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1c0) // DMA TCD14 Source Address
#define DMA_TCD14_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1c4)  // DMA TCD14 Signed Source Address Offset
#define DMA_TCD14_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x1c6)// DMA TCD14 Transfer Attributes
#define DMA_TCD14_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1c8) // DMA TCD14 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD14_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1c8) // DMA TCD14 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD14_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1c8) // DMA TCD14 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD14_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1cc) // DMA TCD14 Last Source Address Adjustment
#define DMA_TCD14_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1d0) // DMA TCD14 Destination Address
#define DMA_TCD14_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1d4)  // DMA TCD14 Signed Destination Address Offset
#define DMA_TCD14_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1d6) // DMA TCD14 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD14_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1d6) // DMA TCD14 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD14_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1d8) // DMA TCD14 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD14_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x1dc) // DMA TCD14 Control and Status
#define DMA_TCD14_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x1de) // DMA TCD14 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD14_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x1de) // DMA TCD14 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD15_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1e0) // DMA TCD15 Source Address
#define DMA_TCD15_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1e4)  // DMA TCD15 Signed Source Address Offset
#define DMA_TCD15_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x1e6)// DMA TCD15 Transfer Attributes
#define DMA_TCD15_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1e8) // DMA TCD15 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD15_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1e8) // DMA TCD15 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD15_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1e8) // DMA TCD15 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD15_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1ec) // DMA TCD15 Last Source Address Adjustment
#define DMA_TCD15_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x1f0) // DMA TCD15 Destination Address
#define DMA_TCD15_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x1f4)  // DMA TCD15 Signed Destination Address Offset
#define DMA_TCD15_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1f6) // DMA TCD15 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD15_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x1f6) // DMA TCD15 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD15_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x1f8) // DMA TCD15 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD15_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x1fc) // DMA TCD15 Control and Status
#define DMA_TCD15_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x1fe) // DMA TCD15 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD15_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x1fe) // DMA TCD15 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD16_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x200) // DMA TCD16 Source Address
#define DMA_TCD16_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x204)  // DMA TCD16 Signed Source Address Offset
#define DMA_TCD16_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x206)// DMA TCD16 Transfer Attributes
#define DMA_TCD16_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x208) // DMA TCD16 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD16_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x208) // DMA TCD16 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD16_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x208) // DMA TCD16 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD16_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x20c) // DMA TCD16 Last Source Address Adjustment
#define DMA_TCD16_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x210) // DMA TCD16 Destination Address
#define DMA_TCD16_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x214)  // DMA TCD16 Signed Destination Address Offset
#define DMA_TCD16_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x216) // DMA TCD16 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD16_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x216) // DMA TCD16 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD16_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x218) // DMA TCD16 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD16_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x21c) // DMA TCD16 Control and Status
#define DMA_TCD16_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x21e) // DMA TCD16 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD16_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x21e) // DMA TCD16 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD17_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x220) // DMA TCD17 Source Address
#define DMA_TCD17_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x224)  // DMA TCD17 Signed Source Address Offset
#define DMA_TCD17_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x226)// DMA TCD17 Transfer Attributes
#define DMA_TCD17_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x228) // DMA TCD17 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD17_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x228) // DMA TCD17 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD17_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x228) // DMA TCD17 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD17_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x22c) // DMA TCD17 Last Source Address Adjustment
#define DMA_TCD17_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x230) // DMA TCD17 Destination Address
#define DMA_TCD17_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x234)  // DMA TCD17 Signed Destination Address Offset
#define DMA_TCD17_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x236) // DMA TCD17 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD17_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x236) // DMA TCD17 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD17_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x238) // DMA TCD17 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD17_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x23c) // DMA TCD17 Control and Status
#define DMA_TCD17_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x23e) // DMA TCD17 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD17_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x23e) // DMA TCD17 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD18_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x240) // DMA TCD18 Source Address
#define DMA_TCD18_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x244)  // DMA TCD18 Signed Source Address Offset
#define DMA_TCD18_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x246)// DMA TCD18 Transfer Attributes
#define DMA_TCD18_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x248) // DMA TCD18 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD18_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x248) // DMA TCD18 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD18_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x248) // DMA TCD18 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD18_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x24c) // DMA TCD18 Last Source Address Adjustment
#define DMA_TCD18_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x250) // DMA TCD18 Destination Address
#define DMA_TCD18_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x254)  // DMA TCD18 Signed Destination Address Offset
#define DMA_TCD18_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x256) // DMA TCD18 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD18_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x256) // DMA TCD18 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD18_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x258) // DMA TCD18 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD18_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x25c) // DMA TCD18 Control and Status
#define DMA_TCD18_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x25e) // DMA TCD18 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD18_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x25e) // DMA TCD18 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD19_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x260) // DMA TCD19 Source Address
#define DMA_TCD19_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x264)  // DMA TCD19 Signed Source Address Offset
#define DMA_TCD19_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x266)// DMA TCD19 Transfer Attributes
#define DMA_TCD19_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x268) // DMA TCD19 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD19_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x268) // DMA TCD19 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD19_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x268) // DMA TCD19 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD19_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x26c) // DMA TCD19 Last Source Address Adjustment
#define DMA_TCD19_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x270) // DMA TCD19 Destination Address
#define DMA_TCD19_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x274)  // DMA TCD19 Signed Destination Address Offset
#define DMA_TCD19_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x276) // DMA TCD19 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD19_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x276) // DMA TCD19 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD19_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x278) // DMA TCD19 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD19_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x27c) // DMA TCD19 Control and Status
#define DMA_TCD19_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x27e) // DMA TCD19 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD19_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x27e) // DMA TCD19 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD20_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x280) // DMA TCD20 Source Address
#define DMA_TCD20_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x284)  // DMA TCD20 Signed Source Address Offset
#define DMA_TCD20_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x286)// DMA TCD20 Transfer Attributes
#define DMA_TCD20_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x288) // DMA TCD20 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD20_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x288) // DMA TCD20 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD20_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x288) // DMA TCD20 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD20_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x28c) // DMA TCD20 Last Source Address Adjustment
#define DMA_TCD20_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x290) // DMA TCD20 Destination Address
#define DMA_TCD20_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x294)  // DMA TCD20 Signed Destination Address Offset
#define DMA_TCD20_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x296) // DMA TCD20 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD20_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x296) // DMA TCD20 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD20_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x298) // DMA TCD20 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD20_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x29c) // DMA TCD20 Control and Status
#define DMA_TCD20_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x29e) // DMA TCD20 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD20_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x29e) // DMA TCD20 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD21_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2a0) // DMA TCD21 Source Address
#define DMA_TCD21_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2a4)  // DMA TCD21 Signed Source Address Offset
#define DMA_TCD21_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x2a6)// DMA TCD21 Transfer Attributes
#define DMA_TCD21_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2a8) // DMA TCD21 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD21_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2a8) // DMA TCD21 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD21_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2a8) // DMA TCD21 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD21_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2ac) // DMA TCD21 Last Source Address Adjustment
#define DMA_TCD21_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2b0) // DMA TCD21 Destination Address
#define DMA_TCD21_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2b4)  // DMA TCD21 Signed Destination Address Offset
#define DMA_TCD21_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2b6) // DMA TCD21 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD21_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2b6) // DMA TCD21 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD21_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2b8) // DMA TCD21 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD21_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x2bc) // DMA TCD21 Control and Status
#define DMA_TCD21_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x2be) // DMA TCD21 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD21_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x2be) // DMA TCD21 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled
#define DMA_TCD22_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2c0) // DMA TCD22 Source Address
#define DMA_TCD22_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2c4)  // DMA TCD22 Signed Source Address Offset
#define DMA_TCD22_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x2c6)// DMA TCD22 Transfer Attributes
#define DMA_TCD22_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2c8) // DMA TCD22 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD22_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2c8) // DMA TCD22 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD22_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2c8) // DMA TCD22 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD22_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2cc) // DMA TCD22 Last Source Address Adjustment
#define DMA_TCD22_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2d0) // DMA TCD22 Destination Address
#define DMA_TCD22_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2d4)  // DMA TCD22 Signed Destination Address Offset
#define DMA_TCD22_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2d6) // DMA TCD22 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD22_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2d6) // DMA TCD22 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD22_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2d8) // DMA TCD22 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD22_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x2dc) // DMA TCD22 Control and Status
#define DMA_TCD22_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x2de) // DMA TCD22 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD22_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x2de) // DMA TCD22 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD23_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2e0) // DMA TCD23 Source Address
#define DMA_TCD23_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2e4)  // DMA TCD23 Signed Source Address Offset
#define DMA_TCD23_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x2e6)// DMA TCD23 Transfer Attributes
#define DMA_TCD23_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2e8) // DMA TCD23 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD23_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2e8) // DMA TCD23 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD23_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2e8) // DMA TCD23 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD23_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2ec) // DMA TCD23 Last Source Address Adjustment
#define DMA_TCD23_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x2f0) // DMA TCD23 Destination Address
#define DMA_TCD23_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x2f4)  // DMA TCD23 Signed Destination Address Offset
#define DMA_TCD23_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2f6) // DMA TCD23 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD23_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x2f6) // DMA TCD23 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD23_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x2f8) // DMA TCD23 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD23_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x2fc) // DMA TCD23 Control and Status
#define DMA_TCD23_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x2fe) // DMA TCD23 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD23_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x2fe) // DMA TCD23 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD24_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x300) // DMA TCD24 Source Address
#define DMA_TCD24_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x304)  // DMA TCD24 Signed Source Address Offset
#define DMA_TCD24_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x306)// DMA TCD24 Transfer Attributes
#define DMA_TCD24_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x308) // DMA TCD24 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD24_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x308) // DMA TCD24 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD24_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x308) // DMA TCD24 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD24_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x30c) // DMA TCD24 Last Source Address Adjustment
#define DMA_TCD24_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x310) // DMA TCD24 Destination Address
#define DMA_TCD24_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x314)  // DMA TCD24 Signed Destination Address Offset
#define DMA_TCD24_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x316) // DMA TCD24 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD24_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x316) // DMA TCD24 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD24_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x318) // DMA TCD24 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD24_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x31c) // DMA TCD24 Control and Status
#define DMA_TCD24_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x31e) // DMA TCD24 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD24_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x31e) // DMA TCD24 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD25_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x320) // DMA TCD25 Source Address
#define DMA_TCD25_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x324)  // DMA TCD25 Signed Source Address Offset
#define DMA_TCD25_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x326)// DMA TCD25 Transfer Attributes
#define DMA_TCD25_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x328) // DMA TCD25 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD25_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x328) // DMA TCD25 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD25_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x328) // DMA TCD25 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD25_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x32c) // DMA TCD25 Last Source Address Adjustment
#define DMA_TCD25_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x330) // DMA TCD25 Destination Address
#define DMA_TCD25_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x334)  // DMA TCD25 Signed Destination Address Offset
#define DMA_TCD25_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x336) // DMA TCD25 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD25_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x336) // DMA TCD25 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD25_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x338) // DMA TCD25 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD25_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x33c) // DMA TCD25 Control and Status
#define DMA_TCD25_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x33e) // DMA TCD25 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD25_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x33e) // DMA TCD25 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD26_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x340) // DMA TCD26 Source Address
#define DMA_TCD26_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x344)  // DMA TCD26 Signed Source Address Offset
#define DMA_TCD26_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x346)// DMA TCD26 Transfer Attributes
#define DMA_TCD26_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x348) // DMA TCD26 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD26_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x348) // DMA TCD26 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD26_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x348) // DMA TCD26 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD26_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x34c) // DMA TCD26 Last Source Address Adjustment
#define DMA_TCD26_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x350) // DMA TCD26 Destination Address
#define DMA_TCD26_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x354)  // DMA TCD26 Signed Destination Address Offset
#define DMA_TCD26_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x356) // DMA TCD26 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD26_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x356) // DMA TCD26 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD26_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x358) // DMA TCD26 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD26_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x35c) // DMA TCD26 Control and Status
#define DMA_TCD26_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x35e) // DMA TCD26 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD26_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x35e) // DMA TCD26 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD27_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x360) // DMA TCD27 Source Address
#define DMA_TCD27_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x364)  // DMA TCD27 Signed Source Address Offset
#define DMA_TCD27_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x366)// DMA TCD27 Transfer Attributes
#define DMA_TCD27_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x368) // DMA TCD27 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD27_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x368) // DMA TCD27 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD27_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x368) // DMA TCD27 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD27_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x36c) // DMA TCD27 Last Source Address Adjustment
#define DMA_TCD27_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x370) // DMA TCD27 Destination Address
#define DMA_TCD27_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x374)  // DMA TCD27 Signed Destination Address Offset
#define DMA_TCD27_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x376) // DMA TCD27 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD27_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x376) // DMA TCD27 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD27_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x378) // DMA TCD27 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD27_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x37c) // DMA TCD27 Control and Status
#define DMA_TCD27_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x37e) // DMA TCD27 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD27_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x37e) // DMA TCD27 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD28_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x380) // DMA TCD28 Source Address
#define DMA_TCD28_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x384)  // DMA TCD28 Signed Source Address Offset
#define DMA_TCD28_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x386)// DMA TCD28 Transfer Attributes
#define DMA_TCD28_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x388) // DMA TCD28 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD28_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x388) // DMA TCD28 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD28_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x388) // DMA TCD28 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD28_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x38c) // DMA TCD28 Last Source Address Adjustment
#define DMA_TCD28_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x390) // DMA TCD28 Destination Address
#define DMA_TCD28_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x394)  // DMA TCD28 Signed Destination Address Offset
#define DMA_TCD28_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x396) // DMA TCD28 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD28_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x396) // DMA TCD28 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD28_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x398) // DMA TCD28 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD28_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x39c) // DMA TCD28 Control and Status
#define DMA_TCD28_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x39e) // DMA TCD28 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD28_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x39e) // DMA TCD28 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD29_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3a0) // DMA TCD29 Source Address
#define DMA_TCD29_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3a4)  // DMA TCD29 Signed Source Address Offset
#define DMA_TCD29_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x3a6)// DMA TCD29 Transfer Attributes
#define DMA_TCD29_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3a8) // DMA TCD29 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD29_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3a8) // DMA TCD29 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD29_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3a8) // DMA TCD29 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD29_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3ac) // DMA TCD29 Last Source Address Adjustment
#define DMA_TCD29_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3b0) // DMA TCD29 Destination Address
#define DMA_TCD29_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3b4)  // DMA TCD29 Signed Destination Address Offset
#define DMA_TCD29_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3b6) // DMA TCD29 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD29_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3b6) // DMA TCD29 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD29_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3b8) // DMA TCD29 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD29_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x3bc) // DMA TCD29 Control and Status
#define DMA_TCD29_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x3be) // DMA TCD29 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD29_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x3be) // DMA TCD29 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD30_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3c0) // DMA TCD30 Source Address
#define DMA_TCD30_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3c4)  // DMA TCD30 Signed Source Address Offset
#define DMA_TCD30_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x3c6)// DMA TCD30 Transfer Attributes
#define DMA_TCD30_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3c8) // DMA TCD30 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD30_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3c8) // DMA TCD30 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD30_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3c8) // DMA TCD30 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD30_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3cc) // DMA TCD30 Last Source Address Adjustment
#define DMA_TCD30_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3d0) // DMA TCD30 Destination Address
#define DMA_TCD30_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3d4)  // DMA TCD30 Signed Destination Address Offset
#define DMA_TCD30_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3d6) // DMA TCD30 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD30_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3d6) // DMA TCD30 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD30_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3d8) // DMA TCD30 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD30_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x3dc) // DMA TCD30 Control and Status
#define DMA_TCD30_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x3de) // DMA TCD30 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD30_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x3de) // DMA TCD30 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD31_SADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3e0) // DMA TCD31 Source Address
#define DMA_TCD31_SOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3e4)  // DMA TCD31 Signed Source Address Offset
#define DMA_TCD31_ATTR      *(unsigned short *)(eDMA_DESCRIPTORS + 0x3e6)// DMA TCD31 Transfer Attributes
#define DMA_TCD31_NBYTES_MLNO *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3e8) // DMA TCD31 Minor Byte Count (Minor Loop Disabled)
#define DMA_TCD31_NBYTES_MLOFFNO *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3e8) // DMA TCD31 Signed Minor Byte Count (Minor Loop Enabled and Offset Disabled)
#define DMA_TCD31_NBYTES_MLOFFYES *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3e8) // DMA TCD31 Signed Minor Byte Count (Minor Loop Enabled and Offset Enabled)
#define DMA_TCD31_SLAST     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3ec) // DMA TCD31 Last Source Address Adjustment
#define DMA_TCD31_DADDR     *(volatile unsigned long *)(eDMA_DESCRIPTORS + 0x3f0) // DMA TCD31 Destination Address
#define DMA_TCD31_DOFF      *(signed short *)(eDMA_DESCRIPTORS + 0x3f4)  // DMA TCD31 Signed Destination Address Offset
#define DMA_TCD31_CITER_ELINKYES *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3f6) // DMA TCD31 Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD31_CITER_ELINKNO *(volatile signed short *)(eDMA_DESCRIPTORS + 0x3f6) // DMA TCD31 Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
#define DMA_TCD31_DLASTSGA  *(volatile signed long *)(eDMA_DESCRIPTORS + 0x3f8) // DMA TCD31 Last Destination Address Adjustment/Scatter Gather Address
#define DMA_TCD31_CSR       *(volatile unsigned short *)(eDMA_DESCRIPTORS + 0x3fc) // DMA TCD31 Control and Status
#define DMA_TCD31_BITER_ELINKYES *(unsigned short *)(eDMA_DESCRIPTORS + 0x3fe) // DMA TCD31 Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
#define DMA_TCD31_BITER_ELINKNO *(unsigned short *)(eDMA_DESCRIPTORS + 0x3fe) // DMA TCD31 Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled
#define eDMA_DESCRIPTORS_END (unsigned long *)(eDMA_DESCRIPTORS + 0x400)

#define _SET_DMA_CHANNEL_PRIORITY(channel, priority) *(DMA_DCHPRI0_ADD + ((channel/4) * 4) - (channel%4)) = (priority); // macro to set DMA channel priority register for particualar channel
#define _SET_DMA_CHANNEL_CHARACTERISTIC(channel, characteristic) *(DMA_DCHPRI0_ADD + ((channel/4) * 4) - (channel%4)) |= (characteristic); // macro to set channel characteristics without modifying priority
#define _SET_DMA_CHANNEL_RESET(channel) *(DMA_DCHPRI0_ADD + ((channel/4) * 4) - (channel%4)) &= ~(DMA_DCHPRI_DPA | DMA_DCHPRI_ECP); // macro to reset channel characteristics without modifying priority

typedef struct stKINETIS_DMA_TDC
{
    volatile unsigned long  DMA_TCD_SADDR;
    volatile signed short   DMA_TCD_SOFF;
    unsigned short          DMA_TCD_ATTR;
    volatile unsigned long  DMA_TCD_NBYTES_ML;
    volatile unsigned long  DMA_TCD_SLAST;
    volatile unsigned long  DMA_TCD_DADDR;
    volatile signed short   DMA_TCD_DOFF;
    volatile signed short   DMA_TCD_CITER_ELINK;
    volatile unsigned long  DMA_TCD_DLASTSGA;
    volatile unsigned short DMA_TCD_CSR;
    unsigned short          DMA_TCD_BITER_ELINK;
} KINETIS_DMA_TDC;


#define DMA_BYTES                    0x00000001
#define DMA_HALF_WORDS               0x00000002
#define DMA_LONG_WORDS               0x00000004
#define DMA_AUTOREPEAT               0x00000008
#define DMA_HALF_BUFFER_INTERRUPT    0x00000010
#define DMA_DIRECTION_INPUT          0x00000000                          // fixed source address to buffer
#define DMA_DIRECTION_OUTPUT         0x00000020                          // buffer to fixed destination address
#define DMA_FIXED_ADDRESSES          0x00000040                          // neither source nor distination address is changed during the transfer
#define DMA_NO_MODULO                0x00000080
#define DMA_SINGLE_CYCLE             0x00000100
#define DMA_SW_TRIGGER               0x00000200
#define DMA_INITIATE_TRANSFER        0x00000400
#define DMA_WAIT_TERMINATION         0x00000800
#define DMA_BUFFER_BURST_MODE        0x00001000                          // complete buffer is transfered at each trigger
#define DMA_DIRECTION_BUFFER_BUFFER  0x00002000                          // buffer to buffer
#define DMA_SW_TRIGGER_WAIT_TERMINATION (DMA_SW_TRIGGER | DMA_INITIATE_TRANSFER | DMA_WAIT_TERMINATION)

extern int fnConfigDMA_buffer(unsigned char ucDMA_channel, unsigned short ucDmaTriggerSource, unsigned long ulBufLength, void *ptrBufSource, void *ptrBufDest, unsigned long ulRules, void(*int_handler)(void), int int_priority);
    #define DMA_ERROR_OCCURRED       -1


#define INPUT_TO_INTMUX0_CHANNEL_0        0
#define INPUT_TO_INTMUX0_CHANNEL_1        1
#define INPUT_TO_INTMUX0_CHANNEL_2        2
#define INPUT_TO_INTMUX0_CHANNEL_3        3







#define CROSSBAR_MASTER_ARM_CORE_CODE    MASTER_M0
#define CROSSBAR_MASTER_ARM_CORE_SYSTEM  MASTER_M0
#if !defined KINETIS_KL2
    #define CROSSBAR_MASTER_DMA          MASTER_M2
    #if !defined KINETIS_KL
        #define CROSSBAR_MASTER_EZPORT   MASTER_M2
    #endif
#endif

#define CROSSBAR_SLAVE_FLASH_CONTROLLER  SLAVE_S0
#define CROSSBAR_SLAVE_SRAML_SRAMU       SLAVE_S1
#define CROSSBAR_SLAVE_SRAM_BACKDOOR     SLAVE_S1
#define CROSSBAR_SLAVE_BME               SLAVE_S2
#define CROSSBAR_SLAVE_PERIPH_BRIDGE_0   SLAVE_S2
#define CROSSBAR_SLAVE_PERIPH_BRIDGE_1   SLAVE_S3
#define CROSSBAR_SLAVE_GPIO_CONTROLLER   SLAVE_S3
#define CROSSBAR_SLAVE_FLEXBUS           SLAVE_S4
#define CROSSBAR_SLAVE_DRAM1             SLAVE_S5
#define CROSSBAR_SLAVE_DRAM2             SLAVE_S6
#define CROSSBAR_SLAVE_DRAM3             SLAVE_S7



typedef struct stRESET_VECTOR_VALIDATION
{
    void  *ptrResetSP;                                                   // initial stack pointer
    void  (*ptrResetPC)(void);                                           // initial program counter
    unsigned long ulValSupport[2];                                       // signal that val. supported
    unsigned long ulValidated[2];                                        // space for validation programming
} RESET_VECTOR_VALIDATION;


extern int fnProgramOnce(int iCommand, unsigned long *ptrBuffer, unsigned char ucBlockNumber, unsigned char ucLength);
    #define PROGRAM_ONCE_READ    0
    #define PROGRAM_ONCE_WRITE   1
extern int fnBackdoorUnlock(unsigned long Key[2]);

#if !defined DEVICE_WITHOUT_DMA
    // DMAMUX 0
    //
    #define DMA_MUX_REGISTER     unsigned long
    #define DMAMUX0_CHCFG_ADD   (unsigned long *)(DMAMUX0_BLOCK + 0x00)
    #define DMAMUX0_CHCFG0     *(unsigned long *)(DMAMUX0_BLOCK + 0x00)  // channel 0 configuration register
        #define DMAMUX0_CHCFG_SOURCE_FLEXIO1_0_1     0                   // 0x00 FlexIO 1 request 0 or 1
        #define DMAMUX0_CHCFG_SOURCE_FLEXIO1_4_5     1                   // 0x01 FlexIO 1 request 4 or 5
        #define DMAMUX0_CHCFG_SOURCE_LPUART1_TX      2                   // 0x02 LPUART1 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART1_RX      3                   // 0x03 LPUART1 RX
        #define DMAMUX0_CHCFG_SOURCE_LPUART3_TX      4                   // 0x04 LPUART3 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART3_RX      5                   // 0x05 LPUART3 RX
        #define DMAMUX0_CHCFG_SOURCE_LPUART5_TX      6                   // 0x06 LPUART5 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART5_RX      7                   // 0x07 LPUART5 RX
        #define DMAMUX0_CHCFG_SOURCE_LPUART7_TX      8                   // 0x08 LPUART7 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART7_RX      9                   // 0x09 LPUART7 RX

        #define DMAMUX0_CHCFG_SOURCE_LPSPI1_RX       13                  // 0x0d LPSPI1 RX
        #define DMAMUX0_CHCFG_SOURCE_LPSPI1_TX       14                  // 0x0e LPSPI1 TX
        #define DMAMUX0_CHCFG_SOURCE_LPSPI3_RX       15                  // 0x0f LPSPI3 RX
        #define DMAMUX0_CHCFG_SOURCE_LPSPI3_TX       16                  // 0x10 LPSPI3 TX
        #define DMAMUX0_CHCFG_SOURCE_LPI2C1          17                  // 0x11 LPI2C1
        #define DMAMUX0_CHCFG_SOURCE_LPI2C3          18                  // 0x12 LPI2C3
        #define DMAMUX0_CHCFG_SOURCE_SAI1_RX         19                  // 0x13 SAI1 RX
        #define DMAMUX0_CHCFG_SOURCE_SAI1_TX         20                  // 0x14 SAI1 TX
        #define DMAMUX0_CHCFG_SOURCE_SAI2_RX         21                  // 0x15 SAI2 RX
        #define DMAMUX0_CHCFG_SOURCE_SAI2_TX         22                  // 0x16 SAI2 TX
        #define DMAMUX0_CHCFG_SOURCE_ADC_ETC         23                  // 0x17 ADC ETC
        #define DMAMUX0_CHCFG_SOURCE_ADC1            24                  // 0x18 ADC1
        #define DMAMUX0_CHCFG_SOURCE_ACMP1           25                  // 0x19 ACMP1
        #define DMAMUX0_CHCFG_SOURCE_ACMP3           26                  // 0x1a ACMP3

        #define DMAMUX0_CHCFG_SOURCE_FLEXSPI_RX      28                  // 0x1c FLEXSPI RX
        #define DMAMUX0_CHCFG_SOURCE_FLEXSPI_TX      29                  // 0x1d FLEXSPI TX
        #define DMAMUX0_CHCFG_SOURCE_XBAR1_0         30                  // 0x1e XBAR1 request 0
        #define DMAMUX0_CHCFG_SOURCE_XBAR1_1         31                  // 0x1f XBAR1 request 1
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM0_CAP 32                // 0x20 FLEXPWM1 PWM0 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM1_CAP 33                // 0x21 FLEXPWM1 PWM1 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM2_CAP 34                // 0x22 FLEXPWM1 PWM2 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM3_CAP 35                // 0x23 FLEXPWM1 PWM3 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM0_VAL 36                // 0x24 FLEXPWM1 PWM0 - value
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM1_VAL 37                // 0x25 FLEXPWM1 PWM1 - value
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM2_VAL 38                // 0x26 FLEXPWM1 PWM2 - value
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM1_PWM3_VAL 39                // 0x27 FLEXPWM1 PWM3 - value

        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_0_CAP   48                  // 0x30 QTIMER1 timer 0 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_1_CAP   49                  // 0x31 QTIMER1 timer 1 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_2_CAP   50                  // 0x32 QTIMER1 timer 2 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_3_CAP   51                  // 0x33 QTIMER1 timer 3 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_0_CMP1  52                  // 0x34 QTIMER1 timer 0 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_1_CMP2  52                  // 0x34 QTIMER1 timer 1 - compare 2
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_1_CMP1  53                  // 0x35 QTIMER1 timer 1 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_0_CMP2  53                  // 0x35 QTIMER1 timer 0 - compare 2
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_2_CMP1  54                  // 0x36 QTIMER1 timer 2 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_3_CMP2  54                  // 0x36 QTIMER1 timer 3 - compare 2
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_3_CMP1  55                  // 0x37 QTIMER1 timer 3 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER1_2_CMP2  55                  // 0x37 QTIMER1 timer 2 - compare 2

        #define DMAMUX0_CHCFG_SOURCE_FLEXIO1_2_3     64                  // 0x40 FlexIO 1 request 2 or 3
        #define DMAMUX0_CHCFG_SOURCE_FLEXIO1_6_7     65                  // 0x41 FlexIO 1 request 6 or 7
        #define DMAMUX0_CHCFG_SOURCE_LPUART2_TX      66                  // 0x42 LPUART2 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART2_RX      67                  // 0x43 LPUART2 RX
        #define DMAMUX0_CHCFG_SOURCE_LPUART4_TX      68                  // 0x44 LPUART4 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART4_RX      69                  // 0x45 LPUART4 RX
        #define DMAMUX0_CHCFG_SOURCE_LPUART6_TX      70                  // 0x46 LPUART6 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART6_RX      71                  // 0x47 LPUART6 RX
        #define DMAMUX0_CHCFG_SOURCE_LPUART8_TX      72                  // 0x48 LPUART8 TX
        #define DMAMUX0_CHCFG_SOURCE_LPUART8_RX      73                  // 0x49 LPUART8 RX

        #define DMAMUX0_CHCFG_SOURCE_LPSPI2_RX       77                  // 0x4d LPSPI2 RX
        #define DMAMUX0_CHCFG_SOURCE_LPSPI2_TX       78                  // 0x4e LPSPI2 TX
        #define DMAMUX0_CHCFG_SOURCE_LPSPI4_RX       79                  // 0x4f LPSPI4 RX
        #define DMAMUX0_CHCFG_SOURCE_LPSPI4_TX       80                  // 0x50 LPSPI4 TX
        #define DMAMUX0_CHCFG_SOURCE_LPI2C2          81                  // 0x51 LPI2C2
        #define DMAMUX0_CHCFG_SOURCE_LPI2C4          82                  // 0x52 LPI2C4
        #define DMAMUX0_CHCFG_SOURCE_SAI3_RX         83                  // 0x53 SAI3 RX
        #define DMAMUX0_CHCFG_SOURCE_SAI3_TX         84                  // 0x54 SAI3 TX
        #define DMAMUX0_CHCFG_SOURCE_SPDIF_RX        85                  // 0x55 SPDIF RX
        #define DMAMUX0_CHCFG_SOURCE_SPDIF_TX        86                  // 0x56 SPDIF TX

        #define DMAMUX0_CHCFG_SOURCE_ADC2            88                  // 0x58 ADC2
        #define DMAMUX0_CHCFG_SOURCE_ACMP2           89                  // 0x59 ACMP2
        #define DMAMUX0_CHCFG_SOURCE_ACMP4           90                  // 0x5a ACMP4

        #define DMAMUX0_CHCFG_SOURCE_ENET_0          92                  // 0x5c ENET timer DMA request 0
        #define DMAMUX0_CHCFG_SOURCE_ENET_1          93                  // 0x5d ENET timer DMA request 1
        #define DMAMUX0_CHCFG_SOURCE_XBAR1_2         94                  // 0x5e XBAR1 request 2
        #define DMAMUX0_CHCFG_SOURCE_XBAR1_3         95                  // 0x5f XBAR1 request 3
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM0_CAP 96                // 0x60 FLEXPWM2 PWM0 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM1_CAP 97                // 0x61 FLEXPWM2 PWM1 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM2_CAP 98                // 0x62 FLEXPWM2 PWM2 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM3_CAP 99                // 0x63 FLEXPWM2 PWM3 - capture
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM0_VAL 100               // 0x64 FLEXPWM2 PWM0 - value
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM1_VAL 101               // 0x65 FLEXPWM2 PWM1 - value
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM2_VAL 102               // 0x66 FLEXPWM2 PWM2 - value
        #define DMAMUX0_CHCFG_SOURCE_FLEXPWM2_PWM3_VAL 103               // 0x67 FLEXPWM2 PWM3 - value

        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_0_CAP   112                 // 0x70 QTIMER2 timer 0 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_1_CAP   113                 // 0x71 QTIMER2 timer 1 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_2_CAP   114                 // 0x72 QTIMER2 timer 2 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_3_CAP   115                 // 0x73 QTIMER2 timer 3 - capture
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_0_CMP1  116                 // 0x74 QTIMER2 timer 0 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_1_CMP2  116                 // 0x74 QTIMER2 timer 1 - compare 2
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_1_CMP1  117                 // 0x75 QTIMER2 timer 1 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_0_CMP2  117                 // 0x75 QTIMER2 timer 0 - compare 2
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_2_CMP1  118                 // 0x76 QTIMER2 timer 2 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_3_CMP2  118                 // 0x76 QTIMER2 timer 3 - compare 2
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_3_CMP1  119                 // 0x77 QTIMER2 timer 3 - compare 1
        #define DMAMUX0_CHCFG_SOURCE_QTIMER2_2_CMP2  119                 // 0x77 QTIMER2 timer 2 - compare 2

      #define DMAMUX_CHCFG_A_ON                  0x20000000              // DMA channel always enable
      #define DMAMUX_CHCFG_TRIG                  0x40000000              // DMA channel trigger enable
      #define DMAMUX_CHCFG_ENBL                  0x80000000              // DMA channel enable

        #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT0       (120 | DMAMUX_CHCFG_TRIG)
        #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT1       (121 | DMAMUX_CHCFG_TRIG)
        #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT2       (122 | DMAMUX_CHCFG_TRIG)
        #define DMAMUX0_DMA0_CHCFG_SOURCE_PIT3       (123 | DMAMUX_CHCFG_TRIG)

    #define DMAMUX0_CHCFG1     *(unsigned long *)(DMAMUX0_BLOCK + 0x04)  // Channel 1 Configuration Register
    #define DMAMUX0_CHCFG2     *(unsigned long *)(DMAMUX0_BLOCK + 0x08)  // Channel 2 Configuration Register
    #define DMAMUX0_CHCFG3     *(unsigned long *)(DMAMUX0_BLOCK + 0x0c)  // Channel 3 Configuration Register
    #define DMAMUX0_CHCFG4     *(unsigned long *)(DMAMUX0_BLOCK + 0x10)  // Channel 4 Configuration Register
    #define DMAMUX0_CHCFG5     *(unsigned long *)(DMAMUX0_BLOCK + 0x14)  // Channel 5 Configuration Register
    #define DMAMUX0_CHCFG6     *(unsigned long *)(DMAMUX0_BLOCK + 0x18)  // Channel 6 Configuration Register
    #define DMAMUX0_CHCFG7     *(unsigned long *)(DMAMUX0_BLOCK + 0x1c)  // Channel 7 Configuration Register
    #define DMAMUX0_CHCFG8     *(unsigned long *)(DMAMUX0_BLOCK + 0x20)  // Channel 8 Configuration Register
    #define DMAMUX0_CHCFG9     *(unsigned long *)(DMAMUX0_BLOCK + 0x24)  // Channel 9 Configuration Register
    #define DMAMUX0_CHCFG10    *(unsigned long *)(DMAMUX0_BLOCK + 0x28)  // Channel 10 Configuration Register
    #define DMAMUX0_CHCFG11    *(unsigned long *)(DMAMUX0_BLOCK + 0x2c)  // Channel 11 Configuration Register
    #define DMAMUX0_CHCFG12    *(unsigned long *)(DMAMUX0_BLOCK + 0x30)  // Channel 12 Configuration Register
    #define DMAMUX0_CHCFG13    *(unsigned long *)(DMAMUX0_BLOCK + 0x34)  // Channel 13 Configuration Register
    #define DMAMUX0_CHCFG14    *(unsigned long *)(DMAMUX0_BLOCK + 0x38)  // Channel 14 Configuration Register
    #define DMAMUX0_CHCFG15    *(unsigned long *)(DMAMUX0_BLOCK + 0x3c)  // Channel 15 Configuration Register
    #define DMAMUX0_CHCFG16    *(unsigned long *)(DMAMUX0_BLOCK + 0x40)  // Channel 16 Configuration Register
    #define DMAMUX0_CHCFG17    *(unsigned long *)(DMAMUX0_BLOCK + 0x44)  // Channel 17 Configuration Register
    #define DMAMUX0_CHCFG18    *(unsigned long *)(DMAMUX0_BLOCK + 0x48)  // Channel 18 Configuration Register
    #define DMAMUX0_CHCFG19    *(unsigned long *)(DMAMUX0_BLOCK + 0x4c)  // Channel 19 Configuration Register
    #define DMAMUX0_CHCFG20    *(unsigned long *)(DMAMUX0_BLOCK + 0x50)  // Channel 20 Configuration Register
    #define DMAMUX0_CHCFG21    *(unsigned long *)(DMAMUX0_BLOCK + 0x54)  // Channel 21 Configuration Register
    #define DMAMUX0_CHCFG22    *(unsigned long *)(DMAMUX0_BLOCK + 0x58)  // Channel 22 Configuration Register
    #define DMAMUX0_CHCFG23    *(unsigned long *)(DMAMUX0_BLOCK + 0x5c)  // Channel 23 Configuration Register
    #define DMAMUX0_CHCFG24    *(unsigned long *)(DMAMUX0_BLOCK + 0x60)  // Channel 24 Configuration Register
    #define DMAMUX0_CHCFG25    *(unsigned long *)(DMAMUX0_BLOCK + 0x64)  // Channel 25 Configuration Register
    #define DMAMUX0_CHCFG26    *(unsigned long *)(DMAMUX0_BLOCK + 0x68)  // Channel 26 Configuration Register
    #define DMAMUX0_CHCFG27    *(unsigned long *)(DMAMUX0_BLOCK + 0x6c)  // Channel 27 Configuration Register
    #define DMAMUX0_CHCFG28    *(unsigned long *)(DMAMUX0_BLOCK + 0x70)  // Channel 28 Configuration Register
    #define DMAMUX0_CHCFG29    *(unsigned long *)(DMAMUX0_BLOCK + 0x74)  // Channel 29 Configuration Register
    #define DMAMUX0_CHCFG30    *(unsigned long *)(DMAMUX0_BLOCK + 0x78)  // Channel 30 Configuration Register
    #define DMAMUX0_CHCFG31    *(unsigned long *)(DMAMUX0_BLOCK + 0x7c)  // Channel 31 Configuration Register
#endif


// I2S (SAI - Synchronous Audio Interface)
//
#if defined I2S_AVAILABLE
    #define I2S0_TCSR          *(volatile unsigned long *)(I2S0_BLOCK + 0x000)    // I2S0 transmit control register
        #define I2S_TCSR_FWDE  0x00000002                                // FIFO warning DMA enable
        #define I2S_TCSR_FWIE  0x00000200                                // FIFO warning interrupt enable
        #define I2S_TCSR_FEIE  0x00000400                                // FIFO error interrupt enable
        #define I2S_TCSR_WSIE  0x00000800                                // word start interrupt enable
        #define I2S_TCSR_FWF   0x00020000                                // FIFO warning flag (read-only)
        #define I2S_TCSR_FEF   0x00040000                                // FIFO error flag (write '1' to clear)
        #define I2S_TCSR_SEF   0x00080000                                // sync error flag (write '1' to clear)
        #define I2S_TCSR_WSF   0x00100000                                // word start flag (write '1' to clear)
        #define I2S_TCSR_SR    0x01000000                                // software reset
        #define I2S_TCSR_FR    0x02000000                                // FIFO reset (reads always '0')
        #define I2S_TCSR_BCE   0x10000000                                // bit clock enable
        #define I2S_TCSR_DBGE  0x20000000                                // debug enable
        #define I2S_TCSR_STOPE 0x40000000                                // stop enable
        #define I2S_TCSR_TE    0x80000000                                // transmitter enable
    #define I2S0_TCR2          *(unsigned long *)(I2S0_BLOCK + 0x008)    // I2S0 transmit configuration 2 register
        #define I2S_TCR2_DIV_MASK        0x000000ff                      // bit clock divide mask ((DIV + 1) * 2)
        #define I2S_TCR2_BCD_EXT_SLAVE   0x00000000                      // bit clock direction - generated externally in slave mode
        #define I2S_TCR2_BCD_INT_MASTER  0x01000000                      // bit clock direction - generated internally in master mode
        #define I2S_TCR2_BCP_ACT_HIGH    0x00000000                      // bit clock polarity - active high [drive outputs on rising edge and sample inputs on falling edge]
        #define I2S_TCR2_BCP_ACT_LOW     0x02000000                      // bit clock polarity - active low [drive outputs on falling edge and sample inputs on rising edge]
        #define I2S_TCR2_MSEL_BUS        0x00000000                      // MCLK select - bus clock selected
        #define I2S_TCR2_MSEL1           0x04000000                      // MCLK select - master clock 1 option
        #define I2S_TCR2_MSEL2           0x08000000                      // MCLK select - master clock 2 option
        #define I2S_TCR2_MSEL3           0x0c000000                      // MCLK select - master clock 3 option
        #define I2S_TCR2_BCI             0x10000000                      // bit clock input
        #define I2S_TCR2_BCS             0x20000000                      // bit clock swap
        #define I2S_TCR2_SYNC_ASYN       0x00000000                      // asynchronous mode
        #define I2S_TCR2_SYNC_SYN_RX     0x40000000                      // synchronous with receiver
        #define I2S_TCR2_SYNC_SYN_SAI_TX 0x80000000                      // synchronous with another SAI transmitter
        #define I2S_TCR2_SYNC_SYN_SAI_RX 0xc0000000                      // synchronous with another SAI receiver
    #define I2S0_TCR3          *(unsigned long *)(I2S0_BLOCK + 0x00c)    // I2S0 transmit configuration 3 register
        #define I2S_TCR3_WDFL_FIRST      0x00000000                      // word flag configuration - first in frame
        #define I2S_TCR3_WDFL_SECOND     0x00000001                      // word flag configuration - second in frame
        #define I2S_TCR3_TCE             0x00010000                      // transmit channel enable
    #define I2S0_TCR4          *(unsigned long *)(I2S0_BLOCK + 0x010)    // I2S0 transmit configuration 4 register
        #define I2S_TCR4_FSD_EXT_SLAVE   0x00000000                      // frame sync direction - generated externally (slave)
        #define I2S_TCR4_FSD_INT_MASTER  0x00000001                      // frame sync direction - generated internally (master)
        #define I2S_TCR4_FSP_LOW         0x00000000                      // frame sync polarity - active low
        #define I2S_TCR4_FSP_HIGH        0x00000002                      // frame sync polarity - active high
        #define I2S_TCR4_ONDEM           0x00000004                      // on demand mode
        #define I2S_TCR4_FSE             0x00000008                      // frame sync early
        #define I2S_TCR4_MF_LSB          0x00000000                      // LSB first
        #define I2S_TCR4_MF_MSB          0x00000010                      // MSB first
        #define I2S_TCR4_SYWD_MASK       0x00001f00                      // synch width (bits - 1)
        #define I2S_TCR4_SYWD_SHIFT      8
        #define I2S_TCR4_FRSZ_1          0x00000000                      // frame size one word
        #define I2S_TCR4_FRSZ_2          0x00010000                      // frame size two word
        #define I2S_TCR4_FPACK_OFF       0x00000000                      // FIFO packing mode - FIFO packing disabled
        #define I2S_TCR4_FPACK_8         0x02000000                      // FIFO packing mode - 8-bit FIFO packing enabled
        #define I2S_TCR4_FPACK_16        0x03000000                      // FIFO packing mode - 16-bit FIFO packing enabled
        #define I2S_TCR4_FCONT           0x10000000                      // FIFO continue on error
    #define I2S0_TCR5          *(unsigned long *)(I2S0_BLOCK + 0x014)    // I2S0 transmit configuration 5 register
        #define I2S_TCR5_FBT_MASK        0x00001f00                      // first bit shifted mask
        #define I2S_TCR5_FBT_SHIFT       8
        #define I2S_TCR5_W0W_MASK        0x001f0000                      // word 0 width mask
        #define I2S_TCR5_W0W_SHIFT       16
        #define I2S_TCR5_WNW_MASK        0x1f000000                      // word N width
        #define I2S_TCR5_WNW_SHIFT       24
    #define I2S0_TDR0          *(volatile unsigned long *)(I2S0_BLOCK + 0x020) // I2S0 transmit data register (write-only - always reads 0)
    #define I2S0_TMR           *(unsigned long *)(I2S0_BLOCK + 0x060)    // I2S0 transmit mask register
        #define I2S_TMR_CH0_MASK         0x00000001                      // word 0 is masked (not copied to FIFO)
        #define I2S_TMR_CH1_MASK         0x00000002                      // word 1 is masked (not copied to FIFO)
    #define I2S0_RCSR          *(volatile unsigned long *)(I2S0_BLOCK + 0x080) // I2S0 receive control register
        #define I2S_RCSR_FWDE  0x00000002                                // FIFO warning DMA enable
        #define I2S_RCSR_FWIE  0x00000200                                // FIFO warning interrupt enable
        #define I2S_RCSR_FEIE  0x00000400                                // FIFO error interrupt enable
        #define I2S_RCSR_WSIE  0x00000800                                // word start interrupt enable
        #define I2S_RCSR_FWF   0x00020000                                // FIFO warning flag (read-only)
        #define I2S_RCSR_FEF   0x00040000                                // FIFO error flag (write '1' to clear)
        #define I2S_RCSR_SEF   0x00080000                                // sync error flag (write '1' to clear)
        #define I2S_RCSR_WSF   0x00100000                                // word start flag (write '1' to clear)
        #define I2S_RCSR_SR    0x01000000                                // software reset
        #define I2S_RCSR_FR    0x02000000                                // FIFO reset (reads always '0')
        #define I2S_RCSR_BCE   0x10000000                                // bit clock enable
        #define I2S_RCSR_DBGE  0x20000000                                // debug enable
        #define I2S_RCSR_STOPE 0x40000000                                // stop enable
        #define I2S_RCSR_RE    0x80000000                                // receiver enable
    #define I2S0_RCR2          *(unsigned long *)(I2S0_BLOCK + 0x088)    // I2S0 receive configuration 2 register
        #define I2S_RCR2_DIV_MASK        0x000000ff                      // bit clock divide mask ((DIV + 1) * 2)
        #define I2S_RCR2_BCD_EXT_SLAVE   0x00000000                      // bit clock direction - generated externally in slave mode
        #define I2S_RCR2_BCD_INT_MASTER  0x01000000                      // bit clock direction - generated internally in master mode
        #define I2S_RCR2_BCP_ACT_HIGH    0x00000000                      // bit clock polarity - active high [drive outputs on rising edge and sample inputs on falling edge]
        #define I2S_RCR2_BCP_ACT_LOW     0x02000000                      // bit clock polarity - active low [drive outputs on falling edge and sample inputs on rising edge]
        #define I2S_RCR2_MSEL_BUS        0x00000000                      // MCLK select - bus clock selected
        #define I2S_RCR2_MSEL1           0x04000000                      // MCLK select - master clock 1 option
        #define I2S_RCR2_MSEL2           0x08000000                      // MCLK select - master clock 2 option
        #define I2S_RCR2_MSEL3           0x0c000000                      // MCLK select - master clock 3 option
        #define I2S_RCR2_BCI             0x10000000                      // bit clock input
        #define I2S_RCR2_BCS             0x20000000                      // bit clock swap
        #define I2S_RCR2_SYNC_ASYN       0x00000000                      // asynchronous mode
        #define I2S_RCR2_SYNC_SYN_TX     0x40000000                      // synchronous with transmitter
        #define I2S_RCR2_SYNC_SYN_SAI_RX 0x80000000                      // synchronous with another SAI receiver
        #define I2S_RCR2_SYNC_SYN_SAI_TX 0xc0000000                      // synchronous with another SAI transmitter
    #define I2S0_RCR3          *(unsigned long *)(I2S0_BLOCK + 0x08c)    // I2S0 receive configuration 3 register
        #define I2S_RCR3_WDFL_FIRST      0x00000000                      // word flag configuration - first in frame
        #define I2S_RCR3_WDFL_SECOND     0x00000001                      // word flag configuration - second in frame
        #define I2S_RCR3_RCE             0x00010000                      // receive channel enable
    #define I2S0_RCR4          *(unsigned long *)(I2S0_BLOCK + 0x090)    // I2S0 receive configuration 4 register
        #define I2S_RCR4_FSD_EXT_SLAVE   0x00000000                      // frame sync direction - generated externally (slave)
        #define I2S_RCR4_FSD_INT_MASTER  0x00000001                      // frame sync direction - generated internally (master)
        #define I2S_RCR4_FSP_LOW         0x00000000                      // frame sync polarity - active low
        #define I2S_RCR4_FSP_HIGH        0x00000002                      // frame sync polarity - active high
        #define I2S_RCR4_ONDEM           0x00000004                      // on demand mode
        #define I2S_RCR4_FSE             0x00000008                      // frame sync early
        #define I2S_RCR4_MF_LSB          0x00000000                      // LSB first
        #define I2S_RCR4_MF_MSB          0x00000010                      // MSB first
        #define I2S_RCR4_SYWD_MASK       0x00001f00                      // synch width (bits - 1)
        #define I2S_RCR4_SYWD_SHIFT      8
        #define I2S_RCR4_FRSZ_1          0x00000000                      // frame size one word
        #define I2S_RCR4_FRSZ_2          0x00010000                      // frame size two word
        #define I2S_RCR4_FPACK_OFF       0x00000000                      // FIFO packing mode - FIFO packing disabled
        #define I2S_RCR4_FPACK_8         0x02000000                      // FIFO packing mode - 8-bit FIFO packing enabled
        #define I2S_RCR4_FPACK_16        0x03000000                      // FIFO packing mode - 16-bit FIFO packing enabled
        #define I2S_RCR4_FCONT           0x10000000                      // FIFO continue on error
    #define I2S0_RCR5          *(unsigned long *)(I2S0_BLOCK + 0x094)    // I2S0 receive configuration 5 register
        #define I2S_RCR5_FBT_MASK        0x00001f00                      // first bit shifted mask
        #define I2S_RCR5_FBT_SHIFT       8
        #define I2S_RCR5_W0W_MASK        0x001f0000                      // word 0 width mask
        #define I2S_RCR5_W0W_SHIFT       16
        #define I2S_RCR5_WNW_MASK        0x1f000000                      // word N width
        #define I2S_RCR5_WNW_SHIFT       24
    #define I2S0_RDR0          *(volatile unsigned long *)(I2S0_BLOCK + 0x0a0) // I2S0 receive data register (read-only)
    #define I2S0_RMR           *(unsigned long *)(I2S0_BLOCK + 0x0e0)    // I2S0 receive mask register
        #define I2S_RMR_CH0_MASK         0x00000001                      // word 0 is masked (not copied to FIFO)
        #define I2S_RMR_CH1_MASK         0x00000002                      // word 1 is masked (not copied to FIFO)
    #define I2S0_MCR           *(volatile unsigned long *)(I2S0_BLOCK + 0x100)    // I2S0 MCLK control register
        #define I2S_MCR_MICS_0  0x00000000                               // MCLK divider input clock 0 select
        #define I2S_MCR_MICS_1  0x01000000                               // MCLK divider input clock 1 select
        #define I2S_MCR_MICS_2  0x02000000                               // MCLK divider input clock 2 select
        #define I2S_MCR_MICS_3  0x03000000                               // MCLK divider input clock 3 select
        #define I2S_MCR_MOE_IN  0x00000000                               // MCLK is input (slave)
        #define I2S_MCR_MOE_OUT 0x40000000                               // MCLK output enable (master)
        #define I2S_MCR_DUF     0x80000000                               // divide update flag (read-only)

    typedef struct st_KINETIS_I2S_SAI                                    // I2S/SAI control struct
    {
    volatile unsigned long I2S_TCSR;
    unsigned long ulRes0;
    unsigned long I2S_TCR2;
    unsigned long I2S_TCR3;
    unsigned long I2S_TCR4;
    unsigned long I2S_TCR5;
    unsigned long ulRes1[2];
    volatile unsigned long I2S_TDR0;
    unsigned long ulRes2[15];
    unsigned long I2S_TMR;
    unsigned long ulRes3[7];
    volatile unsigned long I2S_RCSR;
    unsigned long ulRes4;
    unsigned long I2S_RCR2;
    unsigned long I2S_RCR3;
    unsigned long I2S_RCR4;
    unsigned long I2S_RCR5;
    unsigned long ulRes5[2];
    volatile unsigned long I2S_RDR0;
    unsigned long ulRes6[15];
    unsigned long I2S_RMR;
    unsigned long ulRes7[7];
    volatile unsigned long I2S_MCR;
    } _KINETIS_I2S_SAI;
#endif

// LPSPI
//
#define LPSPI1_VERID        *(volatile unsigned long *)(LPSPI1_BLOCK + 0x00) // LPSPI1 version ID register (read-only)
#define LPSPI1_PARAM        *(volatile unsigned long *)(LPSPI1_BLOCK + 0x04) // LPSPI1 parameter register (read-only)
#define LPSPI1_CR           *(volatile unsigned long *)(LPSPI1_BLOCK + 0x10) // LPSPI1 control register
    #define LPSPI_CR_MEN    0x00000001                                   // module enable
    #define LPSPI_CR_RST    0x00000002                                   // software reset - remains set until cleared by software
    #define LPSPI_CR_DOZEN  0x00000004                                   // doze mode enable
    #define LPSPI_CR_DBGEN  0x00000008                                   // debug enable
    #define LPSPI_CR_RTF    0x00000100                                   // receive FIFO reset - write '1' to reset - reads always '0'
    #define LPSPI_CR_RRF    0x00000200                                   // transmit FIFO reset - write '1' to reset - reads always '0'
#define LPSPI1_SR           *(volatile unsigned long *)(LPSPI1_BLOCK + 0x14) // LPSPI1 status register
    #define LPSPI_SR_TDF    0x00000001                                   // transmit data is requested (read-only)
    #define LPSPI_SR_RDF    0x00000002                                   // receive data is ready (read-only)
    #define LPSPI_SR_WCF    0x00000100                                   // word complete flag (write '1' to clear)
    #define LPSPI_SR_FCF    0x00000200                                   // frame complete flag (write '1' to clear)
    #define LPSPI_SR_TCF    0x00000400                                   // transmit complete flag (write '1' to clear)
    #define LPSPI_SR_TEF    0x00000800                                   // transmit error flag (write '1' to clear)
    #define LPSPI_SR_REF    0x00001000                                   // receive error flag (write '1' to clear)
    #define LPSPI_SR_DMF    0x00002000                                   // data match flag (write '1' to clear)
    #define LPSPI_SR_MBF    0x01000000                                   // module busy flag (read-only)
#define LPSPI1_IER          *(unsigned long *)(LPSPI1_BLOCK + 0x18)      // LPSPI1 interrupt enable register
    #define LPSPI_IER_TDIE  0x00000001                                   // transmit data interrupt enable
    #define LPSPI_IER_RDIE  0x00000002                                   // receive data interrupt enable
    #define LPSPI_IER_WCIE  0x00000100                                   // word complete interrupt enable
    #define LPSPI_IER_FCIE  0x00000200                                   // frame complete interrupt enable
    #define LPSPI_IER_TCIE  0x00000400                                   // transmit complete interrupt enable
    #define LPSPI_IER_TEIE  0x00000800                                   // transmit error interrupt enable
    #define LPSPI_IER_REIE  0x00001000                                   // receive error interrupt enable
    #define LPSPI_IER_DMIE  0x00002000                                   // data match interrupt enable
#define LPSPI1_DER          *(unsigned long *)(LPSPI1_BLOCK + 0x1c)      // LPSPI1 DMA enable register
#define LPSPI1_CFGR0        *(unsigned long *)(LPSPI1_BLOCK + 0x20)      // LPSPI1 configuration register 0
    #define LPSPI_CFGR0_HREN    0x00000001                               // host request enable
    #define LPSPI_CFGR0_HRPOL   0x00000002                               // host request polarity
    #define LPSPI_CFGR0_HRSEL   0x00000004                               // host request select
    #define LPSPI_CFGR0_CIRFIFO 0x00000100                               // circular FIFO enable
    #define LPSPI_CFGR0_RDMO    0x00000200                               // receive data match only
#define LPSPI1_CFGR1        *(unsigned long *)(LPSPI1_BLOCK + 0x24)      // LPSPI1 configuration register 1 (should only be written when LPSPI is disabled)
    #define LPSPI_CFGR1_MASTER  0x00000001                               // master mode
    #define LPSPI_CFGR1_SAMPLE  0x00000002                               // input sampled of delayed SCK (only valid in master mode)
    #define LPSPI_CFGR1_AUTOPCS 0x00000004                               // automatic PCS
    #define LPSPI_CFGR1_NOSTALL 0x00000008                               // no stall
    #define LPSPI_CFGR1_PCSPOL  0x00000f00                               // PCS is acive high
    #define LPSPI_CFGR1_MATCFG  0x00070000                               // match configuration
    #define LPSPI_CFGR1_PINCFG  0x03000000                               // pin configuration
    #define LPSPI_CFGR1_OUTCFG  0x04000000                               // output configuration
    #define LPSPI_CFGR1_PCSCFG  0x08000000                               // peripheral chip select configuration - PCS[3:2]
#define LPSPI1_DMR0         *(unsigned long *)(LPSPI1_BLOCK + 0x30)      // LPSPI1 data match register 0
#define LPSPI1_DMR1         *(unsigned long *)(LPSPI1_BLOCK + 0x34)      // LPSPI1 data match register 1
#define LPSPI1_CCR          *(unsigned long *)(LPSPI1_BLOCK + 0x40)      // LPSPI1 clock configuration register (only used in master mode and can't be changed when LPSPI is enabled)
    #define LPSPI_CCR_SCKDIV 0x000000ff                                  // SCK divider - divides the LPSPI functional clock by this value + 2
    #define LPSPI_CCR_SCKDIV_SHIFT    0                                  
    #define LPSPI_CCR_DBT    0x0000ff00                                  // PCS negation to next PCS assertion delay in LPSPI functional clock cycles
    #define LPSPI_CCR_DBT_SHIFT       8                                  
    #define LPSPI_CCR_PCSSCK 0x00ff0000                                  // PCS assertion to first SCK delay in LPSPI function clock cycles
    #define LPSPI_CCR_PCSSCK_SHIFT   16                                  
    #define LPSPI_CCR_SCKPCS 0xff000000                                  // last edge of SCK to PCS delay in LPSPI functional clock cycles
    #define LPSPI_CCR_SCKPCS_SHIFT   24
    #define LPSPI_MASTER_CLOCK_SETTING(chan, div, delay_pcs_sck, delay_sck_pcs, delay_between) LPSPI##chan##_CCR = (((div - 2) & LPSPI_CCR_SCKDIV) | (((delay_pcs_sck - 1) << LPSPI_CCR_PCSSCK_SHIFT) & LPSPI_CCR_PCSSCK) | (((delay_sck_pcs - 1) << LPSPI_CCR_SCKPCS_SHIFT) & LPSPI_CCR_SCKPCS) | (((delay_between - 2) << LPSPI_CCR_DBT_SHIFT) & LPSPI_CCR_DBT));
#define LPSPI1_FCR          *(unsigned long *)(LPSPI1_BLOCK + 0x58)      // LPSPI1 FIFO control register
#define LPSPI1_FSR          *(volatile unsigned long *)(LPSPI1_BLOCK + 0x5c) // LPSPI1 FIFO status register
    #define LPSPI1_FSR_TXCOUNT_MASK 0x0000001f                           // transmit FIFO count
    #define LPSPI1_FSR_RXCOUNT_MASK 0x001f0000                           // receive FIFO count
#define LPSPI1_TCR          *(volatile unsigned long *)(LPSPI1_BLOCK + 0x60)  // LPSPI1 transmit command register
    #define LPSPI_TCR_FRAMESZ_MASK  0x00000fff                           // frame size mask
    #define LPSPI_TCR_FRAMESZ_8     0x00000007                           // frame size 8 bits
    #define LPSPI_TCR_FRAMESZ_16    0x0000000f                           // frame size 16 bits
    #define LPSPI_TCR_FRAMESZ_24    0x00000017                           // frame size 24 bits
    #define LPSPI_TCR_FRAMESZ_32    0x0000001f                           // frame size 32 bits
    #define LPSPI_TCR_WIDTH    0x00030000                                // transfer mask
    #define LPSPI_TCR_TXMSK    0x00040000                                // transmit data mask
    #define LPSPI_TCR_RXMSK    0x00080000                                // receive data mask
    #define LPSPI_TCR_CONTC    0x00100000                                // continuing command
    #define LPSPI_TCR_CONT     0x00200000                                // continuous mode
    #define LPSPI_TCR_BYSW     0x00400000                                // byte swap
    #define LPSPI_TCR_MSBF     0x00000000                                // MSB first
    #define LPSPI_TCR_LSBF     0x00800000                                // LSB first
    #define LPSPI_TCR_PCS_0    0x00000000                                // peripheral chip select PCS0 used during transfer
    #define LPSPI_TCR_PCS_1    0x01000000                                // peripheral chip select PCS1 used during transfer
    #define LPSPI_TCR_PCS_2    0x02000000                                // peripheral chip select PCS2 used during transfer
    #define LPSPI_TCR_PCS_3    0x03000000                                // peripheral chip select PCS3 used during transfer
    #define LPSPI_TCR_PRESCALE_1   0x00000000                            // clock prescaler - divide by 1
    #define LPSPI_TCR_PRESCALE_2   0x08000000                            // clock prescaler - divide by 2
    #define LPSPI_TCR_PRESCALE_4   0x10000000                            // clock prescaler - divide by 4
    #define LPSPI_TCR_PRESCALE_8   0x18000000                            // clock prescaler - divide by 8
    #define LPSPI_TCR_PRESCALE_16  0x20000000                            // clock prescaler - divide by 16
    #define LPSPI_TCR_PRESCALE_32  0x28000000                            // clock prescaler - divide by 32
    #define LPSPI_TCR_PRESCALE_64  0x30000000                            // clock prescaler - divide by 64
    #define LPSPI_TCR_PRESCALE_128 0x38000000                            // clock prescaler - divide by 128
     #define LPSPI_TCR_PRESCALE_SHIFT 24
    #define LPSPI_TCR_CPHA     0x40000000                                // clock phase
    #define LPSPI_TCR_CPOL     0x80000000                                // clock polarity
#define LPSPI1_TDR          *(volatile unsigned long *)(LPSPI1_BLOCK + 0x64) // LPSPI1 transmit data register (write-only)
#define LPSPI1_RSR          *(volatile unsigned long *)(LPSPI1_BLOCK + 0x70) // LPSPI1 receive status register (read-only)
    #define LPSPI_RSR_SOF     0x00000001                                 // start of frame
    #define LPSPI_RSR_RXEMPTY 0x00000002                                 // receive FIFO is empty
#define LPSPI1_RDR          *(volatile unsigned long *)(LPSPI1_BLOCK + 0x74) // LPSPI1 receive data register (read-only)

#if (LPSPI_AVAILABLE > 1)
    #define LPSPI2_VERID        *(volatile unsigned long *)(LPSPI2_BLOCK + 0x00) // LPSPI2 version ID register (read-only)
    #define LPSPI2_PARAM        *(volatile unsigned long *)(LPSPI2_BLOCK + 0x04) // LPSPI2 parameter register (read-only)
    #define LPSPI2_CR           *(volatile unsigned long *)(LPSPI2_BLOCK + 0x10) // LPSPI2 control register
    #define LPSPI2_SR           *(volatile unsigned long *)(LPSPI2_BLOCK + 0x14) // LPSPI2 status register
    #define LPSPI2_IER          *(unsigned long *)(LPSPI2_BLOCK + 0x18)  // LPSPI2 interrupt enable register
    #define LPSPI2_DER          *(unsigned long *)(LPSPI2_BLOCK + 0x1c)  // LPSPI2 DMA enable register
    #define LPSPI2_CFGR0        *(unsigned long *)(LPSPI2_BLOCK + 0x20)  // LPSPI2 configuration register 0
    #define LPSPI2_CFGR1        *(unsigned long *)(LPSPI2_BLOCK + 0x24)  // LPSPI2 configuration register 1 (should only be written when LPSPI is disabled)
    #define LPSPI2_DMR0         *(unsigned long *)(LPSPI2_BLOCK + 0x30)  // LPSPI2 data match register 0
    #define LPSPI2_DMR1         *(unsigned long *)(LPSPI2_BLOCK + 0x34)  // LPSPI2 data match register 1
    #define LPSPI2_CCR          *(unsigned long *)(LPSPI2_BLOCK + 0x40)  // LPSPI2 clock configuration register
    #define LPSPI2_FCR          *(unsigned long *)(LPSPI2_BLOCK + 0x58)  // LPSPI2 FIFO control register
    #define LPSPI2_FSR          *(volatile unsigned long *)(LPSPI2_BLOCK + 0x5c) // LPSPI2 FIFO status register
    #define LPSPI2_TCR          *(volatile unsigned long *)(LPSPI2_BLOCK + 0x60) // LPSPI2 transmit command register
    #define LPSPI2_TDR          *(volatile unsigned long *)(LPSPI2_BLOCK + 0x64) // LPSPI2 transmit data register (write-only)
    #define LPSPI2_RSR          *(volatile unsigned long *)(LPSPI2_BLOCK + 0x70) // LPSPI2 receive status register (read only)
    #define LPSPI2_RDR          *(volatile unsigned long *)(LPSPI2_BLOCK + 0x74) // LPSPI2 receive data register (read only)
#endif

#if (LPSPI_AVAILABLE > 2)
    #define LPSPI3_VERID        *(volatile unsigned long *)(LPSPI3_BLOCK + 0x00) // LPSPI3 version ID register (read-only)
    #define LPSPI3_PARAM        *(volatile unsigned long *)(LPSPI3_BLOCK + 0x04) // LPSPI3 parameter register (read-only)
    #define LPSPI3_CR           *(volatile unsigned long *)(LPSPI3_BLOCK + 0x10) // LPSPI3 control register
    #define LPSPI3_SR           *(volatile unsigned long *)(LPSPI3_BLOCK + 0x14) // LPSPI3 status register
    #define LPSPI3_IER          *(unsigned long *)(LPSPI3_BLOCK + 0x18)  // LPSPI3 interrupt enable register
    #define LPSPI3_DER          *(unsigned long *)(LPSPI3_BLOCK + 0x1c)  // LPSPI3 DMA enable register
    #define LPSPI3_CFGR0        *(unsigned long *)(LPSPI3_BLOCK + 0x20)  // LPSPI3 configuration register 0
    #define LPSPI3_CFGR1        *(unsigned long *)(LPSPI3_BLOCK + 0x24)  // LPSPI3 configuration register 1 (should only be written when LPSPI is disabled)
    #define LPSPI3_DMR0         *(unsigned long *)(LPSPI3_BLOCK + 0x30)  // LPSPI3 data match register 0
    #define LPSPI3_DMR1         *(unsigned long *)(LPSPI3_BLOCK + 0x34)  // LPSPI3 data match register 1
    #define LPSPI3_CCR          *(unsigned long *)(LPSPI3_BLOCK + 0x40)  // LPSPI3 clock configuration register
    #define LPSPI3_FCR          *(unsigned long *)(LPSPI3_BLOCK + 0x58)  // LPSPI3 FIFO control register
    #define LPSPI3_FSR          *(volatile unsigned long *)(LPSPI3_BLOCK + 0x5c) // LPSPI3 FIFO status register
    #define LPSPI3_TCR          *(volatile unsigned long *)(LPSPI3_BLOCK + 0x60) // LPSPI3 transmit command register
    #define LPSPI3_TDR          *(volatile unsigned long *)(LPSPI3_BLOCK + 0x64) // LPSPI3 transmit data register (write-only)
    #define LPSPI3_RSR          *(volatile unsigned long *)(LPSPI3_BLOCK + 0x70) // LPSPI3 receive status register (read-only)
    #define LPSPI3_RDR          *(volatile unsigned long *)(LPSPI3_BLOCK + 0x74) // LPSPI3 receive data register (read-only)
#endif

#if (LPSPI_AVAILABLE > 3)
    #define LPSPI4_VERID        *(volatile unsigned long *)(LPSPI4_BLOCK + 0x00) // LPSPI4 version ID register (read-only)
    #define LPSPI4_PARAM        *(volatile unsigned long *)(LPSPI4_BLOCK + 0x04) // LPSPI4 parameter register (read-only)
    #define LPSPI4_CR           *(volatile unsigned long *)(LPSPI4_BLOCK + 0x10) // LPSPI4 control register
    #define LPSPI4_SR           *(volatile unsigned long *)(LPSPI4_BLOCK + 0x14) // LPSPI4 status register
    #define LPSPI4_IER          *(unsigned long *)(LPSPI4_BLOCK + 0x18)  // LPSPI4 interrupt enable register
    #define LPSPI4_DER          *(unsigned long *)(LPSPI4_BLOCK + 0x1c)  // LPSPI4 DMA enable register
    #define LPSPI4_CFGR0        *(unsigned long *)(LPSPI4_BLOCK + 0x20)  // LPSPI4 configuration register 0
    #define LPSPI4_CFGR1        *(unsigned long *)(LPSPI4_BLOCK + 0x24)  // LPSPI4 configuration register 1 (should only be written when LPSPI is disabled)
    #define LPSPI4_DMR0         *(unsigned long *)(LPSPI4_BLOCK + 0x30)  // LPSPI4 data match register 0
    #define LPSPI4_DMR1         *(unsigned long *)(LPSPI4_BLOCK + 0x34)  // LPSPI4 data match register 1
    #define LPSPI4_CCR          *(unsigned long *)(LPSPI4_BLOCK + 0x40)  // LPSPI4 clock configuration register
    #define LPSPI4_FCR          *(unsigned long *)(LPSPI4_BLOCK + 0x58)  // LPSPI4 FIFO control register
    #define LPSPI4_FSR          *(volatile unsigned long *)(LPSPI4_BLOCK + 0x5c) // LPSPI4 FIFO status register
    #define LPSPI4_TCR          *(volatile unsigned long *)(LPSPI4_BLOCK + 0x60) // LPSPI4 transmit command register
    #define LPSPI4_TDR          *(volatile unsigned long *)(LPSPI4_BLOCK + 0x64) // LPSPI4 transmit data register (write-only)
    #define LPSPI4_RSR          *(volatile unsigned long *)(LPSPI4_BLOCK + 0x70) // LPSPI4 receive status register (read-only)
    #define LPSPI4_RDR          *(volatile unsigned long *)(LPSPI4_BLOCK + 0x74) // LPSPI4 receive data register (read-only)
#endif

typedef struct st_KINETIS_LPSPI
{
    volatile unsigned long LPSPI_VERID;
    volatile unsigned long LPSPI_PARAM;
    unsigned long ulRes0[2];
    volatile unsigned long LPSPI_CR;
    volatile unsigned long LPSPI_SR;
    unsigned long LPSPI_IER;
    unsigned long LPSPI_DER;
    unsigned long LPSPI_CFGR0;
    unsigned long LPSPI_CFGR1;
    unsigned long ulRes1[2];
    unsigned long LPSPI_DMR0;
    unsigned long LPSPI_DMR1;
    unsigned long ulRes2[2];
    unsigned long LPSPI_CCR;
    unsigned long ulRes3[5];
    unsigned long LPSPI_FCR;
    volatile unsigned long LPSPI_FSR;
    volatile unsigned long LPSPI_TCR;
    volatile unsigned long LPSPI_TDR;
    unsigned long ulRes4[2];
    volatile unsigned long LPSPI_RSR;
    volatile unsigned long LPSPI_RDR;
} _KINETIS_LPSPI;
#define _iMX_LPSPI  _KINETIS_LPSPI


#if defined LTC_AVAILABLE                                                // {92}
    // LTC
    //
    #define LTC0_MD             *(volatile unsigned long *)(LTC_BLOCK + 0x000) // LTC mode (non-PKHA/non-RNG use)
      #define LTC_MD_ENC_DECRYPT       0x00000000                        // decrypt
      #define LTC_MD_ENC_ENCRYPT       0x00000001                        // encrypt
      #define LTC_MD_ICV_TEST          0x00000002                        // ICV checking/test AES fault detection
      #define LTC_MD_AS_UPDATE         0x00000000                        // algorithm update
      #define LTC_MD_AS_INITIALISE     0x00000004                        // algorithm initialise
      #define LTC_MD_AS_FINALISE       0x00000008                        // algorithm finalise
      #define LTC_MD_AS_INIT_FINAL     0x0000000c                        // algorithm initialise/finalise
      #define LTC_MD_AAI_CTR           0x00000000                        // additional algorithm information CTR (mod 2^128)
      #define LTC_MD_AAI_CBC           0x00000100                        // additional algorithm information CBC
      #define LTC_MD_AAI_ECB           0x00000200                        // additional algorithm information ECB
      #define LTC_MD_AAI_CMAC          0x00000600                        // additional algorithm information CMAC
      #define LTC_MD_AAI_XCBC_MAC      0x00000700                        // additional algorithm information XCBC-MAC
      #define LTC_MD_AAI_CCM           0x00000800                        // additional algorithm information CCM
      #define LTC_MD_AAI_GCM           0x00000900                        // additional algorithm information GCM
      #define LTC_MD_AAI_DK            0x00001000                        // decrypt key
      #define LTC_MD_ALG_AES           0x00100000                        // algorithm AES
      #define LTC_MD_ALG_DES           0x00200000                        // algorithm DES
      #define LTC_MD_ALG_3DES          0x00210000                        // algorithm 3DES
    #if defined LTC_HAS_SHA
      #define LTC_MD_ALG_SHA1          0x00410000                        // algorithm MDHA SHA-1
      #define LTC_MD_ALG_SHA224        0x00420000                        // algorithm MDHA SHA-224
      #define LTC_MD_ALG_SHA256        0x00430000                        // algorithm MDHA SHA-256
      #define LTC_MD_ALG_SHA_TYPE      0x00400000                        // SHA modes share this bit - it can be used to recognise a SHA mode type
    #endif
    #define LTC0_MDPK           *(unsigned long *)(LTC_BLOCK + 0x000)    // LTC mode (public key)
    #define LTC0_KS             *(unsigned long *)(LTC_BLOCK + 0x008)    // LTC key size (size of AES key - in bytes - loaded into the key register)
    #define LTC0_DS             *(unsigned long *)(LTC_BLOCK + 0x010)    // LTC data size (the amount of AES data that will be loaded into the input data register)
    #define LTC0_ICVS           *(unsigned long *)(LTC_BLOCK + 0x018)    // LTC ICV size
    #define LTC0_COM            *(volatile unsigned long *)(LTC_BLOCK + 0x030) // LTC command (write-only)
      #define LTC_COM_ALL        0x00000001                              // reset all hardware accelerator engines and internal registers
      #define LTC_COM_AES        0x00000002                              // reset AES accelerator
      #define LTC_COM_DES        0x00000004                              // reset DES accelerator
      #define LTC_COM_PK         0x00000040                              // reset public key hardware accelerator
      #define LTC_COM_MD         0x00000080                              // reset message digest hardware accelerator
    #define LTC0_CTL            *(volatile unsigned long *)(LTC_BLOCK + 0x034) // LTC control
      #define LTC_CTL_IM         0x00000001                              // interrupt masked (only cleared by hard reset)
      #define LTC_CTL_PDE        0x00000010                              // PKHA register DMA enable
      #define LTC_CTL_IFE        0x00000100                              // input FIFO DMA enable
      #define LTC_CTL_IFR_1      0x00000000                              // input FIFO request size 1 entrie
      #define LTC_CTL_IFR_4      0x00000200                              // input FIFO request size 4 entries
      #define LTC_CTL_OFE        0x00001000                              // output FIFO DMA enable
      #define LTC_CTL_OFR_1      0x00000000                              // output FIFO request size 1 entrie
      #define LTC_CTL_OFR_4      0x00002000                              // output FIFO request size 4 entries
      #define LTC_CTL_IFS        0x00010000                              // input FIFO byte swap data
      #define LTC_CTL_OFS        0x00020000                              // output FIFO byte swap data
      #define LTC_CTL_KIS        0x00100000                              // key register input byte swap data
      #define LTC_CTL_KOS        0x00200000                              // key register output byte swap data
      #define LTC_CTL_CIS        0x00400000                              // context register input byte swap data
      #define LTC_CTL_COS        0x00800000                              // context register output byte swap data
      #define LTC_CTL_KAL        0x80000000                              // key register access lock (only cleared by hard reset)
    #define LTC0_CW             *(volatile unsigned long *)(LTC_BLOCK + 0x040) // LTC clear written (write-only)
      #define LTC_CW_CM          0x00000001                              // clear mode register
      #define LTC_CW_CDS         0x00000004                              // clear data size register (and also AAD size)
      #define LTC_CW_CICV        0x00000080                              // clear ICV size register
      #define LTC_CW_CCR         0x00000020                              // clear context register
      #define LTC_CW_CKR         0x00000040                              // clear key register
      #define LTC_CW_CPKA        0x00001000                              // clear PKHA A size register
      #define LTC_CW_CPKB        0x00002000                              // clear PKHA B size register
      #define LTC_CW_CPKN        0x00004000                              // clear PKHA N size register
      #define LTC_CW_CPKE        0x00008000                              // clear PKHA E size register
      #define LTC_CW_COF         0x40000000                              // clear output FIFO
      #define LTC_CW_CIF         0x80000000                              // clear input FIFO
    #define LTC0_STA            *(volatile unsigned long *)(LTC_BLOCK + 0x048) // LTC status (read-only/write '1' to clear)
      #define LTC_STA_AB         0x00000002                              // AESA busy
      #define LTC_STA_DB         0x00000004                              // DESA busy
      #define LTC_STA_PB         0x00000040                              // PKHA busy
      #define LTC_STA_DI         0x00010000                              // done interrupt asserted (write '1' to clear)
      #define LTC_STA_EI         0x00100000                              // error interrupt
      #define LTC_STA_PKP        0x10000000                              // public key is prime
      #define LTC_STA_PKO        0x20000000                              // public key operation is one
      #define LTC_STA_PKZ        0x40000000                              // public key operation is zero
    #define LTC0_ESTA           *(volatile unsigned long *)(LTC_BLOCK + 0x04c) // LTC error status (read-only)
    #define LTC0_AADSZ          *(unsigned long *)(LTC_BLOCK + 0x058)    // LTC AAD size
    #define LTC0_IVS            *(unsigned long *)(LTC_BLOCK + 0x060)    // LTC IV size
    #define LTC0_DPAMS          *(volatile unsigned long *)(LTC_BLOCK + 0x068) // LTC DPA mask seed (write-only)
    #define LTC0_PKASZ          *(unsigned long *)(LTC_BLOCK + 0x080)    // LTC PKHA A size
    #define LTC0_PKBSZ          *(unsigned long *)(LTC_BLOCK + 0x088)    // LTC PKHA B size
    #define LTC0_PKNSZ          *(unsigned long *)(LTC_BLOCK + 0x090)    // LTC PKHA N size
    #define LTC0_PKESZ          *(unsigned long *)(LTC_BLOCK + 0x098)    // LTC PKHA E size
    #define LTC0_CTX_0          *(unsigned long *)(LTC_BLOCK + 0x100)    // LTC context 0
    #define LTC0_CTX_1          *(unsigned long *)(LTC_BLOCK + 0x104)    // LTC context 1
    #define LTC0_CTX_2          *(unsigned long *)(LTC_BLOCK + 0x108)    // LTC context 2
    #define LTC0_CTX_3          *(unsigned long *)(LTC_BLOCK + 0x10c)    // LTC context 3
    #define LTC0_CTX_4          *(unsigned long *)(LTC_BLOCK + 0x110)    // LTC context 4
    #define LTC0_CTX_5          *(unsigned long *)(LTC_BLOCK + 0x114)    // LTC context 5
    #define LTC0_CTX_6          *(unsigned long *)(LTC_BLOCK + 0x118)    // LTC context 6
    #define LTC0_CTX_7          *(unsigned long *)(LTC_BLOCK + 0x11c)    // LTC context 7
    #define LTC0_CTX_8          *(unsigned long *)(LTC_BLOCK + 0x120)    // LTC context 8
    #define LTC0_CTX_9          *(unsigned long *)(LTC_BLOCK + 0x124)    // LTC context 9
    #define LTC0_CTX_10         *(unsigned long *)(LTC_BLOCK + 0x128)    // LTC context 10
    #define LTC0_CTX_11         *(unsigned long *)(LTC_BLOCK + 0x12c)    // LTC context 11
    #define LTC0_CTX_12         *(unsigned long *)(LTC_BLOCK + 0x130)    // LTC context 12
    #define LTC0_CTX_13         *(unsigned long *)(LTC_BLOCK + 0x134)    // LTC context 13
    #define LTC0_CTX_14         *(unsigned long *)(LTC_BLOCK + 0x138)    // LTC context 14
    #define LTC0_CTX_15         *(unsigned long *)(LTC_BLOCK + 0x13c)    // LTC context 15
    #define LTC0_KEY_0          *(unsigned long *)(LTC_BLOCK + 0x200)    // LTC key 0
    #define LTC0_KEY_1          *(unsigned long *)(LTC_BLOCK + 0x204)    // LTC key 1
    #define LTC0_KEY_2          *(unsigned long *)(LTC_BLOCK + 0x208)    // LTC key 2
    #define LTC0_KEY_3          *(unsigned long *)(LTC_BLOCK + 0x20c)    // LTC key 3
    #define LTC0_KEY_4          *(unsigned long *)(LTC_BLOCK + 0x210)    // LTC key 4
    #define LTC0_KEY_5          *(unsigned long *)(LTC_BLOCK + 0x214)    // LTC key 5
    #define LTC0_KEY_6          *(unsigned long *)(LTC_BLOCK + 0x218)    // LTC key 6
    #define LTC0_KEY_7          *(unsigned long *)(LTC_BLOCK + 0x21c)    // LTC key 7
    #define LTC0_FIFOSTA        *(volatile unsigned long *)(LTC_BLOCK + 0x7c0) // LTC FIFO status (read-only)
      #define LTC_FIFOSTA_IFL_MASK 0x0000007f                            // input FIFO level mask
      #define LTC_FIFOSTA_IFF      0x00008000                            // input FIFO full
      #define LTC_FIFOSTA_OFL_MASK 0x007f0000                            // output FIFO level mask
      #define LTC_FIFOSTA_OFF      0x80000000                            // output FIFO full
    #define LTC0_IFIFO          *(volatile unsigned long *)(LTC_BLOCK + 0x7e0) // LTC input data FIFO (read-only)
    #define LTC0_OFIFO          *(volatile unsigned long *)(LTC_BLOCK + 0x7f0) // LTC output data FIFO (write-only)
#endif


#if defined KINETIS_KE
// Keyboard Interrupt
//
  #if (defined KINETIS_KE04 && !(SIZE_OF_FLASH <= (8 * 1024))) || defined KINETIS_KE06 || defined KINETIS_KEA64 || defined KINETIS_KEA128
    #define KBI0_PE             *(unsigned long *)(KBI0_BLOCK + 0x0)     // KBI0 Pin Enable Register (enable pin as KBI interrupt)
    #define KBI0_ES             *(unsigned long *)(KBI0_BLOCK + 0x4)     // KBI0 Edge Select Register ('1' is rising edge / '0' is  falling edge)
    #define KBI0_SC             *(volatile unsigned long *)(KBI0_BLOCK + 0x8) // KBI0 Status and Control Register
      #define KBI_SC_KBMOD      0x00000001                               // KBI detection mode (detects levels as well as edges)
      #define KBI_SC_KBIE       0x00000002                               // KBI interrupt enable
      #define KBI_SC_KBACK      0x00000004                               // KBI acknowledge (write-only)
      #define KBI_SC_KBF        0x00000008                               // KBI interrupt flag (read-only)
      #define KBI_SC_KBSPEN     0x00000010                               // real KBI_SP register enable
      #define KBI_SC_RSTKBSP    0x00000020                               // write '1' to clear KBIx_SP (always reads '0')
    #define KBI0_SP             *(volatile unsigned long *)(KBI0_BLOCK + 0xc) // KBI0 Source Pin Register (read-only) - sources are latched '1' and cleared only by setting KBI_SC_RSTKBSP or reset

    #define KBI1_PE             *(unsigned long *)(KBI1_BLOCK + 0x0)     // KBI1 Pin Enable Register
    #define KBI1_ES             *(unsigned long *)(KBI1_BLOCK + 0x4)     // KBI1 Edge Select Register
    #define KBI1_SC             *(volatile unsigned long *)(KBI1_BLOCK + 0x8) // KBI1 Status and Control Register
    #define KBI1_SP             *(volatile unsigned long *)(KBI1_BLOCK + 0xc) // KBI1 Source Pin Register (read-only)

    typedef struct st_KINETIS_KBI                                        // KBI control struct
    {
        unsigned long KBI_PE;
        unsigned long KBI_ES;
        volatile unsigned long KBI_SC;
        volatile unsigned long KBI_SP;
    } _KINETIS_KBI;
  #else                                                                  // KE02/KE04 with 8k Flash
    #define KBI0_SC             *(volatile unsigned char *)(KBI0_BLOCK + 0x0) // KBI0 Status and Control Register
      #define KBI_SC_KBMOD      0x00000001                               // KBI detection mode (detects levels as well as edges)
      #define KBI_SC_KBIE       0x00000002                               // KBI interrupt enable
      #define KBI_SC_KBACK      0x00000004                               // KBI acknowledge (write-only)
      #define KBI_SC_KBF        0x00000008                               // KBI interrupt flag (read-only)
    #define KBI0_PE             *(unsigned char *)(KBI0_BLOCK + 0x1)     // KBI0 Pin Enable Register (enable pin as KBI interrupt)
    #define KBI0_ES             *(unsigned char *)(KBI0_BLOCK + 0x2)     // KBI0 Edge Select Register ('1' is rising edge / '0' is  falling edge)
    #if KBIS_AVAILABLE > 1
      #define KBI1_SC           *(volatile unsigned char *)(KBI1_BLOCK + 0x0) // KBI1 Status and Control Register
      #define KBI1_PE           *(unsigned char *)(KBI1_BLOCK + 0x1)     // KBI1 Pin Enable Register
      #define KBI1_ES           *(unsigned char *)(KBI1_BLOCK + 0x2)     // KBI1 Edge Select Register
    #endif

    typedef struct st_KINETIS_KBI                                        // KBI control struct
    {
        volatile unsigned char KBI_SC;
        unsigned char KBI_PE;
        unsigned char KBI_ES;
    } _KINETIS_KBI;
  #endif
#endif

// Power management controller
//
#if defined KINETIS_KL28
    #define PMC_OFFSET 0x08
#else
    #define PMC_OFFSET 0x00
#endif
#if defined KINETIS_KL28
    #define PMC_VERID           *(volatile unsigned long *)(PMC_BLOCK + 0x00) // version ID register (read-only)
    #define PMC_PARAM           *(volatile unsigned long *)(PMC_BLOCK + 0x04) // parameter register (read-only)
    #define PMC_LVDSC1          *(volatile unsigned long *)(PMC_BLOCK + 0x08) // low voltage detect status and control 1 register
        #define PMC_LVDSC1_LVDV   0x01                                        // high trip point select
        #define PMC_LVDSC1_LVDRE  0x10                                        // low voltage detect reset enable
        #define PMC_LVDSC1_LVDIE  0x20                                        // low voltage detect interrupt enable
        #define PMC_LVDSC1_LVDACK 0x40                                        // write '1' to clear LVDF
        #define PMC_LVDSC1_LVDF   0x80                                        // low voltage detect flag (read-only)
    #define PMC_LVDSC2          *(volatile unsigned long *)(PMC_BLOCK + 0x0c) // low voltage detect status and control 2 register
        #define PMC_LVDSC2_LVWV_LOW  0x00                                     // low voltage warning voltage select - low
        #define PMC_LVDSC2_LVWV_MID1 0x01                                     // low voltage warning voltage select - mid 1
        #define PMC_LVDSC2_LVWV_MID2 0x02                                     // low voltage warning voltage select - mid 2
        #define PMC_LVDSC2_LVWV_HIGH 0x03                                     // low voltage warning voltage select - high
        #define PMC_LVDSC2_LVWIE     0x20                                     // low voltage warning interrupt enable
        #define PMC_LVDSC2_LVWACK    0x40                                     // write '1' to clear LVWF
        #define PMC_LVDSC1_LVWF      0x80                                     // low voltage warning flag (read-only)
    #define PMC_REGSC           *(volatile unsigned char *)(PMC_BLOCK + 0x10) // regulator status and control 1 register
        #define PMC_REGSC_BGBE    0x01                                        // bandgap buffer enable
        #define PMC_REGSC_REGONS  0x04                                        // regulator in run regulation status
        #define PMC_REGSC_ACKISO  0x08                                        // acknowledge isolation
        #define PMC_REGSC_BGEN    0x10                                        // bandgap enable in VLPx operation
        #define PMC_REGSC_VLPO    0x40                                        // VLPx option
    #define PMC_HVDSC1          *(volatile unsigned char *)(PMC_BLOCK + 0x34) // high voltage detect status and control 1 register
#else
    #define PMC_LVDSC1          *(volatile unsigned char *)(PMC_BLOCK + 0x0) // low voltage detect status and control 1 register
      #define PMC_LVDSC1_LVDV   0x01                                         // high trip point select
      #define PMC_LVDSC1_LVDRE  0x10                                         // low voltage detect reset enable (default i senabled)
      #define PMC_LVDSC1_LVDIE  0x20                                         // low voltage detect interrupt enable
      #define PMC_LVDSC1_LVDACK 0x40                                         // write '1' to clear LVDF (reads always '0')
      #define PMC_LVDSC1_LVDF   0x80                                         // low voltage detect flag (read-only)
    #define PMC_LVDSC2          *(volatile unsigned char *)(PMC_BLOCK + 0x1) // low voltage detect status and control 2 register
      #define PMC_LVDSC2_LVWV_LOW  0x00                                      // low voltage warning voltage select - low
      #define PMC_LVDSC2_LVWV_MID1 0x01                                      // low voltage warning voltage select - mid 1
      #define PMC_LVDSC2_LVWV_MID2 0x02                                      // low voltage warning voltage select - mid 2
      #define PMC_LVDSC2_LVWV_HIGH 0x03                                      // low voltage warning voltage select - high
      #define PMC_LVDSC2_LVWIE     0x20                                      // low voltage warning interrupt enable
      #define PMC_LVDSC2_LVWACK    0x40                                      // write '1' to clear LVWF
      #define PMC_LVDSC1_LVWF      0x80                                      // low voltage warning flag (read-only)
    #define PMC_REGSC           *(volatile unsigned char *)(PMC_BLOCK + 0x2) // regulator status and control 1 register
      #define PMC_REGSC_BGBE    0x01                                         // bandgap buffer enable
      #define PMC_REGSC_REGONS  0x04                                         // regulator in run regulation status
      #define PMC_REGSC_ACKISO  0x08                                         // acknowledge isolation
      #define PMC_REGSC_BGEN    0x10                                         // bandgap enable in VLPx operation
#endif

#if defined LLWU_AVAILABLE
// Low-Leakage Wakeup Unit
//
#define LLWU_PE1            *(unsigned char *)(LLWU_BLOCK + 0x0)         // LLWU Pin Enable 1 Register
  #define LLWU_PE_WUPE_MASK    0x03                                      // 4 pin settings per register
  #define LLWU_PE_WUPE_SHIFT   2
  #define LLWU_PE_WUPE_OFF     0x00                                      // external input pin disabled as wakeup pin
  #define LLWU_PE_WUPE_RISING  0x01                                      // external input pin enabled with rising edge detection
  #define LLWU_PE_WUPE_FALLING 0x02                                      // external input pin enabled with falling edge detection
  #define LLWU_PE_WUPE_CHANGE  0x03                                      // external input pin enabled with change detection
#define LLWU_PE2            *(unsigned char *)(LLWU_BLOCK + 0x1)         // LLWU Pin Enable 2 Register
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_ME         *(unsigned char *)(LLWU_BLOCK + 0x2)         // LLWU Module Enable Register
#else
    #define LLWU_PE3        *(unsigned char *)(LLWU_BLOCK + 0x2)         // LLWU Pin Enable 3 Register
    #define LLWU_PE4        *(unsigned char *)(LLWU_BLOCK + 0x3)         // LLWU Pin Enable 4 Register
    #define LLWU_ME         *(unsigned char *)(LLWU_BLOCK + 0x4)         // LLWU Module Enable Register
#endif
  #define LLWU_ME_WUME0     0x01                                         // internal module 0 flag used as wakeup source
  #define LLWU_ME_WUME1     0x02                                         // internal module 1 flag used as wakeup source
  #define LLWU_ME_WUME2     0x04                                         // internal module 2 flag used as wakeup source
  #define LLWU_ME_WUME3     0x08                                         // internal module 3 flag used as wakeup source
  #define LLWU_ME_WUME4     0x10                                         // internal module 4 flag used as wakeup source
  #define LLWU_ME_WUME5     0x20                                         // internal module 5 flag used as wakeup source
  #define LLWU_ME_WUME6     0x40                                         // internal module 6 flag used as wakeup source
  #define LLWU_ME_WUME7     0x80                                         // internal module 7 flag used as wakeup source
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_FLAG_ADDRESS (volatile unsigned char *)(LLWU_BLOCK + 0x3)
    #define LLWU_F1         *(volatile unsigned char *)(LLWU_BLOCK + 0x3)// LLWU Flag 1 Register
#else
    #define LLWU_FLAG_ADDRESS (volatile unsigned char *)(LLWU_BLOCK + 0x5)
    #define LLWU_F1         *(volatile unsigned char *)(LLWU_BLOCK + 0x5)// LLWU Flag 1 Register
#endif
  #define LLWU_F_WUF0       0x01                                         // wakeup flag indicating that this pin was a source of exiting a low-leakage power mode
  #define LLWU_F_WUF1       0x02                                         // write '1' to clear bits
  #define LLWU_F_WUF2       0x04
  #define LLWU_F_WUF3       0x08
  #define LLWU_F_WUF4       0x10
  #define LLWU_F_WUF5       0x20
  #define LLWU_F_WUF6       0x40
  #define LLWU_F_WUF7       0x80
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_F3         *(volatile unsigned char *)(LLWU_BLOCK + 0x4)// LLWU Flag 3 Register
    #define LLWU_FILT1      *(volatile unsigned char *)(LLWU_BLOCK + 0x5)// LLWU Pin Filter 1 Register
#else
    #define LLWU_F2         *(volatile unsigned char *)(LLWU_BLOCK + 0x6)// LLWU Flag 2 Register
    #define LLWU_F3         *(volatile unsigned char *)(LLWU_BLOCK + 0x7)// LLWU Flag 3 Register
    #define LLWU_FILT1      *(volatile unsigned char *)(LLWU_BLOCK + 0x8)// LLWU Pin Filter 1 Register
#endif
  #define LLWU_FILT_FILTSEL_0     0x00                                   // select filter on LLWU_P0
  #define LLWU_FILT_FILTSEL_1     0x01                                   // select filter on LLWU_P1
  #define LLWU_FILT_FILTSEL_2     0x02                                   // select filter on LLWU_P2
  #define LLWU_FILT_FILTSEL_3     0x03                                   // select filter on LLWU_P3
  #define LLWU_FILT_FILTSEL_4     0x04                                   // select filter on LLWU_P4
  #define LLWU_FILT_FILTSEL_5     0x05                                   // select filter on LLWU_P5
  #define LLWU_FILT_FILTSEL_6     0x06                                   // select filter on LLWU_P6
  #define LLWU_FILT_FILTSEL_7     0x07                                   // select filter on LLWU_P7
  #define LLWU_FILT_FILTSEL_8     0x08                                   // select filter on LLWU_P8
  #define LLWU_FILT_FILTSEL_9     0x09                                   // select filter on LLWU_P9
  #define LLWU_FILT_FILTSEL_10    0x0a                                   // select filter on LLWU_P10
  #define LLWU_FILT_FILTSEL_11    0x0b                                   // select filter on LLWU_P11
  #define LLWU_FILT_FILTSEL_12    0x0c                                   // select filter on LLWU_P12
  #define LLWU_FILT_FILTSEL_13    0x0d                                   // select filter on LLWU_P13
  #define LLWU_FILT_FILTSEL_14    0x0e                                   // select filter on LLWU_P14
  #define LLWU_FILT_FILTSEL_15    0x0f                                   // select filter on LLWU_P15
  #define LLWU_FILT_FILTE_OFF     0x00                                   // filter disabled (3 LPO clock cyle filtering - 3ms - with 2 additional LPO cycle clock delay = 5ms reaction time)
  #define LLWU_FILT_FILTE_RISING  0x20                                   // rising edge      
  #define LLWU_FILT_FILTE_FALLING 0x40                                   // fallin edge      
  #define LLWU_FILT_FILTE_CHANGE  0x60                                   // rising and falling edge     
  #define LLWU_FILT_FILTF         0x80                                   // filter detect flag (this was a source of low-leakage power mode exit (write '1' to clear))
#if defined KINETIS_KL03 || defined KINETIS_KL05
    #define LLWU_FILT2      *(volatile unsigned char *)(LLWU_BLOCK + 0x6)// LLWU Pin Filter 2 Register
#else
    #define LLWU_FILT2      *(volatile unsigned char *)(LLWU_BLOCK + 0x9)// LLWU Pin Filter 2 Register
    #define LLWU_RST        *(unsigned char *)(LLWU_BLOCK + 0xa)         // LLWUReset Enable Register
      #define LLWU_RST_RSTFILT    0x01                                   // digital filtere on reset pin
      #define LLWU_RST_LLRSTE     0x02                                   // low leakage mode reset enable
#endif

#define LLWU_P0    0
#define LLWU_P1    1
#define LLWU_P2    2
#define LLWU_P3    3
#define LLWU_P4    4
#define LLWU_P5    5
#define LLWU_P6    6
#define LLWU_P7    7
#define LLWU_P8    8
#define LLWU_P9    9
#define LLWU_P10   10
#define LLWU_P11   11
#define LLWU_P12   12
#define LLWU_P13   13
#define LLWU_P14   14
#define LLWU_P15   15
#define NO_WAKEUP 0xff
#endif

#if defined KINETIS_KE
// IRQ
//
#define IRQ_SC              *(volatile unsigned char *)(IRQ_BLOCK + 0x0) // Interrupt Pin Request Status and Control Register
  #define IRQ_SC_IRQMOD     0x01                                         // IRQ detection mode ('1' level sensitive as well as edge sensitive)
  #define IRQ_SC_IRQIE      0x02                                         // IRQ interrupt enable
  #define IRQ_SC_IRQACK     0x04                                         // IRQ interrupt acknowledge (write '1' to clear IRQF)
  #define IRQ_SC_IRQF       0x08                                         // IRQ flag (read-only)
  #define IRQ_SC_IRQPE      0x10                                         // IRQ pin function enable
  #define IRQ_SC_IRQEDG     0x20                                         // IRQ edge select ('0' for falling edge/low sensitive, '1' for rising edge/high sensitive)
  #define IRQ_SC_IRQPDD     0x40                                         // IRQ pull-up disable
#endif

// CRC
//
#define CRC_CRC             *(volatile unsigned long *)(CRC_BLOCK + 0x0) // CRC Data Register
#define CRC_CRC_LL_SHORT_WORD_ACCESS *(volatile unsigned short *)(CRC_BLOCK + 0x0) // CRC Data Register - short word access
#define CRC_CRC_LL          *(volatile unsigned char *)(CRC_BLOCK + 0x0) // CRC Data Register - byte accesses
#define CRC_CRC_LU          *(volatile unsigned char *)(CRC_BLOCK + 0x1) // CRC Data Register - byte accesses
#define CRC_CRC_HL          *(volatile unsigned char *)(CRC_BLOCK + 0x2) // CRC Data Register - byte accesses
#define CRC_CRC_HU          *(volatile unsigned char *)(CRC_BLOCK + 0x3) // CRC Data Register - byte accesses
#define CRC_GPOLY           *(volatile unsigned long *)(CRC_BLOCK + 0x4) // CRC Polynomial Register
#define CRC_CTRL            *(volatile unsigned long *)(CRC_BLOCK + 0x8) // CRC Control Register
  #define CRC_CTRL_TCRC_16  0x00000000
  #define CRC_CTRL_TCRC_32  0x01000000
  #define CRC_CTRL_WAS      0x02000000                                   // writes to CRC data register are seed values
  #define CRC_CTRL_FXOR     0x04000000                                   // invert of complement the read value of the CRC data register
  #define CRC_CTRL_TOTR_BITS       0x10000000                            // value read from CRC data register is transposed - bits transposed but not bytes
  #define CRC_CTRL_TOTR_BITS_BYTES 0x20000000                            // value read from CRC data register is transposed - bits and bytes transposed
  #define CRC_CTRL_TOTR_BYTES      0x30000000                            // value read from CRC data register is transposed - bytes transposed but not bits
  #define CRC_CTRL_TOT_BITS        0x40000000                            // value written to CRC data register is transposed - bits transposed but not bytes
  #define CRC_CTRL_TOT_BITS_BYTES  0x80000000                            // value written to CRC data register is transposed - bits and bytes transposed
  #define CRC_CTRL_TOT_BYTES       0xc0000000                            // value written to CRC data register is transposed - bytes transposed but not bits


#if !defined IMX_WITHOUT_PIT
    // PIT Timers
    //
    #define PIT_MCR             *(volatile unsigned long *)(PIT_BLOCK + 0x000) // PIT module control register
        #define PIT_MCR_FRZ       0x00000001                             // timers are stopped in debug mode
        #define PIT_MCR_MDIS      0x00000002                             // clock for PIT timers is disabled
    #define PIT_LTMR64H         *(volatile unsigned long *)(PIT_BLOCK + 0x0e0) // PIT Upper Lifetime Timer Register (read-only)
    #define PIT_LTMR64L         *(volatile unsigned long *)(PIT_BLOCK + 0x0e4) // PIT Lower Lifetime Timer Register (read-only)
    #define PIT_CTL_ADD         (unsigned long *)(PIT_BLOCK + 0x100)
    #define PIT_LDVAL0          *(unsigned long *)(PIT_BLOCK + 0x100)    // PIT 0 Timer Load Value Register
    #define PIT_CVAL0           *(volatile unsigned long *)(PIT_BLOCK + 0x104) // PIT 0 Current Timer Value Register
    #define PIT_TCTRL0          *(volatile unsigned long *)(PIT_BLOCK + 0x108) // PIT 0 Timer Control Register
        #define PIT_TCTRL_TEN     0x00000001                             // timer enable
        #define PIT_TCTRL_TIE     0x00000002                             // timer interrupt enable
        #define PIT_TCTRL_CHN     0x00000004                             // chain mode
    #define PIT_TFLG0           *(volatile unsigned long *)(PIT_BLOCK + 0x10c) // PIT 0 Timer Flag Register
        #define PIT_TFLG_TIF      0x00000001                             // time out has occurred (write 1 to clear)
    #define PIT_LDVAL1          *(unsigned long *)(PIT_BLOCK + 0x110)    // PIT 1 Timer Load Value Register
    #define PIT_CVAL1           *(volatile unsigned long *)(PIT_BLOCK + 0x114) // PIT 1 Current Timer Value Register
    #define PIT_TCTRL1          *(volatile unsigned long *)(PIT_BLOCK + 0x118) // PIT 1 Timer Control Register
    #define PIT_TFLG1           *(volatile unsigned long *)(PIT_BLOCK + 0x11c) // 1 Timer Flag Register
    #if PITS_AVAILABLE == 4
        #define PIT_LDVAL2      *(unsigned long *)(PIT_BLOCK + 0x120)    // PIT 2 Timer Load Value Register
        #define PIT_CVAL2       *(volatile unsigned long *)(PIT_BLOCK + 0x124) // PIT 2 Current Timer Value Register
        #define PIT_TCTRL2      *(volatile unsigned long *)(PIT_BLOCK + 0x128) // PIT 2 Timer Control Register
        #define PIT_TFLG2       *(volatile unsigned long *)(PIT_BLOCK + 0x12c) // PIT 2 Timer Flag Register
        #define PIT_LDVAL3      *(unsigned long *)(PIT_BLOCK + 0x130)    // PIT 3 Timer Load Value Register
        #define PIT_CVAL3       *(volatile unsigned long *)(PIT_BLOCK + 0x134) // PIT 3 Current Timer Value Register
        #define PIT_TCTRL3      *(volatile unsigned long *)(PIT_BLOCK + 0x138) // PIT 3 Timer Control Register
        #define PIT_TFLG3       *(volatile unsigned long *)(PIT_BLOCK + 0x13c) // PIT 3 Timer Flag Register
    #endif

    typedef struct stKINETIS_PIT_CTL                                     // PIT channel control struct
    {
        unsigned long PIT_LDVAL;
        volatile unsigned long PIT_CVAL;
        volatile unsigned long PIT_TCTRL;
        volatile unsigned long PIT_TFLG;
    } KINETIS_PIT_CTL;

    #if defined _WINDOWS
        #define LOAD_PIT(x, load_val)    PIT_LDVAL##x = (load_val); PIT_CVAL##x = (load_val)
    #else
        #define LOAD_PIT(x, load_val)    PIT_TCTRL##x = 0; PIT_LDVAL##x = (load_val)
    #endif
#endif

// General Purpose Timer
//
#define GPT1_CR                 *(volatile unsigned long *)(GPT1_BLOCK + 0x00)    // GPT1 control register
    #define GPT_CR_EN           0x00000001                               // GPT enable
    #define GPT_CR_ENMOD        0x00000002                               // GPT counter value is reset when it is disabled, rather than being frozen
    #define GPT_DBGEN           0x00000004                               // GPT remains enabled in debug mode
    #define GPT_WAITEN          0x00000008                               // GPT remains enabled in wait mode
    #define GPT_DOZEEN          0x00000010                               // GPT remains enabled in doze mode
    #define GPT_STOPEN          0x00000020                               // GPT remains enabled in stop mode
    #define GPT_CLKSRC_DISABLED 0x00000000                               // clock source has no clock
    #define GPT_CLKSRC_PERCLK   0x00000040                               // clock source is peripheral clock (ipg_clk)
    #define GPT_CLKSRC_HF_REF   0x00000080                               // clock source is the high speed reference clock (ipg_clk_highfreq)
    #define GPT_CLKSRC_EXT_CLK  0x000000c0                               // clock source is the GPT external clock input pin
    #define GPT_CLKSRC_LF_REF   0x00000100                               // clock source is the low speed reference clock (ipg_clk_32k)
    #define GPT_CLKSRC_24M_REF  0x00000140                               // clock source is the 24MHz oscillator/crystal source (ipg_clk_24M)
    #define GPT_CLKSRC_MASK     0x000001c0
    #define GPT_FRR             0x00000200                               // free-running more rather than restart mode
    #define GPT_EN_24M          0x00000400                               // enable 24MHz clock input from crystal (cleared only by hardware reset and not by software reset)
    #define GPT_SWR             0x00008000                               // software reset (self-clearing)
    #define GPT_IM1_RISING      0x00010000                               // capture channel 1 on rising edge
    #define GPT_IM1_FALLING     0x00020000                               // capture channel 1 on falling edge
    #define GPT_IM1_BOTH        0x00030000                               // capture channel 1 on both rising and falling edges
    #define GPT_IM2_RISING      0x00040000                               // capture channel 2 on rising edge
    #define GPT_IM2_FALLING     0x00080000                               // capture channel 2 on falling edge
    #define GPT_IM2_BOTH        0x000c0000                               // capture channel 2 on both rising and falling edges
    #define GPT_OM1_DISABLE     0x00000000                               // output compare channel 1 doesn't control output
    #define GPT_OM1_TOGGLE      0x00100000                               // output compare channel 1 toggles output
    #define GPT_OM1_CLEAR       0x00200000                               // output compare channel 1 clears output
    #define GPT_OM1_SET         0x00300000                               // output compare channel 1 sets output
    #define GPT_OM1_PULSE       0x00400000                               // output compare channel 1 generates an active low pulse on output (one input clock wide)
    #define GPT_OM1_MASK        0x00700000
    #define GPT_OM2_DISABLE     0x00000000                               // output compare channel 2 doesn't control output
    #define GPT_OM2_TOGGLE      0x00800000                               // output compare channel 2 toggles output
    #define GPT_OM2_CLEAR       0x01000000                               // output compare channel 2 clears output
    #define GPT_OM2_SET         0x01800000                               // output compare channel 2 sets output
    #define GPT_OM2_PULSE       0x02000000                               // output compare channel 2 generates an active low pulse on output (one input clock wide)
    #define GPT_OM2_MASK        0x03800000
    #define GPT_OM3_DISABLE     0x00000000                               // output compare channel 3 doesn't control output
    #define GPT_OM3_TOGGLE      0x04000000                               // output compare channel 3 toggles output
    #define GPT_OM3_CLEAR       0x08000000                               // output compare channel 3 clears output
    #define GPT_OM3_SET         0x0c000000                               // output compare channel 3 sets output
    #define GPT_OM3_PULSE       0x10000000                               // output compare channel 3 generates an active low pulse on output (one input clock wide)
    #define GPT_OM3_MASK        0x1c000000
    #define GPT_FO1             0x20000000                               // force output compare channel 1 (write-only)
    #define GPT_FO2             0x40000000                               // force output compare channel 2 (write-only)
    #define GPT_FO3             0x80000000                               // force output compare channel 3 (write-only)
#define GPT1_PR                 *(unsigned long *)(GPT1_BLOCK + 0x04)    // GPT1 prescale register
#define GPT1_SR                 *(volatile unsigned long *)(GPT1_BLOCK + 0x08) // GPT1 status register
    #define GPT_SR_OF1          0x00000001                               // channel 1 output capture event has occurred (write '1' to clear)
    #define GPT_SR_OF2          0x00000002                               // channel 2 output capture event has occurred (write '1' to clear)
    #define GPT_SR_OF3          0x00000004                               // channel 3 output capture event has occurred (write '1' to clear)
    #define GPT_SR_IF1          0x00000008                               // channel 1 input capture event has occurred (write '1' to clear)
    #define GPT_SR_IF2          0x00000010                               // channel 2 input capture event has occurred (write '1' to clear)
    #define GPT_SR_ROV          0x00000020                               // rollover has occurred (write '1' to clear)
#define GPT1_IR                 *(unsigned long *)(GPT1_BLOCK + 0x0c)    // GPT1 interrupt register
    #define GPT_IR_OF1IE        0x00000001                               // output compare channel 1 interrupt enable
    #define GPT_IR_OF2IE        0x00000002                               // output compare channel 2 interrupt enable
    #define GPT_IR_OF3IE        0x00000004                               // output compare channel 3 interrupt enable
    #define GPT_IR_IF1IE        0x00000008                               // input capture channel 1 interrupt enable
    #define GPT_IR_IF2IE        0x00000010                               // input capture channel 2 interrupt enable
    #define GPT_IR_ROVIE        0x00000020                               // rollover interrupt enable
#define GPT1_OCR1               *(unsigned long *)(GPT1_BLOCK + 0x10)    // GPT1 output compare register 1
#define GPT1_OCR2               *(unsigned long *)(GPT1_BLOCK + 0x14)    // GPT1 output compare register 2
#define GPT1_OCR3               *(unsigned long *)(GPT1_BLOCK + 0x18)    // GPT1 output compare register 3
#define GPT1_ICR1               *(volatile unsigned long *)(GPT1_BLOCK + 0x1c) // GPT1 input capture register 1 (read-only)
#define GPT1_ICR2               *(volatile unsigned long *)(GPT1_BLOCK + 0x20) // GPT1 input capture register 2 (read-only)
#define GPT1_CNT                *(volatile unsigned long *)(GPT1_BLOCK + 0x24) // GPT1 counter register (read-only)

#define GPT2_CR                 *(volatile unsigned long *)(GPT2_BLOCK + 0x00)    // GPT2 control register
#define GPT2_PR                 *(unsigned long *)(GPT2_BLOCK + 0x04)    // GPT2 prescale register
#define GPT2_SR                 *(volatile unsigned long *)(GPT2_BLOCK + 0x08) // GPT2 status register
#define GPT2_IR                 *(unsigned long *)(GPT2_BLOCK + 0x0c)    // GPT2 interrupt register
#define GPT2_OCR1               *(unsigned long *)(GPT2_BLOCK + 0x10)    // GPT2 output compare register 1
#define GPT2_OCR2               *(unsigned long *)(GPT2_BLOCK + 0x14)    // GPT2 output compare register 2
#define GPT2_OCR3               *(unsigned long *)(GPT2_BLOCK + 0x18)    // GPT2 output compare register 3
#define GPT2_ICR1               *(volatile unsigned long *)(GPT2_BLOCK + 0x1c) // GPT2 input capture register 1 (read-only)
#define GPT2_ICR2               *(volatile unsigned long *)(GPT2_BLOCK + 0x20) // GPT2 input capture register 2 (read-only)
#define GPT2_CNT                *(volatile unsigned long *)(GPT2_BLOCK + 0x24) // GPT2 counter register (read-only)
        

typedef struct stGPTIMER_MODULE
{
    volatile unsigned long GPT_CR;
    unsigned long GPT_PR;
    volatile unsigned long GPT_SR;
    unsigned long GPT_IR;
    unsigned long GPT_OCR[3];
    volatile unsigned long GPT_ICR[2];
    volatile unsigned long GPT_CNT;
} GPTIMER_MODULE;

#if QUAD_TIMER_AVAILABLE > 0
    #define TMR1_COMP10         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x00) // quad timer 1 channel 0 compare register 1
    #define TMR1_COMP20         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x02) // quad timer 1 channel 0 compare register 2
    #define TMR1_CAPT0          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x04) // quad timer 1 channel 0 capture register
    #define TMR1_LOAD0          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x06) // quad timer 1 channel 0 load register
    #define TMR1_HOLD0          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x08) // quad timer 1 channel 0 hold register
    #define TMR1_CNTR0          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x0a) // quad timer 1 channel 0 counter register
    #define TMR1_CTRL0          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x0c) // quad timer 1 channel 0 control register
        #define TMR_CTRL_OUTMODE_ASSERT             0x0000               // OFLAG output asserted while counter is active
        #define TMR_CTRL_OUTMODE_CLEAR_COMP         0x0001               // clear OFLAG output on successful compare
        #define TMR_CTRL_OUTMODE_SET_COMP           0x0002               // set OFLAG output on successful compare
        #define TMR_CTRL_OUTMODE_TOGGLE_COMP        0x0003               // toggle OFLAG output on successful compare
        #define TMR_CTRL_OUTMODE_TOGGLE_ALT         0x0004               // toggle OFLAG output using alternating compare registers
        #define TMR_CTRL_OUTMODE_SET_COMPARE_SEC    0x0005               // set OFLAG output on compare, cleared on secondary source input edge
        #define TMR_CTRL_OUTMODE_SET_COMPARE_ROVER  0x0006               // set OFLAG output on compare, cleared on counter rollover
        #define TMR_CTRL_OUTMODE_GATED_CLOCK        0x0007               // OFLAG output follows gated clock output while counter is active
        #define TMR_CTRL_COINIT                     0x0008               // co-channel initialisation
        #define TMR_CTRL_DIR_UP                     0x0000               // up counting direction
        #define TMR_CTRL_DIR_DOWN                   0x0010               // down counting direction
        #define TMR_CTRL_LENGTH                     0x0020               // count until compare and re-initialise, rather that countin to 0xffff and rolling over (up-counting uses COMP1 and down-counting uses COMP2)
        #define TMR_CTRL_ONCE                       0x0040               // count once until compare and stop (up-counting uses COMP1 and down-counting uses COMP2)
        #define TMR_CTRL_SCS_COUNTER_3_INPUT_PIN    0x0180               // secondary count source is counter 0 input pin
        #define TMR_CTRL_SCS_COUNTER_3_INPUT_PIN    0x0180               // secondary count source is counter 1 input pin
        #define TMR_CTRL_SCS_COUNTER_3_INPUT_PIN    0x0180               // secondary count source is counter 2 input pin
        #define TMR_CTRL_SCS_COUNTER_3_INPUT_PIN    0x0180               // secondary count source is counter 3 input pin
        #define TMR_CTRL_PCS_COUNTER_0_INPUT_PIN    0x0000               // primary count source counter 0 input pin
        #define TMR_CTRL_PCS_COUNTER_1_INPUT_PIN    0x0200               // primary count source counter 1 input pin
        #define TMR_CTRL_PCS_COUNTER_2_INPUT_PIN    0x0400               // primary count source counter 2 input pin
        #define TMR_CTRL_PCS_COUNTER_3_INPUT_PIN    0x0600               // primary count source counter 3 input pin
        #define TMR_CTRL_PCS_COUNTER_0_OUTPUT       0x0800               // primary count source counter 0 output (timer 0 can't select its own output!)
        #define TMR_CTRL_PCS_COUNTER_2_OUTPUT       0x0a00               // primary count source counter 1 output (timer 1 can't select its own output!)
        #define TMR_CTRL_PCS_COUNTER_3_OUTPUT       0x0c00               // primary count source counter 2 output (timer 2 can't select its own output!)
        #define TMR_CTRL_PCS_COUNTER_4_OUTPUT       0x0e00               // primary count source counter 3 output (timer 3 can't select its own output!)
        #define TMR_CTRL_PCS_IPBUS_DIV1             0x1000               // primary count source is IP bus clock divided by 1 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV2             0x1200               // primary count source is IP bus clock divided by 2 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV4             0x1400               // primary count source is IP bus clock divided by 4 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV8             0x1600               // primary count source is IP bus clock divided by 8 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV16            0x1800               // primary count source is IP bus clock divided by 16 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV32            0x1a00               // primary count source is IP bus clock divided by 32 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV64            0x1c00               // primary count source is IP bus clock divided by 64 prescaler
        #define TMR_CTRL_PCS_IPBUS_DIV128           0x1e00               // primary count source is IP bus clock divided by 128 prescaler
        #define TMR_CTRL_CM_NO_OPERATION            0x0000
        #define TMR_CTRL_CM_RISING_PRIMARY          0x2000               // count rising edges of primary source (rising edges are counted only when SCTRL[IPS] = 0 - falling edges are counted when SCTRL[IPS] = 1 - if the primary count source is IP bus clock divide by 1, only rising edges are counted regardless of the value of SCTRL[IPS])
        #define TMR_CTRL_CM_RISING_FALLING_PRIMARY  0x4000               // count rising and falling edges of primary source (IP bus clock divide by 1 cannot be used as a primary count source in edge count mode)
        #define TMR_CTRL_CM_GATED_RISING_PRIMARY    0x6000               // count rising edges of primary source while secondary input high active
        #define TMR_CTRL_CM_QUADRATURE              0x8000               // quadrature count mode, uses primary and secondary sources
        #define TMR_CTRL_CM_RISING_PRIMARY_DIR      0xa000               // count rising edges of primary source; secondary source specifies direction (rising edges are counted only when SCTRL[IPS] = 0 - falling edges are counted when SCTRL[IPS] = 1)
        #define TMR_CTRL_CM_SECONDARY_TRIGGER       0xc000               // edge of secondary source triggers primary count until compare
        #define TMR_CTRL_CM_CASCADED                0xe000               // cascaded counter mode (up/down) - the primary count source must be set to one of the counter outputs
    #define TMR1_SCTRL0         *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x0e) // quad timer 1 channel 0 status and control register
        #define TMR_SCTRL_OEN                       0x0001               // output enable (OFLAG is driven onto the external pin)
        #define TMR_SCTRL_OPS                       0x0002               // output polarity select
        #define TMR_SCTRL_FORCE                     0x0004               // (write-only: reads always as '0')
        #define TMR_SCTRL_VAL                       0x0008               // forced OFLAG value
        #define TMR_SCTRL_EEOF                      0x0010
        #define TMR_SCTRL_MSTR                      0x0020               // master mode
        #define TMR_SCTRL_CAPTURE_MODE_DISABLED     0x0000
        #define TMR_SCTRL_CAPTURE_MODE_RISING       0x0040
        #define TMR_SCTRL_CAPTURE_MODE_FALLING      0x0080
        #define TMR_SCTRL_CAPTURE_MODE_BOTH_EDGES   0x00c0
        #define TMR_SCTRL_INPUT                     0x0100               // (read-only)
        #define TMR_SCTRL_IPS                       0x0200
        #define TMR_SCTRL_IEFIE                     0x0400
        #define TMR_SCTRL_IEF                       0x0800
        #define TMR_SCTRL_TOFIE                     0x1000
        #define TMR_SCTRL_TOF                       0x2000
        #define TMR_SCTRL_TCFIE                     0x4000
        #define TMR_SCTRL_TCF                       0x8000
    #define TMR1_CMPLD10        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x10) // quad timer 1 channel 0 comparator load register 1
    #define TMR1_CMPLD20        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x12) // quad timer 1 channel 0 comparator load register 2
    #define TMR1_CSCTRL0        *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x14) // quad timer 1 channel 0 comparator status and control register
    #define TMR1_FILT0          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x16) // quad timer 1 channel 0 input filer register
    #define TMR1_DMA0           *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x18) // quad timer 1 channel 0 DMA enable register

    #define TMR1_ENBL           *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x1e) // quad timer 1 channel enable register
        #define TMR_ENBL_CH_0   0x0001                                   // enable timer channel 0
        #define TMR_ENBL_CH_1   0x0002                                   // enable timer channel 1
        #define TMR_ENBL_CH_2   0x0004                                   // enable timer channel 2
        #define TMR_ENBL_CH_3   0x0008                                   // enable timer channel 3
    #define TMR1_COMP11         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x20) // quad timer 1 channel 1 compare register 1
    #define TMR1_COMP21         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x22) // quad timer 1 channel 1 compare register 2
    #define TMR1_CAPT1          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x24) // quad timer 1 channel 1 capture register
    #define TMR1_LOAD1          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x26) // quad timer 1 channel 1 load register
    #define TMR1_HOLD1          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x28) // quad timer 1 channel 1 hold register
    #define TMR1_CNTR1          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x2a) // quad timer 1 channel 1 counter register
    #define TMR1_CTRL1          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x2c) // quad timer 1 channel 1 control register
    #define TMR1_SCTRL1         *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x2e) // quad timer 1 channel 1 status and control register
    #define TMR1_CMPLD11        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x30) // quad timer 1 channel 1 comparator load register 1
    #define TMR1_CMPLD21        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x32) // quad timer 1 channel 1 comparator load register 2
    #define TMR1_CSCTRL1        *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x34) // quad timer 1 channel 1 comparator status and control register
    #define TMR1_FILT1          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x36) // quad timer 1 channel 1 input filer register
    #define TMR1_DMA1           *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x38) // quad timer 1 channel 1 DMA enable register

    #define TMR1_COMP12         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x40) // quad timer 1 channel 2 compare register 1
    #define TMR1_COMP22         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x42) // quad timer 1 channel 2 compare register 2
    #define TMR1_CAPT2          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x44) // quad timer 1 channel 2 capture register
    #define TMR1_LOAD2          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x46) // quad timer 1 channel 2 load register
    #define TMR1_HOLD2          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x48) // quad timer 1 channel 2 hold register
    #define TMR1_CNTR2          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x4a) // quad timer 1 channel 2 counter register
    #define TMR1_CTRL2          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x4c) // quad timer 1 channel 2 control register
    #define TMR1_SCTRL2         *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x4e) // quad timer 1 channel 2 status and control register
    #define TMR1_CMPLD12        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x50) // quad timer 1 channel 2 comparator load register 1
    #define TMR1_CMPLD22        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x52) // quad timer 1 channel 2 comparator load register 2
    #define TMR1_CSCTRL2        *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x54) // quad timer 1 channel 2 comparator status and control register
    #define TMR1_FILT2          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x56) // quad timer 1 channel 2 input filer register
    #define TMR1_DMA2           *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x58) // quad timer 1 channel 2 DMA enable register

    #define TMR1_COMP13         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x60) // quad timer 1 channel 3 compare register 1
    #define TMR1_COMP23         *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x62) // quad timer 1 channel 3 compare register 2
    #define TMR1_CAPT3          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x64) // quad timer 1 channel 3 capture register
    #define TMR1_LOAD3          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x66) // quad timer 1 channel 3 load register
    #define TMR1_HOLD3          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x68) // quad timer 1 channel 3 hold register
    #define TMR1_CNTR3          *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x6a) // quad timer 1 channel 3 counter register
    #define TMR1_CTRL3          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x6c) // quad timer 1 channel 3 control register
    #define TMR1_SCTRL3         *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x6e) // quad timer 1 channel 3 status and control register
    #define TMR1_CMPLD13        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x70) // quad timer 1 channel 3 comparator load register 1
    #define TMR1_CMPLD23        *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x72) // quad timer 1 channel 3 comparator load register 2
    #define TMR1_CSCTRL3        *(volatile unsigned short *)(QUAD_TIMER1_BLOCK + 0x74) // quad timer 1 channel 3 comparator status and control register
    #define TMR1_FILT3          *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x76) // quad timer 1 channel 3 input filer register
    #define TMR1_DMA3           *(unsigned short *)(QUAD_TIMER1_BLOCK + 0x78) // quad timer 1 channel 3 DMA enable register
#endif
#if QUAD_TIMER_AVAILABLE > 1
    #define TMR2_COMP10         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x00) // quad timer 2 channel 0 compare register 1
    #define TMR2_COMP20         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x02) // quad timer 2 channel 0 compare register 2
    #define TMR2_CAPT0          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x04) // quad timer 2 channel 0 capture register
    #define TMR2_LOAD0          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x06) // quad timer 2 channel 0 load register
    #define TMR2_HOLD0          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x08) // quad timer 2 channel 0 hold register
    #define TMR2_CNTR0          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x0a) // quad timer 2 channel 0 counter register
    #define TMR2_CTRL0          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x0c) // quad timer 2 channel 0 control register
    #define TMR2_SCTRL0         *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x0e) // quad timer 2 channel 0 status and control register
    #define TMR2_CMPLD10        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x10) // quad timer 2 channel 0 comparator load register 1
    #define TMR2_CMPLD20        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x12) // quad timer 2 channel 0 comparator load register 2
    #define TMR2_CSCTRL0        *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x14) // quad timer 2 channel 0 comparator status and control register
    #define TMR2_FILT0          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x16) // quad timer 2 channel 0 input filer register
    #define TMR2_DMA0           *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x18) // quad timer 2 channel 0 DMA enable register

    #define TMR2_ENBL           *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x1e) // quad timer 2 channel enable register

    #define TMR2_COMP11         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x20) // quad timer 2 channel 1 compare register 1
    #define TMR2_COMP21         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x22) // quad timer 2 channel 1 compare register 2
    #define TMR2_CAPT1          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x24) // quad timer 2 channel 1 capture register
    #define TMR2_LOAD1          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x26) // quad timer 2 channel 1 load register
    #define TMR2_HOLD1          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x28) // quad timer 2 channel 1 hold register
    #define TMR2_CNTR1          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x2a) // quad timer 2 channel 1 counter register
    #define TMR2_CTRL1          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x2c) // quad timer 2 channel 1 control register
    #define TMR2_SCTRL1         *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x2e) // quad timer 2 channel 1 status and control register
    #define TMR2_CMPLD11        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x30) // quad timer 2 channel 1 comparator load register 1
    #define TMR2_CMPLD21        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x32) // quad timer 2 channel 1 comparator load register 2
    #define TMR2_CSCTRL1        *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x34) // quad timer 2 channel 1 comparator status and control register
    #define TMR2_FILT1          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x36) // quad timer 2 channel 1 input filer register
    #define TMR2_DMA1           *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x38) // quad timer 2 channel 1 DMA enable register

    #define TMR2_COMP12         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x40) // quad timer 2 channel 2 compare register 1
    #define TMR2_COMP22         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x42) // quad timer 2 channel 2 compare register 2
    #define TMR2_CAPT2          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x44) // quad timer 2 channel 2 capture register
    #define TMR2_LOAD2          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x46) // quad timer 2 channel 2 load register
    #define TMR2_HOLD2          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x48) // quad timer 2 channel 2 hold register
    #define TMR2_CNTR2          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x4a) // quad timer 2 channel 2 counter register
    #define TMR2_CTRL2          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x4c) // quad timer 2 channel 2 control register
    #define TMR2_SCTRL2         *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x4e) // quad timer 2 channel 2 status and control register
    #define TMR2_CMPLD12        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x50) // quad timer 2 channel 2 comparator load register 1
    #define TMR2_CMPLD22        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x52) // quad timer 2 channel 2 comparator load register 2
    #define TMR2_CSCTRL2        *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x54) // quad timer 2 channel 2 comparator status and control register
    #define TMR2_FILT2          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x56) // quad timer 2 channel 2 input filer register
    #define TMR2_DMA2           *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x58) // quad timer 2 channel 2 DMA enable register

    #define TMR2_COMP13         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x60) // quad timer 2 channel 3 compare register 1
    #define TMR2_COMP23         *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x62) // quad timer 2 channel 3 compare register 2
    #define TMR2_CAPT3          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x64) // quad timer 2 channel 3 capture register
    #define TMR2_LOAD3          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x66) // quad timer 2 channel 3 load register
    #define TMR2_HOLD3          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x68) // quad timer 2 channel 3 hold register
    #define TMR2_CNTR3          *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x6a) // quad timer 2 channel 3 counter register
    #define TMR2_CTRL3          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x6c) // quad timer 2 channel 3 control register
    #define TMR2_SCTRL3         *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x6e) // quad timer 2 channel 3 status and control register
    #define TMR2_CMPLD13        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x70) // quad timer 2 channel 3 comparator load register 1
    #define TMR2_CMPLD23        *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x72) // quad timer 2 channel 3 comparator load register 2
    #define TMR2_CSCTRL3        *(volatile unsigned short *)(QUAD_TIMER2_BLOCK + 0x74) // quad timer 2 channel 3 comparator status and control register
    #define TMR2_FILT3          *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x76) // quad timer 2 channel 3 input filer register
    #define TMR2_DMA3           *(unsigned short *)(QUAD_TIMER2_BLOCK + 0x78) // quad timer 2 channel 3 DMA enable register
#endif
#if QUAD_TIMER_AVAILABLE > 2
    #define TMR3_COMP10         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x00) // quad timer 3 channel 0 compare register 1
    #define TMR3_COMP20         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x02) // quad timer 3 channel 0 compare register 2
    #define TMR3_CAPT0          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x04) // quad timer 3 channel 0 capture register
    #define TMR3_LOAD0          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x06) // quad timer 3 channel 0 load register
    #define TMR3_HOLD0          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x08) // quad timer 3 channel 0 hold register
    #define TMR3_CNTR0          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x0a) // quad timer 3 channel 0 counter register
    #define TMR3_CTRL0          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x0c) // quad timer 3 channel 0 control register
    #define TMR3_SCTRL0         *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x0e) // quad timer 3 channel 0 status and control register
    #define TMR3_CMPLD10        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x10) // quad timer 3 channel 0 comparator load register 1
    #define TMR3_CMPLD20        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x12) // quad timer 3 channel 0 comparator load register 2
    #define TMR3_CSCTRL0        *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x14) // quad timer 3 channel 0 comparator status and control register
    #define TMR3_FILT0          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x16) // quad timer 3 channel 0 input filer register
    #define TMR3_DMA0           *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x18) // quad timer 3 channel 0 DMA enable register

    #define TMR3_ENBL           *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x1e) // quad timer 3 channel enable register

    #define TMR3_COMP11         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x20) // quad timer 3 channel 1 compare register 1
    #define TMR3_COMP21         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x22) // quad timer 3 channel 1 compare register 2
    #define TMR3_CAPT1          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x24) // quad timer 3 channel 1 capture register
    #define TMR3_LOAD1          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x26) // quad timer 3 channel 1 load register
    #define TMR3_HOLD1          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x28) // quad timer 3 channel 1 hold register
    #define TMR3_CNTR1          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x2a) // quad timer 3 channel 1 counter register
    #define TMR3_CTRL1          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x2c) // quad timer 3 channel 1 control register
    #define TMR3_SCTRL1         *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x2e) // quad timer 3 channel 1 status and control register
    #define TMR3_CMPLD11        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x30) // quad timer 3 channel 1 comparator load register 1
    #define TMR3_CMPLD21        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x32) // quad timer 3 channel 1 comparator load register 2
    #define TMR3_CSCTRL1        *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x34) // quad timer 3 channel 1 comparator status and control register
    #define TMR3_FILT1          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x36) // quad timer 3 channel 1 input filer register
    #define TMR3_DMA1           *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x38) // quad timer 3 channel 1 DMA enable register

    #define TMR3_COMP12         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x40) // quad timer 3 channel 2 compare register 1
    #define TMR3_COMP22         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x42) // quad timer 3 channel 2 compare register 2
    #define TMR3_CAPT2          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x44) // quad timer 3 channel 2 capture register
    #define TMR3_LOAD2          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x46) // quad timer 3 channel 2 load register
    #define TMR3_HOLD2          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x48) // quad timer 3 channel 2 hold register
    #define TMR3_CNTR2          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x4a) // quad timer 3 channel 2 counter register
    #define TMR3_CTRL2          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x4c) // quad timer 3 channel 2 control register
    #define TMR3_SCTRL2         *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x4e) // quad timer 3 channel 2 status and control register
    #define TMR3_CMPLD12        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x50) // quad timer 3 channel 2 comparator load register 1
    #define TMR3_CMPLD22        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x52) // quad timer 3 channel 2 comparator load register 2
    #define TMR3_CSCTRL2        *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x54) // quad timer 3 channel 2 comparator status and control register
    #define TMR3_FILT2          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x56) // quad timer 3 channel 2 input filer register
    #define TMR3_DMA2           *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x58) // quad timer 3 channel 2 DMA enable register

    #define TMR3_COMP13         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x60) // quad timer 3 channel 3 compare register 1
    #define TMR3_COMP23         *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x62) // quad timer 3 channel 3 compare register 2
    #define TMR3_CAPT3          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x64) // quad timer 3 channel 3 capture register
    #define TMR3_LOAD3          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x66) // quad timer 3 channel 3 load register
    #define TMR3_HOLD3          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x68) // quad timer 3 channel 3 hold register
    #define TMR3_CNTR3          *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x6a) // quad timer 3 channel 3 counter register
    #define TMR3_CTRL3          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x6c) // quad timer 3 channel 3 control register
    #define TMR3_SCTRL3         *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x6e) // quad timer 3 channel 3 status and control register
    #define TMR3_CMPLD13        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x70) // quad timer 3 channel 3 comparator load register 1
    #define TMR3_CMPLD23        *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x72) // quad timer 3 channel 3 comparator load register 2
    #define TMR3_CSCTRL3        *(volatile unsigned short *)(QUAD_TIMER3_BLOCK + 0x74) // quad timer 3 channel 3 comparator status and control register
    #define TMR3_FILT3          *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x76) // quad timer 3 channel 3 input filer register
    #define TMR3_DMA3           *(unsigned short *)(QUAD_TIMER3_BLOCK + 0x78) // quad timer 3 channel 3 DMA enable register
#endif
#if QUAD_TIMER_AVAILABLE > 3
    #define TMR4_COMP10         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x00) // quad timer 4 channel 0 compare register 1
    #define TMR4_COMP20         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x02) // quad timer 4 channel 0 compare register 2
    #define TMR4_CAPT0          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x04) // quad timer 4 channel 0 capture register
    #define TMR4_LOAD0          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x06) // quad timer 4 channel 0 load register
    #define TMR4_HOLD0          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x08) // quad timer 4 channel 0 hold register
    #define TMR4_CNTR0          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x0a) // quad timer 4 channel 0 counter register
    #define TMR4_CTRL0          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x0c) // quad timer 4 channel 0 control register
    #define TMR4_SCTRL0         *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x0e) // quad timer 4 channel 0 status and control register
    #define TMR4_CMPLD10        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x10) // quad timer 4 channel 0 comparator load register 1
    #define TMR4_CMPLD20        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x12) // quad timer 4 channel 0 comparator load register 2
    #define TMR4_CSCTRL0        *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x14) // quad timer 4 channel 0 comparator status and control register
    #define TMR4_FILT0          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x16) // quad timer 4 channel 0 input filer register
    #define TMR4_DMA0           *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x18) // quad timer 4 channel 0 DMA enable register

    #define TMR4_ENBL           *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x1e) // quad timer 4 channel enable register

    #define TMR4_COMP11         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x20) // quad timer 4 channel 1 compare register 1
    #define TMR4_COMP21         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x22) // quad timer 4 channel 1 compare register 2
    #define TMR4_CAPT1          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x24) // quad timer 4 channel 1 capture register
    #define TMR4_LOAD1          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x26) // quad timer 4 channel 1 load register
    #define TMR4_HOLD1          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x28) // quad timer 4 channel 1 hold register
    #define TMR4_CNTR1          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x2a) // quad timer 4 channel 1 counter register
    #define TMR4_CTRL1          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x2c) // quad timer 4 channel 1 control register
    #define TMR4_SCTRL1         *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x2e) // quad timer 4 channel 1 status and control register
    #define TMR4_CMPLD11        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x30) // quad timer 4 channel 1 comparator load register 1
    #define TMR4_CMPLD21        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x32) // quad timer 4 channel 1 comparator load register 2
    #define TMR4_CSCTRL1        *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x34) // quad timer 4 channel 1 comparator status and control register
    #define TMR4_FILT1          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x36) // quad timer 4 channel 1 input filer register
    #define TMR4_DMA1           *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x38) // quad timer 4 channel 1 DMA enable register

    #define TMR4_COMP12         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x40) // quad timer 4 channel 2 compare register 1
    #define TMR4_COMP22         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x42) // quad timer 4 channel 2 compare register 2
    #define TMR4_CAPT2          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x44) // quad timer 4 channel 2 capture register
    #define TMR4_LOAD2          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x46) // quad timer 4 channel 2 load register
    #define TMR4_HOLD2          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x48) // quad timer 4 channel 2 hold register
    #define TMR4_CNTR2          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x4a) // quad timer 4 channel 2 counter register
    #define TMR4_CTRL2          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x4c) // quad timer 4 channel 2 control register
    #define TMR4_SCTRL2         *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x4e) // quad timer 4 channel 2 status and control register
    #define TMR4_CMPLD12        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x50) // quad timer 4 channel 2 comparator load register 1
    #define TMR4_CMPLD22        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x52) // quad timer 4 channel 2 comparator load register 2
    #define TMR4_CSCTRL2        *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x54) // quad timer 4 channel 2 comparator status and control register
    #define TMR4_FILT2          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x56) // quad timer 4 channel 2 input filer register
    #define TMR4_DMA2           *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x58) // quad timer 4 channel 2 DMA enable register

    #define TMR4_COMP13         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x60) // quad timer 4 channel 3 compare register 1
    #define TMR4_COMP23         *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x62) // quad timer 4 channel 3 compare register 2
    #define TMR4_CAPT3          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x64) // quad timer 4 channel 3 capture register
    #define TMR4_LOAD3          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x66) // quad timer 4 channel 3 load register
    #define TMR4_HOLD3          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x68) // quad timer 4 channel 3 hold register
    #define TMR4_CNTR3          *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x6a) // quad timer 4 channel 3 counter register
    #define TMR4_CTRL3          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x6c) // quad timer 4 channel 3 control register
    #define TMR4_SCTRL3         *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x6e) // quad timer 4 channel 3 status and control register
    #define TMR4_CMPLD13        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x70) // quad timer 4 channel 3 comparator load register 1
    #define TMR4_CMPLD23        *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x72) // quad timer 4 channel 3 comparator load register 2
    #define TMR4_CSCTRL3        *(volatile unsigned short *)(QUAD_TIMER4_BLOCK + 0x74) // quad timer 4 channel 3 comparator status and control register
    #define TMR4_FILT3          *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x76) // quad timer 4 channel 3 input filer register
    #define TMR4_DMA3           *(unsigned short *)(QUAD_TIMER4_BLOCK + 0x78) // quad timer 4 channel 3 DMA enable register
#endif

#if QUAD_TIMER_AVAILABLE > 0
typedef struct stQUAD_TIMER_CHANNEL
{
    unsigned short TMR_COMP1;
    unsigned short TMR_COMP2;
    volatile unsigned short TMR_CAPT;
    unsigned short TMR_LOAD;
    unsigned short TMR_HOLD;
    volatile unsigned short TMR_CNTR;
    unsigned short TMR_CTRL;
    volatile unsigned short TMR_SCTRL;
    unsigned short TMR_CMPLD1;
    unsigned short TMR_CMPLD2;
    volatile unsigned short TMR_CSCTRL;
    unsigned short TMR_FILT;
    unsigned short TMR_DMA;
} QUAD_TIMER_CHANNEL;

typedef struct stQUAD_TIMER_MODULE
{
    QUAD_TIMER_CHANNEL channel0;
    unsigned short usRes0[2];
    unsigned short TMR_ENBL;
    QUAD_TIMER_CHANNEL channel1;
    unsigned short usRes1[3];
    QUAD_TIMER_CHANNEL channel2;
    unsigned short usRes2[3];
    QUAD_TIMER_CHANNEL channel3;
} QUAD_TIMER_MODULE;
#endif


// enhanced FLEXPWM
//
#define FLEXPWM1_SM0CNT         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x000) // FlexPWM1 channel 0 counter register (read-only) - must be accesses with short word reads
#define FLEXPWM1_SM0INIT        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x002) // FlexPWM1 channel 0 initial count register (buffered register) - must be accesses with short word reads/writes
#define FLEXPWM1_SM0CTRL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x004) // FlexPWM1 channel 0 control 2 register
    #define FLEXPWM_SMCTRL2_CLK_SEL_IPBus   0x0000                        // IPBus clock is used as the clock for the local prescaler and counter
    #define FLEXPWM_SMCTRL2_CLK_SEL_EXT_CLK 0x0001                        // EXT_CLK is used as the clock for the local prescaler and counter
    #define FLEXPWM_SMCTRL2_CLK_SEL_AUX_CLK 0x0002                        // AUX_CLK is used as the clock for the local prescaler and counter - should not be used for channel 0 as it will force the clock to logic '0'
    #define FLEXPWM_SMCTRL2_CLK_SEL_MASK    0x0003
    #define FLEXPWM_SMCTRL2_RELOAD_SEL      0x0004                        // master RELOAD signal is used, rather than local RELOAD signal - should not be used for channel 0 as it will force the clock to logic '0'
    #define FLEXPWM_SMCTRL2_FORCE_SEL_CTRL2 0x0000                        // source of the FORCE OUTPUT signal is the FORCE flag
    #define FLEXPWM_SMCTRL2_FORCE_SEL_MASK  0x0038
    #define FLEXPWM_SMCTRL2_FORCE           0x0040                        // force initialisation (reads as '0') - used with FLEXPWM_SMCTRL2_FORCE_SEL_CTRL2 -> caues PWM_A and PWM_B to assume values based on DTSRCSEL[SMxSEL23] and DTSRCSEL[SMxSEL45] / if CTRL2[FRCEN] is set, the counter value will be initialized with the INIT register value
    #define FLEXPWM_SMCTRL2_FRCEN           0x0080
    #define FLEXPWM_SMCTRL2_INT_SEL_MASK    0x0300
    #define FLEXPWM_SMCTRL2_PWMX_INIT       0x0400
    #define FLEXPWM_SMCTRL2_PWM45_INIT      0x0800
    #define FLEXPWM_SMCTRL2_PWM23_INIT      0x1000
    #define FLEXPWM_SMCTRL2_COMP            0x0000                       // PWM_A_and PWM_B for a complimentary pair
    #define FLEXPWM_SMCTRL2_INDEP           0x2000                       // PWM_A_and PWM_B are independent PWMs
    #define FLEXPWM_SMCTRL2_WAITEN          0x4000
    #define FLEXPWM_SMCTRL2_DBGEN           0x8000
#define FLEXPWM1_SM0CTRL        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x006) // FlexPWM1 channel 0 control register
    #define FLEXPWM_SMCTRL_DBLEN            0x0001                       // double switching enabled - not compatible with fractional PWM clock generation - make sure this bit is clear when setting FRCTRL[FRAC23_EN], FRCTRL[FRAC45_EN], or FRCTRL[FRAC1_EN].
    #define FLEXPWM_SMCTRL_DBLX             0x0002                       // PWMX doube switching enable
    #define FLEXPWM_SMCTRL_LDMOD            0x0004                       // load mode select
    #define FLEXPWM_SMCTRL_SPLIT            0x0008                       // split the DBLPWM signal to PWMA and PWMB
    #define FLEXPWM_SMCTRL_PRSC_1           0x0000                       // prescaler divide by 1
    #define FLEXPWM_SMCTRL_PRSC_2           0x0010                       // prescaler divide by 2
    #define FLEXPWM_SMCTRL_PRSC_4           0x0020                       // prescaler divide by 4
    #define FLEXPWM_SMCTRL_PRSC_8           0x0030                       // prescaler divide by 8
    #define FLEXPWM_SMCTRL_PRSC_16          0x0040                       // prescaler divide by 16
    #define FLEXPWM_SMCTRL_PRSC_32          0x0050                       // prescaler divide by 32
    #define FLEXPWM_SMCTRL_PRSC_64          0x0060                       // prescaler divide by 64
    #define FLEXPWM_SMCTRL_PRSC_128         0x0070                       // prescaler divide by 128
    #define FLEXPWM_SMCTRL_COMPMODE         0x0080                       // compare mode
    #define FLEXPWM_SMCTRL_DT_0             0x0100                       // dead time 0 sample value (read-only)
    #define FLEXPWM_SMCTRL_DT_1             0x0200                       // dead time 1 sample value (read-only)
    #define FLEXPWM_SMCTRL_FULL             0x0400                       // full cycle reload
    #define FLEXPWM_SMCTRL_HALF             0x0800                       // half cycle reload
    #define FLEXPWM_SMCTRL_LDFQ_1           0x0000                       // load frequency every PWM opportunity
    #define FLEXPWM_SMCTRL_LDFQ_2           0x1000                       // load frequency every 2 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_3           0x2000                       // load frequency every 3 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_4           0x3000                       // load frequency every 4 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_5           0x4000                       // load frequency every 5 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_6           0x5000                       // load frequency every 6 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_7           0x6000                       // load frequency every 7 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_8           0x7000                       // load frequency every 8 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_9           0x8000                       // load frequency every 9 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_10          0x9000                       // load frequency every 10 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_11          0xa000                       // load frequency every 11 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_12          0xb000                       // load frequency every 12 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_13          0xc000                       // load frequency every 13 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_14          0xd000                       // load frequency every 14 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_15          0xe000                       // load frequency every 15 PWM opportunities
    #define FLEXPWM_SMCTRL_LDFQ_16          0xf000                       // load frequency every 16 PWM opportunities
#define FLEXPWM1_SM0VAL0        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x00a) // FlexPWM1 channel 0 value 0 register
#define FLEXPWM1_SM0FRACVAL1    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x00c) // FlexPWM1 channel 0 fractional value 1 register
    #define FLEXPWM_SMFRACVAL_MASK          0xf800
#define FLEXPWM1_SM0VAL1        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x00e) // FlexPWM1 channel 0 value 1 register
#define FLEXPWM1_SM0FRACVAL2    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x010) // FlexPWM1 channel 0 fractional value 2 register
#define FLEXPWM1_SM0VAL2        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x012) // FlexPWM1 channel 0 value 2 register
#define FLEXPWM1_SM0FRACVAL3    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x014) // FlexPWM1 channel 0 fractional value 3 register
#define FLEXPWM1_SM0VAL3        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x016) // FlexPWM1 channel 0 value 3 register
#define FLEXPWM1_SM0FRACVAL4    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x018) // FlexPWM1 channel 0 fractional value 4 register
#define FLEXPWM1_SM0VAL4        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x01a) // FlexPWM1 channel 0 value 4 register
#define FLEXPWM1_SM0FRACVAL5    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x01c) // FlexPWM1 channel 0 fractional value 5 register
#define FLEXPWM1_SM0VAL5        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x01e) // FlexPWM1 channel 0 value 5 register
#define FLEXPWM1_SM0FRCTRL      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x020) // FlexPWM1 channel 0 fractional control register
#define FLEXPWM1_SM0OCTRL       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x022) // FlexPWM1 channel 0 output control register
    #define FLEXPWM_SMOCTRL_PWMXFS_0    0x0000                           // PWM_X fault state - output forced to '0' (prior to output polarity control)
    #define FLEXPWM_SMOCTRL_PWMXFS_1    0x0001                           // PWM_X fault state - output forced to '1' (prior to output polarity control)
    #define FLEXPWM_SMOCTRL_PWMXFS_TRI  0x0003                           // PWM_X fault state - output is tristated
    #define FLEXPWM_SMOCTRL_PWMBFS_0    0x0000                           // PWM_B fault state - output forced to '0' (prior to output polarity control)
    #define FLEXPWM_SMOCTRL_PWMBFS_1    0x0004                           // PWM_B fault state - output forced to '1' (prior to output polarity control)
    #define FLEXPWM_SMOCTRL_PWMBFS_TRI  0x000c                           // PWM_B fault state - output is tristated
    #define FLEXPWM_SMOCTRL_PWMAFS_0    0x0000                           // PWM_A fault state - output forced to '0' (prior to output polarity control)
    #define FLEXPWM_SMOCTRL_PWMAFS_1    0x0010                           // PWM_A fault state - output forced to '1' (prior to output polarity control)
    #define FLEXPWM_SMOCTRL_PWMAFS_TRI  0x0030                           // PWM_A fault state - output is tristated
    #define FLEXPWM_SMOCTRL_POLX        0x0100                           // PWM_X output inverted
    #define FLEXPWM_SMOCTRL_POLB        0x0200                           // PWM_B output inverted
    #define FLEXPWM_SMOCTRL_POLA        0x0400                           // PWM_A output inverted
    #define FLEXPWM_SMOCTRL_PWMX_IN     0x2000                           // logic value currently being driven into the PWM_X input (read-only)
    #define FLEXPWM_SMOCTRL_PWMB_IN     0x4000                           // logic value currently being driven into the PWM_B input (read-only)
    #define FLEXPWM_SMOCTRL_PWMA_IN     0x8000                           // logic value currently being driven into the PWM_A input (read-only)
#define FLEXPWM1_SM0STS         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x024) // FlexPWM1 channel 0 status register
    #define FLEXPWM_SMSTS_CMPF_0   0x0001                                // compare flag VAL0 (write '1' to clear)
    #define FLEXPWM_SMSTS_CMPF_1   0x0002                                // compare flag VAL1 (write '1' to clear)
    #define FLEXPWM_SMSTS_CMPF_2   0x0004                                // compare flag VAL2 (write '1' to clear)
    #define FLEXPWM_SMSTS_CMPF_3   0x0008                                // compare flag VAL3 (write '1' to clear)
    #define FLEXPWM_SMSTS_CMPF_4   0x0010                                // compare flag VAL4 (write '1' to clear)
    #define FLEXPWM_SMSTS_CMPF_5   0x0020                                // compare flag VAL5 (write '1' to clear)
    #define FLEXPWM_SMSTS_CFX0     0x0040                                // capture flag X0 (write '1' to clear)
    #define FLEXPWM_SMSTS_CFX1     0x0080                                // capture flag X1 (write '1' to clear)
    #define FLEXPWM_SMSTS_CFB0     0x0100                                // capture flag B0 (write '1' to clear)
    #define FLEXPWM_SMSTS_CFB1     0x0200                                // capture flag B1 (write '1' to clear)
    #define FLEXPWM_SMSTS_CFA0     0x0400                                // capture flag A0 (write '1' to clear)
    #define FLEXPWM_SMSTS_CFA1     0x0800                                // capture flag A1 (write '1' to clear)
    #define FLEXPWM_SMSTS_RF       0x1000                                // reload flag (write '1' to clear)
    #define FLEXPWM_SMSTS_REF      0x2000                                // reload error flag (write '1' to clear)
    #define FLEXPWM_SMSTS_RUF      0x4000                                // register updated flag (read-only)
#define FLEXPWM1_SM0INTEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x026) // FlexPWM1 channel 0 interrupt enable register
    #define FLEXPWM_SMINTEN_CMPIE_0 0x0001                               // compare VAL0 interrupt enable
    #define FLEXPWM_SMINTEN_CMPIE_1 0x0002                               // compare VAL1 interrupt enable
    #define FLEXPWM_SMINTEN_CMPIE_2 0x0004                               // compare VAL2 interrupt enable
    #define FLEXPWM_SMINTEN_CMPIE_3 0x0008                               // compare VAL3 interrupt enable
    #define FLEXPWM_SMINTEN_CMPIE_4 0x0010                               // compare VAL4 interrupt enable
    #define FLEXPWM_SMINTEN_CMPIE_5 0x0020                               // compare VAL5 interrupt enable
    #define FLEXPWM_SMINTEN_CFX0IE  0x0040                               // capture flag X0 interrupt enable
    #define FLEXPWM_SMINTEN_CFX1IE  0x0080                               // capture flag X1 interrupt enable
    #define FLEXPWM_SMINTEN_CFB0IE  0x0100                               // capture flag B0 interrupt enable
    #define FLEXPWM_SMINTEN_CFB1IE  0x0200                               // capture flag B1 interrupt enable
    #define FLEXPWM_SMINTEN_CFA0IE  0x0400                               // capture flag A0 interrupt enable
    #define FLEXPWM_SMINTEN_CFA1IE  0x0800                               // capture flag A1 interrupt enable
    #define FLEXPWM_SMINTEN_REI     0x1000                               // reload flag interrupt enable
    #define FLEXPWM_SMINTEN_REIE    0x2000                               // reload error flag interrupt enable
#define FLEXPWM1_SM0DMAEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x028)          // FlexPWM1 channel 0 DMA enable register
#define FLEXPWM1_SM0TCTRL       *(unsigned short *)(FLEXPWM1_BLOCK + 0x02a)          // FlexPWM1 channel 0 output trigger control register
#define FLEXPWM1_SM0DISPMAP0    *(unsigned short *)(FLEXPWM1_BLOCK + 0x02c)          // FlexPWM1 channel 0 fault disable mapping register 0
#define FLEXPWM1_SM0DISPMAP1    *(unsigned short *)(FLEXPWM1_BLOCK + 0x02e)          // FlexPWM1 channel 0 fault disable mapping register 1
#define FLEXPWM1_SM0DTCNT0      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x030) // FlexPWM1 channel 0 deadtime count register 0
#define FLEXPWM1_SM0DTCNT1      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x032) // FlexPWM1 channel 0 deadtime count register 1
#define FLEXPWM1_SM0CAPTCTRLA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x034)          // FlexPWM1 channel 0 capture control A register
#define FLEXPWM1_SM0CAPTCOMPA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x036)          // FlexPWM1 channel 0 capture compare A register
#define FLEXPWM1_SM0CAPTCTRLB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x038)          // FlexPWM1 channel 0 capture control B register
#define FLEXPWM1_SM0CAPTCOMPB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x03a)          // FlexPWM1 channel 0 capture compare B register
#define FLEXPWM1_SM0CAPTCTRLX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x03c)          // FlexPWM1 channel 0 capture control X register
#define FLEXPWM1_SM0CAPTCOMPX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x03e)          // FlexPWM1 channel 0 capture compare X register
#define FLEXPWM1_SM0CVAL0       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x040) // FlexPWM1 channel 0 capture value 0 register (read-only)
#define FLEXPWM1_SM0CVAL0CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x042) // FlexPWM1 channel 0 capture value 0 cycle register (read-only)
#define FLEXPWM1_SM0CVAL1       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x044) // FlexPWM1 channel 0 capture value 1 register (read-only)
#define FLEXPWM1_SM0CVAL1CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x046) // FlexPWM1 channel 0 capture value 1 cycle register (read-only)
#define FLEXPWM1_SM0CVAL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x048) // FlexPWM1 channel 0 capture value 2 register (read-only)
#define FLEXPWM1_SM0CVAL2CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x04a) // FlexPWM1 channel 0 capture value 2 cycle register (read-only)
#define FLEXPWM1_SM0CVAL3       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x04c) // FlexPWM1 channel 0 capture value 3 register (read-only)
#define FLEXPWM1_SM0CVAL3CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x04e) // FlexPWM1 channel 0 capture value 3 cycle register (read-only)
#define FLEXPWM1_SM0CVAL4       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x050) // FlexPWM1 channel 0 capture value 4 register (read-only)
#define FLEXPWM1_SM0CVAL4CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x052) // FlexPWM1 channel 0 capture value 4 cycle register (read-only)
#define FLEXPWM1_SM0CVAL5       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x054) // FlexPWM1 channel 0 capture value 5 register (read-only)
#define FLEXPWM1_SM0CVAL5CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x056) // FlexPWM1 channel 0 capture value 5 cycle register (read-only)

#define FLEXPWM1_SM1CNT         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x060) // FlexPWM1 channel 1 counter register (read-only)
#define FLEXPWM1_SM1INIT        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x062) // FlexPWM1 channel 1 initial count register
#define FLEXPWM1_SM1CTRL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x064) // FlexPWM1 channel 1 control 2 register
#define FLEXPWM1_SM1CTRL        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x066) // FlexPWM1 channel 1 control register

#define FLEXPWM1_SM1VAL0        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x06a) // FlexPWM1 channel 1 value 0 register
#define FLEXPWM1_SM1FRACVAL1    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x06c) // FlexPWM1 channel 1 fractional value 1 register
#define FLEXPWM1_SM1VAL1        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x06e) // FlexPWM1 channel 1 value 1 register
#define FLEXPWM1_SM1FRACVAL2    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x070) // FlexPWM1 channel 1 fractional value 2 register
#define FLEXPWM1_SM1VAL2        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x072) // FlexPWM1 channel 1 value 2 register
#define FLEXPWM1_SM1FRACVAL3    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x074) // FlexPWM1 channel 1 fractional value 3 register
#define FLEXPWM1_SM1VAL3        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x076) // FlexPWM1 channel 1 value 3 register
#define FLEXPWM1_SM1FRACVAL4    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x078) // FlexPWM1 channel 1 fractional value 4 register
#define FLEXPWM1_SM1VAL4        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x07a) // FlexPWM1 channel 1 value 4 register
#define FLEXPWM1_SM1FRACVAL5    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x07c) // FlexPWM1 channel 1 fractional value 5 register
#define FLEXPWM1_SM1VAL5        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x07e) // FlexPWM1 channel 1 value 5 register
#define FLEXPWM1_SM1FRCTRL      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x080) // FlexPWM1 channel 1 fractional control register
#define FLEXPWM1_SM1OCTRL       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x082) // FlexPWM1 channel 1 output control register
#define FLEXPWM1_SM1STS         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x084) // FlexPWM1 channel 1 status register (write '1' to clear)
#define FLEXPWM1_SM1INTEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x086)          // FlexPWM1 channel 1 interrupt enable register
#define FLEXPWM1_SM1DMAEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x088)          // FlexPWM1 channel 1 DMA enable register
#define FLEXPWM1_SM1TCTRL       *(unsigned short *)(FLEXPWM1_BLOCK + 0x08a)          // FlexPWM1 channel 1 output trigger control register
#define FLEXPWM1_SM1DISPMAP0    *(unsigned short *)(FLEXPWM1_BLOCK + 0x08c)          // FlexPWM1 channel 1 fault disable mapping register 0
#define FLEXPWM1_SM1DISPMAP1    *(unsigned short *)(FLEXPWM1_BLOCK + 0x08e)          // FlexPWM1 channel 1 fault disable mapping register 1
#define FLEXPWM1_SM1DTCNT0      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x090) // FlexPWM1 channel 1 deadtime count register 0
#define FLEXPWM1_SM1DTCNT1      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x092) // FlexPWM1 channel 1 deadtime count register 1
#define FLEXPWM1_SM1CAPTCTRLA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x094)          // FlexPWM1 channel 1 capture control A register
#define FLEXPWM1_SM1CAPTCOMPA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x096)          // FlexPWM1 channel 1 capture compare A register
#define FLEXPWM1_SM1CAPTCTRLB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x098)          // FlexPWM1 channel 1 capture control B register
#define FLEXPWM1_SM1CAPTCOMPB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x09a)          // FlexPWM1 channel 1 capture compare B register
#define FLEXPWM1_SM1CAPTCTRLX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x09c)          // FlexPWM1 channel 1 capture control X register
#define FLEXPWM1_SM1CAPTCOMPX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x09e)          // FlexPWM1 channel 1 capture compare X register
#define FLEXPWM1_SM1CVAL0       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0a0) // FlexPWM1 channel 1 capture value 0 register (read-only)
#define FLEXPWM1_SM1CVAL0CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0a2) // FlexPWM1 channel 1 capture value 0 cycle register (read-only)
#define FLEXPWM1_SM1CVAL1       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0a4) // FlexPWM1 channel 1 capture value 1 register (read-only)
#define FLEXPWM1_SM1CVAL1CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0a6) // FlexPWM1 channel 1 capture value 1 cycle register (read-only)
#define FLEXPWM1_SM1CVAL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0a8) // FlexPWM1 channel 1 capture value 2 register (read-only)
#define FLEXPWM1_SM1CVAL2CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0aa) // FlexPWM1 channel 1 capture value 2 cycle register (read-only)
#define FLEXPWM1_SM1CVAL3       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0ac) // FlexPWM1 channel 1 capture value 3 register (read-only)
#define FLEXPWM1_SM1CVAL3CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0ae) // FlexPWM1 channel 1 capture value 3 cycle register (read-only)
#define FLEXPWM1_SM1CVAL4       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0b0) // FlexPWM1 channel 1 capture value 4 register (read-only)
#define FLEXPWM1_SM1CVAL4CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0b2) // FlexPWM1 channel 1 capture value 4 cycle register (read-only)
#define FLEXPWM1_SM1CVAL5       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0b4) // FlexPWM1 channel 1 capture value 5 register (read-only)
#define FLEXPWM1_SM1CVAL5CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0b6) // FlexPWM1 channel 1 capture value 5 cycle register (read-only)

#define FLEXPWM1_SM2CNT         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0c0) // FlexPWM1 channel 2 counter register (read-only)
#define FLEXPWM1_SM2INIT        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0c2) // FlexPWM1 channel 2 initial count register
#define FLEXPWM1_SM2CTRL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0c4) // FlexPWM1 channel 2 control 2 register
#define FLEXPWM1_SM2CTRL        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0c6) // FlexPWM1 channel 2 control register

#define FLEXPWM1_SM2VAL0        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0ca) // FlexPWM1 channel 2 value 0 register
#define FLEXPWM1_SM2FRACVAL1    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0cc) // FlexPWM1 channel 2 fractional value 1 register
#define FLEXPWM1_SM2VAL1        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0ce) // FlexPWM1 channel 2 value 1 register
#define FLEXPWM1_SM2FRACVAL2    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0d0) // FlexPWM1 channel 2 fractional value 2 register
#define FLEXPWM1_SM2VAL2        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0d2) // FlexPWM1 channel 2 value 2 register
#define FLEXPWM1_SM2FRACVAL3    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0d4) // FlexPWM1 channel 2 fractional value 3 register
#define FLEXPWM1_SM2VAL3        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0d6) // FlexPWM1 channel 2 value 3 register
#define FLEXPWM1_SM2FRACVAL4    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0d8) // FlexPWM1 channel 2 fractional value 4 register
#define FLEXPWM1_SM2VAL4        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0da) // FlexPWM1 channel 2 value 4 register
#define FLEXPWM1_SM2FRACVAL5    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0dc) // FlexPWM1 channel 2 fractional value 5 register
#define FLEXPWM1_SM2VAL5        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0de) // FlexPWM1 channel 2 value 5 register
#define FLEXPWM1_SM2FRCTRL      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0e0) // FlexPWM1 channel 2 fractional control register
#define FLEXPWM1_SM2OCTRL       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0e2) // FlexPWM1 channel 2 output control register
#define FLEXPWM1_SM2STS         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0e4) // FlexPWM1 channel 2 status register (write '1' to clear)
#define FLEXPWM1_SM2INTEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x0e6)          // FlexPWM1 channel 2 interrupt enable register
#define FLEXPWM1_SM2DMAEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x0e8)          // FlexPWM1 channel 2 DMA enable register
#define FLEXPWM1_SM2TCTRL       *(unsigned short *)(FLEXPWM1_BLOCK + 0x0ea)          // FlexPWM1 channel 2 output trigger control register
#define FLEXPWM1_SM2DISPMAP0    *(unsigned short *)(FLEXPWM1_BLOCK + 0x0ec)          // FlexPWM1 channel 2 fault disable mapping register 0
#define FLEXPWM1_SM2DISPMAP1    *(unsigned short *)(FLEXPWM1_BLOCK + 0x0ee)          // FlexPWM1 channel 2 fault disable mapping register 1
#define FLEXPWM1_SM2DTCNT0      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0f0) // FlexPWM1 channel 2 deadtime count register 0 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
#define FLEXPWM1_SM2DTCNT1      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x0f2) // FlexPWM1 channel 2 deadtime count register 1 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
#define FLEXPWM1_SM2CAPTCTRLA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x0f4)          // FlexPWM1 channel 2 capture control A register
#define FLEXPWM1_SM2CAPTCOMPA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x0f6)          // FlexPWM1 channel 2 capture compare A register
#define FLEXPWM1_SM2CAPTCTRLB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x0f8)          // FlexPWM1 channel 2 capture control B register
#define FLEXPWM1_SM2CAPTCOMPB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x0fa)          // FlexPWM1 channel 2 capture compare B register
#define FLEXPWM1_SM2CAPTCTRLX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x0fc)          // FlexPWM1 channel 2 capture control X register
#define FLEXPWM1_SM2CAPTCOMPX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x0fe)          // FlexPWM1 channel 2 capture compare X register
#define FLEXPWM1_SM2CVAL0       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x100) // FlexPWM1 channel 2 capture value 0 register (read-only)
#define FLEXPWM1_SM2CVAL0CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x102) // FlexPWM1 channel 2 capture value 0 cycle register (read-only)
#define FLEXPWM1_SM2CVAL1       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x104) // FlexPWM1 channel 2 capture value 1 register (read-only)
#define FLEXPWM1_SM2CVAL1CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x106) // FlexPWM1 channel 2 capture value 1 cycle register (read-only)
#define FLEXPWM1_SM2CVAL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x108) // FlexPWM1 channel 2 capture value 2 register (read-only)
#define FLEXPWM1_SM2CVAL2CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x10a) // FlexPWM1 channel 2 capture value 2 cycle register (read-only)
#define FLEXPWM1_SM2CVAL3       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x10c) // FlexPWM1 channel 2 capture value 3 register (read-only)
#define FLEXPWM1_SM2CVAL3CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x10e) // FlexPWM1 channel 2 capture value 3 cycle register (read-only)
#define FLEXPWM1_SM2CVAL4       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x110) // FlexPWM1 channel 2 capture value 4 register (read-only)
#define FLEXPWM1_SM2CVAL4CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x112) // FlexPWM1 channel 2 capture value 4 cycle register (read-only)
#define FLEXPWM1_SM2CVAL5       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x114) // FlexPWM1 channel 2 capture value 5 register (read-only)
#define FLEXPWM1_SM2CVAL5CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x116) // FlexPWM1 channel 2 capture value 5 cycle register (read-only)

#define FLEXPWM1_SM3CNT         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x120) // FlexPWM1 channel 3 counter register (read-only)
#define FLEXPWM1_SM3INIT        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x122) // FlexPWM1 channel 3 initial count register
#define FLEXPWM1_SM3CTRL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x124) // FlexPWM1 channel 3 control 2 register
#define FLEXPWM1_SM3CTRL        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x126) // FlexPWM1 channel 3 control register

#define FLEXPWM1_SM3VAL0        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x12a) // FlexPWM1 channel 3 value 0 register
#define FLEXPWM1_SM3FRACVAL1    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x12c) // FlexPWM1 channel 3 fractional value 1 register
#define FLEXPWM1_SM3VAL1        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x12e) // FlexPWM1 channel 3 value 1 register
#define FLEXPWM1_SM3FRACVAL2    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x130) // FlexPWM1 channel 3 fractional value 2 register
#define FLEXPWM1_SM3VAL2        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x132) // FlexPWM1 channel 3 value 2 register
#define FLEXPWM1_SM3FRACVAL3    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x134) // FlexPWM1 channel 3 fractional value 3 register
#define FLEXPWM1_SM3VAL3        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x136) // FlexPWM1 channel 3 value 3 register
#define FLEXPWM1_SM3FRACVAL4    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x138) // FlexPWM1 channel 3 fractional value 4 register
#define FLEXPWM1_SM3VAL4        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x13a) // FlexPWM1 channel 3 value 4 register
#define FLEXPWM1_SM3FRACVAL5    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x13c) // FlexPWM1 channel 3 fractional value 5 register
#define FLEXPWM1_SM3VAL5        *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x13e) // FlexPWM1 channel 3 value 5 register
#define FLEXPWM1_SM3FRCTRL      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x140) // FlexPWM1 channel 3 fractional control register
#define FLEXPWM1_SM3OCTRL       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x142) // FlexPWM1 channel 3 output control register
#define FLEXPWM1_SM3STS         *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x144) // FlexPWM1 channel 3 status register (write '1' to clear)
#define FLEXPWM1_SM3INTEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x146)          // FlexPWM1 channel 3 interrupt enable register
#define FLEXPWM1_SM3DMAEN       *(unsigned short *)(FLEXPWM1_BLOCK + 0x148)          // FlexPWM1 channel 3 DMA enable register
#define FLEXPWM1_SM3TCTRL       *(unsigned short *)(FLEXPWM1_BLOCK + 0x14a)          // FlexPWM1 channel 3 output trigger control register
#define FLEXPWM1_SM3DISPMAP0    *(unsigned short *)(FLEXPWM1_BLOCK + 0x14c)          // FlexPWM1 channel 3 fault disable mapping register 0
#define FLEXPWM1_SM3DISPMAP1    *(unsigned short *)(FLEXPWM1_BLOCK + 0x14e)          // FlexPWM1 channel 3 fault disable mapping register 1
#define FLEXPWM1_SM3DTCNT0      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x150) // FlexPWM1 channel 3 deadtime count register 0
#define FLEXPWM1_SM3DTCNT1      *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x152) // FlexPWM1 channel 3 deadtime count register 1
#define FLEXPWM1_SM3CAPTCTRLA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x154)          // FlexPWM1 channel 3 capture control A register
#define FLEXPWM1_SM3CAPTCOMPA   *(unsigned short *)(FLEXPWM1_BLOCK + 0x156)          // FlexPWM1 channel 3 capture compare A register
#define FLEXPWM1_SM3CAPTCTRLB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x158)          // FlexPWM1 channel 3 capture control B register
#define FLEXPWM1_SM3CAPTCOMPB   *(unsigned short *)(FLEXPWM1_BLOCK + 0x15a)          // FlexPWM1 channel 3 capture compare B register
#define FLEXPWM1_SM3CAPTCTRLX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x15c)          // FlexPWM1 channel 3 capture control X register
#define FLEXPWM1_SM3CAPTCOMPX   *(unsigned short *)(FLEXPWM1_BLOCK + 0x15e)          // FlexPWM1 channel 3 capture compare X register
#define FLEXPWM1_SM3CVAL0       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x160) // FlexPWM1 channel 3 capture value 0 register (read-only)
#define FLEXPWM1_SM3CVAL0CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x162) // FlexPWM1 channel 3 capture value 0 cycle register (read-only)
#define FLEXPWM1_SM3CVAL1       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x164) // FlexPWM1 channel 3 capture value 1 register (read-only)
#define FLEXPWM1_SM3CVAL1CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x166) // FlexPWM1 channel 3 capture value 1 cycle register (read-only)
#define FLEXPWM1_SM3CVAL2       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x168) // FlexPWM1 channel 3 capture value 2 register (read-only)
#define FLEXPWM1_SM3CVAL2CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x16a) // FlexPWM1 channel 3 capture value 2 cycle register (read-only)
#define FLEXPWM1_SM3CVAL3       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x16c) // FlexPWM1 channel 3 capture value 3 register (read-only)
#define FLEXPWM1_SM3CVAL3CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x16e) // FlexPWM1 channel 3 capture value 3 cycle register (read-only)
#define FLEXPWM1_SM3CVAL4       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x170) // FlexPWM1 channel 3 capture value 4 register (read-only)
#define FLEXPWM1_SM3CVAL4CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x172) // FlexPWM1 channel 3 capture value 4 cycle register (read-only)
#define FLEXPWM1_SM3CVAL5       *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x174) // FlexPWM1 channel 3 capture value 5 register (read-only)
#define FLEXPWM1_SM3CVAL5CYC    *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x176) // FlexPWM1 channel 3 capture value 5 cycle register (read-only)

#define FLEXPWM1_OUTEN          *(unsigned short *)(FLEXPWM1_BLOCK + 0x180)          // FlexPWM1 output enable register
    #define FLEXPWM_OUTEN_PWMX_EN_0  00x001
    #define FLEXPWM_OUTEN_PWMX_EN_1  00x002
    #define FLEXPWM_OUTEN_PWMX_EN_2  00x004
    #define FLEXPWM_OUTEN_PWMX_EN_3  00x008
    #define FLEXPWM_OUTEN_PWMB_EN_0  0x0010
    #define FLEXPWM_OUTEN_PWMB_EN_1  0x0020
    #define FLEXPWM_OUTEN_PWMB_EN_2  0x0040
    #define FLEXPWM_OUTEN_PWMB_EN_3  0x0080
    #define FLEXPWM_OUTEN_PWMA_EN_0  0x0100
    #define FLEXPWM_OUTEN_PWMA_EN_1  0x0200
    #define FLEXPWM_OUTEN_PWMA_EN_2  0x0400
    #define FLEXPWM_OUTEN_PWMA_EN_3  0x0800
#define FLEXPWM1_MASK           *(unsigned short *)(FLEXPWM1_BLOCK + 0x182)          // FlexPWM1 mask register
#define FLEXPWM1_SWCOUT         *(unsigned short *)(FLEXPWM1_BLOCK + 0x184)          // FlexPWM1 software controlled output register
#define FLEXPWM1_DTSRCSEL       *(unsigned short *)(FLEXPWM1_BLOCK + 0x186)          // FlexPWM1 PWM select source register
#define FLEXPWM1_MCTRL          *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x188) // FlexPWM1 master control register
    #define FLEXPWM_MCTRL_LDOK_0  0x0001                                 // load OK
    #define FLEXPWM_MCTRL_LDOK_1  0x0002
    #define FLEXPWM_MCTRL_LDOK_2  0x0004
    #define FLEXPWM_MCTRL_LDOK_3  0x0008
    #define FLEXPWM_MCTRL_CLDOK_0 0x0010                                 // clear load OK (reads as '0')
    #define FLEXPWM_MCTRL_CLDOK_1 0x0020
    #define FLEXPWM_MCTRL_CLDOK_2 0x0040
    #define FLEXPWM_MCTRL_CLDOK_3 0x0080
    #define FLEXPWM_MCTRL_RUN_0   0x0100                                 // allow channel to run
    #define FLEXPWM_MCTRL_RUN_1   0x0200
    #define FLEXPWM_MCTRL_RUN_2   0x0400
    #define FLEXPWM_MCTRL_RUN_3   0x0800
    #define FLEXPWM_MCTRL_IPOL_0  0x1000                                 // current polarity - PWN45 is used to generate complementary PWM pair, rather than PWM23
    #define FLEXPWM_MCTRL_IPOL_1  0x2000
    #define FLEXPWM_MCTRL_IPOL_2  0x4000
    #define FLEXPWM_MCTRL_IPOL_3  0x8000
#define FLEXPWM1_MCTRL2         *(unsigned short *)(FLEXPWM1_BLOCK + 0x18a)          // FlexPWM1 master control register 2
#define FLEXPWM1_FCTRL0         *(unsigned short *)(FLEXPWM1_BLOCK + 0x18c)          // FlexPWM1 fault control register
    #define FLEXPWM_FCTRL0_FIE_0  0x0001                                 // fault 0 interrup enable
    #define FLEXPWM_FCTRL0_FIE_1  0x0002                                 // fault 1 interrup enable
    #define FLEXPWM_FCTRL0_FIE_2  0x0004                                 // fault 2 interrup enable
    #define FLEXPWM_FCTRL0_FIE_3  0x0008                                 // fault 3 interrup enable
    #define FLEXPWM_FCTRL0_FLVL_0 0x1000                                 // fault level '1' indicates fault on FAULT_0
    #define FLEXPWM_FCTRL0_FLVL_1 0x2000                                 // fault level '1' indicates fault on FAULT_1
    #define FLEXPWM_FCTRL0_FLVL_2 0x4000                                 // fault level '1' indicates fault on FAULT_2
    #define FLEXPWM_FCTRL0_FLVL_3 0x8000                                 // fault level '1' indicates fault on FAULT_3
#define FLEXPWM1_FSTS0          *(volatile unsigned short *)(FLEXPWM1_BLOCK + 0x18e) // FlexPWM1 fault status register (write '1' to clear)
    #define FLEXPWM_FSTS0_FFLAG_0 0x0001                                             // fault flag 0 (write '1' to clear)
    #define FLEXPWM_FSTS0_FFLAG_1 0x0002                                             // fault flag 1 (write '1' to clear)
    #define FLEXPWM_FSTS0_FFLAG_2 0x0004                                             // fault flag 2 (write '1' to clear)
    #define FLEXPWM_FSTS0_FFLAG_3 0x0008                                             // fault flag 3 (write '1' to clear)
#define FLEXPWM1_FFILT0         *(unsigned short *)(FLEXPWM1_BLOCK + 0x190)          // FlexPWM1 fault filter register
#define FLEXPWM1_FTST0          *(unsigned short *)(FLEXPWM1_BLOCK + 0x192)          // FlexPWM1 fault test register
#define FLEXPWM1_FCTRL20        *(unsigned short *)(FLEXPWM1_BLOCK + 0x194)          // FlexPWM1 fault control 2 register

#if FLEXPWM_AVAILABLE > 1
    #define FLEXPWM2_SM0CNT         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x000) // FlexPWM2 channel 0 counter register (read-only)
    #define FLEXPWM2_SM0INIT        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x002) // FlexPWM2 channel 0 initial count register
    #define FLEXPWM2_SM0CTRL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x004) // FlexPWM2 channel 0 control 2 register
    #define FLEXPWM2_SM0CTRL        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x006) // FlexPWM2 channel 0 control register

    #define FLEXPWM2_SM0VAL0        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x00a) // FlexPWM2 channel 0 value 0 register
    #define FLEXPWM2_SM0FRACVAL1    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x00c) // FlexPWM2 channel 0 fractional value 1 register
    #define FLEXPWM2_SM0VAL1        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x00e) // FlexPWM2 channel 0 value 1 register
    #define FLEXPWM2_SM0FRACVAL2    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x010) // FlexPWM2 channel 0 fractional value 2 register
    #define FLEXPWM2_SM0VAL2        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x012) // FlexPWM2 channel 0 value 2 register
    #define FLEXPWM2_SM0FRACVAL3    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x014) // FlexPWM2 channel 0 fractional value 3 register
    #define FLEXPWM2_SM0VAL3        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x016) // FlexPWM2 channel 0 value 3 register
    #define FLEXPWM2_SM0FRACVAL4    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x018) // FlexPWM2 channel 0 fractional value 4 register
    #define FLEXPWM2_SM0VAL4        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x01a) // FlexPWM2 channel 0 value 4 register
    #define FLEXPWM2_SM0FRACVAL5    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x01c) // FlexPWM2 channel 0 fractional value 5 register
    #define FLEXPWM2_SM0VAL5        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x01e) // FlexPWM2 channel 0 value 5 register
    #define FLEXPWM2_SM0FRCTRL      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x020) // FlexPWM2 channel 0 fractional control register
    #define FLEXPWM2_SM0OCTRL       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x022) // FlexPWM2 channel 0 output control register
    #define FLEXPWM2_SM0STS         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x024) // FlexPWM2 channel 0 status register (write '1' to clear)
    #define FLEXPWM2_SM0INTEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x026)          // FlexPWM2 channel 0 interrupt enable register
    #define FLEXPWM2_SM0DMAEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x028)          // FlexPWM2 channel 0 DMA enable register
    #define FLEXPWM2_SM0TCTRL       *(unsigned short *)(FLEXPWM2_BLOCK + 0x02a)          // FlexPWM2 channel 0 output trigger control register
    #define FLEXPWM2_SM0DISPMAP0    *(unsigned short *)(FLEXPWM2_BLOCK + 0x02c)          // FlexPWM2 channel 0 fault disable mapping register 0
    #define FLEXPWM2_SM0DISPMAP1    *(unsigned short *)(FLEXPWM2_BLOCK + 0x02e)          // FlexPWM2 channel 0 fault disable mapping register 1
    #define FLEXPWM2_SM0DTCNT0      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x030) // FlexPWM2 channel 0 deadtime count register 0
    #define FLEXPWM2_SM0DTCNT1      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x032) // FlexPWM2 channel 0 deadtime count register 1
    #define FLEXPWM2_SM0CAPTCTRLA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x034)          // FlexPWM2 channel 0 capture control A register
    #define FLEXPWM2_SM0CAPTCOMPA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x036)          // FlexPWM2 channel 0 capture compare A register
    #define FLEXPWM2_SM0CAPTCTRLB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x038)          // FlexPWM2 channel 0 capture control B register
    #define FLEXPWM2_SM0CAPTCOMPB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x03a)          // FlexPWM2 channel 0 capture compare B register
    #define FLEXPWM2_SM0CAPTCTRLX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x03c)          // FlexPWM2 channel 0 capture control X register
    #define FLEXPWM2_SM0CAPTCOMPX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x03e)          // FlexPWM2 channel 0 capture compare X register
    #define FLEXPWM2_SM0CVAL0       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x040) // FlexPWM2 channel 0 capture value 0 register (read-only)
    #define FLEXPWM2_SM0CVAL0CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x042) // FlexPWM2 channel 0 capture value 0 cycle register (read-only)
    #define FLEXPWM2_SM0CVAL1       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x044) // FlexPWM2 channel 0 capture value 1 register (read-only)
    #define FLEXPWM2_SM0CVAL1CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x046) // FlexPWM2 channel 0 capture value 1 cycle register (read-only)
    #define FLEXPWM2_SM0CVAL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x048) // FlexPWM2 channel 0 capture value 2 register (read-only)
    #define FLEXPWM2_SM0CVAL2CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x04a) // FlexPWM2 channel 0 capture value 2 cycle register (read-only)
    #define FLEXPWM2_SM0CVAL3       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x04c) // FlexPWM2 channel 0 capture value 3 register (read-only)
    #define FLEXPWM2_SM0CVAL3CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x04e) // FlexPWM2 channel 0 capture value 3 cycle register (read-only)
    #define FLEXPWM2_SM0CVAL4       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x050) // FlexPWM2 channel 0 capture value 4 register (read-only)
    #define FLEXPWM2_SM0CVAL4CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x052) // FlexPWM2 channel 0 capture value 4 cycle register (read-only)
    #define FLEXPWM2_SM0CVAL5       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x054) // FlexPWM2 channel 0 capture value 5 register (read-only)
    #define FLEXPWM2_SM0CVAL5CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x056) // FlexPWM2 channel 0 capture value 5 cycle register (read-only)

    #define FLEXPWM2_SM1CNT         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x060) // FlexPWM2 channel 1 counter register (read-only)
    #define FLEXPWM2_SM1INIT        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x062) // FlexPWM2 channel 1 initial count register
    #define FLEXPWM2_SM1CTRL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x064) // FlexPWM2 channel 1 control 2 register
    #define FLEXPWM2_SM1CTRL        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x066) // FlexPWM2 channel 1 control register

    #define FLEXPWM2_SM1VAL0        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x06a) // FlexPWM2 channel 1 value 0 register
    #define FLEXPWM2_SM1FRACVAL1    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x06c) // FlexPWM2 channel 1 fractional value 1 register
    #define FLEXPWM2_SM1VAL1        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x06e) // FlexPWM2 channel 1 value 1 register
    #define FLEXPWM2_SM1FRACVAL2    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x070) // FlexPWM2 channel 1 fractional value 2 register
    #define FLEXPWM2_SM1VAL2        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x072) // FlexPWM2 channel 1 value 2 register
    #define FLEXPWM2_SM1FRACVAL3    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x074) // FlexPWM2 channel 1 fractional value 3 register
    #define FLEXPWM2_SM1VAL3        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x076) // FlexPWM2 channel 1 value 3 register
    #define FLEXPWM2_SM1FRACVAL4    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x078) // FlexPWM2 channel 1 fractional value 4 register
    #define FLEXPWM2_SM1VAL4        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x07a) // FlexPWM2 channel 1 value 4 register
    #define FLEXPWM2_SM1FRACVAL5    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x07c) // FlexPWM2 channel 1 fractional value 5 register
    #define FLEXPWM2_SM1VAL5        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x07e) // FlexPWM2 channel 1 value 5 register
    #define FLEXPWM2_SM1FRCTRL      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x080) // FlexPWM2 channel 1 fractional control register
    #define FLEXPWM2_SM1OCTRL       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x082) // FlexPWM2 channel 1 output control register
    #define FLEXPWM2_SM1STS         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x084) // FlexPWM2 channel 1 status register (write '1' to clear)
    #define FLEXPWM2_SM1INTEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x086)          // FlexPWM2 channel 1 interrupt enable register
    #define FLEXPWM2_SM1DMAEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x088)          // FlexPWM2 channel 1 DMA enable register
    #define FLEXPWM2_SM1TCTRL       *(unsigned short *)(FLEXPWM2_BLOCK + 0x08a)          // FlexPWM2 channel 1 output trigger control register
    #define FLEXPWM2_SM1DISPMAP0    *(unsigned short *)(FLEXPWM2_BLOCK + 0x08c)          // FlexPWM2 channel 1 fault disable mapping register 0
    #define FLEXPWM2_SM1DISPMAP1    *(unsigned short *)(FLEXPWM2_BLOCK + 0x08e)          // FlexPWM2 channel 1 fault disable mapping register 1
    #define FLEXPWM2_SM1DTCNT0      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x090) // FlexPWM2 channel 1 deadtime count register 0 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
    #define FLEXPWM2_SM1DTCNT1      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x092) // FlexPWM2 channel 1 deadtime count register 1 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
    #define FLEXPWM2_SM1CAPTCTRLA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x094)          // FlexPWM2 channel 1 capture control A register
    #define FLEXPWM2_SM1CAPTCOMPA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x096)          // FlexPWM2 channel 1 capture compare A register
    #define FLEXPWM2_SM1CAPTCTRLB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x098)          // FlexPWM2 channel 1 capture control B register
    #define FLEXPWM2_SM1CAPTCOMPB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x09a)          // FlexPWM2 channel 1 capture compare B register
    #define FLEXPWM2_SM1CAPTCTRLX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x09c)          // FlexPWM2 channel 1 capture control X register
    #define FLEXPWM2_SM1CAPTCOMPX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x09e)          // FlexPWM2 channel 1 capture compare X register
    #define FLEXPWM2_SM1CVAL0       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0a0) // FlexPWM2 channel 1 capture value 0 register (read-only)
    #define FLEXPWM2_SM1CVAL0CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0a2) // FlexPWM2 channel 1 capture value 0 cycle register (read-only)
    #define FLEXPWM2_SM1CVAL1       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0a4) // FlexPWM2 channel 1 capture value 1 register (read-only)
    #define FLEXPWM2_SM1CVAL1CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0a6) // FlexPWM2 channel 1 capture value 1 cycle register (read-only)
    #define FLEXPWM2_SM1CVAL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0a8) // FlexPWM2 channel 1 capture value 2 register (read-only)
    #define FLEXPWM2_SM1CVAL2CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0aa) // FlexPWM2 channel 1 capture value 2 cycle register (read-only)
    #define FLEXPWM2_SM1CVAL3       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0ac) // FlexPWM2 channel 1 capture value 3 register (read-only)
    #define FLEXPWM2_SM1CVAL3CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0ae) // FlexPWM2 channel 1 capture value 3 cycle register (read-only)
    #define FLEXPWM2_SM1CVAL4       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0b0) // FlexPWM2 channel 1 capture value 4 register (read-only)
    #define FLEXPWM2_SM1CVAL4CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0b2) // FlexPWM2 channel 1 capture value 4 cycle register (read-only)
    #define FLEXPWM2_SM1CVAL5       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0b4) // FlexPWM2 channel 1 capture value 5 register (read-only)
    #define FLEXPWM2_SM1CVAL5CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0b6) // FlexPWM2 channel 1 capture value 5 cycle register (read-only)

    #define FLEXPWM2_SM2CNT         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0c0) // FlexPWM2 channel 2 counter register (read-only)
    #define FLEXPWM2_SM2INIT        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0c2) // FlexPWM2 channel 2 initial count register
    #define FLEXPWM2_SM2CTRL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0c4) // FlexPWM2 channel 2 control 2 register
    #define FLEXPWM2_SM2CTRL        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0c6) // FlexPWM2 channel 2 control register

    #define FLEXPWM2_SM2VAL0        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0ca) // FlexPWM2 channel 2 value 0 register
    #define FLEXPWM2_SM2FRACVAL1    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0cc) // FlexPWM2 channel 2 fractional value 1 register
    #define FLEXPWM2_SM2VAL1        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0ce) // FlexPWM2 channel 2 value 1 register
    #define FLEXPWM2_SM2FRACVAL2    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0d0) // FlexPWM2 channel 2 fractional value 2 register
    #define FLEXPWM2_SM2VAL2        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0d2) // FlexPWM2 channel 2 value 2 register
    #define FLEXPWM2_SM2FRACVAL3    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0d4) // FlexPWM2 channel 2 fractional value 3 register
    #define FLEXPWM2_SM2VAL3        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0d6) // FlexPWM2 channel 2 value 3 register
    #define FLEXPWM2_SM2FRACVAL4    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0d8) // FlexPWM2 channel 2 fractional value 4 register
    #define FLEXPWM2_SM2VAL4        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0da) // FlexPWM2 channel 2 value 4 register
    #define FLEXPWM2_SM2FRACVAL5    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0dc) // FlexPWM2 channel 2 fractional value 5 register
    #define FLEXPWM2_SM2VAL5        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0de) // FlexPWM2 channel 2 value 5 register
    #define FLEXPWM2_SM2FRCTRL      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0e0) // FlexPWM2 channel 2 fractional control register
    #define FLEXPWM2_SM2OCTRL       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0e2) // FlexPWM2 channel 2 output control register
    #define FLEXPWM2_SM2STS         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0e4) // FlexPWM2 channel 2 status register (write '1' to clear)
    #define FLEXPWM2_SM2INTEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x0e6)          // FlexPWM2 channel 2 interrupt enable register
    #define FLEXPWM2_SM2DMAEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x0e8)          // FlexPWM2 channel 2 DMA enable register
    #define FLEXPWM2_SM2TCTRL       *(unsigned short *)(FLEXPWM2_BLOCK + 0x0ea)          // FlexPWM2 channel 2 output trigger control register
    #define FLEXPWM2_SM2DISPMAP0    *(unsigned short *)(FLEXPWM2_BLOCK + 0x0ec)          // FlexPWM2 channel 2 fault disable mapping register 0
    #define FLEXPWM2_SM2DISPMAP1    *(unsigned short *)(FLEXPWM2_BLOCK + 0x0ee)          // FlexPWM2 channel 2 fault disable mapping register 1
    #define FLEXPWM2_SM2DTCNT0      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0f0) // FlexPWM2 channel 2 deadtime count register 0
    #define FLEXPWM2_SM2DTCNT1      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x0f2) // FlexPWM2 channel 2 deadtime count register 1
    #define FLEXPWM2_SM2CAPTCTRLA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x0f4)          // FlexPWM2 channel 2 capture control A register
    #define FLEXPWM2_SM2CAPTCOMPA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x0f6)          // FlexPWM2 channel 2 capture compare A register
    #define FLEXPWM2_SM2CAPTCTRLB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x0f8)          // FlexPWM2 channel 2 capture control B register
    #define FLEXPWM2_SM2CAPTCOMPB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x0fa)          // FlexPWM2 channel 2 capture compare B register
    #define FLEXPWM2_SM2CAPTCTRLX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x0fc)          // FlexPWM2 channel 2 capture control X register
    #define FLEXPWM2_SM2CAPTCOMPX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x0fe)          // FlexPWM2 channel 2 capture compare X register
    #define FLEXPWM2_SM2CVAL0       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x100) // FlexPWM2 channel 2 capture value 0 register (read-only)
    #define FLEXPWM2_SM2CVAL0CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x102) // FlexPWM2 channel 2 capture value 0 cycle register (read-only)
    #define FLEXPWM2_SM2CVAL1       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x104) // FlexPWM2 channel 2 capture value 1 register (read-only)
    #define FLEXPWM2_SM2CVAL1CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x106) // FlexPWM2 channel 2 capture value 1 cycle register (read-only)
    #define FLEXPWM2_SM2CVAL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x108) // FlexPWM2 channel 2 capture value 2 register (read-only)
    #define FLEXPWM2_SM2CVAL2CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x10a) // FlexPWM2 channel 2 capture value 2 cycle register (read-only)
    #define FLEXPWM2_SM2CVAL3       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x10c) // FlexPWM2 channel 2 capture value 3 register (read-only)
    #define FLEXPWM2_SM2CVAL3CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x10e) // FlexPWM2 channel 2 capture value 3 cycle register (read-only)
    #define FLEXPWM2_SM2CVAL4       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x110) // FlexPWM2 channel 2 capture value 4 register (read-only)
    #define FLEXPWM2_SM2CVAL4CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x112) // FlexPWM2 channel 2 capture value 4 cycle register (read-only)
    #define FLEXPWM2_SM2CVAL5       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x114) // FlexPWM2 channel 2 capture value 5 register (read-only)
    #define FLEXPWM2_SM2CVAL5CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x116) // FlexPWM2 channel 2 capture value 5 cycle register (read-only)

    #define FLEXPWM2_SM3CNT         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x120) // FlexPWM2 channel 3 counter register (read-only)
    #define FLEXPWM2_SM3INIT        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x122) // FlexPWM2 channel 3 initial count register
    #define FLEXPWM2_SM3CTRL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x124) // FlexPWM2 channel 3 control 2 register
    #define FLEXPWM2_SM3CTRL        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x126) // FlexPWM2 channel 3 control register

    #define FLEXPWM2_SM3VAL0        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x12a) // FlexPWM2 channel 3 value 0 register
    #define FLEXPWM2_SM3FRACVAL1    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x12c) // FlexPWM2 channel 3 fractional value 1 register
    #define FLEXPWM2_SM3VAL1        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x12e) // FlexPWM2 channel 3 value 1 register
    #define FLEXPWM2_SM3FRACVAL2    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x130) // FlexPWM2 channel 3 fractional value 2 register
    #define FLEXPWM2_SM3VAL2        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x132) // FlexPWM2 channel 3 value 2 register
    #define FLEXPWM2_SM3FRACVAL3    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x134) // FlexPWM2 channel 3 fractional value 3 register
    #define FLEXPWM2_SM3VAL3        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x136) // FlexPWM2 channel 3 value 3 register
    #define FLEXPWM2_SM3FRACVAL4    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x138) // FlexPWM2 channel 3 fractional value 4 register
    #define FLEXPWM2_SM3VAL4        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x13a) // FlexPWM2 channel 3 value 4 register
    #define FLEXPWM2_SM3FRACVAL5    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x13c) // FlexPWM2 channel 3 fractional value 5 register
    #define FLEXPWM2_SM3VAL5        *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x13e) // FlexPWM2 channel 3 value 5 register
    #define FLEXPWM2_SM3FRCTRL      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x140) // FlexPWM2 channel 3 fractional control register
    #define FLEXPWM2_SM3OCTRL       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x142) // FlexPWM2 channel 3 output control register
    #define FLEXPWM2_SM3STS         *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x144) // FlexPWM2 channel 3 status register (write '1' to clear)
    #define FLEXPWM2_SM3INTEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x146)          // FlexPWM2 channel 3 interrupt enable register
    #define FLEXPWM2_SM3DMAEN       *(unsigned short *)(FLEXPWM2_BLOCK + 0x148)          // FlexPWM2 channel 3 DMA enable register
    #define FLEXPWM2_SM3TCTRL       *(unsigned short *)(FLEXPWM2_BLOCK + 0x14a)          // FlexPWM2 channel 3 output trigger control register
    #define FLEXPWM2_SM3DISPMAP0    *(unsigned short *)(FLEXPWM2_BLOCK + 0x14c)          // FlexPWM2 channel 3 fault disable mapping register 0
    #define FLEXPWM2_SM3DISPMAP1    *(unsigned short *)(FLEXPWM2_BLOCK + 0x14e)          // FlexPWM2 channel 3 fault disable mapping register 1
    #define FLEXPWM2_SM3DTCNT0      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x150) // FlexPWM2 channel 3 deadtime count register 0
    #define FLEXPWM2_SM3DTCNT1      *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x152) // FlexPWM2 channel 3 deadtime count register 1
    #define FLEXPWM2_SM3CAPTCTRLA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x154)          // FlexPWM2 channel 3 capture control A register
    #define FLEXPWM2_SM3CAPTCOMPA   *(unsigned short *)(FLEXPWM2_BLOCK + 0x156)          // FlexPWM2 channel 3 capture compare A register
    #define FLEXPWM2_SM3CAPTCTRLB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x158)          // FlexPWM2 channel 3 capture control B register
    #define FLEXPWM2_SM3CAPTCOMPB   *(unsigned short *)(FLEXPWM2_BLOCK + 0x15a)          // FlexPWM2 channel 3 capture compare B register
    #define FLEXPWM2_SM3CAPTCTRLX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x15c)          // FlexPWM2 channel 3 capture control X register
    #define FLEXPWM2_SM3CAPTCOMPX   *(unsigned short *)(FLEXPWM2_BLOCK + 0x15e)          // FlexPWM2 channel 3 capture compare X register
    #define FLEXPWM2_SM3CVAL0       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x160) // FlexPWM2 channel 3 capture value 0 register (read-only)
    #define FLEXPWM2_SM3CVAL0CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x162) // FlexPWM2 channel 3 capture value 0 cycle register (read-only)
    #define FLEXPWM2_SM3CVAL1       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x164) // FlexPWM2 channel 3 capture value 1 register (read-only)
    #define FLEXPWM2_SM3CVAL1CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x166) // FlexPWM2 channel 3 capture value 1 cycle register (read-only)
    #define FLEXPWM2_SM3CVAL2       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x168) // FlexPWM2 channel 3 capture value 2 register (read-only)
    #define FLEXPWM2_SM3CVAL2CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x16a) // FlexPWM2 channel 3 capture value 2 cycle register (read-only)
    #define FLEXPWM2_SM3CVAL3       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x16c) // FlexPWM2 channel 3 capture value 3 register (read-only)
    #define FLEXPWM2_SM3CVAL3CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x16e) // FlexPWM2 channel 3 capture value 3 cycle register (read-only)
    #define FLEXPWM2_SM3CVAL4       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x170) // FlexPWM2 channel 3 capture value 4 register (read-only)
    #define FLEXPWM2_SM3CVAL4CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x172) // FlexPWM2 channel 3 capture value 4 cycle register (read-only)
    #define FLEXPWM2_SM3CVAL5       *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x174) // FlexPWM2 channel 3 capture value 5 register (read-only)
    #define FLEXPWM2_SM3CVAL5CYC    *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x176) // FlexPWM2 channel 3 capture value 5 cycle register (read-only)

    #define FLEXPWM2_OUTEN          *(unsigned short *)(FLEXPWM2_BLOCK + 0x180)          // FlexPWM2 output enable register
    #define FLEXPWM2_MASK           *(unsigned short *)(FLEXPWM2_BLOCK + 0x182)          // FlexPWM2 mask register
    #define FLEXPWM2_SWCOUT         *(unsigned short *)(FLEXPWM2_BLOCK + 0x184)          // FlexPWM2 software controlled output register
    #define FLEXPWM2_DTSRCSEL       *(unsigned short *)(FLEXPWM2_BLOCK + 0x186)          // FlexPWM2 PWM select source register
    #define FLEXPWM2_MCTRL          *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x188) // FlexPWM2 master control register
    #define FLEXPWM2_MCTRL2         *(unsigned short *)(FLEXPWM2_BLOCK + 0x18a)          // FlexPWM2 master control register 2
    #define FLEXPWM2_FCTRL0         *(unsigned short *)(FLEXPWM2_BLOCK + 0x18c)          // FlexPWM2 fault control register
    #define FLEXPWM2_FSTS0          *(volatile unsigned short *)(FLEXPWM2_BLOCK + 0x18e) // FlexPWM2 fault status register
    #define FLEXPWM2_FFILT0         *(unsigned short *)(FLEXPWM2_BLOCK + 0x190)          // FlexPWM2 fault filter register
    #define FLEXPWM2_FTST0          *(unsigned short *)(FLEXPWM2_BLOCK + 0x192)          // FlexPWM2 fault test register
    #define FLEXPWM2_FCTRL20        *(unsigned short *)(FLEXPWM2_BLOCK + 0x194)          // FlexPWM2 fault control 2 register
#endif
#if FLEXPWM_AVAILABLE > 2
    #define FLEXPWM3_SM0CNT         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x000) // FlexPWM3 channel 0 counter register (read-only)
    #define FLEXPWM3_SM0INIT        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x002) // FlexPWM3 channel 0 initial count register
    #define FLEXPWM3_SM0CTRL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x004) // FlexPWM3 channel 0 control 2 register
    #define FLEXPWM3_SM0CTRL        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x006) // FlexPWM3 channel 0 control register

    #define FLEXPWM3_SM0VAL0        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x00a) // FlexPWM3 channel 0 value 0 register
    #define FLEXPWM3_SM0FRACVAL1    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x00c) // FlexPWM3 channel 0 fractional value 1 register
    #define FLEXPWM3_SM0VAL1        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x00e) // FlexPWM3 channel 0 value 1 register
    #define FLEXPWM3_SM0FRACVAL2    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x010) // FlexPWM3 channel 0 fractional value 2 register
    #define FLEXPWM3_SM0VAL2        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x012) // FlexPWM3 channel 0 value 2 register
    #define FLEXPWM3_SM0FRACVAL3    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x014) // FlexPWM3 channel 0 fractional value 3 register
    #define FLEXPWM3_SM0VAL3        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x016) // FlexPWM3 channel 0 value 3 register
    #define FLEXPWM3_SM0FRACVAL4    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x018) // FlexPWM3 channel 0 fractional value 4 register
    #define FLEXPWM3_SM0VAL4        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x01a) // FlexPWM3 channel 0 value 4 register
    #define FLEXPWM3_SM0FRACVAL5    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x01c) // FlexPWM3 channel 0 fractional value 5 register
    #define FLEXPWM3_SM0VAL5        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x01e) // FlexPWM3 channel 0 value 5 register
    #define FLEXPWM3_SM0FRCTRL      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x020) // FlexPWM3 channel 0 fractional control register
    #define FLEXPWM3_SM0OCTRL       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x022) // FlexPWM3 channel 0 output control register
    #define FLEXPWM3_SM0STS         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x024) // FlexPWM3 channel 0 status register (write '1' to clear)
    #define FLEXPWM3_SM0INTEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x026)          // FlexPWM3 channel 0 interrupt enable register
    #define FLEXPWM3_SM0DMAEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x028)          // FlexPWM3 channel 0 DMA enable register
    #define FLEXPWM3_SM0TCTRL       *(unsigned short *)(FLEXPWM3_BLOCK + 0x02a)          // FlexPWM3 channel 0 output trigger control register
    #define FLEXPWM3_SM0DISPMAP0    *(unsigned short *)(FLEXPWM3_BLOCK + 0x02c)          // FlexPWM3 channel 0 fault disable mapping register 0
    #define FLEXPWM3_SM0DISPMAP1    *(unsigned short *)(FLEXPWM3_BLOCK + 0x02e)          // FlexPWM3 channel 0 fault disable mapping register 1
    #define FLEXPWM3_SM0DTCNT0      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x030) // FlexPWM3 channel 0 deadtime count register 0
    #define FLEXPWM3_SM0DTCNT1      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x032) // FlexPWM3 channel 0 deadtime count register 1
    #define FLEXPWM3_SM0CAPTCTRLA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x034)          // FlexPWM3 channel 0 capture control A register
    #define FLEXPWM3_SM0CAPTCOMPA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x036)          // FlexPWM3 channel 0 capture compare A register
    #define FLEXPWM3_SM0CAPTCTRLB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x038)          // FlexPWM3 channel 0 capture control B register
    #define FLEXPWM3_SM0CAPTCOMPB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x03a)          // FlexPWM3 channel 0 capture compare B register
    #define FLEXPWM3_SM0CAPTCTRLX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x03c)          // FlexPWM3 channel 0 capture control X register
    #define FLEXPWM3_SM0CAPTCOMPX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x03e)          // FlexPWM3 channel 0 capture compare X register
    #define FLEXPWM3_SM0CVAL0       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x040) // FlexPWM3 channel 0 capture value 0 register (read-only)
    #define FLEXPWM3_SM0CVAL0CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x042) // FlexPWM3 channel 0 capture value 0 cycle register (read-only)
    #define FLEXPWM3_SM0CVAL1       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x044) // FlexPWM3 channel 0 capture value 1 register (read-only)
    #define FLEXPWM3_SM0CVAL1CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x046) // FlexPWM3 channel 0 capture value 1 cycle register (read-only)
    #define FLEXPWM3_SM0CVAL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x048) // FlexPWM3 channel 0 capture value 2 register (read-only)
    #define FLEXPWM3_SM0CVAL2CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x04a) // FlexPWM3 channel 0 capture value 2 cycle register (read-only)
    #define FLEXPWM3_SM0CVAL3       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x04c) // FlexPWM3 channel 0 capture value 3 register (read-only)
    #define FLEXPWM3_SM0CVAL3CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x04e) // FlexPWM3 channel 0 capture value 3 cycle register (read-only)
    #define FLEXPWM3_SM0CVAL4       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x050) // FlexPWM3 channel 0 capture value 4 register (read-only)
    #define FLEXPWM3_SM0CVAL4CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x052) // FlexPWM3 channel 0 capture value 4 cycle register (read-only)
    #define FLEXPWM3_SM0CVAL5       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x054) // FlexPWM3 channel 0 capture value 5 register (read-only)
    #define FLEXPWM3_SM0CVAL5CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x056) // FlexPWM3 channel 0 capture value 5 cycle register (read-only)

    #define FLEXPWM3_SM1CNT         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x060) // FlexPWM3 channel 1 counter register (read-only)
    #define FLEXPWM3_SM1INIT        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x062) // FlexPWM3 channel 1 initial count register
    #define FLEXPWM3_SM1CTRL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x064) // FlexPWM3 channel 1 control 2 register
    #define FLEXPWM3_SM1CTRL        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x066) // FlexPWM3 channel 1 control register

    #define FLEXPWM3_SM1VAL0        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x06a) // FlexPWM3 channel 1 value 0 register
    #define FLEXPWM3_SM1FRACVAL1    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x06c) // FlexPWM3 channel 1 fractional value 1 register
    #define FLEXPWM3_SM1VAL1        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x06e) // FlexPWM3 channel 1 value 1 register
    #define FLEXPWM3_SM1FRACVAL2    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x070) // FlexPWM3 channel 1 fractional value 2 register
    #define FLEXPWM3_SM1VAL2        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x072) // FlexPWM3 channel 1 value 2 register
    #define FLEXPWM3_SM1FRACVAL3    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x074) // FlexPWM3 channel 1 fractional value 3 register
    #define FLEXPWM3_SM1VAL3        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x076) // FlexPWM3 channel 1 value 3 register
    #define FLEXPWM3_SM1FRACVAL4    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x078) // FlexPWM3 channel 1 fractional value 4 register
    #define FLEXPWM3_SM1VAL4        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x07a) // FlexPWM3 channel 1 value 4 register
    #define FLEXPWM3_SM1FRACVAL5    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x07c) // FlexPWM3 channel 1 fractional value 5 register
    #define FLEXPWM3_SM1VAL5        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x07e) // FlexPWM3 channel 1 value 5 register
    #define FLEXPWM3_SM1FRCTRL      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x080) // FlexPWM3 channel 1 fractional control register
    #define FLEXPWM3_SM1OCTRL       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x082) // FlexPWM3 channel 1 output control register
    #define FLEXPWM3_SM1STS         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x084) // FlexPWM3 channel 1 status register (write '1' to clear)
    #define FLEXPWM3_SM1INTEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x086)          // FlexPWM3 channel 1 interrupt enable register
    #define FLEXPWM3_SM1DMAEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x088)          // FlexPWM3 channel 1 DMA enable register
    #define FLEXPWM3_SM1TCTRL       *(unsigned short *)(FLEXPWM3_BLOCK + 0x08a)          // FlexPWM3 channel 1 output trigger control register
    #define FLEXPWM3_SM1DISPMAP0    *(unsigned short *)(FLEXPWM3_BLOCK + 0x08c)          // FlexPWM3 channel 1 fault disable mapping register 0
    #define FLEXPWM3_SM1DISPMAP1    *(unsigned short *)(FLEXPWM3_BLOCK + 0x08e)          // FlexPWM3 channel 1 fault disable mapping register 1
    #define FLEXPWM3_SM1DTCNT0      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x090) // FlexPWM3 channel 1 deadtime count register 0 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
    #define FLEXPWM3_SM1DTCNT1      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x092) // FlexPWM3 channel 1 deadtime count register 1 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
    #define FLEXPWM3_SM1CAPTCTRLA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x094)          // FlexPWM3 channel 1 capture control A register
    #define FLEXPWM3_SM1CAPTCOMPA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x096)          // FlexPWM3 channel 1 capture compare A register
    #define FLEXPWM3_SM1CAPTCTRLB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x098)          // FlexPWM3 channel 1 capture control B register
    #define FLEXPWM3_SM1CAPTCOMPB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x09a)          // FlexPWM3 channel 1 capture compare B register
    #define FLEXPWM3_SM1CAPTCTRLX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x09c)          // FlexPWM3 channel 1 capture control X register
    #define FLEXPWM3_SM1CAPTCOMPX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x09e)          // FlexPWM3 channel 1 capture compare X register
    #define FLEXPWM3_SM1CVAL0       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0a0) // FlexPWM3 channel 1 capture value 0 register (read-only)
    #define FLEXPWM3_SM1CVAL0CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0a2) // FlexPWM3 channel 1 capture value 0 cycle register (read-only)
    #define FLEXPWM3_SM1CVAL1       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0a4) // FlexPWM3 channel 1 capture value 1 register (read-only)
    #define FLEXPWM3_SM1CVAL1CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0a6) // FlexPWM3 channel 1 capture value 1 cycle register (read-only)
    #define FLEXPWM3_SM1CVAL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0a8) // FlexPWM3 channel 1 capture value 2 register (read-only)
    #define FLEXPWM3_SM1CVAL2CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0aa) // FlexPWM3 channel 1 capture value 2 cycle register (read-only)
    #define FLEXPWM3_SM1CVAL3       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0ac) // FlexPWM3 channel 1 capture value 3 register (read-only)
    #define FLEXPWM3_SM1CVAL3CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0ae) // FlexPWM3 channel 1 capture value 3 cycle register (read-only)
    #define FLEXPWM3_SM1CVAL4       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0b0) // FlexPWM3 channel 1 capture value 4 register (read-only)
    #define FLEXPWM3_SM1CVAL4CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0b2) // FlexPWM3 channel 1 capture value 4 cycle register (read-only)
    #define FLEXPWM3_SM1CVAL5       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0b4) // FlexPWM3 channel 1 capture value 5 register (read-only)
    #define FLEXPWM3_SM1CVAL5CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0b6) // FlexPWM3 channel 1 capture value 5 cycle register (read-only)

    #define FLEXPWM3_SM2CNT         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0c0) // FlexPWM3 channel 2 counter register (read-only)
    #define FLEXPWM3_SM2INIT        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0c2) // FlexPWM3 channel 2 initial count register
    #define FLEXPWM3_SM2CTRL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0c4) // FlexPWM3 channel 2 control 2 register
    #define FLEXPWM3_SM2CTRL        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0c6) // FlexPWM3 channel 2 control register

    #define FLEXPWM3_SM2VAL0        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0ca) // FlexPWM3 channel 2 value 0 register
    #define FLEXPWM3_SM2FRACVAL1    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0cc) // FlexPWM3 channel 2 fractional value 1 register
    #define FLEXPWM3_SM2VAL1        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0ce) // FlexPWM3 channel 2 value 1 register
    #define FLEXPWM3_SM2FRACVAL2    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0d0) // FlexPWM3 channel 2 fractional value 2 register
    #define FLEXPWM3_SM2VAL2        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0d2) // FlexPWM3 channel 2 value 2 register
    #define FLEXPWM3_SM2FRACVAL3    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0d4) // FlexPWM3 channel 2 fractional value 3 register
    #define FLEXPWM3_SM2VAL3        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0d6) // FlexPWM3 channel 2 value 3 register
    #define FLEXPWM3_SM2FRACVAL4    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0d8) // FlexPWM3 channel 2 fractional value 4 register
    #define FLEXPWM3_SM2VAL4        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0da) // FlexPWM3 channel 2 value 4 register
    #define FLEXPWM3_SM2FRACVAL5    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0dc) // FlexPWM3 channel 2 fractional value 5 register
    #define FLEXPWM3_SM2VAL5        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0de) // FlexPWM3 channel 2 value 5 register
    #define FLEXPWM3_SM2FRCTRL      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0e0) // FlexPWM3 channel 2 fractional control register
    #define FLEXPWM3_SM2OCTRL       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0e2) // FlexPWM3 channel 2 output control register
    #define FLEXPWM3_SM2STS         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0e4) // FlexPWM3 channel 2 status register (write '1' to clear)
    #define FLEXPWM3_SM2INTEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x0e6)          // FlexPWM3 channel 2 interrupt enable register
    #define FLEXPWM3_SM2DMAEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x0e8)          // FlexPWM3 channel 2 DMA enable register
    #define FLEXPWM3_SM2TCTRL       *(unsigned short *)(FLEXPWM3_BLOCK + 0x0ea)          // FlexPWM3 channel 2 output trigger control register
    #define FLEXPWM3_SM2DISPMAP0    *(unsigned short *)(FLEXPWM3_BLOCK + 0x0ec)          // FlexPWM3 channel 2 fault disable mapping register 0
    #define FLEXPWM3_SM2DISPMAP1    *(unsigned short *)(FLEXPWM3_BLOCK + 0x0ee)          // FlexPWM3 channel 2 fault disable mapping register 1
    #define FLEXPWM3_SM2DTCNT0      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0f0) // FlexPWM3 channel 2 deadtime count register 0
    #define FLEXPWM3_SM2DTCNT1      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x0f2) // FlexPWM3 channel 2 deadtime count register 1
    #define FLEXPWM3_SM2CAPTCTRLA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x0f4)          // FlexPWM3 channel 2 capture control A register
    #define FLEXPWM3_SM2CAPTCOMPA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x0f6)          // FlexPWM3 channel 2 capture compare A register
    #define FLEXPWM3_SM2CAPTCTRLB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x0f8)          // FlexPWM3 channel 2 capture control B register
    #define FLEXPWM3_SM2CAPTCOMPB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x0fa)          // FlexPWM3 channel 2 capture compare B register
    #define FLEXPWM3_SM2CAPTCTRLX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x0fc)          // FlexPWM3 channel 2 capture control X register
    #define FLEXPWM3_SM2CAPTCOMPX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x0fe)          // FlexPWM3 channel 2 capture compare X register
    #define FLEXPWM3_SM2CVAL0       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x100) // FlexPWM3 channel 2 capture value 0 register (read-only)
    #define FLEXPWM3_SM2CVAL0CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x102) // FlexPWM3 channel 2 capture value 0 cycle register (read-only)
    #define FLEXPWM3_SM2CVAL1       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x104) // FlexPWM3 channel 2 capture value 1 register (read-only)
    #define FLEXPWM3_SM2CVAL1CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x106) // FlexPWM3 channel 2 capture value 1 cycle register (read-only)
    #define FLEXPWM3_SM2CVAL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x108) // FlexPWM3 channel 2 capture value 2 register (read-only)
    #define FLEXPWM3_SM2CVAL2CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x10a) // FlexPWM3 channel 2 capture value 2 cycle register (read-only)
    #define FLEXPWM3_SM2CVAL3       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x10c) // FlexPWM3 channel 2 capture value 3 register (read-only)
    #define FLEXPWM3_SM2CVAL3CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x10e) // FlexPWM3 channel 2 capture value 3 cycle register (read-only)
    #define FLEXPWM3_SM2CVAL4       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x110) // FlexPWM3 channel 2 capture value 4 register (read-only)
    #define FLEXPWM3_SM2CVAL4CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x112) // FlexPWM3 channel 2 capture value 4 cycle register (read-only)
    #define FLEXPWM3_SM2CVAL5       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x114) // FlexPWM3 channel 2 capture value 5 register (read-only)
    #define FLEXPWM3_SM2CVAL5CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x116) // FlexPWM3 channel 2 capture value 5 cycle register (read-only)

    #define FLEXPWM3_SM3CNT         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x120) // FlexPWM3 channel 3 counter register (read-only)
    #define FLEXPWM3_SM3INIT        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x122) // FlexPWM3 channel 3 initial count register
    #define FLEXPWM3_SM3CTRL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x124) // FlexPWM3 channel 3 control 2 register
    #define FLEXPWM3_SM3CTRL        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x126) // FlexPWM3 channel 3 control register

    #define FLEXPWM3_SM3VAL0        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x12a) // FlexPWM3 channel 3 value 0 register
    #define FLEXPWM3_SM3FRACVAL1    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x12c) // FlexPWM3 channel 3 fractional value 1 register
    #define FLEXPWM3_SM3VAL1        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x12e) // FlexPWM3 channel 3 value 1 register
    #define FLEXPWM3_SM3FRACVAL2    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x130) // FlexPWM3 channel 3 fractional value 2 register
    #define FLEXPWM3_SM3VAL2        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x132) // FlexPWM3 channel 3 value 2 register
    #define FLEXPWM3_SM3FRACVAL3    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x134) // FlexPWM3 channel 3 fractional value 3 register
    #define FLEXPWM3_SM3VAL3        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x136) // FlexPWM3 channel 3 value 3 register
    #define FLEXPWM3_SM3FRACVAL4    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x138) // FlexPWM3 channel 3 fractional value 4 register
    #define FLEXPWM3_SM3VAL4        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x13a) // FlexPWM3 channel 3 value 4 register
    #define FLEXPWM3_SM3FRACVAL5    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x13c) // FlexPWM3 channel 3 fractional value 5 register
    #define FLEXPWM3_SM3VAL5        *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x13e) // FlexPWM3 channel 3 value 5 register
    #define FLEXPWM3_SM3FRCTRL      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x140) // FlexPWM3 channel 3 fractional control register
    #define FLEXPWM3_SM3OCTRL       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x142) // FlexPWM3 channel 3 output control register
    #define FLEXPWM3_SM3STS         *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x144) // FlexPWM3 channel 3 status register (write '1' to clear)
    #define FLEXPWM3_SM3INTEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x146)          // FlexPWM3 channel 3 interrupt enable register
    #define FLEXPWM3_SM3DMAEN       *(unsigned short *)(FLEXPWM3_BLOCK + 0x148)          // FlexPWM3 channel 3 DMA enable register
    #define FLEXPWM3_SM3TCTRL       *(unsigned short *)(FLEXPWM3_BLOCK + 0x14a)          // FlexPWM3 channel 3 output trigger control register
    #define FLEXPWM3_SM3DISPMAP0    *(unsigned short *)(FLEXPWM3_BLOCK + 0x14c)          // FlexPWM3 channel 3 fault disable mapping register 0
    #define FLEXPWM3_SM3DISPMAP1    *(unsigned short *)(FLEXPWM3_BLOCK + 0x14e)          // FlexPWM3 channel 3 fault disable mapping register 1
    #define FLEXPWM3_SM3DTCNT0      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x150) // FlexPWM3 channel 3 deadtime count register 0
    #define FLEXPWM3_SM3DTCNT1      *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x152) // FlexPWM3 channel 3 deadtime count register 1
    #define FLEXPWM3_SM3CAPTCTRLA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x154)          // FlexPWM3 channel 3 capture control A register
    #define FLEXPWM3_SM3CAPTCOMPA   *(unsigned short *)(FLEXPWM3_BLOCK + 0x156)          // FlexPWM3 channel 3 capture compare A register
    #define FLEXPWM3_SM3CAPTCTRLB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x158)          // FlexPWM3 channel 3 capture control B register
    #define FLEXPWM3_SM3CAPTCOMPB   *(unsigned short *)(FLEXPWM3_BLOCK + 0x15a)          // FlexPWM3 channel 3 capture compare B register
    #define FLEXPWM3_SM3CAPTCTRLX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x15c)          // FlexPWM3 channel 3 capture control X register
    #define FLEXPWM3_SM3CAPTCOMPX   *(unsigned short *)(FLEXPWM3_BLOCK + 0x15e)          // FlexPWM3 channel 3 capture compare X register
    #define FLEXPWM3_SM3CVAL0       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x160) // FlexPWM3 channel 3 capture value 0 register (read-only)
    #define FLEXPWM3_SM3CVAL0CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x162) // FlexPWM3 channel 3 capture value 0 cycle register (read-only)
    #define FLEXPWM3_SM3CVAL1       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x164) // FlexPWM3 channel 3 capture value 1 register (read-only)
    #define FLEXPWM3_SM3CVAL1CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x166) // FlexPWM3 channel 3 capture value 1 cycle register (read-only)
    #define FLEXPWM3_SM3CVAL2       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x168) // FlexPWM3 channel 3 capture value 2 register (read-only)
    #define FLEXPWM3_SM3CVAL2CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x16a) // FlexPWM3 channel 3 capture value 2 cycle register (read-only)
    #define FLEXPWM3_SM3CVAL3       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x16c) // FlexPWM3 channel 3 capture value 3 register (read-only)
    #define FLEXPWM3_SM3CVAL3CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x16e) // FlexPWM3 channel 3 capture value 3 cycle register (read-only)
    #define FLEXPWM3_SM3CVAL4       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x170) // FlexPWM3 channel 3 capture value 4 register (read-only)
    #define FLEXPWM3_SM3CVAL4CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x172) // FlexPWM3 channel 3 capture value 4 cycle register (read-only)
    #define FLEXPWM3_SM3CVAL5       *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x174) // FlexPWM3 channel 3 capture value 5 register (read-only)
    #define FLEXPWM3_SM3CVAL5CYC    *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x176) // FlexPWM3 channel 3 capture value 5 cycle register (read-only)

    #define FLEXPWM3_OUTEN          *(unsigned short *)(FLEXPWM3_BLOCK + 0x180)          // FlexPWM3 output enable register
    #define FLEXPWM3_MASK           *(unsigned short *)(FLEXPWM3_BLOCK + 0x182)          // FlexPWM3 mask register
    #define FLEXPWM3_SWCOUT         *(unsigned short *)(FLEXPWM3_BLOCK + 0x184)          // FlexPWM3 software controlled output register
    #define FLEXPWM3_DTSRCSEL       *(unsigned short *)(FLEXPWM3_BLOCK + 0x186)          // FlexPWM3 PWM select source register
    #define FLEXPWM3_MCTRL          *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x188) // FlexPWM3 master control register
    #define FLEXPWM3_MCTRL2         *(unsigned short *)(FLEXPWM3_BLOCK + 0x18a)          // FlexPWM3 master control register 2
    #define FLEXPWM3_FCTRL0         *(unsigned short *)(FLEXPWM3_BLOCK + 0x18c)          // FlexPWM3 fault control register
    #define FLEXPWM3_FSTS0          *(volatile unsigned short *)(FLEXPWM3_BLOCK + 0x18e) // FlexPWM3 fault status register
    #define FLEXPWM3_FFILT0         *(unsigned short *)(FLEXPWM3_BLOCK + 0x190)          // FlexPWM3 fault filter register
    #define FLEXPWM3_FTST0          *(unsigned short *)(FLEXPWM3_BLOCK + 0x192)          // FlexPWM3 fault test register
    #define FLEXPWM3_FCTRL20        *(unsigned short *)(FLEXPWM3_BLOCK + 0x194)          // FlexPWM3 fault control 2 register
#endif
#if FLEXPWM_AVAILABLE > 3
    #define FLEXPWM4_SM0CNT         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x000) // FlexPWM4 channel 0 counter register (read-only)
    #define FLEXPWM4_SM0INIT        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x002) // FlexPWM4 channel 0 initial count register
    #define FLEXPWM4_SM0CTRL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x004) // FlexPWM4 channel 0 control 2 register
    #define FLEXPWM4_SM0CTRL        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x006) // FlexPWM4 channel 0 control register

    #define FLEXPWM4_SM0VAL0        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x00a) // FlexPWM4 channel 0 value 0 register
    #define FLEXPWM4_SM0FRACVAL1    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x00c) // FlexPWM4 channel 0 fractional value 1 register
    #define FLEXPWM4_SM0VAL1        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x00e) // FlexPWM4 channel 0 value 1 register
    #define FLEXPWM4_SM0FRACVAL2    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x010) // FlexPWM4 channel 0 fractional value 2 register
    #define FLEXPWM4_SM0VAL2        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x012) // FlexPWM4 channel 0 value 2 register
    #define FLEXPWM4_SM0FRACVAL3    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x014) // FlexPWM4 channel 0 fractional value 3 register
    #define FLEXPWM4_SM0VAL3        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x016) // FlexPWM4 channel 0 value 3 register
    #define FLEXPWM4_SM0FRACVAL4    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x018) // FlexPWM4 channel 0 fractional value 4 register
    #define FLEXPWM4_SM0VAL4        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x01a) // FlexPWM4 channel 0 value 4 register
    #define FLEXPWM4_SM0FRACVAL5    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x01c) // FlexPWM4 channel 0 fractional value 5 register
    #define FLEXPWM4_SM0VAL5        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x01e) // FlexPWM4 channel 0 value 5 register
    #define FLEXPWM4_SM0FRCTRL      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x020) // FlexPWM4 channel 0 fractional control register
    #define FLEXPWM4_SM0OCTRL       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x022) // FlexPWM4 channel 0 output control register
    #define FLEXPWM4_SM0STS         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x024) // FlexPWM4 channel 0 status register (write '1' to clear)
    #define FLEXPWM4_SM0INTEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x026)          // FlexPWM4 channel 0 interrupt enable register
    #define FLEXPWM4_SM0DMAEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x028)          // FlexPWM4 channel 0 DMA enable register
    #define FLEXPWM4_SM0TCTRL       *(unsigned short *)(FLEXPWM4_BLOCK + 0x02a)          // FlexPWM4 channel 0 output trigger control register
    #define FLEXPWM4_SM0DISPMAP0    *(unsigned short *)(FLEXPWM4_BLOCK + 0x02c)          // FlexPWM4 channel 0 fault disable mapping register 0
    #define FLEXPWM4_SM0DISPMAP1    *(unsigned short *)(FLEXPWM4_BLOCK + 0x02e)          // FlexPWM4 channel 0 fault disable mapping register 1
    #define FLEXPWM4_SM0DTCNT0      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x030) // FlexPWM4 channel 0 deadtime count register 0
    #define FLEXPWM4_SM0DTCNT1      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x032) // FlexPWM4 channel 0 deadtime count register 1
    #define FLEXPWM4_SM0CAPTCTRLA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x034)          // FlexPWM4 channel 0 capture control A register
    #define FLEXPWM4_SM0CAPTCOMPA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x036)          // FlexPWM4 channel 0 capture compare A register
    #define FLEXPWM4_SM0CAPTCTRLB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x038)          // FlexPWM4 channel 0 capture control B register
    #define FLEXPWM4_SM0CAPTCOMPB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x03a)          // FlexPWM4 channel 0 capture compare B register
    #define FLEXPWM4_SM0CAPTCTRLX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x03c)          // FlexPWM4 channel 0 capture control X register
    #define FLEXPWM4_SM0CAPTCOMPX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x03e)          // FlexPWM4 channel 0 capture compare X register
    #define FLEXPWM4_SM0CVAL0       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x040) // FlexPWM4 channel 0 capture value 0 register (read-only)
    #define FLEXPWM4_SM0CVAL0CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x042) // FlexPWM4 channel 0 capture value 0 cycle register (read-only)
    #define FLEXPWM4_SM0CVAL1       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x044) // FlexPWM4 channel 0 capture value 1 register (read-only)
    #define FLEXPWM4_SM0CVAL1CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x046) // FlexPWM4 channel 0 capture value 1 cycle register (read-only)
    #define FLEXPWM4_SM0CVAL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x048) // FlexPWM4 channel 0 capture value 2 register (read-only)
    #define FLEXPWM4_SM0CVAL2CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x04a) // FlexPWM4 channel 0 capture value 2 cycle register (read-only)
    #define FLEXPWM4_SM0CVAL3       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x04c) // FlexPWM4 channel 0 capture value 3 register (read-only)
    #define FLEXPWM4_SM0CVAL3CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x04e) // FlexPWM4 channel 0 capture value 3 cycle register (read-only)
    #define FLEXPWM4_SM0CVAL4       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x050) // FlexPWM4 channel 0 capture value 4 register (read-only)
    #define FLEXPWM4_SM0CVAL4CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x052) // FlexPWM4 channel 0 capture value 4 cycle register (read-only)
    #define FLEXPWM4_SM0CVAL5       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x054) // FlexPWM4 channel 0 capture value 5 register (read-only)
    #define FLEXPWM4_SM0CVAL5CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x056) // FlexPWM4 channel 0 capture value 5 cycle register (read-only)

    #define FLEXPWM4_SM1CNT         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x060) // FlexPWM4 channel 1 counter register (read-only)
    #define FLEXPWM4_SM1INIT        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x062) // FlexPWM4 channel 1 initial count register
    #define FLEXPWM4_SM1CTRL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x064) // FlexPWM4 channel 1 control 2 register
    #define FLEXPWM4_SM1CTRL        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x066) // FlexPWM4 channel 1 control register

    #define FLEXPWM4_SM1VAL0        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x06a) // FlexPWM4 channel 1 value 0 register
    #define FLEXPWM4_SM1FRACVAL1    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x06c) // FlexPWM4 channel 1 fractional value 1 register
    #define FLEXPWM4_SM1VAL1        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x06e) // FlexPWM4 channel 1 value 1 register
    #define FLEXPWM4_SM1FRACVAL2    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x070) // FlexPWM4 channel 1 fractional value 2 register
    #define FLEXPWM4_SM1VAL2        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x072) // FlexPWM4 channel 1 value 2 register
    #define FLEXPWM4_SM1FRACVAL3    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x074) // FlexPWM4 channel 1 fractional value 3 register
    #define FLEXPWM4_SM1VAL3        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x076) // FlexPWM4 channel 1 value 3 register
    #define FLEXPWM4_SM1FRACVAL4    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x078) // FlexPWM4 channel 1 fractional value 4 register
    #define FLEXPWM4_SM1VAL4        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x07a) // FlexPWM4 channel 1 value 4 register
    #define FLEXPWM4_SM1FRACVAL5    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x07c) // FlexPWM4 channel 1 fractional value 5 register
    #define FLEXPWM4_SM1VAL5        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x07e) // FlexPWM4 channel 1 value 5 register
    #define FLEXPWM4_SM1FRCTRL      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x080) // FlexPWM4 channel 1 fractional control register
    #define FLEXPWM4_SM1OCTRL       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x082) // FlexPWM4 channel 1 output control register
    #define FLEXPWM4_SM1STS         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x084) // FlexPWM4 channel 1 status register (write '1' to clear)
    #define FLEXPWM4_SM1INTEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x086)          // FlexPWM4 channel 1 interrupt enable register
    #define FLEXPWM4_SM1DMAEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x088)          // FlexPWM4 channel 1 DMA enable register
    #define FLEXPWM4_SM1TCTRL       *(unsigned short *)(FLEXPWM4_BLOCK + 0x08a)          // FlexPWM4 channel 1 output trigger control register
    #define FLEXPWM4_SM1DISPMAP0    *(unsigned short *)(FLEXPWM4_BLOCK + 0x08c)          // FlexPWM4 channel 1 fault disable mapping register 0
    #define FLEXPWM4_SM1DISPMAP1    *(unsigned short *)(FLEXPWM4_BLOCK + 0x08e)          // FlexPWM4 channel 1 fault disable mapping register 1
    #define FLEXPWM4_SM1DTCNT0      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x090) // FlexPWM4 channel 1 deadtime count register 0 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
    #define FLEXPWM4_SM1DTCNT1      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x092) // FlexPWM4 channel 1 deadtime count register 1 (used only in complimentary mode and alwas in IPBus clocks withut prescaler)
    #define FLEXPWM4_SM1CAPTCTRLA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x094)          // FlexPWM4 channel 1 capture control A register
    #define FLEXPWM4_SM1CAPTCOMPA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x096)          // FlexPWM4 channel 1 capture compare A register
    #define FLEXPWM4_SM1CAPTCTRLB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x098)          // FlexPWM4 channel 1 capture control B register
    #define FLEXPWM4_SM1CAPTCOMPB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x09a)          // FlexPWM4 channel 1 capture compare B register
    #define FLEXPWM4_SM1CAPTCTRLX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x09c)          // FlexPWM4 channel 1 capture control X register
    #define FLEXPWM4_SM1CAPTCOMPX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x09e)          // FlexPWM4 channel 1 capture compare X register
    #define FLEXPWM4_SM1CVAL0       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0a0) // FlexPWM4 channel 1 capture value 0 register (read-only)
    #define FLEXPWM4_SM1CVAL0CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0a2) // FlexPWM4 channel 1 capture value 0 cycle register (read-only)
    #define FLEXPWM4_SM1CVAL1       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0a4) // FlexPWM4 channel 1 capture value 1 register (read-only)
    #define FLEXPWM4_SM1CVAL1CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0a6) // FlexPWM4 channel 1 capture value 1 cycle register (read-only)
    #define FLEXPWM4_SM1CVAL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0a8) // FlexPWM4 channel 1 capture value 2 register (read-only)
    #define FLEXPWM4_SM1CVAL2CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0aa) // FlexPWM4 channel 1 capture value 2 cycle register (read-only)
    #define FLEXPWM4_SM1CVAL3       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0ac) // FlexPWM4 channel 1 capture value 3 register (read-only)
    #define FLEXPWM4_SM1CVAL3CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0ae) // FlexPWM4 channel 1 capture value 3 cycle register (read-only)
    #define FLEXPWM4_SM1CVAL4       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0b0) // FlexPWM4 channel 1 capture value 4 register (read-only)
    #define FLEXPWM4_SM1CVAL4CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0b2) // FlexPWM4 channel 1 capture value 4 cycle register (read-only)
    #define FLEXPWM4_SM1CVAL5       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0b4) // FlexPWM4 channel 1 capture value 5 register (read-only)
    #define FLEXPWM4_SM1CVAL5CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0b6) // FlexPWM4 channel 1 capture value 5 cycle register (read-only)

    #define FLEXPWM4_SM2CNT         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0c0) // FlexPWM4 channel 2 counter register (read-only)
    #define FLEXPWM4_SM2INIT        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0c2) // FlexPWM4 channel 2 initial count register
    #define FLEXPWM4_SM2CTRL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0c4) // FlexPWM4 channel 2 control 2 register
    #define FLEXPWM4_SM2CTRL        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0c6) // FlexPWM4 channel 2 control register

    #define FLEXPWM4_SM2VAL0        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0ca) // FlexPWM4 channel 2 value 0 register
    #define FLEXPWM4_SM2FRACVAL1    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0cc) // FlexPWM4 channel 2 fractional value 1 register
    #define FLEXPWM4_SM2VAL1        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0ce) // FlexPWM4 channel 2 value 1 register
    #define FLEXPWM4_SM2FRACVAL2    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0d0) // FlexPWM4 channel 2 fractional value 2 register
    #define FLEXPWM4_SM2VAL2        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0d2) // FlexPWM4 channel 2 value 2 register
    #define FLEXPWM4_SM2FRACVAL3    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0d4) // FlexPWM4 channel 2 fractional value 3 register
    #define FLEXPWM4_SM2VAL3        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0d6) // FlexPWM4 channel 2 value 3 register
    #define FLEXPWM4_SM2FRACVAL4    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0d8) // FlexPWM4 channel 2 fractional value 4 register
    #define FLEXPWM4_SM2VAL4        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0da) // FlexPWM4 channel 2 value 4 register
    #define FLEXPWM4_SM2FRACVAL5    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0dc) // FlexPWM4 channel 2 fractional value 5 register
    #define FLEXPWM4_SM2VAL5        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0de) // FlexPWM4 channel 2 value 5 register
    #define FLEXPWM4_SM2FRCTRL      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0e0) // FlexPWM4 channel 2 fractional control register
    #define FLEXPWM4_SM2OCTRL       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0e2) // FlexPWM4 channel 2 output control register
    #define FLEXPWM4_SM2STS         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0e4) // FlexPWM4 channel 2 status register (write '1' to clear)
    #define FLEXPWM4_SM2INTEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x0e6)          // FlexPWM4 channel 2 interrupt enable register
    #define FLEXPWM4_SM2DMAEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x0e8)          // FlexPWM4 channel 2 DMA enable register
    #define FLEXPWM4_SM2TCTRL       *(unsigned short *)(FLEXPWM4_BLOCK + 0x0ea)          // FlexPWM4 channel 2 output trigger control register
    #define FLEXPWM4_SM2DISPMAP0    *(unsigned short *)(FLEXPWM4_BLOCK + 0x0ec)          // FlexPWM4 channel 2 fault disable mapping register 0
    #define FLEXPWM4_SM2DISPMAP1    *(unsigned short *)(FLEXPWM4_BLOCK + 0x0ee)          // FlexPWM4 channel 2 fault disable mapping register 1
    #define FLEXPWM4_SM2DTCNT0      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0f0) // FlexPWM4 channel 2 deadtime count register 0
    #define FLEXPWM4_SM2DTCNT1      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x0f2) // FlexPWM4 channel 2 deadtime count register 1
    #define FLEXPWM4_SM2CAPTCTRLA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x0f4)          // FlexPWM4 channel 2 capture control A register
    #define FLEXPWM4_SM2CAPTCOMPA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x0f6)          // FlexPWM4 channel 2 capture compare A register
    #define FLEXPWM4_SM2CAPTCTRLB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x0f8)          // FlexPWM4 channel 2 capture control B register
    #define FLEXPWM4_SM2CAPTCOMPB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x0fa)          // FlexPWM4 channel 2 capture compare B register
    #define FLEXPWM4_SM2CAPTCTRLX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x0fc)          // FlexPWM4 channel 2 capture control X register
    #define FLEXPWM4_SM2CAPTCOMPX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x0fe)          // FlexPWM4 channel 2 capture compare X register
    #define FLEXPWM4_SM2CVAL0       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x100) // FlexPWM4 channel 2 capture value 0 register (read-only)
    #define FLEXPWM4_SM2CVAL0CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x102) // FlexPWM4 channel 2 capture value 0 cycle register (read-only)
    #define FLEXPWM4_SM2CVAL1       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x104) // FlexPWM4 channel 2 capture value 1 register (read-only)
    #define FLEXPWM4_SM2CVAL1CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x106) // FlexPWM4 channel 2 capture value 1 cycle register (read-only)
    #define FLEXPWM4_SM2CVAL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x108) // FlexPWM4 channel 2 capture value 2 register (read-only)
    #define FLEXPWM4_SM2CVAL2CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x10a) // FlexPWM4 channel 2 capture value 2 cycle register (read-only)
    #define FLEXPWM4_SM2CVAL3       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x10c) // FlexPWM4 channel 2 capture value 3 register (read-only)
    #define FLEXPWM4_SM2CVAL3CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x10e) // FlexPWM4 channel 2 capture value 3 cycle register (read-only)
    #define FLEXPWM4_SM2CVAL4       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x110) // FlexPWM4 channel 2 capture value 4 register (read-only)
    #define FLEXPWM4_SM2CVAL4CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x112) // FlexPWM4 channel 2 capture value 4 cycle register (read-only)
    #define FLEXPWM4_SM2CVAL5       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x114) // FlexPWM4 channel 2 capture value 5 register (read-only)
    #define FLEXPWM4_SM2CVAL5CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x116) // FlexPWM4 channel 2 capture value 5 cycle register (read-only)

    #define FLEXPWM4_SM3CNT         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x120) // FlexPWM4 channel 3 counter register (read-only)
    #define FLEXPWM4_SM3INIT        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x122) // FlexPWM4 channel 3 initial count register
    #define FLEXPWM4_SM3CTRL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x124) // FlexPWM4 channel 3 control 2 register
    #define FLEXPWM4_SM3CTRL        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x126) // FlexPWM4 channel 3 control register

    #define FLEXPWM4_SM3VAL0        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x12a) // FlexPWM4 channel 3 value 0 register
    #define FLEXPWM4_SM3FRACVAL1    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x12c) // FlexPWM4 channel 3 fractional value 1 register
    #define FLEXPWM4_SM3VAL1        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x12e) // FlexPWM4 channel 3 value 1 register
    #define FLEXPWM4_SM3FRACVAL2    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x130) // FlexPWM4 channel 3 fractional value 2 register
    #define FLEXPWM4_SM3VAL2        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x132) // FlexPWM4 channel 3 value 2 register
    #define FLEXPWM4_SM3FRACVAL3    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x134) // FlexPWM4 channel 3 fractional value 3 register
    #define FLEXPWM4_SM3VAL3        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x136) // FlexPWM4 channel 3 value 3 register
    #define FLEXPWM4_SM3FRACVAL4    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x138) // FlexPWM4 channel 3 fractional value 4 register
    #define FLEXPWM4_SM3VAL4        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x13a) // FlexPWM4 channel 3 value 4 register
    #define FLEXPWM4_SM3FRACVAL5    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x13c) // FlexPWM4 channel 3 fractional value 5 register
    #define FLEXPWM4_SM3VAL5        *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x13e) // FlexPWM4 channel 3 value 5 register
    #define FLEXPWM4_SM3FRCTRL      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x140) // FlexPWM4 channel 3 fractional control register
    #define FLEXPWM4_SM3OCTRL       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x142) // FlexPWM4 channel 3 output control register
    #define FLEXPWM4_SM3STS         *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x144) // FlexPWM4 channel 3 status register (write '1' to clear)
    #define FLEXPWM4_SM3INTEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x146)          // FlexPWM4 channel 3 interrupt enable register
    #define FLEXPWM4_SM3DMAEN       *(unsigned short *)(FLEXPWM4_BLOCK + 0x148)          // FlexPWM4 channel 3 DMA enable register
    #define FLEXPWM4_SM3TCTRL       *(unsigned short *)(FLEXPWM4_BLOCK + 0x14a)          // FlexPWM4 channel 3 output trigger control register
    #define FLEXPWM4_SM3DISPMAP0    *(unsigned short *)(FLEXPWM4_BLOCK + 0x14c)          // FlexPWM4 channel 3 fault disable mapping register 0
    #define FLEXPWM4_SM3DISPMAP1    *(unsigned short *)(FLEXPWM4_BLOCK + 0x14e)          // FlexPWM4 channel 3 fault disable mapping register 1
    #define FLEXPWM4_SM3DTCNT0      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x150) // FlexPWM4 channel 3 deadtime count register 0
    #define FLEXPWM4_SM3DTCNT1      *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x152) // FlexPWM4 channel 3 deadtime count register 1
    #define FLEXPWM4_SM3CAPTCTRLA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x154)          // FlexPWM4 channel 3 capture control A register
    #define FLEXPWM4_SM3CAPTCOMPA   *(unsigned short *)(FLEXPWM4_BLOCK + 0x156)          // FlexPWM4 channel 3 capture compare A register
    #define FLEXPWM4_SM3CAPTCTRLB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x158)          // FlexPWM4 channel 3 capture control B register
    #define FLEXPWM4_SM3CAPTCOMPB   *(unsigned short *)(FLEXPWM4_BLOCK + 0x15a)          // FlexPWM4 channel 3 capture compare B register
    #define FLEXPWM4_SM3CAPTCTRLX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x15c)          // FlexPWM4 channel 3 capture control X register
    #define FLEXPWM4_SM3CAPTCOMPX   *(unsigned short *)(FLEXPWM4_BLOCK + 0x15e)          // FlexPWM4 channel 3 capture compare X register
    #define FLEXPWM4_SM3CVAL0       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x160) // FlexPWM4 channel 3 capture value 0 register (read-only)
    #define FLEXPWM4_SM3CVAL0CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x162) // FlexPWM4 channel 3 capture value 0 cycle register (read-only)
    #define FLEXPWM4_SM3CVAL1       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x164) // FlexPWM4 channel 3 capture value 1 register (read-only)
    #define FLEXPWM4_SM3CVAL1CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x166) // FlexPWM4 channel 3 capture value 1 cycle register (read-only)
    #define FLEXPWM4_SM3CVAL2       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x168) // FlexPWM4 channel 3 capture value 2 register (read-only)
    #define FLEXPWM4_SM3CVAL2CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x16a) // FlexPWM4 channel 3 capture value 2 cycle register (read-only)
    #define FLEXPWM4_SM3CVAL3       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x16c) // FlexPWM4 channel 3 capture value 3 register (read-only)
    #define FLEXPWM4_SM3CVAL3CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x16e) // FlexPWM4 channel 3 capture value 3 cycle register (read-only)
    #define FLEXPWM4_SM3CVAL4       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x170) // FlexPWM4 channel 3 capture value 4 register (read-only)
    #define FLEXPWM4_SM3CVAL4CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x172) // FlexPWM4 channel 3 capture value 4 cycle register (read-only)
    #define FLEXPWM4_SM3CVAL5       *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x174) // FlexPWM4 channel 3 capture value 5 register (read-only)
    #define FLEXPWM4_SM3CVAL5CYC    *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x176) // FlexPWM4 channel 3 capture value 5 cycle register (read-only)

    #define FLEXPWM4_OUTEN          *(unsigned short *)(FLEXPWM4_BLOCK + 0x180)          // FlexPWM4 output enable register
    #define FLEXPWM4_MASK           *(unsigned short *)(FLEXPWM4_BLOCK + 0x182)          // FlexPWM4 mask register
    #define FLEXPWM4_SWCOUT         *(unsigned short *)(FLEXPWM4_BLOCK + 0x184)          // FlexPWM4 software controlled output register
    #define FLEXPWM4_DTSRCSEL       *(unsigned short *)(FLEXPWM4_BLOCK + 0x186)          // FlexPWM4 PWM select source register
    #define FLEXPWM4_MCTRL          *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x188) // FlexPWM4 master control register
    #define FLEXPWM4_MCTRL2         *(unsigned short *)(FLEXPWM4_BLOCK + 0x18a)          // FlexPWM4 master control register 2
    #define FLEXPWM4_FCTRL0         *(unsigned short *)(FLEXPWM4_BLOCK + 0x18c)          // FlexPWM4 fault control register
    #define FLEXPWM4_FSTS0          *(volatile unsigned short *)(FLEXPWM4_BLOCK + 0x18e) // FlexPWM4 fault status register
    #define FLEXPWM4_FFILT0         *(unsigned short *)(FLEXPWM4_BLOCK + 0x190)          // FlexPWM4 fault filter register
    #define FLEXPWM4_FTST0          *(unsigned short *)(FLEXPWM4_BLOCK + 0x192)          // FlexPWM4 fault test register
    #define FLEXPWM4_FCTRL20        *(unsigned short *)(FLEXPWM4_BLOCK + 0x194)          // FlexPWM4 fault control 2 register
#endif

typedef struct stFLEXPWM_VALUE
{
    volatile unsigned short FLEXPWM_SMFRACVAL;
    volatile unsigned short FLEXPWM_SMVAL;
} FLEXPWM_VALUE;


typedef struct stFLEXPWM_CAPTURE_VALUE
{
    volatile unsigned short FLEXPWM_SMCVAL;
    volatile unsigned short FLEXPWM_SMCVALCYC;
} FLEXPWM_CAPTURE_VALUE;


typedef struct stFLEXPWM_CHANNEL
{
    volatile unsigned short FLEXPWM_SMCNT;
    volatile unsigned short FLEXPWM_SMINIT;
    volatile unsigned short FLEXPWM_SMCTRL2;
    volatile unsigned short FLEXPWM_SMCTRL;
    FLEXPWM_VALUE  flexPWM_val[6];                                       // note that flexPWM_val[0].FLEXPWM_SMFRACVAL doesn't exist
    volatile unsigned short FLEXPWM_SMFRCTRL;
    volatile unsigned short FLEXPWM_SMOCTRL;
    volatile unsigned short FLEXPWM_SMSTS;
    unsigned short FLEXPWM_SMINTEN;
    unsigned short FLEXPWM_SMDMAEN;
    unsigned short FLEXPWM_SMTCTRL;
    unsigned short FLEXPWM_SMDISPMAP0;
    unsigned short FLEXPWM_SMDISPMAP1;
    unsigned short FLEXPWM_SMDTCNT0;
    unsigned short FLEXPWM_SMDTCNT1;
    unsigned short FLEXPWM_SMCAPTCTRLA;
    unsigned short FLEXPWM_SMCAPTCOMPA;
    unsigned short FLEXPWM_SMCAPTCTRLB;
    unsigned short FLEXPWM_SMCAPTCOMPB;
    unsigned short FLEXPWM_SMCAPTCTRLX;
    unsigned short FLEXPWM_SMCAPTCOMPX;
    FLEXPWM_CAPTURE_VALUE flexPWM_captureVal[6];
    unsigned short usRev1[4];
} FLEXPWM_CHANNEL;

typedef struct stFLEXPWM_MODULE
{
    FLEXPWM_CHANNEL flexPWM_ch[4];
    unsigned short FLEXPWM_OUTEN;
    unsigned short FLEXPWM_MASK;
    unsigned short FLEXPWM_SWCOUT;
    unsigned short FLEXPWM_DTSRCSEL;
    volatile unsigned short FLEXPWM_MCTRL;
    unsigned short FLEXPWM_MCTRL2;
    unsigned short FLEXPWM_FCTRL0;
    unsigned short FLEXPWM_FSTS0;
    unsigned short FLEXPWM_FFILT0;
    unsigned short FLEXPWM_FTST0;
    unsigned short FLEXPWM_FCTRL20;
} FLEXPWM_MODULE;


// ADC
//
#define ADC1_HC0                *(unsigned long *)(ADC1_BLOCK + 0x000)   // ADC1 control register for hardware triggers 0
    #define ADC_HC_ADCH_0       0x00000000                               // input channel select - channel 0
    #define ADC_HC_ADCH_1       0x00000001                               // input channel select - channel 1
    #define ADC_HC_ADCH_2       0x00000002                               // input channel select - channel 2
    #define ADC_HC_ADCH_3       0x00000003                               // input channel select - channel 3
    #define ADC_HC_ADCH_4       0x00000004                               // input channel select - channel 4
    #define ADC_HC_ADCH_5       0x00000005                               // input channel select - channel 5
    #define ADC_HC_ADCH_6       0x00000006                               // input channel select - channel 6
    #define ADC_HC_ADCH_7       0x00000007                               // input channel select - channel 7
    #define ADC_HC_ADCH_8       0x00000008                               // input channel select - channel 8
    #define ADC_HC_ADCH_9       0x00000009                               // input channel select - channel 9
    #define ADC_HC_ADCH_10      0x0000000a                               // input channel select - channel 10
    #define ADC_HC_ADCH_11      0x0000000b                               // input channel select - channel 11
    #define ADC_HC_ADCH_12      0x0000000c                               // input channel select - channel 12
    #define ADC_HC_ADCH_13      0x0000000d                               // input channel select - channel 13
    #define ADC_HC_ADCH_14      0x0000000e                               // input channel select - channel 14
    #define ADC_HC_ADCH_15      0x0000000f                               // input channel select - channel 15
    #define ADC_HC_ADCH_ADC_ETC 0x00000010                               // input channel selection from ADC_ETC
    #define ADC_HC_ADCH_VREFSH  0x00000019                               // input channel select - VREFSH select (hard connected to VRH internally))
    #define ADC_HC_ADCH_OFF     0x0000001f                               // conversion disabled - hardware triggers will not initiate any conversion
    #define ADC_HC_ADCH_MASK    0x0000001f                               // input channel select mask
    #define ADC_HC_AIEN         0x00000080                               // conversion complete interrupt enabled
#define ADC1_HC1                *(unsigned long *)(ADC1_BLOCK + 0x004)   // ADC1 control register for hardware triggers 1
#define ADC1_HC2                *(unsigned long *)(ADC1_BLOCK + 0x008)   // ADC1 control register for hardware triggers 2
#define ADC1_HC3                *(unsigned long *)(ADC1_BLOCK + 0x00c)   // ADC1 control register for hardware triggers 3
#define ADC1_HC4                *(unsigned long *)(ADC1_BLOCK + 0x010)   // ADC1 control register for hardware triggers 4
#define ADC1_HC5                *(unsigned long *)(ADC1_BLOCK + 0x014)   // ADC1 control register for hardware triggers 5
#define ADC1_HC6                *(unsigned long *)(ADC1_BLOCK + 0x018)   // ADC1 control register for hardware triggers 6
#define ADC1_HC7                *(unsigned long *)(ADC1_BLOCK + 0x01c)   // ADC1 control register for hardware triggers 7
#define ADC1_HS                 *(volatile unsigned long *)(ADC1_BLOCK + 0x020) // ADC1 status register for HW triggers (reads-only)
    #define ADC_HS_COCO         0x00000001                               // conversion complete flag
#define ADC1_R0                 *(volatile unsigned long *)(ADC1_BLOCK + 0x024) // ADC1 data result register for HW triggers 0 (read-only)
#define ADC1_R1                 *(volatile unsigned long *)(ADC1_BLOCK + 0x028) // ADC1 data result register for HW triggers 1 (read-only)
#define ADC1_R2                 *(volatile unsigned long *)(ADC1_BLOCK + 0x02c) // ADC1 data result register for HW triggers 2 (read-only)
#define ADC1_R3                 *(volatile unsigned long *)(ADC1_BLOCK + 0x030) // ADC1 data result register for HW triggers 3 (read-only)
#define ADC1_R4                 *(volatile unsigned long *)(ADC1_BLOCK + 0x034) // ADC1 data result register for HW triggers 4 (read-only)
#define ADC1_R5                 *(volatile unsigned long *)(ADC1_BLOCK + 0x038) // ADC1 data result register for HW triggers 5 (read-only)
#define ADC1_R6                 *(volatile unsigned long *)(ADC1_BLOCK + 0x03c) // ADC1 data result register for HW triggers 6 (read-only)
#define ADC1_R7                 *(volatile unsigned long *)(ADC1_BLOCK + 0x040) // ADC1 data result register for HW triggers 7 (read-only)
#define ADC1_CFG                *(unsigned long *)(ADC1_BLOCK + 0x044)   // ADC1 configuration register
    #define ADC_CFG_ADICLK_IPG  0x00000000                               // input clock select - IPG clock
    #define ADC_CFG_ADICLK_IPG2 0x00000001                               // input clock select - IPG clock divided by 2
    #define ADC_CFG_ADICLK_ASY  0x00000003                               // input clock select - asynchronous clock (ADACK)
    #define ADC_CFG_MODE_MASK   0x0000000c
    #define ADC_CFG_MODE_8      0x00000000                               // conversion mode - single-ended 8 bit
    #define ADC_CFG_MODE_10     0x00000004                               // conversion mode - single-ended 10 bit
    #define ADC_CFG_MODE_12     0x00000008                               // conversion mode - single-ended 12 bit
    #define ADC_CFG_ADLSMP_SHORT 0x00000000                              // short sample time
    #define ADC_CFG_ADLSMP_LONG  0x00000010                              // long sample time
    #define ADC_CFG_ADIV_1      0x00000000                               // ADC clock not divided
    #define ADC_CFG_ADIV_2      0x00000020                               // ADC clock divided by 2
    #define ADC_CFG_ADIV_4      0x00000040                               // ADC clock divided by 4
    #define ADC_CFG_ADIV_8      0x00000060                               // ADC clock divided by 8
    #define ADC_CFG_ADLPC       0x00000080                               // low power configuration
    #define ADC_CFG_ADSTS_2     0x00000000                               // sample time select - 2 ADC clocks (ADLSMP '0')
    #define ADC_CFG_ADSTS_4     0x00000100                               // sample time select - 4 ADC clocks (ADLSMP '0')
    #define ADC_CFG_ADSTS_6     0x00000200                               // sample time select - 6 ADC clocks (ADLSMP '0')
    #define ADC_CFG_ADSTS_8     0x00000300                               // sample time select - 8 ADC clocks (ADLSMP '0')
    #define ADC_CFG_ADSTS_12    (0x00000000 | ADC_CFG_ADLSMP_LONG)       // sample time select - 12 ADC clocks (ADLSMP '1')
    #define ADC_CFG_ADSTS_16    (0x00000100 | ADC_CFG_ADLSMP_LONG)       // sample time select - 16 ADC clocks (ADLSMP '1')
    #define ADC_CFG_ADSTS_20    (0x00000200 | ADC_CFG_ADLSMP_LONG)       // sample time select - 20 ADC clocks (ADLSMP '1')
    #define ADC_CFG_ADSTS_24    (0x00000300 | ADC_CFG_ADLSMP_LONG)       // sample time select - 24 ADC clocks (ADLSMP '2')
    #define ADC_CFG_ADHSC       0x00000400                               // high speed configuration
    #define ADC_CFG_REFSEL_VREFH_VREFL 0x00000000                        // selects VREFH/VREFL as reference voltage
    #define ADC_CFG_ADTRG_SW    0x00000000                               // conversion trigger select - software
    #define ADC_CFG_ADTRG_HW    0x00002000                               // conversion trigger select - hardware
    #define ADC_CFG_AVGS_4      0x00000000                               // hardware average select - 4 samples averaged
    #define ADC_CFG_AVGS_8      0x00004000                               // hardware average select - 8 samples averaged
    #define ADC_CFG_AVGS_16     0x00008000                               // hardware average select - 16 samples averaged
    #define ADC_CFG_AVGS_32     0x0000c000                               // hardware average select - 32 samples averaged
    #define ADC_CFG_OVWREN      0x00010000                               // data overwrite enable
#define ADC1_GC                 *(volatile unsigned long *)(ADC1_BLOCK + 0x048) // ADC1 general control register
    #define ADC_GC_ADACKEN      0x00000001                               // asynchronous clock and clock output enabled regardless of ADC state
    #define ADC_GC_DMAEN        0x00000002                               // DMA enabled
    #define ADC_GC_ACREN        0x00000004                               // compare function range enable
    #define ADC_GC_ACFGT        0x00000008                               // compare function greater than enable
    #define ADC_GC_ACFE         0x00000010                               // compare function enable
    #define ADC_GC_AVGE         0x00000020                               // hardware average enable
    #define ADC_GC_ADCO         0x00000040                               // continuous conversion enable
    #define ADC_GC_CAL          0x00000080                               // calibration (self resetting)
#define ADC1_GS                 *(volatile unsigned long *)(ADC1_BLOCK + 0x04c) // ADC1 general status register
    #define ADC_GS_ADACT        0x00000001                               // ADC conversion in progress (read-only)
    #define ADC_GS_CALF         0x00000002                               // ADC calibration failed flag (write '1' to clear)
    #define ADC_GS_AWKST        0x00000004                               // ADC Asynchronous wake up interrupt occurred in stop mode (write '1' to clear)
#define ADC1_CV                 *(unsigned long *)(ADC1_BLOCK + 0x050)   // ADC1 compare value register
#define ADC1_OFS                *(unsigned long *)(ADC1_BLOCK + 0x054)   // ADC1 offset correction value register
#define ADC1_CAL                *(volatile unsigned long *)(ADC1_BLOCK + 0x058) // ADC1 calibration value register
                                
#define ADC2_HC0                *(unsigned long *)(ADC2_BLOCK + 0x000)   // ADC2 control register for hardware triggers 0
#define ADC2_HC1                *(unsigned long *)(ADC2_BLOCK + 0x004)   // ADC2 control register for hardware triggers 1
#define ADC2_HC2                *(unsigned long *)(ADC2_BLOCK + 0x008)   // ADC2 control register for hardware triggers 2
#define ADC2_HC3                *(unsigned long *)(ADC2_BLOCK + 0x00c)   // ADC2 control register for hardware triggers 3
#define ADC2_HC4                *(unsigned long *)(ADC2_BLOCK + 0x010)   // ADC2 control register for hardware triggers 4
#define ADC2_HC5                *(unsigned long *)(ADC2_BLOCK + 0x014)   // ADC2 control register for hardware triggers 5
#define ADC2_HC6                *(unsigned long *)(ADC2_BLOCK + 0x018)   // ADC2 control register for hardware triggers 6
#define ADC2_HC7                *(unsigned long *)(ADC2_BLOCK + 0x01c)   // ADC2 control register for hardware triggers 7
#define ADC2_HS                 *(volatile unsigned long *)(ADC2_BLOCK + 0x020) // ADC2 status register for HW triggers (reads '0')
#define ADC2_R0                 *(volatile unsigned long *)(ADC2_BLOCK + 0x024) // ADC2 data result register for HW triggers 0 (read-only)
#define ADC2_R1                 *(volatile unsigned long *)(ADC2_BLOCK + 0x028) // ADC2 data result register for HW triggers 1 (read-only)
#define ADC2_R2                 *(volatile unsigned long *)(ADC2_BLOCK + 0x02c) // ADC2 data result register for HW triggers 2 (read-only)
#define ADC2_R3                 *(volatile unsigned long *)(ADC2_BLOCK + 0x030) // ADC2 data result register for HW triggers 3 (read-only)
#define ADC2_R4                 *(volatile unsigned long *)(ADC2_BLOCK + 0x034) // ADC2 data result register for HW triggers 4 (read-only)
#define ADC2_R5                 *(volatile unsigned long *)(ADC2_BLOCK + 0x038) // ADC2 data result register for HW triggers 5 (read-only)
#define ADC2_R6                 *(volatile unsigned long *)(ADC2_BLOCK + 0x03c) // ADC2 data result register for HW triggers 6 (read-only)
#define ADC2_R7                 *(volatile unsigned long *)(ADC2_BLOCK + 0x040) // ADC2 data result register for HW triggers 7 (read-only)
#define ADC2_CFG                *(unsigned long *)(ADC2_BLOCK + 0x044)   // ADC2 configuration register
#define ADC2_GC                 *(volatile unsigned long *)(ADC2_BLOCK + 0x048) // ADC2 general control register
#define ADC2_GS                 *(volatile unsigned long *)(ADC2_BLOCK + 0x04c) // ADC2 general status register
#define ADC2_CV                 *(unsigned long *)(ADC2_BLOCK + 0x050)   // ADC2 compare value register
#define ADC2_OFS                *(unsigned long *)(ADC2_BLOCK + 0x054)   // ADC2 offset correction value register
#define ADC2_CAL                *(volatile unsigned long *)(ADC2_BLOCK + 0x058) // ADC2 calibration value register

#define ADC_SE0_SINGLE          0
#define ADC_SE1_SINGLE          1
#define ADC_SE2_SINGLE          2
#define ADC_SE3_SINGLE          3
#define ADC_SE4_SINGLE          4
#define ADC_SE5_SINGLE          5
#define ADC_SE6_SINGLE          6
#define ADC_SE7_SINGLE          7
#define ADC_SE8_SINGLE          8
#define ADC_SE9_SINGLE          9
#define ADC_SE10_SINGLE         10
#define ADC_SE11_SINGLE         11
#define ADC_SE12_SINGLE         12
#define ADC_SE13_SINGLE         13
#define ADC_SE14_SINGLE         14
#define ADC_SE15_SINGLE         15
#define ADC_ETC_SINGLE          16

#define ADC_VREFH               25

#define ADC_DISABLED            31

typedef struct stiMX_ADC_REGS
{
    unsigned long ADC_HC0;
    unsigned long ADC_HC1;
    unsigned long ADC_HC2;
    unsigned long ADC_HC3;
    unsigned long ADC_HC4;
    unsigned long ADC_HC5;
    unsigned long ADC_HC6;
    unsigned long ADC_HC7;
    volatile unsigned long ADC_HS;
    volatile unsigned long ADC_R0;
    volatile unsigned long ADC_R1;
    volatile unsigned long ADC_R2;
    volatile unsigned long ADC_R3;
    volatile unsigned long ADC_R4;
    volatile unsigned long ADC_R5;
    volatile unsigned long ADC_R6;
    volatile unsigned long ADC_R7;
    unsigned long ADC_CFG;
    volatile unsigned long ADC_GC;
    volatile unsigned long ADC_GS;
    unsigned long ADC_CV;
    unsigned long ADC_OFS;
    volatile unsigned long ADC_CAL;
} iMX_ADC_REGS;


// NAND Flash Controller (NFC)
//
#define NFC_CMD1            *(volatile unsigned long *)(NFC_BLOCK + 0x00)// Flash command 1
  #define NFC_CMD1_BYTES3   0x00ff0000                                   // third command byte that may be sent to the flash device
  #define NFC_CMD1_BYTES2   0xff000000                                   // second command byte that may be sent to the flash device
#define NFC_CMD2            *(volatile unsigned long *)(NFC_BLOCK + 0x04)// Flash command 2
  #define NFC_CMD2_BUSY_START 0x00000001                                 // busy indicator and start command
  #define NFC_CMD2_BUFNO    0x00000006                                   // internal buffer number used for command
  #define NFC_CMD2_CODE_START_DMA_WRITE_SRAM          0x00800200
  #define NFC_CMD2_CODE_SEND_COMMAND_BYTE1_TO_FLASH   0x00400200
  #define NFC_CMD2_CODE_SEND_COL_ADD1_TO_FLASH        0x00200200
  #define NFC_CMD2_CODE_SEND_COL_ADD2_TO_FLASH        0x00100200
  #define NFC_CMD2_CODE_SEND_ROW_ADD1_TO_FLASH        0x00080200
  #define NFC_CMD2_CODE_SEND_ROW_ADD2_TO_FLASH        0x00040200
  #define NFC_CMD2_CODE_SEND_ROW_ADD3_TO_FLASH        0x00020200
  #define NFC_CMD2_CODE_WRITE_DATA_TO_FLASH           0x00010200
  #define NFC_CMD2_CODE_SEND_COMMAND_BYTE2_TO_FLASH   0x00008200
  #define NFC_CMD2_CODE_WAIT_FOR_FLASH_R_B_HANDSHAKE  0x00004200
  #define NFC_CMD2_CODE_READ_DATA_FROM_FLASH          0x00002200
  #define NFC_CMD2_CODE_SEND_COMMAND_BYTE3_TO_FLASH   0x00001200
  #define NFC_CMD2_CODE_READ_FLASH_STATUS             0x00000a00
  #define NFC_CMD2_CODE_READ_ID                       0x00000600
  #define NFC_CMD2_BYTES1   0xff000000                                   // first command byte that may be sent to the flash device
#define NFC_CAR             *(unsigned long *)(NFC_BLOCK + 0x08)         // Column address
#define NFC_RAR             *(unsigned long *)(NFC_BLOCK + 0x0c)         // Row address
  #define NFC_RAR_RB0       0x01000000                                   // ready/busy 0 enabled
  #define NFC_RAR_RB1       0x02000000                                   // ready/busy 1 enabled
  #define NFC_RAR_CS0       0x10000000                                   // chip select 0 enabled
  #define NFC_RAR_CS1       0x20000000                                   // chip select 1 enabled
#define NFC_RPT             *(unsigned long *)(NFC_BLOCK + 0x10)         // Flash command repeat
#define NFC_RAI             *(unsigned long *)(NFC_BLOCK + 0x14)         // Row address increment
#define NFC_SR1             *(volatile unsigned long *)(NFC_BLOCK + 0x18)// Flash status 1 (read-only)
#define NFC_SR2             *(volatile unsigned long *)(NFC_BLOCK + 0x1c)// Flash status 2 (read-only)
#define NFC_DMA1            *(unsigned long *)(NFC_BLOCK + 0x20)         // DMA channel 1 address
#define NFC_DMACFG          *(unsigned long *)(NFC_BLOCK + 0x24)         // DMA channel 1 configuration
#define NFC_SWAP            *(unsigned long *)(NFC_BLOCK + 0x28)         // Cache swap
#define NFC_SECSZ           *(unsigned long *)(NFC_BLOCK + 0x2c)         // Sector size
#define NFC_CFG             *(unsigned long *)(NFC_BLOCK + 0x30)         // Flash configuration
  #define NFC_CFG_PAGECNT   0x0000000f                                   // number of virtual pages to be read or written
  #define NFC_CFG_AIBN      0x00000010                                   // auto-increment the buffer number
  #define NFC_CFG_AIAD      0x00000020                                   // auto-increment the flash row address
  #define NFC_CFG_BITWIDTH_8  0x00000000                                 // 8-bit wide flash mode
  #define NFC_CFG_BITWIDTH_16 0x00000080                                 // 16-bit wide flash mode
  #define NFC_CFG_TIMEOUT   0x00001f00                                   // timeout value in flash clock sycles
  #define NFC_CFG_IDCNT     0x0000e000                                   // number of bytes that are read for the read ID command
  #define NFC_CFG_IDCNT_5   0x0000a000
  #define NFC_CFG_FAST      0x00010000                                   // fast flash timing
  #define NFC_CFG_ECCMODE_NONE 0x00000000                                // ECC bypass
  #define NFC_CFG_ECCMODE_8  0x00020000                                  // ECC using 8 bytes for 4-error correction
  #define NFC_CFG_ECCMODE_12 0x00040000                                  // ECC using 12 bytes for 6-error correction
  #define NFC_CFG_ECCMODE_15 0x00060000                                  // ECC using 15 bytes for 8-error correction
  #define NFC_CFG_ECCMODE_23 0x00080000                                  // ECC using 23 bytes for 12-error correction
  #define NFC_CFG_ECCMODE_30 0x000a0000                                  // ECC using 30 bytes for 16-error correction
  #define NFC_CFG_ECCMODE_45 0x000c0000                                  // ECC using 45 bytes for 24-error correction
  #define NFC_CFG_ECCMODE_60 0x000e0000                                  // ECC using 60 bytes for 32-error correction
  #define NFC_CFG_DMAREQ     0x00100000                                  // after ECC done, transfer sector using DMA
  #define NFC_CFG_ECCSRAM    0x00200000                                  // write ECC status to SRAM
  #define NFC_CFG_ECCAD      0x7fc00000                                  // byte address in SRAM where ECC status is written
  #define NFC_CFG_STOPWERR   0x80000000                                  // auto-sequencer stops on a write error
#define NFC_DMA2            *(unsigned long *)(NFC_BLOCK + 0x34)         // DMA channel 2 address
#define NFC_ISR             *(volatile unsigned long *)(NFC_BLOCK + 0x38)// Interrupt status
  #define NFC_ISR_DMABN     0x00000003                                   // DMA buffer number
  #define NFC_ISR_ECCBN     0x0000000c                                   // ECC buffer number
  #define NFC_ISR_RESBN     0x00000030                                   // residue buffer number
  #define NFC_ISR_IDLECLR   0x00020000                                   // IDLE clear (write '1' to clear)
  #define NFC_ISR_DONECLR   0x00040000                                   // DONE clear (write '1' to clear)
  #define NFC_ISR_WERRCLR   0x00080000                                   // WERR clear (write '1' to clear)
  #define NFC_ISR_IDLEEN    0x00100000                                   // IDLE enable
  #define NFC_ISR_DONEEN    0x00200000                                   // DONE enable
  #define NFC_ISR_WERREN    0x00400000                                   // WERR enable
  #define NFC_ISR_DMABUSY   0x00800000                                   // DMA engine busy (read-only)
  #define NFC_ISR_ECCBUSY   0x01000000                                   // EEC engine busy (read-only)
  #define NFC_ISR_RESBUSY   0x02000000                                   // residue engine busy (read-only)
  #define NFC_ISR_CMDBUSY   0x04000000                                   // command busy (read-only)
  #define NFC_ISR_WERRNS    0x08000000                                   // write error status (read-only) - non-sticky
  #define NFC_ISR_IDLE      0x20000000                                   // command done and all engines are idle (read-only)
  #define NFC_ISR_DONE      0x40000000                                   // command processing done (read-only)
  #define NFC_ISR_WERR      0x80000000                                   // write error status (read-only) - non-sticky


#if defined ENHANCED_LCD_INTERFACE
    // Enhanced LCD controller (eLCDIF)
    //
    #define LCDIF_CTRL         *(volatile unsigned long *)(LCDC_BLOCK + 0x000) // LCDIF general control register
        #define LCDIF_CTRL_RUN                   0x00000001              // LCD operation enabled (transfers data between the SoC and the display)
        #define LCDIF_CTRL_DATA_FORMAT_24_BIT    0x00000002              // drop upper 2 bits per byte when enabled
        #define LCDIF_CTRL_DATA_FORMAT_18_BIT    0x00000004              // upper 18 bits valid
        #define LCDIF_CTRL_DATA_FORMAT_16_BIT    0x00000008              // ARGB555 format (rather than RGB565 format)
        #define LCDIF_CTRL_MASTER                0x00000020              // LCDIF acts as bus master
        #define LCDIF_CTRL_ENABLE_PXP_HANDSHAKE  0x00000040              // 
        #define LCDIF_CTRL_WORD_LENGTH_8_BIT     0x00000100              // input data is 8 bits per pixel
        #define LCDIF_CTRL_WORD_LENGTH_16_BIT    0x00000000              // input data is 16 bits per pixel
        #define LCDIF_CTRL_WORD_LENGTH_18_BIT    0x00000200              // input data is 18 bits per pixel
        #define LCDIF_CTRL_WORD_LENGTH_24_BIT    0x00000300              // input data is 24 bits per pixel
        #define LCDIF_CTRL_LCD_DATABUS_WIDTH_8   0x00000400              // 8 bit data bus mode
        #define LCDIF_CTRL_LCD_DATABUS_WIDTH_16  0x00000000              // 16 bit data bus mode
        #define LCDIF_CTRL_LCD_DATABUS_WIDTH_18  0x00000800              // 18 bit data bus mode
        #define LCDIF_CTRL_LCD_DATABUS_WIDTH_24  0x00000c00              // 24 bit data bus mode
        #define LCDIF_CTRL_CSC_DATA_SWIZZLE_LITTLE_ENDIAN  0x00000000    // no byte swapping (little-endian)
        #define LCDIF_CTRL_CSC_DATA_SWIZZLE_BIG_ENDIAN     0x00001000    // big-endan swap
        #define LCDIF_CTRL_CSC_DATA_SWIZZLE_HW_SWAP        0x00002000    // half-word swap
        #define LCDIF_CTRL_CSC_DATA_SWIZZLE_BYTE_SWAP      0x00003000    // swap bytes within each half-word
        #define LCDIF_CTRL_INPUT_DATA_SWIZZLE_LITTLE_ENDIAN 0x00000000   // no byte swapping (little-endian)
        #define LCDIF_CTRL_INPUT_DATA_SWIZZLE_BIG_ENDIAN    0x00004000   // big-endan swap
        #define LCDIF_CTRL_INPUT_DATA_SWIZZLE_HW_SWAP       0x00008000   // half-word swap
        #define LCDIF_CTRL_INPUT_DATA_SWIZZLE_BYTE_SWAP     0x0000c000   // swap bytes within each half-word
        #define LCDIF_CTRL_DOT_CLOCK_MODE        0x00020000              //
        #define LCDIF_CTRL_BYPASS_COUNT          0x00080000              //
        #define LCDIF_CTRL_SHIFT_NUM_BITS_MASK   0x02e00000              //
        #define LCDIF_CTRL_DATA_SHIFT_DIR        0x04000000              //
        #define LCDIF_CTRL_CLKGATE               0x40000000              // gates clocks to the LCD block
        #define LCDIF_CTRL_SFTRST                0x80000000              // block level reset
    #define LCDIF_CTRL_SET     *(volatile unsigned long *)(LCDC_BLOCK + 0x004) // LCDIF general control register - set
    #define LCDIF_CTRL_CLR     *(volatile unsigned long *)(LCDC_BLOCK + 0x008) // LCDIF general control register - clear
    #define LCDIF_CTRL_TOG     *(volatile unsigned long *)(LCDC_BLOCK + 0x00c) // LCDIF general control register - toggle
    #define LCDIF_CTRL1        *(volatile unsigned long *)(LCDC_BLOCK + 0x010) // LCDIF general control register
        #define LCDIF_CTRL1_VSYNC_EDGE_IRQ        0x00000100              // VSYNC edge interrupt flag - cleared by writing a '1' to its SCT clear address
        #define LCDIF_CTRL1_CUR_FRAME_DONE_IRQ    0x00000200              // current frame done interrupt flag - cleared by writing a '1' to its SCT clear address
        #define LCDIF_CTRL1_UNDERFLOW_IRQ         0x00000400              // underflow interrupt flag - cleared by writing a '1' to its SCT clear address
        #define LCDIF_CTRL1_OVERFLOW_IRQ          0x00000800              // overflow interrupt flag - cleared by writing a '1' to its SCT clear address
        #define LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN     0x00001000              // enable VSYNC edge interrupt
        #define LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN 0x00002000              // enable current frame done interrupt
        #define LCDIF_CTRL1_UNDERFLOW_IRQ_EN      0x00004000              // enable underflow interrupt
        #define LCDIF_CTRL1_OVERFLOW_IRQ_EN       0x00008000              // enable overflow interrupt
        #define LCDIF_CTRL1_BYTE_PACKING_FORMAT_24_ARGB  0x00070000       // byte packing format 24-bit unpacket format (A-R-G-B where A values isn't transmitted)
        #define LCDIF_CTRL1_BYTE_PACKING_FORMAT_16_IN_32 0x000f0000       // two 16 it words in each 32 bit source
    #define LCDIF_CTRL1_SET    *(volatile unsigned long *)(LCDC_BLOCK + 0x014) // LCDIF general control register - set
    #define LCDIF_CTRL1_CLR    *(volatile unsigned long *)(LCDC_BLOCK + 0x018) // LCDIF general control register - clear
    #define LCDIF_CTRL1_TOG    *(volatile unsigned long *)(LCDC_BLOCK + 0x01c) // LCDIF general control register - toggle
    #define LCDIF_CTRL2        *(volatile unsigned long *)(LCDC_BLOCK + 0x020) // LCDIF general control register
        #define LCDIF_CTRL2_EVEN_LINE_PATTERN_MASK 0x00007000
        #define LCDIF_CTRL2_ODD_LINE_PATTERN_MASK  0x00070000
        #define LCDIF_CTRL2_BURST_LEN_8            0x00100000
        #define LCDIF_CTRL2_OUTSTANDING_REQS_1     0x00000000
        #define LCDIF_CTRL2_OUTSTANDING_REQS_2     0x00200000
        #define LCDIF_CTRL2_OUTSTANDING_REQS_4     0x00400000
        #define LCDIF_CTRL2_OUTSTANDING_REQS_8     0x00600000
        #define LCDIF_CTRL2_OUTSTANDING_REQS_16    0x00800000
        #define LCDIF_CTRL2_OUTSTANDING_REQS_MASK  0x00e00000
    #define LCDIF_CTRL2_SET    *(volatile unsigned long *)(LCDC_BLOCK + 0x024) // LCDIF general control register - set
    #define LCDIF_CTRL2_CLR    *(volatile unsigned long *)(LCDC_BLOCK + 0x028) // LCDIF general control register - clear
    #define LCDIF_CTRL2_TOG    *(volatile unsigned long *)(LCDC_BLOCK + 0x02c) // LCDIF general control register - toggle
    #define LCDIF_TRANSFER_COUNT  *(volatile unsigned long *)(LCDC_BLOCK + 0x030) // LCDIF horizontal and vertical valid data count register
    #define LCDIF_CUR_BUF      *(volatile unsigned long *)(LCDC_BLOCK + 0x040) // LCDIF interface current buffer address register
    #define LCDIF_NEXT_BUF     *(volatile unsigned long *)(LCDC_BLOCK + 0x050) // LCDIF interface next buffer address register
    #define LCDIF_VDCTRL0      *(volatile unsigned long *)(LCDC_BLOCK + 0x070) // LCDIF VSYNC mode and dotclk mode control register 0
        #define LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_MASK 0x0003ffff          // number of units for which VSYNC signal is active. For the DOTCLK mode, the unit is determined by the VSYNC_PULSE_WIDTH_UNIT - if the VSYNC_PULSE_WIDTH_UNIT is 0 for DOTCLK mode, VSYNC_PULSE_WIDTH must be less than HSYNC_PERIOD - for the VSYNC interface mode, it should be in terms of number of DISPLAY CLOCK(pix_clk) cycles only
        #define LCDIF_VDCTRL0_HALF_LINE_MODE         0x00040000          // all fields end with half a horizontal line and none will begin with half a horizontal line
        #define LCDIF_VDCTRL0_HALF_LINE              0x00080000          // total VSYNC period equal to the VSYNC_PERIOD field plus half the HORIZONTAL_PERIOS field
        #define LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT 0x00100000
        #define LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT      0x00200000
        #define LCDIF_VDCTRL0_ENABLE_POL             0x01000000          // active high
        #define LCDIF_VDCTRL0_DOTCLK_POL             0x02000000          // inverted dot polarity
        #define LCDIF_VDCTRL0_HSYNC_POL              0x04000000
        #define LCDIF_VDCTRL0_VSYNC_POL              0x08000000
        #define LCDIF_VDCTRL0_ENABLE_PRESENT         0x10000000          // generate ENABE signal in the DOZCLK moe
    #define LCDIF_VDCTRL0_SET  *(volatile unsigned long *)(LCDC_BLOCK + 0x074) // LCDIF VSYNC mode and dotclk mode control register 0 - set
    #define LCDIF_VDCTRL0_CLR  *(volatile unsigned long *)(LCDC_BLOCK + 0x078) // LCDIF VSYNC mode and dotclk mode control register 0 - clear
    #define LCDIF_VDCTRL0_TOG  *(volatile unsigned long *)(LCDC_BLOCK + 0x07c) // LCDIF VSYNC mode and dotclk mode control register 0 - toggle
    #define LCDIF_VDCTRL1      *(volatile unsigned long *)(LCDC_BLOCK + 0x080) // LCDIF VSYNC mode and dotclk mode control register 1
    #define LCDIF_VDCTRL2      *(volatile unsigned long *)(LCDC_BLOCK + 0x090) // LCDIF VSYNC mode and dotclk mode control register 2
    #define LCDIF_VDCTRL3      *(volatile unsigned long *)(LCDC_BLOCK + 0x0a0) // LCDIF VSYNC mode and dotclk mode control register 3
        #define LCDIF_VDCTRL3_VERTICAL_WAIT_CNT_MASK   0x0fffffff
        #define LCDIF_VDCTRL3_VSYNC_ONLY               0x10000000
        #define LCDIF_VDCTRL3_MUX_SYNC_SIGNALS         0x20000000
    #define LCDIF_VDCTRL4      *(volatile unsigned long *)(LCDC_BLOCK + 0x0b0) // LCDIF VSYNC mode and dotclk mode control register 4
        #define LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT_MASK 0x0003ffff
        #define LCDIF_VDCTRL4_SYNC_SIGNALS_ON          0x00040000
        #define LCDIF_VDCTRL4_DOTCLK_DLY_SEL_2ns       0x00000000
        #define LCDIF_VDCTRL4_DOTCLK_DLY_SEL_4ns       0x20000000
        #define LCDIF_VDCTRL4_DOTCLK_DLY_SEL_6ns       0x40000000
        #define LCDIF_VDCTRL4_DOTCLK_DLY_SEL_8ns       0x60000000
    #define LCDIF_BM_ERROR_STAT   *(volatile unsigned long *)(LCDC_BLOCK + 0x190) // LCDIF bus master error status register
    #define LCDIF_CRC_STAT     *(volatile unsigned long *)(LCDC_BLOCK + 0x1a0) // LCDIF CRC status register
    #define LCDIF_STAT         *(volatile unsigned long *)(LCDC_BLOCK + 0x1b0) // LCDIF nterface status register (read-only)
    #define LCDIF_RGB_ADJUST   *(volatile unsigned long *)(LCDC_BLOCK + 0x2a0) // LCDIF RGB color range adjust register
    #define LCDIF_RGB_ADJUST_SET  *(volatile unsigned long *)(LCDC_BLOCK + 0x2a4) // LCDIF RGB color range adjust register - set
    #define LCDIF_RGB_ADJUST_CLR  *(volatile unsigned long *)(LCDC_BLOCK + 0x2a8) // LCDIF RGB color range adjust register - clear
    #define LCDIF_RGB_ADJUST_TOG  *(volatile unsigned long *)(LCDC_BLOCK + 0x2ac) // LCDIF RGB color range adjust register - toggle
    #define LCDIF_PIGEONCTRL0     *(volatile unsigned long *)(LCDC_BLOCK + 0x380) // LCDIF pigeon mode control 0 register
    #define LCDIF_PIGEONCTRL0_SET *(volatile unsigned long *)(LCDC_BLOCK + 0x384) // LCDIF pigeon mode control 0 register - set
    #define LCDIF_PIGEONCTRL0_CLR *(volatile unsigned long *)(LCDC_BLOCK + 0x388) // LCDIF pigeon mode control 0 register - clear
    #define LCDIF_PIGEONCTRL0_TOG *(volatile unsigned long *)(LCDC_BLOCK + 0x38c) // LCDIF pigeon mode control 0 register - toggle
    #define LCDIF_PIGEONCTRL1     *(volatile unsigned long *)(LCDC_BLOCK + 0x390) // LCDIF pigeon mode control 1 register
    #define LCDIF_PIGEONCTRL1_SET *(volatile unsigned long *)(LCDC_BLOCK + 0x394) // LCDIF pigeon mode control 1 register - set
    #define LCDIF_PIGEONCTRL1_CLR *(volatile unsigned long *)(LCDC_BLOCK + 0x398) // LCDIF pigeon mode control 1 register - clear
    #define LCDIF_PIGEONCTRL1_TOG *(volatile unsigned long *)(LCDC_BLOCK + 0x39c) // LCDIF pigeon mode control 1 register - toggle
    #define LCDIF_PIGEONCTRL2     *(volatile unsigned long *)(LCDC_BLOCK + 0x3a0) // LCDIF pigeon mode control 2 register
    #define LCDIF_PIGEONCTRL2_SET *(volatile unsigned long *)(LCDC_BLOCK + 0x3a4) // LCDIF pigeon mode control 2 register - set
    #define LCDIF_PIGEONCTRL2_CLR *(volatile unsigned long *)(LCDC_BLOCK + 0x3a8) // LCDIF pigeon mode control 2 register - clear
    #define LCDIF_PIGEONCTRL2_TOG *(volatile unsigned long *)(LCDC_BLOCK + 0x3ac) // LCDIF pigeon mode control 2 register - toggle
    #define LCDIF_PIGEON_0_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x800) // LCDIF panel 0 interface signal generator register 0
    #define LCDIF_PIGEON_0_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x810) // LCDIF panel 0 interface signal generator register 1
    #define LCDIF_PIGEON_0_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x820) // LCDIF panel 0 interface signal generator register 2
    #define LCDIF_PIGEON_1_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x840) // LCDIF panel 1 interface signal generator register 0
    #define LCDIF_PIGEON_1_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x850) // LCDIF panel 1 interface signal generator register 1
    #define LCDIF_PIGEON_1_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x860) // LCDIF panel 1 interface signal generator register 2
    #define LCDIF_PIGEON_2_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x880) // LCDIF panel 2 interface signal generator register 0
    #define LCDIF_PIGEON_2_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x890) // LCDIF panel 2 interface signal generator register 1
    #define LCDIF_PIGEON_2_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x8a0) // LCDIF panel 2 interface signal generator register 2
    #define LCDIF_PIGEON_3_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x8c0) // LCDIF panel 3 interface signal generator register 0
    #define LCDIF_PIGEON_3_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x8d0) // LCDIF panel 3 interface signal generator register 1
    #define LCDIF_PIGEON_3_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x8e0) // LCDIF panel 3 interface signal generator register 2
    #define LCDIF_PIGEON_4_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x900) // LCDIF panel 4 interface signal generator register 0
    #define LCDIF_PIGEON_4_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x910) // LCDIF panel 4 interface signal generator register 1
    #define LCDIF_PIGEON_4_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x920) // LCDIF panel 4 interface signal generator register 2
    #define LCDIF_PIGEON_5_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x940) // LCDIF panel 5 interface signal generator register 0
    #define LCDIF_PIGEON_5_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x950) // LCDIF panel 5 interface signal generator register 1
    #define LCDIF_PIGEON_5_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x960) // LCDIF panel 5 interface signal generator register 2
    #define LCDIF_PIGEON_6_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x980) // LCDIF panel 6 interface signal generator register 0
    #define LCDIF_PIGEON_6_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x990) // LCDIF panel 6 interface signal generator register 1
    #define LCDIF_PIGEON_6_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x9a0) // LCDIF panel 6 interface signal generator register 2
    #define LCDIF_PIGEON_7_0      *(volatile unsigned long *)(LCDC_BLOCK + 0x9c0) // LCDIF panel 7 interface signal generator register 0
    #define LCDIF_PIGEON_7_1      *(volatile unsigned long *)(LCDC_BLOCK + 0x9d0) // LCDIF panel 7 interface signal generator register 1
    #define LCDIF_PIGEON_7_2      *(volatile unsigned long *)(LCDC_BLOCK + 0x9e0) // LCDIF panel 7 interface signal generator register 2
    #define LCDIF_PIGEON_8_0      *(volatile unsigned long *)(LCDC_BLOCK + 0xa00) // LCDIF panel 8 interface signal generator register 0
    #define LCDIF_PIGEON_8_1      *(volatile unsigned long *)(LCDC_BLOCK + 0xa10) // LCDIF panel 8 interface signal generator register 1
    #define LCDIF_PIGEON_8_2      *(volatile unsigned long *)(LCDC_BLOCK + 0xa20) // LCDIF panel 8 interface signal generator register 2
    #define LCDIF_PIGEON_9_0      *(volatile unsigned long *)(LCDC_BLOCK + 0xa40) // LCDIF panel 9 interface signal generator register 0
    #define LCDIF_PIGEON_9_1      *(volatile unsigned long *)(LCDC_BLOCK + 0xa50) // LCDIF panel 9 interface signal generator register 1
    #define LCDIF_PIGEON_9_2      *(volatile unsigned long *)(LCDC_BLOCK + 0xa60) // LCDIF panel 9 interface signal generator register 2
    #define LCDIF_PIGEON_10_0     *(volatile unsigned long *)(LCDC_BLOCK + 0xa80) // LCDIF panel 10 interface signal generator register 0
    #define LCDIF_PIGEON_10_1     *(volatile unsigned long *)(LCDC_BLOCK + 0xa90) // LCDIF panel 10 interface signal generator register 1
    #define LCDIF_PIGEON_10_2     *(volatile unsigned long *)(LCDC_BLOCK + 0xaa0) // LCDIF panel 10 interface signal generator register 2
    #define LCDIF_PIGEON_11_0     *(volatile unsigned long *)(LCDC_BLOCK + 0xac0) // LCDIF panel 11 interface signal generator register 0
    #define LCDIF_PIGEON_11_1     *(volatile unsigned long *)(LCDC_BLOCK + 0xad0) // LCDIF panel 11 interface signal generator register 1
    #define LCDIF_PIGEON_11_2     *(volatile unsigned long *)(LCDC_BLOCK + 0xae0) // LCDIF panel 11 interface signal generator register 2
    #define LCDIF_LUT_CTRL        *(volatile unsigned long *)(LCDC_BLOCK + 0xb00) // LCDIF lookup table control register
    #define LCDIF_LUT0_ADDR       *(volatile unsigned long *)(LCDC_BLOCK + 0xb10) // LCDIF lookup table 0 address register
    #define LCDIF_LUT0_DATA       *(volatile unsigned long *)(LCDC_BLOCK + 0xb20) // LCDIF lookup table 0 data register
    #define LCDIF_LUT1_ADDR       *(volatile unsigned long *)(LCDC_BLOCK + 0xb30) // LCDIF lookup table 1 address register
    #define LCDIF_LUT1_DATA       *(volatile unsigned long *)(LCDC_BLOCK + 0xb40) // LCDIF lookup table 1 data register
#endif


// SDHC
//
#if NUMBER_OF_SDHC > 0
    #define SDHC_DSADDR          *(unsigned long *)(SDHC_BLOCK_1 + 0x000)// SDHC1 DMA system address register
    #define SDHC_BLKATTR         *(unsigned long *)(SDHC_BLOCK_1 + 0x004)// SDHC1 block attributes register
        #define SDHC_BLKATTR_BLKCNT_SHIFT 16
        #define SDHC_BLKATTR_BLKSIZE_MASK 0x00001fff
    #define SDHC_CMDARG          *(unsigned long *)(SDHC_BLOCK_1 + 0x008)// SDHC1 command argument register
    #define SDHC_XFERTYP         *(unsigned long *)(SDHC_BLOCK_1 + 0x00c)// SDHC1 command transfer type register
        #define SDHC_XFERTYP_RSPTYP_NONE  0x00000000                     // response type select - no response
        #define SDHC_XFERTYP_RSPTYP_126   0x00010000                     // response type select - response length 136
        #define SDHC_XFERTYP_RSPTYP_48    0x00020000                     // response type select - response length 48
        #define SDHC_XFERTYP_RSPTYP_48BSY 0x00030000                     // response type select - response length 48 - check busy after response
        #define SDHC_XFERTYP_CCCEN        0x00080000                     // command CRC check enable
        #define SDHC_XFERTYP_CICEN        0x00100000                     // command index check enable
        #define SDHC_XFERTYP_DPSEL        0x00200000                     // data present select
        #define SDHC_XFERTYP_CMDTYP_NORM  0x00000000                     // command type
        #define SDHC_XFERTYP_CMDTYP_SUSP  0x00400000            
        #define SDHC_XFERTYP_CMDTYP_RESUM 0x00800000            
        #define SDHC_XFERTYP_CMDTYP_ABORT 0x00c00000            
        #define SDHC_XFERTYP_CMDINX_MASK  0x3f000000                     // command Index value
        #define SDHC_XFERTYP_CMDINX_SHIFT 24
    #define SDHC_CMDRSP0        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x010) // SDHC1 command response register 0 (read-only)
    #define SDHC_CMDRSP1        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x014) // SDHC1 command response register 1 (read-only)
    #define SDHC_CMDRSP2        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x018) // SDHC1 command response register 2 (read-only)
    #define SDHC_CMDRSP3        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x01c) // SDHC1 command response register 3 (read-only)
    #define SDHC_DATPORT_ADDR   (unsigned long *)(SDHC_BLOCK_1 + 0x020)
    #define SDHC_DATPORT        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x020) // SDHC1 buffer data port register
    #define SDHC_PRSSTAT        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x024) // SDHC1 present status register (read-only)
        #define SDHC_PRSSTAT_CIHB      0x00000001                        // command inhibit (CMD)
        #define SDHC_PRSSTAT_CCIHB     0x00000002                        // command inhibit (DAT)
        #define SDHC_PRSSTAT_DLA       0x00000004                        // data line active
        #define SDHC_PRSSTAT_SDSTB     0x00000008                        // SD clock stable
        #define SDHC_PRSSTAT_IPGOFF    0x00000010                        // bus clock gated off internally
        #define SDHC_PRSSTAT_HCKOFF    0x00000020                        // system clock gated off internally
        #define SDHC_PRSSTAT_PEROFF    0x00000040                        // SDHC clock gated off internally
        #define SDHC_PRSSTAT_SDOFF     0x00000080                        // SD clock gated off internally
        #define SDHC_PRSSTAT_WTA       0x00000100                        // write transfer active
        #define SDHC_PRSSTAT_RTA       0x00000200                        // read transfer active
        #define SDHC_PRSSTAT_BWEN      0x00000400                        // buffer write enable (non-DMA write transfers)
        #define SDHC_PRSSTAT_BREN      0x00000800                        // buffer read enable (non-DMA read transfers)
        #define SDHC_PRSSTAT_RTR       0x00001000                        // sampling clock needs re-tuning
        #define SDHC_PRSSTAT_TSCD      0x00008000                        // delay cell select change is finished
        #define SDHC_PRSSTAT_CINST     0x00010000                        // card presently inserted
        #define SDHC_PRSSTAT_CDPL      0x00040000                        // card present (not debounced)
        #define SDHC_PRSSTAT_WPSPL     0x00080000                        // write enabled (not write protected)
        #define SDHC_PRSSTAT_CLSL      0x00800000                        // CMD line signal level
        #define SDHC_PRSSTAT_DLSL_MASK 0xff000000                        // DAT line signal level
    #define SDHC_PROCTL         *(unsigned long *)(SDHC_BLOCK_1 + 0x028) // SDHC1 protocol control register
        #define SDHC_PROCTL_LCTL         0x00000001                      // LED control
        #define SDHC_PROCTL_DTW_1BIT     0x00000000                      // data transmit width 1 bit
        #define SDHC_PROCTL_DTW_4BIT     0x00000002                      // data transmit width 4 bits
        #define SDHC_PROCTL_DTW_8BIT     0x00000004                      // data transmit width 8 bits
        #define SDHC_PROCTL_D3CD         0x00000008                      // DAT3 as card detection pin
        #define SDHC_PROCTL_EMODE_BIG    0x00000000                      // big endian mode
        #define SDHC_PROCTL_EMODE_HBIG   0x00000010                      // half-word big endian mode
        #define SDHC_PROCTL_EMODE_LITTLE 0x00000020                      // little endian mode
        #define SDHC_PROCTL_CDTL         0x00000040                      // card detect test level
        #define SDHC_PROCTL_CDSS         0x00000080                      // card detect signal selection
        #define SDHC_PROCTL_DMAS_SIMPLE  0x00000000                      // No DMA or simple DMA
        #define SDHC_PROCTL_DMAS_ADMA1   0x00000100                      // ADMA1
        #define SDHC_PROCTL_DMAS_ADMA2   0x00000200                      // ADMA2
        #define SDHC_PROCTL_SABGREQ      0x00010000                      // stop at block gap request
        #define SDHC_PROCTL_CREQ         0x00020000                      // continue request
        #define SDHC_PROCTL_RWCTL        0x00040000                      // read wait control
        #define SDHC_PROCTL_IABG         0x00080000                      // interrupt at block gap
        #define SDHC_PROCTL_RD_DONE_NO_8CLK  0x00100000                  //
        #define SDHC_PROCTL_WECINT       0x01000000                      // wakeup event on card interrupt
        #define SDHC_PROCTL_WECINS       0x02000000                      // wakeup event enable on SD card insert
        #define SDHC_PROCTL_WECRM        0x04000000                      // wakeup event enable on SD card removal
        #define SDHC_PROCTL_BURST_LEN_EN_INCR   0x08000000               // burst length is enabled for INCR
        #define SDHC_PROCTL_BURST_LEN_EN_INCRX  0x10000000               // burst length is enabled for INCR4/INCR8/INCR16
        #define SDHC_PROCTL_BURST_LEN_EN_INCRXW 0x20000000               // burst length is enabled for INCR4-WRAP/INCR8-WRAP/INCR16-WRAP
        #define SDHC_PROCTL_NON_EXACT_BLK_RD    0x40000000               //
    #define SDHC_SYSCTL         *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x02c) // SDHC1 system control register
        #define SDHC_SYSCTL_RESERVED  0x0000000f                         // reserved bits that should be written as '1'
        #define SDHC_SYSCTL_DVS_1     0x00000000                         // SDCLK frequency divisor 1
        #define SDHC_SYSCTL_DVS_2     0x00000010                         // SDCLK frequency divisor 2
        #define SDHC_SYSCTL_DVS_3     0x00000020                         // SDCLK frequency divisor 3
        #define SDHC_SYSCTL_DVS_4     0x00000030                         // SDCLK frequency divisor 4
        #define SDHC_SYSCTL_DVS_5     0x00000040                         // SDCLK frequency divisor 5
        #define SDHC_SYSCTL_DVS_6     0x00000050                         // SDCLK frequency divisor 6
        #define SDHC_SYSCTL_DVS_7     0x00000060                         // SDCLK frequency divisor 7
        #define SDHC_SYSCTL_DVS_8     0x00000070                         // SDCLK frequency divisor 8
        #define SDHC_SYSCTL_DVS_9     0x00000080                         // SDCLK frequency divisor 9
        #define SDHC_SYSCTL_DVS_10    0x00000090                         // SDCLK frequency divisor 10
        #define SDHC_SYSCTL_DVS_11    0x000000a0                         // SDCLK frequency divisor 11
        #define SDHC_SYSCTL_DVS_12    0x000000b0                         // SDCLK frequency divisor 12
        #define SDHC_SYSCTL_DVS_13    0x000000c0                         // SDCLK frequency divisor 13
        #define SDHC_SYSCTL_DVS_14    0x000000d0                         // SDCLK frequency divisor 14
        #define SDHC_SYSCTL_DVS_15    0x000000e0                         // SDCLK frequency divisor 15
        #define SDHC_SYSCTL_DVS_16    0x000000f0                         // SDCLK frequency divisor 16
        #define SDHC_SYSCTL_SDCLKFS_1 0x00000000                         // SDCLK frequency select - base clock divided by 1
        #define SDHC_SYSCTL_SDCLKFS_2 0x00000100                         // SDCLK frequency select - base clock divided by 2
        #define SDHC_SYSCTL_SDCLKFS_4 0x00000200                         // SDCLK frequency select - base clock divided by 4
        #define SDHC_SYSCTL_SDCLKFS_8 0x00000400                         // SDCLK frequency select - base clock divided by 8
        #define SDHC_SYSCTL_SDCLKFS_16 0x00000800                        // SDCLK frequency select - base clock divided by 16
        #define SDHC_SYSCTL_SDCLKFS_32 0x00001000                        // SDCLK frequency select - base clock divided by 32
        #define SDHC_SYSCTL_SDCLKFS_64 0x00002000                        // SDCLK frequency select - base clock divided by 64
        #define SDHC_SYSCTL_SDCLKFS_128 0x00004000                       // SDCLK frequency select - base clock divided by 128
        #define SDHC_SYSCTL_SDCLKFS_256 0x00008000                       // SDCLK frequency select - base clock divided by 256
        #define SDHC_SYSCTL_DTOCV_SDCLK_14 0x00000000                    // data timeout counter value - SD * 2^14 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_15 0x00010000                    // data timeout counter value - SD * 2^15 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_16 0x00020000                    // data timeout counter value - SD * 2^16 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_17 0x00030000                    // data timeout counter value - SD * 2^17 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_18 0x00040000                    // data timeout counter value - SD * 2^18 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_19 0x00050000                    // data timeout counter value - SD * 2^19 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_20 0x00060000                    // data timeout counter value - SD * 2^20 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_21 0x00070000                    // data timeout counter value - SD * 2^21 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_22 0x00080000                    // data timeout counter value - SD * 2^22 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_23 0x00090000                    // data timeout counter value - SD * 2^23 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_24 0x000a0000                    // data timeout counter value - SD * 2^24 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_25 0x000b0000                    // data timeout counter value - SD * 2^25 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_26 0x000c0000                    // data timeout counter value - SD * 2^26 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_27 0x000d0000                    // data timeout counter value - SD * 2^27 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_28 0x000e0000                    // data timeout counter value - SD * 2^28 clocks
        #define SDHC_SYSCTL_DTOCV_SDCLK_29 0x000f0000                    // data timeout counter value - SD * 2^29 clocks
        #define SDHC_SYSCTL_IPP_RST_N 0x00800000                         // not hardware software to card
        #define SDHC_SYSCTL_RSTA    0x01000000                           // software reset for all
        #define SDHC_SYSCTL_RSTC    0x02000000                           // software reset for CMD line
        #define SDHC_SYSCTL_RSTD    0x04000000                           // software reset for DAT line
        #define SDHC_SYSCTL_INITA   0x08000000                           // initialisation active (80 SD-clocks sent to card - self clearing)
        #define SDHC_SYSCTL_RSTT    0x10000000                           // reset tuning
    #define SDHC_IRQSTAT        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x030) // SDHC1 interrupt status register (write 1 to clear) 
        #define SDHC_IRQSTAT_CC    0x00000001                            // Command Complete
        #define SDHC_IRQSTAT_TC    0x00000002                            // Transfer Complete
        #define SDHC_IRQSTAT_BGE   0x00000004                            // Block Gap Event
        #define SDHC_IRQSTAT_DINT  0x00000008                            // DMA Interrupt
        #define SDHC_IRQSTAT_BWR   0x00000010                            // Buffer Write Ready
        #define SDHC_IRQSTAT_BRR   0x00000020                            // Buffer Read Ready
        #define SDHC_IRQSTAT_CINS  0x00000040                            // card insertion
        #define SDHC_IRQSTAT_CRM   0x00000080                            // card removal
        #define SDHC_IRQSTAT_CINT  0x00000100                            // card interrupt
        #define SDHC_IRQSTAT_RTE   0x00001000                            // re-tuning event
        #define SDHC_IRQSTAT_TP    0x00004000                            // tuning pass (CMD19 transfer successful)
        #define SDHC_IRQSTAT_CTOE  0x00010000                            // command timeout error
        #define SDHC_IRQSTAT_CCE   0x00020000                            // command CRC error
        #define SDHC_IRQSTAT_CEBE  0x00040000                            // command end bit error
        #define SDHC_IRQSTAT_CIE   0x00080000                            // command index error
        #define SDHC_IRQSTAT_DTOE  0x00100000                            // data timeout error
        #define SDHC_IRQSTAT_DCE   0x00200000                            // data CRC error
        #define SDHC_IRQSTAT_DEBE  0x00400000                            // data end bit error
        #define SDHC_IRQSTAT_AC12E 0x01000000                            // auto CMD12 Error
        #define SDHC_IRQSTAT_TNE   0x04000000                            // tuning error
        #define SDHC_IRQSTAT_DMAE  0x10000000                            // DMA error
    #define SDHC_IRQSTATEN      *(unsigned long *)(SDHC_BLOCK_1 + 0x034) // SDHC1 interrupt status enable register
    #define SDHC_IRQSIGEN       *(unsigned long *)(SDHC_BLOCK_1 + 0x038) // SDHC1 interrupt signal enable register
        #define SDHC_IRQSIGEN_CRMIEN  0x00000040                         // card insertion interrupt enable
        #define SDHC_IRQSIGEN_CINSIEN 0x00000080                         // card removal interrupt enable
        #define SDHC_IRQSIGEN_CINTIEN 0x00000100                         // card interrupt interrupt enable
    #define SDHC_AC12ERR        *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x03c) // SDHC1 auto CMD12 error status register (read-only)
    #define SDHC_HTCAPBLT       *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x040) // SDHC1 host controller capabilities register (read-only)
    #define SDHC_WML            *(unsigned long *)(SDHC_BLOCK_1 + 0x044) // SDHC1 watermark level register
    #define SDHC_MIXCTRL        *(unsigned long *)(SDHC_BLOCK_1 + 0x048) // SDHC1 mixer control register
        #define SDHC_MIXCTRL_DMAEN        0x00000001                     // enable DMA
        #define SDHC_MIXCTRL_BCEN         0x00000002                     // block count enable
        #define SDHC_MIXCTRL_AC12EN       0x00000004                     // auto CMD12 enable
        #define SDHC_MIXCTRL_DDR_EN       0x00000008                     // dual data rate mode selection
        #define SDHC_MIXCTRL_DTDSEL_WRITE 0x00000000                     // data transfer direction select - write
        #define SDHC_MIXCTRL_DTDSEL_READ  0x00000010                     // data transfer direction select - read
        #define SDHC_MIXCTRL_MSBSEL       0x00000020                     // multi-block select
        #define SDHC_MIXCTRL_NIBBLE_POS   0x00000040                     //
        #define SDHC_MIXCTRL_AC23EN       0x00000080                     // auto CMD23 enable
        #define SDHC_MIXCTRL_RESERVED     0x80000000                     // reseved - write as '1'
    #define SDHC_FEVT           *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x050) // SDHC1 force event register (write only)
    #define SDHC_ADMAES         *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x054) // SDHC1 ADMA error status register (read-only)
        #define SDHC_ADMAES_STSTOP  0x00000000                           // error state was Stop DMA
        #define SDHC_ADMAES_ST_FDS  0x00000001                           // error state was Fetch Descriptor
        #define SDHC_ADMAES_ST_CADR 0x00000002                           // error state was Change Address
        #define SDHC_ADMAES_ST_TFR  0x00000003                           // error state was Transfer Data
        #define SDHC_ADMAES_ADMALME 0x00000004                           // ADMA Length Mismatch Error
        #define SDHC_ADMAES_ADMADCE 0x00000008                           // ADMA Descriptor Error
    #define SDHC_ADSADDR        *(unsigned long *)(SDHC_BLOCK_1 + 0x058) // SDHC1 ADMA system address register

    #define SDHC_DLL_CTRL       *(unsigned long *)(SDHC_BLOCK_1 + 0x060) // SDHC1 delay line control register
    #define SDHC_DLL_STATUS     *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x064) // SDHC1 delay line status register
    #define SDHC_CLK_TUNE_CTRL_STATUS *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x068) // SDHC1 clock tuning control and status register

    #define SDHC_VENDOR         *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x0c0) // SDHC1 vendor specific register
        #define SDHC_VENDOR_VOLTSEL             0x00000002               // voltage select (low voltage range 1.8V)
        #define SDHC_VENDOR_AC12_WR_CHKBUSY_EN  0x00000008               // check busy after auto CMD12 for write data packet
    #define SDHC_MMCBOOT        *(unsigned long *)(SDHC_BLOCK_1 + 0x0c4) // SDHC1 MMC boot register
    #define SDHC_VEND_SPEC2     *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x0c8) // SDHC1 vendor specific 2 register
    #define SDHC_TUNING_CTRL    *(volatile unsigned long *)(SDHC_BLOCK_1 + 0x0cc) // SDHC1 tuning control register
#endif

#if NUMBER_OF_SDHC > 1
    #define SDHC2_DSADDR        *(unsigned long *)(SDHC_BLOCK_2 + 0x000)// SDHC2 DMA system address register
    #define SDHC2_BLKATTR       *(unsigned long *)(SDHC_BLOCK_2 + 0x004)// SDHC2 block attributes register
    #define SDHC2_CMDARG        *(unsigned long *)(SDHC_BLOCK_2 + 0x008) // SDHC2 command argument register
    #define SDHC2_XFERTYP       *(unsigned long *)(SDHC_BLOCK_2 + 0x00c) // SDHC2 command transfer type register
    #define SDHC2_CMDRSP0       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x010) // SDHC2 command response register 0 (read-only)
    #define SDHC2_CMDRSP1       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x014) // SDHC2 command response register 1 (read-only)
    #define SDHC2_CMDRSP2       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x018) // SDHC2 command response register 2 (read-only)
    #define SDHC2_CMDRSP3       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x01c) // SDHC2 command response register 3 (read-only)
    #define SDHC2_DATPORT_ADDR  (unsigned long *)(SDHC_BLOCK_2 + 0x020)
    #define SDHC2_DATPORT       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x020) // SDHC2 Buffer Data Port Register
    #define SDHC2_PRSSTAT       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x024) // SDHC2 Present Status Register (read-only)
    #define SDHC2_PROCTL        *(unsigned long *)(SDHC_BLOCK_2 + 0x028) // SDHC2 protocol control register
    #define SDHC2_SYSCTL        *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x02c) // SDHC2 system control register
    #define SDHC2_IRQSTAT       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x030) // SDHC2 interrupt status register (write 1 to clear) 
    #define SDHC2_IRQSTATEN     *(unsigned long *)(SDHC_BLOCK_2 + 0x034) // SDHC2 interrupt status enable register
    #define SDHC2_IRQSIGEN      *(unsigned long *)(SDHC_BLOCK_2 + 0x038) // SDHC2 interrupt signal enable register
    #define SDHC2_AC12ERR       *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x03c) // SDHC2 auto CMD12 error status register (read-only)
    #define SDHC2_HTCAPBLT      *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x040) // SDHC2 host controller capabilities register (read-only)
    #define SDHC2_WML           *(unsigned long *)(SDHC_BLOCK_2 + 0x044) // SDHC2 watermark level register
    #define SDHC2_MIXCTRL       *(unsigned long *)(SDHC_BLOCK_2 + 0x048) // SDHC2 mixer control register
    #define SDHC2_FEVT          *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x050) // SDHC2 force event register (write only)
    #define SDHC2_ADMAES        *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x054) // SDHC2 ADMA error status register (read-only)
    #define SDHC2_ADSADDR       *(unsigned long *)(SDHC_BLOCK_2 + 0x058) // SDHC2 ADMA system address register

    #define SDHC2_DLL_CTRL      *(unsigned long *)(SDHC_BLOCK_2 + 0x060) // SDHC2 delay line control register
    #define SDHC2_DLL_STATUS    *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x064) // SDHC2 delay line status register
    #define SDHC2_CLK_TUNE_CTRL_STATUS *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x068) // SDHC2 clock tuning control and status register

    #define SDHC2_VENDOR        *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x0c0) // SDHC2 vendor specific register
    #define SDHC2_MMCBOOT       *(unsigned long *)(SDHC_BLOCK_2 + 0x0c4) // SDHC2 MMC boot register
    #define SDHC2_VEND_SPEC2    *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x0c8) // SDHC2 vendor specific 2 register
    #define SDHC2_TUNING_CTRL   *(volatile unsigned long *)(SDHC_BLOCK_2 + 0x0cc) // SDHC2 tuning control register
#endif

extern void fnSetSD_clock(unsigned long ulSpeed);

typedef struct stKINETIS_ADMA2_BD
{
    unsigned long *adma_address_ptr;
    unsigned long len_attribute;
} KINETIS_ADMA2_BD;

#define ADMA2_BD_VALID      0x00000001
#define ADMA2_BD_END        0x00000002
#define ADMA2_BD_INT        0x00000004
#define ADMA2_BD_ACT1       0x00000010
#define ADMA2_BD_ACT2       0x00000020
#define ADMA2_NOP           0
#define ADMA2_TRAN          (ADMA2_BD_ACT2)
#define ADMA2_LINK          (ADMA2_BD_ACT1 | ADMA2_BD_ACT2)
#define ADMA2_BD_LEN_SHIFT  16



// Bit manipulation in variables protected for interrupts
//
#define PROTECTED_SET_VARIABLE(var, bits)      uDisable_Interrupt(); var |= (bits);  uEnable_Interrupt()
#define PROTECTED_CLEAR_VARIABLE(var, bits)    uDisable_Interrupt(); var &= ~(bits); uEnable_Interrupt()

#if defined CLOCKS_DISABLED_IN_WAIT_AND_STOP
    #define POWER_UP_ATOMIC(reg, module)       CCM_CCGR##reg = ((CCM_CCGR##reg & ~(CCM_CCGR##reg##_##module##_STOP)) | (CCM_CCGR##reg##_##module##_RUN))
#else
    #define POWER_UP_ATOMIC(reg, module)       CCM_CCGR##reg |= (CCM_CCGR##reg##_##module##_STOP)
#endif
#define POWER_DOWN_ATOMIC(reg, module)         CCM_CCGR##reg &= ~(unsigned long)(CCM_CCGR##reg##_##module##_MASK)
#define IS_POWERED_UP(reg, module)             ((CCM_CCGR##reg & (CCM_CCGR##reg##_##module##_MASK)) != 0)

#if defined _WINDOWS
    #define _SET_REGISTER(reg, to_set)         reg##_SET = to_set; reg |= reg##_SET; reg##_SET = 0
    #define _CLEAR_REGISTER(reg, to_clear)     reg##_CLR = to_clear; reg &= ~(reg##_CLR); reg##_CLR = 0
    #define _TOGGLE_REGISTER(reg, to_toggle)   reg##_TOG = to_toggle; reg ^= (reg##_TOG); reg##_TOG = 0

    #define _WAIT_REGISTER_TRUE(reg, mask)     while ((reg & mask) != 0) { reg &= ~(mask); }
    #define _WAIT_REGISTER_FALSE(reg, mask)    while ((reg & mask) == 0) { reg |= (mask); }
#else
    #define _SET_REGISTER(reg, to_set)         reg##_SET = to_set
    #define _CLEAR_REGISTER(reg, to_clear)     reg##_CLR = to_clear
    #define _TOGGLE_REGISTER(reg, to_toggle)   reg##_TOG = to_toggle

    #define _WAIT_REGISTER_TRUE(reg, mask)     while ((reg & mask) != 0) {}
    #define _WAIT_REGISTER_FALSE(reg, mask)    while ((reg & mask) == 0) {}
#endif

// Cortex-M7 doesn't support bit banding
//
#define ATOMIC_PERIPHERAL_BIT_REF_SET(reg, bit_ref)    uDisable_Interrupt(); (reg |= (1 << bit_ref)); uEnable_Interrupt()
#define ATOMIC_PERIPHERAL_BIT_REF_CLEAR(reg, bit_ref)  uDisable_Interrupt(); (reg &= ~(1 << bit_ref)); uEnable_Interrupt()
#define ATOMIC_PERIPHERAL_BIT_REF_CHECK(reg, bit_ref)  ((reg & (1 << bit_ref)) != 0)



// Watchdog
//
#define WDOG1_WCR                        *(volatile unsigned short *)(WDOG1_BLOCK + 0x0) // watchdog 1 control
    #define WDOG_WCR_WT                  0xff00                          // watchdog timeout field (0 is 0.5s, each further unit is +0.5s, up to 128s)
    #define WDOG_WCR_WDW                 0x0080                          // watchdog disable for wait
    #define WDOG_WCR_SRE                 0x0040                          // software reset extension
    #define WDOG_WCR_WDA                 0x0020                          // WDOG_B assertion (assert with '0')
    #define WDOG_WCR_SRS                 0x0010                          // software reset signal (assert system reset signal with '0')
    #define WDOG_WCR_WDT                 0x0008                          // WDOG_B timeout assertion when set
    #define WDOG_WCR_WDE                 0x0004                          // watchdog enable
    #define WDOG_WCR_WDBG                0x0002                          // watchdog debug enable
    #define WDOG_WCR_WDZST               0x0001                          // watchdog low power
#define WDOG1_WSR                        *(volatile unsigned short *)(WDOG1_BLOCK + 0x2) // watchdog 1 service
    #define WDOG_WSR_SERVICE_1           0x5555                          // first service write value (any number of instructions can be executed between the two service writes)
    #define WDOG_WSR_SERVICE_2           0xaaaa                          // service service write value
#define WDOG1_WRSR                       *(volatile unsigned short *)(WDOG1_BLOCK + 0x4) // watchdog 1 reset status (read-only)
    #define WDOG_WRSR_POR                0x0010                          // power on reset
    #define WDOG_WRSR_TOUT               0x0002                          // reset due to watchdog timeout
    #define WDOG_WRSR_SFTW               0x0001                          // reset due to software request
#define WDOG1_WICR                       *(volatile unsigned short *)(WDOG1_BLOCK + 0x6) // watchdog 1 interrupt control
    #define WDOG_WICR_WIE                0x8000                          // watchdog timer interrupt enable
    #define WDOG_WICR_WTIS               0x4000                          // watchdog timer interrupt status (write '1' to clear)
    #define WDOG_WICR_WICT               0x00ff                          // watchdog timer interrupt count timeout (0 is 0.5s, each further unit is +0.5s, up to 128s)
#define WDOG1_WMCR                       *(volatile unsigned short *)(WDOG1_BLOCK + 0x2) // watchdog 1 miscellaneous control
    #define WDOG_WMCR_PDE                0x0001                          // watchdog timer power down enable bit

#define WDOG2_WCR                        *(volatile unsigned short *)(WDOG2_BLOCK + 0x0) // watchdog 2 control
#define WDOG2_WSR                        *(volatile unsigned short *)(WDOG2_BLOCK + 0x2) // watchdog 2 service
#define WDOG2_WRSR                       *(volatile unsigned short *)(WDOG2_BLOCK + 0x4) // watchdog 2 reset status (read-only)
#define WDOG2_WICR                       *(volatile unsigned short *)(WDOG2_BLOCK + 0x6) // watchdog 2 interrupt control
#define WDOG2_WMCR                       *(volatile unsigned short *)(WDOG2_BLOCK + 0x2) // watchdog 2 miscellaneous control

#define KICK_WATCHDOG_1()                WDOG1_WSR = WDOG_WSR_SERVICE_1; WDOG1_WSR = WDOG_WSR_SERVICE_2
#define KICK_WATCHDOG_2()                WDOG2_WSR = WDOG_WSR_SERVICE_1; WDOG1_WSR = WDOG_WSR_SERVICE_2


#define WDOG3_CS                         *(volatile unsigned long *)(WDOG3_BLOCK + 0x00) // watchdog control and status register
    #define WDOG_CS_STOP                 0x00000001                      // watchdog enabled in chip stop mode
    #define WDOG_CS_WAIT                 0x00000002                      // watchdog enabled in chip wait mode
    #define WDOG_CS_DBG                  0x00000004                      // watchdog enabled in chip debug mode
    #define WDOG_CS_TST                  0x00000018                      // watchdog test mask
    #define WDOG_CS_UPDATE               0x00000020                      // allow updates
    #define WDOG_CS_INT                  0x00000040                      // watchdog interrupt enable
    #define WDOG_CS_EN                   0x00000080                      // watchdog enable
    #define WDOG_CS_CLK_BUS              0x00000000                      // watchdog clocked from bus clock
    #define WDOG_CS_CLK_LPO              0x00000100                      // watchdog clocked from internal low-power oscillator (32kHz - same as WDOG_CS_CLK_32kHz)
    #define WDOG_CS_CLK_32kHz            0x00000200                      // watchdog clocked from internal 32kHz INTCLK oscillator
    #define WDOG_CS_CLK_EXT              0x00000300                      // watchdog clocked from external clock source (ref_1m_clk: 1MHz clock generated from 24MHz RC oscillator)
    #define WDOG_CS_RCS                  0x00000400                      // watchdog reconfiguration success (read-only)
    #define WDOG_CS_ULK                  0x00000800                      // watchdog unlock status (read-only)
    #define WDOG_CS_PRES_256             0x00001000                      // prescaler of 256 enabled
    #define WDOG_CS_CMD32EN              0x00002000                      // enable 32 bit unlock/refresh support
    #define WDOG_CS_FLG                  0x00004000                      // write '1' to clear
    #define WDOG_CS_WIN                  0x00008000                      // window mode enabled
#define WDOG3_CNT                        *(volatile unsigned long *)(WDOG3_BLOCK + 0x04) // watchdog counter register
    #define WDOG_UNLOCK_SEQUENCE         0xd928c520                       // unlock and retrigger sequences must be performed with two writes within 16 bus clock
    #define WDOG_REFRESH_SEQUENCE        0xb480a602
#define WDOG3_TOVAL                      *(volatile unsigned long *)(WDOG3_BLOCK + 0x08) // watchdog timeout value register
#define WDOG3_WIN                        *(volatile unsigned long *)(WDOG3_BLOCK + 0x0c) // watchdog window register

    #if defined _WINDOWS
        #define KICK_WATCHDOG_3()        WDOG3_CNT = WDOG_REFRESH_SEQUENCE; WDOG3_CNT = 0
        #define UNLOCK_WDOG3()           WDOG3_CNT = WDOG_UNLOCK_SEQUENCE; while ((WDOG3_CS & WDOG_CS_ULK) == 0) {WDOG3_CS |= WDOG_CS_ULK;}; WDOG3_CNT = 0;
    #else
        #define UNLOCK_WDOG3()           WDOG3_CNT = WDOG_UNLOCK_SEQUENCE //; while ((WDOG3_CS & WDOG_CS_ULK) == 0) {} the unlock bit is never set in HW
        #define KICK_WATCHDOG_3()        WDOG3_CNT = WDOG_REFRESH_SEQUENCE
    #endif


// FlexRAM
//
#define FLEXRAM_TCM_CTRL                 *(unsigned long *)(FLEXRAM_BLOCK + 0x00) // FlexRAM TCM CTRL register
    #define FLEXRAM_TCM_CTRL_TCM_WWAIT_EN 0x00000001                     // write RAM accesses are expected to be finished in 2 cycles (rather than 1)
    #define FLEXRAM_TCM_CTRL_TCM_RWAIT_EN 0x00000002                     // read RAM accesses are expected to be finished in 2 cycles (rather than 1)
    #define FLEXRAM_TCM_CTRL_FORCE_CLK_ON 0x00000004                     // force RAM clock always on
#define FLEXRAM_INT_STATUS               *(volatile unsigned long *)(FLEXRAM_BLOCK + 0x10) // FlexRAM interrupt status register (write '1' to clear)
    #define FLEXRAM_INT_STATUS_ITCM_ERR_STATUS   000000008               // ITCM access error occurred
    #define FLEXRAM_INT_STATUS_DTCM_ERR_STATUS   000000010               // DTCM access error occurred
    #define FLEXRAM_INT_STATUS_OCRAM_ERR_STATUS  000000020               // OCRAM access error occurred
#define FLEXRAM_INT_STAT_EN              *(unsigned long *)(FLEXRAM_BLOCK + 0x14) // FlexRAM interrupt status enable register
    #define FLEXRAM_INT_STAT_EN_ITCM_ERR_STATUS  000000008                // ITCM access error status enable
    #define FLEXRAM_INT_STAT_EN_DTCM_ERR_STATUS  000000010                // DTCM access error status enable
    #define FLEXRAM_INT_STAT_EN_OCRAM_ERR_STATUS 000000020                // OCRAM access error status enable
#define FLEXRAM_INT_SIG_EN               *(unsigned long *)(FLEXRAM_BLOCK + 0x18) // FlexRAM enable register
    #define FLEXRAM_INT_SIG_EN_ITCM_ERR_STATUS   000000008                // ITCM access error interrupt enable
    #define FLEXRAM_INT_SIG_EN_DTCM_ERR_STATUS   000000010                // DTCM access error interrupt enable
    #define FLEXRAM_INT_SIG_EN_OCRAM_ERR_STATUS  000000020                // OCRAM access error interrupt enable

#if defined CHIP_HAS_FLEXIO
    #define FLEXIO0_VERID                *(volatile unsigned long *)(FLEXIO_BLOCK + 0x000) // version ID register (read-only)
    #define FLEXIO0_PARAM                *(volatile unsigned long *)(FLEXIO_BLOCK + 0x004) // parameter register (read-only)
    #define FLEXIO0_CTRL                 *(volatile unsigned long *)(FLEXIO_BLOCK + 0x008) // FlexIO control register
        #define FLEXIO_CTRL_FLEXEN       0x00000001                      // flexio module enabled
        #define FLEXIO_CTRL_SWRST        0x00000002                      // software reset
        #define FLEXIO_CTRL_FASTACC      0x00000004                      // fast register access (flexio clock must be twice the bus clock speed to be used)
        #define FLEXIO_CTRL_DBGE         0x40000000                      // enabled in debug mode
        #define FLEXIO_CTRL_DOZEN        0x80000000                      // disabled in doze mode
    #if defined KINETIS_KL28 || defined KINETIS_K80
        #define FLEXIO0_PIN              *(volatile unsigned long *)(FLEXIO_BLOCK + 0x00c) // FlexIO pin state register (read-only)
    #endif
    #define FLEXIO0_SHIFTSTAT            *(volatile unsigned long *)(FLEXIO_BLOCK + 0x010) // shifter status register (write '1' to clear)
        #define FLEXIO_SHIFTSTAT_SSF0    0x00000001                      // status flag of shifter 0
        #define FLEXIO_SHIFTSTAT_SSF1    0x00000002                      // status flag of shifter 1
        #define FLEXIO_SHIFTSTAT_SSF2    0x00000004                      // status flag of shifter 2
        #define FLEXIO_SHIFTSTAT_SSF3    0x00000008                      // status flag of shifter 3
        #define FLEXIO_SHIFTSTAT_SSF4    0x00000010                      // status flag of shifter 4
        #define FLEXIO_SHIFTSTAT_SSF5    0x00000020                      // status flag of shifter 5
        #define FLEXIO_SHIFTSTAT_SSF6    0x00000040                      // status flag of shifter 6
        #define FLEXIO_SHIFTSTAT_SSF7    0x00000080                      // status flag of shifter 7
    #define FLEXIO0_SHIFTERR             *(volatile unsigned long *)(FLEXIO_BLOCK + 0x014) // shifter error register (write '1' to clear)
        #define FLEXIO_SHIFTERR_SEF0     0x00000001                      // error flag of shifter 0
        #define FLEXIO_SHIFTERR_SEF1     0x00000002                      // error flag of shifter 1
        #define FLEXIO_SHIFTERR_SEF2     0x00000004                      // error flag of shifter 2
        #define FLEXIO_SHIFTERR_SEF3     0x00000008                      // error flag of shifter 3
        #define FLEXIO_SHIFTERR_SEF4     0x00000010                      // error flag of shifter 4
        #define FLEXIO_SHIFTERR_SEF5     0x00000020                      // error flag of shifter 5
        #define FLEXIO_SHIFTERR_SEF6     0x00000040                      // error flag of shifter 6
        #define FLEXIO_SHIFTERR_SEF7     0x00000080                      // error flag of shifter 7
    #define FLEXIO0_TIMSTAT              *(volatile unsigned long *)(FLEXIO_BLOCK + 0x018) // timer status register (write '1' to clear)
        #define FLEXIO_TIMSTAT_TSF0      0x00000001                      // status flag of timer 0
        #define FLEXIO_TIMSTAT_TSF1      0x00000002                      // status flag of timer 1
        #define FLEXIO_TIMSTAT_TSF2      0x00000004                      // status flag of timer 2
        #define FLEXIO_TIMSTAT_TSF3      0x00000008                      // status flag of timer 3
        #define FLEXIO_TIMSTAT_TSF4      0x00000010                      // status flag of timer 4
        #define FLEXIO_TIMSTAT_TSF5      0x00000020                      // status flag of timer 5
        #define FLEXIO_TIMSTAT_TSF6      0x00000040                      // status flag of timer 6
        #define FLEXIO_TIMSTAT_TSF7      0x00000080                      // status flag of timer 7
    #define FLEXIO0_SHIFTSIEN            *(unsigned long *)(FLEXIO_BLOCK + 0x020) // shifter status interrupt enable register
    #define FLEXIO0_SHIFTEIEN            *(unsigned long *)(FLEXIO_BLOCK + 0x024) // shifter error interrupt enable register
    #define FLEXIO0_TIMIEN               *(unsigned long *)(FLEXIO_BLOCK + 0x028) // timer interrupt enable register
    #define FLEXIO0_SHIFTSDEN            *(unsigned long *)(FLEXIO_BLOCK + 0x030) // shifter status DMA enable
    #define FLEXIO0_SHIFTCTL0            *(unsigned long *)(FLEXIO_BLOCK + 0x080) // shifter control 0 register
    #define FLEXIO0_SHIFTCTL1            *(unsigned long *)(FLEXIO_BLOCK + 0x084) // shifter control 1 register
    #define FLEXIO0_SHIFTCTL2            *(unsigned long *)(FLEXIO_BLOCK + 0x088) // shifter control 2 register
    #define FLEXIO0_SHIFTCTL3            *(unsigned long *)(FLEXIO_BLOCK + 0x08c) // shifter control 3 register
    #define FLEXIO0_SHIFTCFG0            *(unsigned long *)(FLEXIO_BLOCK + 0x100) // shifter configuration 0 register
    #define FLEXIO0_SHIFTCFG1            *(unsigned long *)(FLEXIO_BLOCK + 0x104) // shifter configuration 1 register
    #define FLEXIO0_SHIFTCFG2            *(unsigned long *)(FLEXIO_BLOCK + 0x108) // shifter configuration 2 register
    #define FLEXIO0_SHIFTCFG3            *(unsigned long *)(FLEXIO_BLOCK + 0x10c) // shifter configuration 3 register
    #define FLEXIO0_SHIFTBUF0            *(unsigned long *)(FLEXIO_BLOCK + 0x200) // shifter buffer 0 register
    #define FLEXIO0_SHIFTBUF1            *(unsigned long *)(FLEXIO_BLOCK + 0x204) // shifter buffer 1 register
    #define FLEXIO0_SHIFTBUF2            *(unsigned long *)(FLEXIO_BLOCK + 0x208) // shifter buffer 2 register
    #define FLEXIO0_SHIFTBUF3            *(unsigned long *)(FLEXIO_BLOCK + 0x20c) // shifter buffer 3 register
    #define FLEXIO0_SHIFTBUFBIS0         *(unsigned long *)(FLEXIO_BLOCK + 0x280) // shifter buffer 0 bit swapped register
    #define FLEXIO0_SHIFTBUFBIS1         *(unsigned long *)(FLEXIO_BLOCK + 0x284) // shifter buffer 1 bit swapped register
    #define FLEXIO0_SHIFTBUFBIS2         *(unsigned long *)(FLEXIO_BLOCK + 0x288) // shifter buffer 2 bit swapped register
    #define FLEXIO0_SHIFTBUFBIS3         *(unsigned long *)(FLEXIO_BLOCK + 0x28c) // shifter buffer 3 bit swapped register
    #define FLEXIO0_SHIFTBUFBYS0         *(unsigned long *)(FLEXIO_BLOCK + 0x300) // shifter buffer 0 byte swapped register
    #define FLEXIO0_SHIFTBUFBYS1         *(unsigned long *)(FLEXIO_BLOCK + 0x304) // shifter buffer 1 byte swapped register
    #define FLEXIO0_SHIFTBUFBYS2         *(unsigned long *)(FLEXIO_BLOCK + 0x308) // shifter buffer 2 byte swapped register
    #define FLEXIO0_SHIFTBUFBYS3         *(unsigned long *)(FLEXIO_BLOCK + 0x30c) // shifter buffer 3 byte swapped register
    #define FLEXIO0_SHIFTBUFBBS0         *(unsigned long *)(FLEXIO_BLOCK + 0x380) // shifter buffer 0 bit byte swapped register
    #define FLEXIO0_SHIFTBUFBBS1         *(unsigned long *)(FLEXIO_BLOCK + 0x384) // shifter buffer 1 bit byte swapped register
    #define FLEXIO0_SHIFTBUFBBS2         *(unsigned long *)(FLEXIO_BLOCK + 0x388) // shifter buffer 2 bit byte swapped register
    #define FLEXIO0_SHIFTBUFBBS3         *(unsigned long *)(FLEXIO_BLOCK + 0x38c) // shifter buffer 3 bit byte swapped register
    #define FLEXIO0_TIMCTL0              *(unsigned long *)(FLEXIO_BLOCK + 0x400) // timer control 0 register
    #define FLEXIO0_TIMCTL1              *(unsigned long *)(FLEXIO_BLOCK + 0x404) // timer control 1 register
    #define FLEXIO0_TIMCTL2              *(unsigned long *)(FLEXIO_BLOCK + 0x408) // timer control 2 register
    #define FLEXIO0_TIMCTL3              *(unsigned long *)(FLEXIO_BLOCK + 0x40c) // timer control 3 register
    #define FLEXIO0_TIMCFG0              *(unsigned long *)(FLEXIO_BLOCK + 0x480) // timer configuration 0 register
    #define FLEXIO0_TIMCFG1              *(unsigned long *)(FLEXIO_BLOCK + 0x484) // timer configuration 1 register
    #define FLEXIO0_TIMCFG2              *(unsigned long *)(FLEXIO_BLOCK + 0x488) // timer configuration 2 register
    #define FLEXIO0_TIMCFG3              *(unsigned long *)(FLEXIO_BLOCK + 0x48c) // timer configuration 3 register
    #define FLEXIO0_TIMCMP0              *(unsigned long *)(FLEXIO_BLOCK + 0x500) // timer compare 0 register
    #define FLEXIO0_TIMCMP1              *(unsigned long *)(FLEXIO_BLOCK + 0x504) // timer compare 1 register
    #define FLEXIO0_TIMCMP2              *(unsigned long *)(FLEXIO_BLOCK + 0x508) // timer compare 2 register
    #define FLEXIO0_TIMCMP3              *(unsigned long *)(FLEXIO_BLOCK + 0x50c) // timer compare 3 register
#endif

// External Watchdog Monitor
//
#define EWM_CTRL                         *(volatile unsigned short *)(EWM_BLOCK + 0x0)  // External Watchdog Monitor Control Register
#define EWM_SERV                         *(volatile unsigned short *)(EWM_BLOCK + 0x1)  // External Watchdog Monitor Service Register
#define EWM_CMPL                         *(volatile unsigned short *)(EWM_BLOCK + 0x2)  // External Watchdog Monitor Compare Low Register
#define EWM_CMPH                         *(volatile unsigned short *)(EWM_BLOCK + 0x3)  // External Watchdog Monitor Compare High Register




// Oscillator
//
#define OSC0_CR                          *(volatile unsigned char *)(OSC0_BLOCK + 0x00) // OSC0 Control Register
#if defined KINETIS_KE
  #define OSC_CR_OSCINIT                 0x01                            // OSC initialisation (read-only) 
  #define OSC_CR_HGO                     0x02                            // high gain mode
  #define OSC_CR_RANGE_LOW               0x00                            // high frequency range 32kHz
  #define OSC_CR_RANGE_HIGH              0x04                            // high frequency range 4..20MHz (4..24MHz KE06)
  #define OSC_CR_OSCOS_EXT               0x00                            // select external clock source as output clock
  #define OSC_CR_OSCOS_SOURCE            0x10                            // select oscillator clock source as output clock
  #define OSC_CR_OSCSTEN                 0x20                            // enable oscillator in stop mode
  #define OSC_CR_OSCEN                   0x80                            // enable OSC module
#else
  #define OSC_CR_SC16P                   0x01                            // add 16pF capacitor to oscillator load
  #define OSC_CR_SC8P                    0x02                            // add 8pF capacitor to oscillator load
  #define OSC_CR_SC4P                    0x04                            // add 4pF capacitor to oscillator load
  #define OSC_CR_SC2P                    0x08                            // add 2pF capacitor to oscillator load
  #define OSC_CR_EREFSTEN                0x20                            // external reference clock stays enabled in stop mode if ERCLKEN is set before entering stop mode
  #define OSC_CR_ERCLKEN                 0x80                            // enable external reference clock
#endif

#if defined ERRATA_ID_3402 && !defined KINETIS_KL
    #define XTAL0_PORT                   _PORTA                          // when the OSC is enabled the XTAL port pin is forced to default function and cannot be used as GPIO
    #define XTAL0_PIN                    19
#endif

#define OSC1_CR                      *(unsigned char*)(OSC1_BLOCK + 0x00) // OSC1 Control Register

// I2C
//
#if I2C_AVAILABLE > 0
    #define I2C0_A1                      *(unsigned char *)(I2C0_BLOCK + 0x0) // I2C0 Address Register 1
    #define I2C0_F                       *(unsigned char *)(I2C0_BLOCK + 0x1) // I2C0 Frequency Divider Register 
    #define I2C0_C1_ADD                  (volatile unsigned char *)(I2C0_BLOCK + 0x2) // I2C0 Control Register 1 address
    #define I2C0_C1                      *(volatile unsigned char *)(I2C0_BLOCK + 0x2) // I2C0 Control Register 1
      #define I2C_DMAEN                  0x01                            // DMA enable
      #define I2C_WUEN                   0x02                            // wakeup enable
      #define I2C_RSTA                   0x04                            // repeat start (write '1' - not readable)
      #define I2C_TXAK                   0x08                            // transmit acknowledge enable
      #define I2C_MTX                    0x10                            // transmit mode select
      #define I2C_MSTA                   0x20                            // master mode
      #define I2C_IIEN                   0x40                            // I2C interrupt enable
      #define I2C_IEN                    0x80                            // I2C enable
    #define I2C0_S                       *(volatile unsigned char *)(I2C0_BLOCK + 0x3) // I2C0 Status Register
      #define I2C_RXACK                  0x01                            // no ack signal detected (read-only)
      #define I2C_IIF                    0x02                            // I2C interrupt (write '1' to clear)
      #define I2C_SRW                    0x04                            // slave transmit (read-only)
      #define I2C_RAM                    0x08                            // range address match
      #define I2C_IAL                    0x10                            // arbitration lost (write '1' to clear)
      #define I2C_IBB                    0x20                            // bus busy status (read-only)
      #define I2C_IAAS                   0x40                            // addressed as slave
      #define I2C_TCF                    0x80                            // transfer complete (read-only)
    #define I2C0_D                       *(volatile unsigned char *)(I2C0_BLOCK + 0x4) // I2C0 Data Register
    #define I2C0_C2                      *(volatile unsigned char *)(I2C0_BLOCK + 0x5) // I2C0 Control Register 2
    #define I2C0_FLT                     *(volatile unsigned char *)(I2C0_BLOCK + 0x6) // I2C0 Programmable Input Glitch Filter Register 
      #if defined DOUBLE_BUFFERED_I2C || defined I2C_START_CONDITION_INTERRUPT
        #define I2C_FLT_FLT_MASK         0x0f                            // programmable filter factor
        #define I2C_FLT_FLT_STARTF       0x10                            // I2C bus start detect flag (write '1' to clear)
        #define I2C_FLT_FLT_SSIE         0x20                            // I2C bus stop or start interrupt enable
        #define I2C_FLT_FLT_INT          I2C_FLT_FLT_SSIE
      #else
        #define I2C_FLT_FLT_MASK         0x1f                            // programmable filter factor
        #define I2C_FLT_FLT_STOPIE       0x20                            // I2C bus stop interrupt enable
        #define I2C_FLT_FLT_INT          I2C_FLT_FLT_STOPIE
      #endif
      #define I2C_FLT_FLT_STOPF          0x40                            // I2C bus stop detected (write '1' to clear)
      #define I2C_FLT_FLT_SHEN           0x80                            // stop hold enable
    #define I2C0_RA                      *(unsigned char *)(I2C0_BLOCK + 0x7) // I2C0 Range Address Register
    #define I2C0_SMB                     *(volatile unsigned char *)(I2C0_BLOCK + 0x8) // I2C0 SMBus Control and Status Register
    #define I2C0_A2                      *(unsigned char *)(I2C0_BLOCK + 0x9) // I2C0 Address Register 2
    #define I2C0_SLTH                    *(unsigned char *)(I2C0_BLOCK + 0xa) // I2C0 SCL Low Timeout Register High
    #define I2C0_SLTL                    *(unsigned char *)(I2C0_BLOCK + 0xb) // I2C0 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C0_S2                  *(volatile unsigned char *)(I2C0_BLOCK + 0xc) // I2C0 Status Register 2
          #define I2C_S2_EMPTY           0x00000001                      // tx or rx buffer is empty and can be writtenm to (new data loaded) (read-only)
          #define I2C_S2_ERROR           0x00000002                      // there are 3 or more write/read errors during the data transfer phase (when the empty flag is not set and the buffer is busy) (write '1' to clear)
    #endif
#endif

#if I2C_AVAILABLE > 1
    #define I2C1_A1                      *(unsigned char *)(I2C1_BLOCK + 0x0) // I2C1 Address Register 1
    #define I2C1_F                       *(unsigned char *)(I2C1_BLOCK + 0x1) // I2C1 Frequency Divider Register 
    #define I2C1_C1_ADD                  (volatile unsigned char *)(I2C1_BLOCK + 0x2) // I2C1 Control Register 1 address
    #define I2C1_C1                      *(volatile unsigned char *)(I2C1_BLOCK + 0x2) // I2C1 Control Register 1
    #define I2C1_S                       *(volatile unsigned char *)(I2C1_BLOCK + 0x3) // I2C1 Status Register
    #define I2C1_D                       *(volatile unsigned char *)(I2C1_BLOCK + 0x4) // I2C1 Data Register
    #define I2C1_C2                      *(volatile unsigned char *)(I2C1_BLOCK + 0x5) // I2C1 Control Register 2
    #define I2C1_FLT                     *(volatile unsigned char *)(I2C1_BLOCK + 0x6) // I2C1 Programmable Input Glitch Filter Register 
    #define I2C1_RA                      *(unsigned char *)(I2C1_BLOCK + 0x7) // I2C1 Range Address Register
    #define I2C1_SMB                     *(volatile unsigned char *)(I2C1_BLOCK + 0x8) // I2C1 SMBus Control and Status Register
    #define I2C1_A2                      *(unsigned char *)(I2C1_BLOCK + 0x9) // I2C1 Address Register 2
    #define I2C1_SLTH                    *(unsigned char *)(I2C1_BLOCK + 0xa) // I2C1 SCL Low Timeout Register High
    #define I2C1_SLTL                    *(unsigned char *)(I2C1_BLOCK + 0xb) // I2C1 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C1_S2                  *(volatile unsigned char *)(I2C1_BLOCK + 0xc) // I2C1 Status Register 2
    #endif
#endif

#if I2C_AVAILABLE > 2
    #define I2C2_A1                      *(unsigned char *)(I2C2_BLOCK + 0x0) // I2C2 Address Register 1
    #define I2C2_F                       *(unsigned char *)(I2C2_BLOCK + 0x1) // I2C2 Frequency Divider Register 
    #define I2C2_C1_ADD                  (volatile unsigned char *)(I2C2_BLOCK + 0x2) // I2C2 Control Register 1 address
    #define I2C2_C1                      *(volatile unsigned char *)(I2C2_BLOCK + 0x2) // I2C2 Control Register 1
    #define I2C2_S                       *(volatile unsigned char *)(I2C2_BLOCK + 0x3) // I2C2 Status Register
    #define I2C2_D                       *(volatile unsigned char *)(I2C2_BLOCK + 0x4) // I2C2 Data Register
    #define I2C2_C2                      *(volatile unsigned char *)(I2C2_BLOCK + 0x5) // I2C2 Control Register 2
    #define I2C2_FLT                     *(volatile unsigned char *)(I2C2_BLOCK + 0x6) // I2C2 Programmable Input Glitch Filter Register 
    #define I2C2_RA                      *(unsigned char *)(I2C2_BLOCK + 0x7) // I2C2 Range Address Register
    #define I2C2_SMB                     *(volatile unsigned char *)(I2C2_BLOCK + 0x8) // I2C2 SMBus Control and Status Register
    #define I2C2_A2                      *(unsigned char *)(I2C2_BLOCK + 0x9) // I2C2 Address Register 2
    #define I2C2_SLTH                    *(unsigned char *)(I2C2_BLOCK + 0xa) // I2C2 SCL Low Timeout Register High
    #define I2C2_SLTL                    *(unsigned char *)(I2C2_BLOCK + 0xb) // I2C2 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C2_S2                  *(volatile unsigned char *)(I2C2_BLOCK + 0xc) // I2C2 Status Register 2
    #endif
#endif

#if I2C_AVAILABLE > 3
    #define I2C3_A1                      *(unsigned char *)(I2C3_BLOCK + 0x0) // I2C3 Address Register 1
    #define I2C3_F                       *(unsigned char *)(I2C3_BLOCK + 0x1) // I2C3 Frequency Divider Register 
    #define I2C3_C1_ADD                  (volatile unsigned char *)(I2C3_BLOCK + 0x2) // I2C3 Control Register 1 address
    #define I2C3_C1                      *(volatile unsigned char *)(I2C3_BLOCK + 0x2) // I2C3 Control Register 1
    #define I2C3_S                       *(volatile unsigned char *)(I2C3_BLOCK + 0x3) // I2C3 Status Register
    #define I2C3_D                       *(volatile unsigned char *)(I2C3_BLOCK + 0x4) // I2C3 Data Register
    #define I2C3_C2                      *(volatile unsigned char *)(I2C3_BLOCK + 0x5) // I2C3 Control Register 2
    #define I2C3_FLT                     *(volatile unsigned char *)(I2C3_BLOCK + 0x6) // I2C3 Programmable Input Glitch Filter Register 
    #define I2C3_RA                      *(unsigned char *)(I2C3_BLOCK + 0x7) // I2C3 Range Address Register
    #define I2C3_SMB                     *(volatile unsigned char *)(I2C3_BLOCK + 0x8) // I2C3 SMBus Control and Status Register
    #define I2C3_A2                      *(unsigned char *)(I2C3_BLOCK + 0x9) // I2C3 Address Register 2
    #define I2C3_SLTH                    *(unsigned char *)(I2C3_BLOCK + 0xa) // I2C3 SCL Low Timeout Register High
    #define I2C3_SLTL                    *(unsigned char *)(I2C3_BLOCK + 0xb) // I2C3 SCL Low Timeout Register Low
    #if defined DOUBLE_BUFFERED_I2C
        #define I2C3_S2                  *(volatile unsigned char *)(I2C2_BLOCK + 0xc) // I2C2 Status Register 2
    #endif
#endif

#if I2C_AVAILABLE > 0
typedef struct stKINETIS_I2C_CONTROL
{

    unsigned char I2C_A1;
    unsigned char I2C_F;
    volatile unsigned char I2C_C1;
    volatile unsigned char I2C_S;
    volatile unsigned char I2C_D;
    volatile unsigned char I2C_C2;
    volatile unsigned char I2C_FLT;
    unsigned char I2C_RA;
    volatile unsigned char I2C_SMB;
    unsigned char I2C_A2;
    unsigned char I2C_SLTH;
    unsigned char I2C_SLTL;
    #if defined DOUBLE_BUFFERED_I2C
        volatile unsigned char I2C_S2;
    #endif
} KINETIS_I2C_CONTROL;
#endif


// On-chip OTP controller
//
#define HW_OCOTP_CTRL                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x000) // OTP controller control register
    #define HW_OCOTP_CTRL_ADDR_MASK      0x0000003f                      // word address location (0x00 - 0x7f)
    #define HW_OCOTP_CTRL_BUSY           0x00000100                      // OTP controller status busy (read-only)
    #define HW_OCOTP_CTRL_ERROR          0x00000200                      // set whe an access to a locked region (OTP or shadow register) is requested - clear using the CLR register
    #define HW_OCOTP_CTRL_RELOAD_SHADOWS 0x00000400                      // set to force re-loading shadow registers - automatically cleared on completion
    #define HW_OCOTP_CTRL_WR_UNLOCK      0x3e770000                      // enable OTP write access (required on a write-by-write basic) - cleared after successful write completion
    #define HW_OCOTP_CTRL_WR_UNLOCK_MASK 0xffff0000
#define HW_OCOTP_CTRL_SET                *(volatile unsigned long *)(OCOTP_BLOCK + 0x004) // OTP controller control register - set
#define HW_OCOTP_CTRL_CLR                *(volatile unsigned long *)(OCOTP_BLOCK + 0x008) // OTP controller control register - clear
#define HW_OCOTP_CTRL_TOG                *(volatile unsigned long *)(OCOTP_BLOCK + 0x00c) // OTP controller control register - toggle
#define HW_OCOTP_TIMING                  *(volatile unsigned long *)(OCOTP_BLOCK + 0x010) // OTP controller timing register
    #define HW_OCOTP_TIMING_STROBE_PROG_MASK  0x00000fff
    #define HW_OCOTP_TIMING_RELAX_MASK        0x0000f000
    #define HW_OCOTP_TIMING_RELAX_SHIFT       12
    #define HW_OCOTP_TIMING_STROBE_READ_MASK  0x003f0000
    #define HW_OCOTP_TIMING_STROBE_READ_SHIFT 16
    #define HW_OCOTP_TIMING_WAIT_MASK         0x0fc00000
    #define HW_OCOTP_TIMING_WAIT_SHIFT        22
#define HW_OCOTP_DATA                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x020) // OTP controller write data register
#define HW_OCOTP_READ_CTRL               *(volatile unsigned long *)(OCOTP_BLOCK + 0x030) // OTP controller read control register
    #define HW_OCOTP_READ_CTRL_READ_FUSE 0x00000001                      // initiate a read to OTP
#define HW_OCOTP_READ_FUSE_DATA          *(volatile unsigned long *)(OCOTP_BLOCK + 0x040) // OTP controller read data register
#define HW_OCOTP_SW_STICKY               *(volatile unsigned long *)(OCOTP_BLOCK + 0x050) // OTP sticky bit register
    #define HW_OCOTP_SW_STICKY_SRK_REVOKE_LOCK   0x00000002              // shadow register write and OTP write lock for SRK_REVOKE region
    #define HW_OCOTP_SW_STICKY_FIELD_RETURN_LOCK 0x00000004              // shadow register write and OTP write lock for FIELD_RETURN region
#define HW_OCOTP_SCS                     *(volatile unsigned long *)(OCOTP_BLOCK + 0x060) // OTP software controllable signals register
#define HW_OCOTP_SCS_SET                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x064) // OTP software controllable signals register - set
#define HW_OCOTP_SCS_CLR                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x068) // OTP software controllable signals register - clear
#define HW_OCOTP_SCS_TOG                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x06c) // OTP software controllable signals register - toggle
#if defined iMX_RT106X
    #define HW_OCOTP_CRC_ADDR            *(volatile unsigned long *)(OCOTP_BLOCK + 0x070) // OTP controllable CRC test address
    #define HW_OCOTP_CRC_VALUE           *(volatile unsigned long *)(OCOTP_BLOCK + 0x080) // OTP controllable CRC value register
#endif
#define HW_OCOTP_VERSION                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x090) // OTP controllable version register (read-only)
#define HW_OCOTP_TIMING2                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x100) // OTP controller timing register 2
#define HW_OCOTP_LOCK                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x400) // value of OTP bank0 word 0 lock
#define HW_OCOTP_CFG0_ADD                (volatile unsigned long *)(OCOTP_BLOCK + 0x410)
#define HW_OCOTP_CFG0                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x410) // value of OTP bank0 word 1 (configuration and manufacturing info.)
#define HW_OCOTP_CFG1                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x420) // value of OTP bank0 word 2 (configuration and manufacturing info.)
#define HW_OCOTP_CFG2                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x430) // value of OTP bank0 word 3 (configuration and manufacturing info.)
#define HW_OCOTP_CFG3                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x440) // value of OTP bank0 word 4 (configuration and manufacturing info.)
#define HW_OCOTP_CFG4                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x450) // value of OTP bank0 word 5 (configuration and manufacturing info.)
#define HW_OCOTP_CFG5                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x460) // value of OTP bank0 word 6 (configuration and manufacturing info.)
#define HW_OCOTP_CFG6                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x470) // value of OTP bank0 word 7 (configuration and manufacturing info.)
#define HW_OCOTP_MEM0_ADD                (volatile unsigned long *)(OCOTP_BLOCK + 0x480)
#define HW_OCOTP_MEM0                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x480) // value of OTP bank1 word 0 (memory related info.)
#define HW_OCOTP_MEM1                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x490) // value of OTP bank1 word 1 (memory related info.)
#define HW_OCOTP_MEM2                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x4a0) // value of OTP bank1 word 2 (memory related info.)
#define HW_OCOTP_MEM3                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x4b0) // value of OTP bank1 word 3 (memory related info.)
#define HW_OCOTP_MEM4                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x4c0) // value of OTP bank1 word 4 (memory related info.)
#define HW_OCOTP_ANA0_ADD                (volatile unsigned long *)(OCOTP_BLOCK + 0x4d0)
#define HW_OCOTP_ANA0                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x4d0) // value of OTP bank1 word 5 (analog info.)
#define HW_OCOTP_ANA1                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x4e0) // value of OTP bank1 word 6 (analog info.)
#define HW_OCOTP_ANA2                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x4f0) // value of OTP bank1 word 7 (analog info.)
#define HW_OCOTP_SRK0_ADD                (volatile unsigned long *)(OCOTP_BLOCK + 0x580)
#define HW_OCOTP_SRK0                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x580) // value of OTP bank3 word 0 (SRK hash)
#define HW_OCOTP_SRK1                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x590) // value of OTP bank3 word 1 (SRK hash)
#define HW_OCOTP_SRK2                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x5a0) // value of OTP bank3 word 2 (SRK hash)
#define HW_OCOTP_SRK3                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x5b0) // value of OTP bank3 word 3 (SRK hash)
#define HW_OCOTP_SRK4                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x5c0) // value of OTP bank3 word 4 (SRK hash)
#define HW_OCOTP_SRK5                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x5d0) // value of OTP bank3 word 5 (SRK hash)
#define HW_OCOTP_SRK6                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x5e0) // value of OTP bank3 word 6 (SRK hash)
#define HW_OCOTP_SRK7                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x5f0) // value of OTP bank3 word 7 (SRK hash)
#define HW_OCOTP_SJC_RESP0               *(volatile unsigned long *)(OCOTP_BLOCK + 0x600) // value of OTP bank4 word 0 (secure JTAG response field)
#define HW_OCOTP_SJC_RESP1               *(volatile unsigned long *)(OCOTP_BLOCK + 0x610) // value of OTP bank4 word 1 (secure JTAG response field)
#define HW_OCOTP_MAC0                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x620) // value of OTP bank4 word 2 (MAC address)
#define HW_OCOTP_MAC1                    *(volatile unsigned long *)(OCOTP_BLOCK + 0x630) // value of OTP bank4 word 3 (MAC address)
#if ETHERNET_COUNT > 1
    #define HW_OCOTP_MAC2                *(volatile unsigned long *)(OCOTP_BLOCK + 0x640) // value of OTP bank4 word 4 (MAC address)
    #define HW_OCOTP_OTPK_CRC32          *(volatile unsigned long *)(OCOTP_BLOCK + 0x650) // value of OTP bank4 word 5 (CRC key)
#else
    #define HW_OCOTP_GP3                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x640) // value of OTP bank4 word 4 (general purpose 3)
#endif
#define HW_OCOTP_GP1                     *(volatile unsigned long *)(OCOTP_BLOCK + 0x660) // value of OTP bank4 word 6 (general purpose 1)
#define HW_OCOTP_GP2                     *(volatile unsigned long *)(OCOTP_BLOCK + 0x670) // value of OTP bank4 word 7 (general purpose 2)
#define HW_OCOTP_SW_GP1_ADD              (volatile unsigned long *)(OCOTP_BLOCK + 0x680)
#define HW_OCOTP_SW_GP1                  *(volatile unsigned long *)(OCOTP_BLOCK + 0x680) // value of OTP bank5 word 0 (software general purpose 1)
#define HW_OCOTP_SW_GP20                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x690) // value of OTP bank5 word 1 (software general purpose 2)
#define HW_OCOTP_SW_GP21                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x6a0) // value of OTP bank5 word 2 (software general purpose 2)
#define HW_OCOTP_SW_GP22                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x6b0) // value of OTP bank5 word 3 (software general purpose 2)
#define HW_OCOTP_SW_GP23                 *(volatile unsigned long *)(OCOTP_BLOCK + 0x6c0) // value of OTP bank5 word 4 (software general purpose 2)
#define HW_OCOTP_MISC_CONF0              *(volatile unsigned long *)(OCOTP_BLOCK + 0x6d0) // value of OTP bank5 word 5 (misc. conf.)
#define HW_OCOTP_MISC_CONF1              *(volatile unsigned long *)(OCOTP_BLOCK + 0x6e0) // value of OTP bank5 word 6 (misc. conf.)
#define HW_OCOTP_SRK_REVOKE              *(volatile unsigned long *)(OCOTP_BLOCK + 0x6f0) // value of OTP bank5 word 7 (SRK revoke)
#if defined iMX_RT106X
    #define HW_OCOTP_ROM_PATCH0_ADD      (volatile unsigned long *)(OCOTP_BLOCK + 0x800)
    #define HW_OCOTP_ROM_PATCH0          *(volatile unsigned long *)(OCOTP_BLOCK + 0x800) // value of OTP bank6 word 0 (ROM patch)
    #define HW_OCOTP_ROM_PATCH1          *(volatile unsigned long *)(OCOTP_BLOCK + 0x810) // value of OTP bank6 word 1 (ROM patch)
    #define HW_OCOTP_ROM_PATCH2          *(volatile unsigned long *)(OCOTP_BLOCK + 0x820) // value of OTP bank6 word 2 (ROM patch)
    #define HW_OCOTP_ROM_PATCH3          *(volatile unsigned long *)(OCOTP_BLOCK + 0x830) // value of OTP bank6 word 3 (ROM patch)
    #define HW_OCOTP_ROM_PATCH4          *(volatile unsigned long *)(OCOTP_BLOCK + 0x840) // value of OTP bank6 word 4 (ROM patch)
    #define HW_OCOTP_ROM_PATCH5          *(volatile unsigned long *)(OCOTP_BLOCK + 0x850) // value of OTP bank6 word 5 (ROM patch)
    #define HW_OCOTP_ROM_PATCH6          *(volatile unsigned long *)(OCOTP_BLOCK + 0x860) // value of OTP bank6 word 6 (ROM patch)
    #define HW_OCOTP_ROM_PATCH7          *(volatile unsigned long *)(OCOTP_BLOCK + 0x870) // value of OTP bank6 word 7 (ROM patch)
    #define HW_OCOTP_GP30_ADD            (volatile unsigned long *)(OCOTP_BLOCK + 0x880)
    #define HW_OCOTP_GP30                *(volatile unsigned long *)(OCOTP_BLOCK + 0x880) // value of OTP bank7 word 0 (GP3)
    #define HW_OCOTP_GP3   HW_OCOTP_GP30                                 // for compatibility
    #define HW_OCOTP_GP31                *(volatile unsigned long *)(OCOTP_BLOCK + 0x890) // value of OTP bank7 word 1 (GP3)
    #define HW_OCOTP_GP32                *(volatile unsigned long *)(OCOTP_BLOCK + 0x8a0) // value of OTP bank7 word 2 (GP3)
    #define HW_OCOTP_GP33                *(volatile unsigned long *)(OCOTP_BLOCK + 0x8b0) // value of OTP bank7 word 3 (GP3)
    #define HW_OCOTP_GP40                *(volatile unsigned long *)(OCOTP_BLOCK + 0x8c0) // value of OTP bank7 word 4 (GP4)
    #define HW_OCOTP_GP41                *(volatile unsigned long *)(OCOTP_BLOCK + 0x8d0) // value of OTP bank7 word 5 (GP4)
    #define HW_OCOTP_GP42                *(volatile unsigned long *)(OCOTP_BLOCK + 0x8e0) // value of OTP bank7 word 6 (GP4)
    #define HW_OCOTP_GP43                *(volatile unsigned long *)(OCOTP_BLOCK + 0x8f0) // value of OTP bank7 word 7 (GP4)
#endif

#define SHADOW_REG_INDEX_LOCK            0x00                            // 0x400
#define SHADOW_REG_INDEX_TEST_0          0x01                            // 0x410
#define SHADOW_REG_INDEX_TEST_1          0x02                            // 0x420
#define SHADOW_REG_INDEX_TEST_2          0x03                            // 0x430
#define SHADOW_REG_INDEX_TEST_3          0x04                            // 0x440
#define SHADOW_REG_INDEX_BOOT_CFG_0      0x05                            // 0x450
#define SHADOW_REG_INDEX_BOOT_CFG_1      0x06                            // 0x460
#define SHADOW_REG_INDEX_BOOT_CFG_2      0x07                            // 0x470
#define SHADOW_REG_INDEX_MEM_0           0x08                            // 0x480
#define SHADOW_REG_INDEX_MEM_1           0x09                            // 0x490
#define SHADOW_REG_INDEX_MEM_2           0x0a                            // 0x4a0
#define SHADOW_REG_INDEX_MEM_3           0x0b                            // 0x4b0
#define SHADOW_REG_INDEX_MEM_4           0x0c                            // 0x4c0
#define SHADOW_REG_INDEX_ANALOG_0        0x0d                            // 0x4d0
#define SHADOW_REG_INDEX_ANALOG_1        0x0e                            // 0x4e0
#define SHADOW_REG_INDEX_ANALOG_2        0x0f                            // 0x4f0

#define SHADOW_REG_INDEX_SRK_0           0x18                            // 0x580
#define SHADOW_REG_INDEX_SRK_1           0x19                            // 0x590
#define SHADOW_REG_INDEX_SRK_2           0x1a                            // 0x5a0
#define SHADOW_REG_INDEX_SRK_3           0x1b                            // 0x5b0
#define SHADOW_REG_INDEX_SRK_4           0x1c                            // 0x5c0
#define SHADOW_REG_INDEX_SRK_5           0x1d                            // 0x5d0
#define SHADOW_REG_INDEX_SRK_6           0x1e                            // 0x5e0
#define SHADOW_REG_INDEX_SRK_7           0x1f                            // 0x5f0
#define SHADOW_REG_INDEX_SJC_0           0x20                            // 0x600
#define SHADOW_REG_INDEX_SJC_1           0x21                            // 0x610
#define SHADOW_REG_INDEX_MAC_0           0x22                            // 0x620
#define SHADOW_REG_INDEX_MAC_1           0x23                            // 0x630
#if ETHERNET_COUNT > 1
    #define SHADOW_REG_INDEX_MAC_2       0x24                            // 0x640
    #define SHADOW_REG_INDEX_MAC_3       0x25                            // 0x650
#else
    #define SHADOW_REG_INDEX_GP3         0x24                            // 0x640
#endif

#define SHADOW_REG_INDEX_GP1             0x26                            // 0x660
#define SHADOW_REG_INDEX_GP2             0x27                            // 0x670
#define SHADOW_REG_INDEX_SW_GP_1         0x28                            // 0x680
#define SHADOW_REG_INDEX_SW_GP_20        0x29                            // 0x690
#define SHADOW_REG_INDEX_SW_GP_21        0x2a                            // 0x6a0
#define SHADOW_REG_INDEX_SW_GP_22        0x2b                            // 0x6b0
#define SHADOW_REG_INDEX_SW_GP_23        0x2c                            // 0x6c0
#define SHADOW_REG_INDEX_MISC_CONF_0     0x2d                            // 0x6d0
#define SHADOW_REG_INDEX_MISC_CONF_1     0x2e                            // 0x6e0
#define SHADOW_REG_INDEX_SRK_REVOKE      0x2f                            // 0x6f0
#if defined iMX_RT106X
    #define SHADOW_REG_INDEX_ROM_PATCH_0 0x40
    #define SHADOW_REG_INDEX_ROM_PATCH_1 0x41
    #define SHADOW_REG_INDEX_ROM_PATCH_2 0x42
    #define SHADOW_REG_INDEX_ROM_PATCH_3 0x43
    #define SHADOW_REG_INDEX_ROM_PATCH_4 0x44
    #define SHADOW_REG_INDEX_ROM_PATCH_5 0x45
    #define SHADOW_REG_INDEX_ROM_PATCH_6 0x46
    #define SHADOW_REG_INDEX_ROM_PATCH_7 0x47
    #define SHADOW_REG_INDEX_GP3_0       0x48                            // 0x880
    #define SHADOW_REG_INDEX_GP3_1       0x49
    #define SHADOW_REG_INDEX_GP3_2       0x4a
    #define SHADOW_REG_INDEX_GP3_3       0x4b
    #define SHADOW_REG_INDEX_GP4_0       0x4c
    #define SHADOW_REG_INDEX_GP4_1       0x4d
    #define SHADOW_REG_INDEX_GP4_2       0x4e
    #define SHADOW_REG_INDEX_GP4_3       0x4f
#endif


// LPI2C
//
#if LPI2C_AVAILABLE > 0
    #define LPI2C0_VERID                 *(volatile unsigned long *)(LPI2C0_BLOCK + 0x000) // LPI2C0 version ID register (read-only)
    #define LPI2C0_PARAM                 *(volatile unsigned long *)(LPI2C0_BLOCK + 0x004) // LPI2C0 parameter register (read-only)
    #define LPI2C0_MCR                   *(volatile unsigned long *)(LPI2C0_BLOCK + 0x010) // LPI2C0 master control register
        #define LPI2C_MCR_MEN            0x00000001                      // master logic enable
        #define LPI2C_MCR_RST            0x00000002                      // master logic reset
        #define LPI2C_MCR_DOZEN          0x00000004                      // doze mode disable (master is disabled in doze mode)
        #define LPI2C_MCR_DBGEN          0x00000008                      // debug enable (master is enabled in debug mode)
        #define LPI2C_MCR_RTF            0x00000010                      // reset transmit FIFO (write-only)
        #define LPI2C_MCR_RRF            0x00000020                      // reset receive FIFO (write-only)
    #define LPI2C0_MSR                   *(volatile unsigned long *)(LPI2C0_BLOCK + 0x014) // LPI2C0 master status register
        #define LPI2C_MSR_TDF            0x00000001                      // transmit data is requested (read-only)
        #define LPI2C_MSR_RDF            0x00000002                      // receive data is ready (read-only)
        #define LPI2C_MSR_EPF            0x00000100                      // end packet flag (write '1' to clear)
        #define LPI2C_MSR_SDF            0x00000200                      // STOP detect flag (write '1' to clear)
        #define LPI2C_MSR_NDF            0x00000400                      // NACK detect flag (write '1' to clear)
        #define LPI2C_MSR_ALF            0x00000800                      // arbitration lost flag (write '1' to clear)
        #define LPI2C_MSR_FEF            0x00001000                      // FIFO error flag (write '1' to clear)
        #define LPI2C_MSR_PLTF           0x00002000                      // pin low timeout flag (write '1' to clear)
        #define LPI2C_MSR_DMF            0x00004000                      // data match flag (write '1' to clear)
        #define LPI2C_MSR_MBF            0x01000000                      // I2C master bus busy (read-only)
        #define LPI2C_MSR_BBF            0x02000000                      // I2C bus busy (read-only)
    #define LPI2C0_MIER                  *(unsigned long *)(LPI2C0_BLOCK + 0x018) // LPI2C0 master interrupt enable register
        #define LPI2C_MIER_TDIE          0x00000001                      // transmit data interrupt enable
        #define LPI2C_MIER_RDIE          0x00000002                      // receive data interrupt enable
        #define LPI2C_MIER_EPIE          0x00000100                      // end packet interrupt enable
        #define LPI2C_MIER_SDIE          0x00000200                      // STOP detect interrupt enable
        #define LPI2C_MIER_NDIE          0x00000400                      // NACK detect interrupt enable
        #define LPI2C_MIER_ALIE          0x00000800                      // arbitration lost interrupt enable
        #define LPI2C_MIER_FEIE          0x00001000                      // FIFO error interrupt enable
        #define LPI2C_MIER_PLTIE         0x00002000                      // pin low timeout interrupt enable
        #define LPI2C_MIER_DMIE          0x00004000                      // data match interrupt enable
    #define LPI2C0_MDER                  *(unsigned long *)(LPI2C0_BLOCK + 0x01c) // LPI2C0 master DMA enable register
        #define LPI2C_MDER_TDDE          0x00000001                      // transmit data DMA enable
        #define LPI2C_MDER_RDDE          0x00000002                      // receive data DMA enable
    #define LPI2C0_MCFGR0                *(unsigned long *)(LPI2C0_BLOCK + 0x020) // LPI2C0 master configuration register 0
        #define LPI2C_MCFGR0_HREN        0x00000001                      // host request enable
        #define LPI2C_MCFGR0_HRPOL       0x00000002                      // host request polarity
        #define LPI2C_MCFGR0_HRSEL       0x00000004                      // host request select
        #define LPI2C_MCFGR0_CIRFIFO     0x00000100                      // circular FIFO enable
        #define LPI2C_MCFGR0_RDMO        0x00000200                      // receive data match only
    #define LPI2C0_MCFGR1                *(unsigned long *)(LPI2C0_BLOCK + 0x024) // LPI2C0 master configuration register 1 (only write when I2C master is disabled)
        #define LPI2C_MCFGR1_PRESCALE_1  0x00000000                      // clock prescaler - divide by 1
        #define LPI2C_MCFGR1_PRESCALE_2  0x00000001                      // clock prescaler - divide by 2
        #define LPI2C_MCFGR1_PRESCALE_4  0x00000002                      // clock prescaler - divide by 4
        #define LPI2C_MCFGR1_PRESCALE_8  0x00000003                      // clock prescaler - divide by 8
        #define LPI2C_MCFGR1_PRESCALE_16 0x00000004                      // clock prescaler - divide by 16
        #define LPI2C_MCFGR1_PRESCALE_32 0x00000005                      // clock prescaler - divide by 32
        #define LPI2C_MCFGR1_PRESCALE_64 0x00000006                      // clock prescaler - divide by 64
        #define LPI2C_MCFGR1_PRESCALE_128 0x00000007                      // clock prescaler - divide by 128
        #define LPI2C_MCFGR1_AUTOSTOP    0x00000100                      // automatic STOP generation
        #define LPI2C_MCFGR1_IGNACK      0x00000200                      // ignore NACK
        #define LPI2C_MCFGR1_TIMECFG     0x00000400                      // timeout configuration
        #define LPI2C_MCFGR1_MATCFG      0x00070000                      // match configuration mask
        #define LPI2C_MCFGR1_MATCFG_DISABLED 0x00070000                   // match configuration - disabled
        #define LPI2C_MCFGR1_PINCFG      0x07000000                      // pin configuration mask
        #define LPI2C_MCFGR1_PINCFG_2_OPEN 0x00000000                   // pin configuration - LPI2C configured for 2-pin open drain mode
    #define LPI2C0_MCFGR2                *(unsigned long *)(LPI2C0_BLOCK + 0x028) // LPI2C0 master configuration register 2 (only write when I2C master is disabled)
        #define LPI2C_MCFGR2_BUSIDLE_OFF  0x00000000                      // bus idle timeout disabled
        #define LPI2C_MCFGR2_BUSIDLE_MASK 0x00000fff                      // bus idle timeout mask
        #define LPI2C_MCFGR2_FILTSCL_MASK 0x000f0000                      // glitch filter SCL
        #define LPI2C_MCFGR2_FILTSDA_MASK 0x0f000000                      // glitch filter SDA
    #define LPI2C0_MCFGR3                *(unsigned long *)(LPI2C0_BLOCK + 0x02c) // LPI2C0 master configuration register 3 (only write when I2C master is disabled)
        #define LPI2C_MCFGR3_PINLOW_MASK 0x000fff00                      // pin low timeout
    #define LPI2C0_MDMR                  *(unsigned long *)(LPI2C0_BLOCK + 0x040) // LPI2C0 master data match register
        #define LPI2C_MDMR_MATCH0        0x000000ff                      // match 0 value
        #define LPI2C_MDMR_MATCH1        0x00ff0000                      // match 1 value
    #define LPI2C0_MCCR0                 *(unsigned long *)(LPI2C0_BLOCK + 0x048) // LPI2C0 master clock configuration register 0 (cannot be changed when I2C master is enabled)
        #define LPI2C_MCCR0_CLKLO_MASK   0x0000003f                      // clock low period
        #define LPI2C_MCCR0_CLKHI_MASK   0x00003f00                      // clock high period
        #define LPI2C_MCCR0_SETHOLD_MASK 0x003f0000                      // setup hold delay
        #define LPI2C_MCCR0_DATAVD_MASK  0x3f000000                      // data valid delay
        #define LPI2C_MCCR_CLKLO_SHIFT   0
        #define LPI2C_MCCR_CLKHI_SHIFT   8
        #define LPI2C_MCCR_SETHOLD_SHIFT 16
        #define LPI2C_MCCR_DATAVD_SHIFT  24
    #define LPI2C0_MCCR1                 *(unsigned long *)(LPI2C0_BLOCK + 0x050) // LPI2C0 master clock configuration register 1 (cannot be changed when I2C master is enabled)
        #define LPI2C_MCCR1_CLKLO_MASK   0x0000003f                      // clock low period
        #define LPI2C_MCCR1_CLKHI_MASK   0x00003f00                      // clock high period
        #define LPI2C_MCCR1_SETHOLD_MASK 0x003f0000                      // setup hold delay
        #define LPI2C_MCCR1_DATAVD_MASK  0x3f000000                      // data valid delay
    #define LPI2C0_MFCR                  *(unsigned long *)(LPI2C0_BLOCK + 0x058) // LPI2C0 master FIFO configuration register
        #define LPI2C_MFCR_TXWATER_MASK  0x000000ff                      // transmit FIFO watermark
        #define LPI2C_MFCR_RXWATER_MASK  0x00ff0000                      // receive FIFO watermark
    #define LPI2C0_MFSR                  *(volatile unsigned long *)(LPI2C0_BLOCK + 0x05c) // LPI2C0 master FIFO status register (read-only)
        #define LPI2C_MFSR_TXCOUNT_MASK  0x000000ff                      // transmit FIFO count
        #define LPI2C_MFSR_RXCOUNT_MASK  0x00ff0000                      // receive FIFO count
    #define LPI2C0_MTDR                  *(volatile unsigned long *)(LPI2C0_BLOCK + 0x060) // LPI2C0 master transmit data register (write-only)
        #define LPI2C_MTDR_DATA_MASK     0x000000ff                      // transmit data mask
        #define LPI2C_MTDR_CMD_TX_DATA        0x00000000                 // command data - transmit DATA[7:0]
        #define LPI2C_MTDR_CMD_RX_DATA        0x00000100                 // command data - receive DATA[7:0] + 1
        #define LPI2C_MTDR_CMD_STOP           0x00000200                 // command data - generate stop bit
        #define LPI2C_MTDR_CMD_DISCARD        0x00000300                 // command data - receive and discard DATA[7:0] + 1
        #define LPI2C_MTDR_CMD_START_DATA     0x00000400                 // command data - generate (repeated) START and transmit address DATA[7:0]
        #define LPI2C_MTDR_CMD_START_DATA_N   0x00000500                 // command data - generate (repeated) START and transmit address DATA[7:0] - expect NACK
        #define LPI2C_MTDR_CMD_START_F_DATA   0x00000600                 // command data - generate (repeated) START and transmit address DATA[7:0] (high speed mode)
        #define LPI2C_MTDR_CMD_START_F_DATA_N 0x00000700                 // command data - generate (repeated) START and transmit address DATA[7:0] - expect NACK (high speed mode)
        #define LPI2C_MTDR_CMD_MASK      0x00000700                      // command data mask
    #define LPI2C0_MRDR                  *(volatile unsigned long *)(LPI2C0_BLOCK + 0x070) // LPI2C0 master receive data register (read-only)
        #define LPI2C_MRDR_DATA_MASK     0x000000ff                      // receive data mask
        #define LPI2C_MRDR_RXEMPTY       0x00004000                      // receive FIFO is empty
    #define LPI2C0_SCR                   *(unsigned long *)(LPI2C0_BLOCK + 0x110) // LPI2C0 slave control register
    #define LPI2C0_SSR                   *(volatile unsigned long *)(LPI2C0_BLOCK + 0x114) // LPI2C0 slave status register
    #define LPI2C0_SIER                  *(unsigned long *)(LPI2C0_BLOCK + 0x118) // LPI2C0 slave interrupt enable register
    #define LPI2C0_SDER                  *(unsigned long *)(LPI2C0_BLOCK + 0x11c) // LPI2C0 slave DMA enable register
    #define LPI2C0_SCFGR1                *(unsigned long *)(LPI2C0_BLOCK + 0x124) // LPI2C0 slave configuration register 1
    #define LPI2C0_SCFGR2                *(unsigned long *)(LPI2C0_BLOCK + 0x128) // LPI2C0 slave configuration register 2
    #define LPI2C0_SAMR                  *(unsigned long *)(LPI2C0_BLOCK + 0x140) // LPI2C0 slave address match register
    #define LPI2C0_SASR                  *(volatile unsigned long *)(LPI2C0_BLOCK + 0x150) // LPI2C0 slave address status register (read-only)
    #define LPI2C0_STAR                  *(unsigned long *)(LPI2C0_BLOCK + 0x154) // LPI2C0 slave transmit ACK register
    #define LPI2C0_STDR                  *(volatile unsigned long *)(LPI2C0_BLOCK + 0x160) // LPI2C0 slave transmit data register (write-only)
    #define LPI2C0_SRDR                  *(volatile unsigned long *)(LPI2C0_BLOCK + 0x170) // LPI2C0 slave receive data register (read-only)
#endif
#if LPI2C_AVAILABLE > 1
    #define LPI2C1_VERID                 *(volatile unsigned long *)(LPI2C1_BLOCK + 0x000) // LPI2C1 version ID register (read-only)
    #define LPI2C1_PARAM                 *(volatile unsigned long *)(LPI2C1_BLOCK + 0x004) // LPI2C1 parameter register (read-only)
    #define LPI2C1_MCR                   *(volatile unsigned long *)(LPI2C1_BLOCK + 0x010) // LPI2C1 master control register
    #define LPI2C1_MSR                   *(volatile unsigned long *)(LPI2C1_BLOCK + 0x014) // LPI2C1 master status register
    #define LPI2C1_MIER                  *(unsigned long *)(LPI2C1_BLOCK + 0x018) // LPI2C1 master interrupt enable register
    #define LPI2C1_MDER                  *(unsigned long *)(LPI2C1_BLOCK + 0x01c) // LPI2C1 master DMA enable register
    #define LPI2C1_MCFGR0                *(unsigned long *)(LPI2C1_BLOCK + 0x020) // LPI2C1 master configuration register 0
    #define LPI2C1_MCFGR1                *(unsigned long *)(LPI2C1_BLOCK + 0x024) // LPI2C1 master configuration register 1
    #define LPI2C1_MCFGR2                *(unsigned long *)(LPI2C1_BLOCK + 0x028) // LPI2C1 master configuration register 2
    #define LPI2C1_MCFGR3                *(unsigned long *)(LPI2C1_BLOCK + 0x02c) // LPI2C1 master configuration register 3
    #define LPI2C1_MDMR                  *(unsigned long *)(LPI2C1_BLOCK + 0x040) // LPI2C1 master data match register
    #define LPI2C1_MCCR0                 *(unsigned long *)(LPI2C1_BLOCK + 0x048) // LPI2C1 master clock configuration register 0
    #define LPI2C1_MCCR1                 *(unsigned long *)(LPI2C1_BLOCK + 0x050) // LPI2C1 master clock configuration register 1
    #define LPI2C1_MFCR                  *(unsigned long *)(LPI2C1_BLOCK + 0x058) // LPI2C1 master FIFO configuration register
    #define LPI2C1_MFSR                  *(volatile unsigned long *)(LPI2C1_BLOCK + 0x05c) // LPI2C1 master FIFO status register (read-only)
    #define LPI2C1_MTDR                  *(volatile unsigned long *)(LPI2C1_BLOCK + 0x060) // LPI2C1 master transmit data register (write-only)
    #define LPI2C1_MRDR                  *(volatile unsigned long *)(LPI2C1_BLOCK + 0x070) // LPI2C1 master receive data register (read-only)
    #define LPI2C1_SCR                   *(unsigned long *)(LPI2C1_BLOCK + 0x110) // LPI2C1 slave control register
    #define LPI2C1_SSR                   *(volatile unsigned long *)(LPI2C1_BLOCK + 0x114) // LPI2C1 slave status register
    #define LPI2C1_SIER                  *(unsigned long *)(LPI2C1_BLOCK + 0x118) // LPI2C1 slave interrupt enable register
    #define LPI2C1_SDER                  *(unsigned long *)(LPI2C1_BLOCK + 0x11c) // LPI2C1 slave DMA enable register
    #define LPI2C1_SCFGR1                *(unsigned long *)(LPI2C1_BLOCK + 0x124) // LPI2C1 slave configuration register 1
    #define LPI2C1_SCFGR2                *(unsigned long *)(LPI2C1_BLOCK + 0x128) // LPI2C1 slave configuration register 2
    #define LPI2C1_SAMR                  *(unsigned long *)(LPI2C1_BLOCK + 0x140) // LPI2C1 slave address match register
    #define LPI2C1_SASR                  *(volatile unsigned long *)(LPI2C1_BLOCK + 0x150) // LPI2C1 slave address status register (read-only)
    #define LPI2C1_STAR                  *(unsigned long *)(LPI2C1_BLOCK + 0x154) // LPI2C1 slave transmit ACK register
    #define LPI2C1_STDR                  *(volatile unsigned long *)(LPI2C1_BLOCK + 0x160) // LPI2C1 slave transmit data register (write-only)
    #define LPI2C1_SRDR                  *(volatile unsigned long *)(LPI2C1_BLOCK + 0x170) // LPI2C1 slave receive data register (read-only)
#endif
#if LPI2C_AVAILABLE > 2
    #define LPI2C2_VERID                 *(volatile unsigned long *)(LPI2C2_BLOCK + 0x000) // LPI2C2 version ID register (read-only)
    #define LPI2C2_PARAM                 *(volatile unsigned long *)(LPI2C2_BLOCK + 0x004) // LPI2C2 parameter register (read-only)
    #define LPI2C2_MCR                   *(volatile unsigned long *)(LPI2C2_BLOCK + 0x010) // LPI2C2 master control register
    #define LPI2C2_MSR                   *(volatile unsigned long *)(LPI2C2_BLOCK + 0x014) // LPI2C2 master status register
    #define LPI2C2_MIER                  *(unsigned long *)(LPI2C2_BLOCK + 0x018) // LPI2C2 master interrupt enable register
    #define LPI2C2_MDER                  *(unsigned long *)(LPI2C2_BLOCK + 0x01c) // LPI2C2 master DMA enable register
    #define LPI2C2_MCFGR0                *(unsigned long *)(LPI2C2_BLOCK + 0x020) // LPI2C2 master configuration register 0
    #define LPI2C2_MCFGR1                *(unsigned long *)(LPI2C2_BLOCK + 0x024) // LPI2C2 master configuration register 1
    #define LPI2C2_MCFGR2                *(unsigned long *)(LPI2C2_BLOCK + 0x028) // LPI2C2 master configuration register 2
    #define LPI2C2_MCFGR3                *(unsigned long *)(LPI2C2_BLOCK + 0x02c) // LPI2C2 master configuration register 3
    #define LPI2C2_MDMR                  *(unsigned long *)(LPI2C2_BLOCK + 0x040) // LPI2C2 master data match register
    #define LPI2C2_MCCR0                 *(unsigned long *)(LPI2C2_BLOCK + 0x048) // LPI2C2 master clock configuration register 0
    #define LPI2C2_MCCR1                 *(unsigned long *)(LPI2C2_BLOCK + 0x050) // LPI2C2 master clock configuration register 1
    #define LPI2C2_MFCR                  *(unsigned long *)(LPI2C2_BLOCK + 0x058) // LPI2C2 master FIFO configuration register
    #define LPI2C2_MFSR                  *(volatile unsigned long *)(LPI2C2_BLOCK + 0x05c) // LPI2C2 master FIFO status register (read-only)
    #define LPI2C2_MTDR                  *(volatile unsigned long *)(LPI2C2_BLOCK + 0x060) // LPI2C2 master transmit data register (write-only)
    #define LPI2C2_MRDR                  *(volatile unsigned long *)(LPI2C2_BLOCK + 0x070) // LPI2C2 master receive data register (read-only)
    #define LPI2C2_SCR                   *(unsigned long *)(LPI2C2_BLOCK + 0x110) // LPI2C2 slave control register
    #define LPI2C2_SSR                   *(volatile unsigned long *)(LPI2C2_BLOCK + 0x114) // LPI2C2 slave status register
    #define LPI2C2_SIER                  *(unsigned long *)(LPI2C2_BLOCK + 0x118) // LPI2C2 slave interrupt enable register
    #define LPI2C2_SDER                  *(unsigned long *)(LPI2C2_BLOCK + 0x11c) // LPI2C2 slave DMA enable register
    #define LPI2C2_SCFGR1                *(unsigned long *)(LPI2C2_BLOCK + 0x124) // LPI2C2 slave configuration register 1
    #define LPI2C2_SCFGR2                *(unsigned long *)(LPI2C2_BLOCK + 0x128) // LPI2C2 slave configuration register 2
    #define LPI2C2_SAMR                  *(unsigned long *)(LPI2C2_BLOCK + 0x140) // LPI2C2 slave address match register
    #define LPI2C2_SASR                  *(volatile unsigned long *)(LPI2C2_BLOCK + 0x150) // LPI2C2 slave address status register (read-only)
    #define LPI2C2_STAR                  *(unsigned long *)(LPI2C2_BLOCK + 0x154) // LPI2C2 slave transmit ACK register
    #define LPI2C2_STDR                  *(volatile unsigned long *)(LPI2C2_BLOCK + 0x160) // LPI2C2 slave transmit data register (write-only)
    #define LPI2C2_SRDR                  *(volatile unsigned long *)(LPI2C2_BLOCK + 0x170) // LPI2C2 slave receive data register (read-only)
#endif
#if LPI2C_AVAILABLE > 3
    #define LPI2C3_VERID                 *(volatile unsigned long *)(LPI2C3_BLOCK + 0x000) // LPI2C3 version ID register (read-only)
    #define LPI2C3_PARAM                 *(volatile unsigned long *)(LPI2C3_BLOCK + 0x004) // LPI2C3 parameter register (read-only)
    #define LPI2C3_MCR                   *(volatile unsigned long *)(LPI2C3_BLOCK + 0x010) // LPI2C3 master control register
    #define LPI2C3_MSR                   *(volatile unsigned long *)(LPI2C3_BLOCK + 0x014) // LPI2C3 master status register
    #define LPI2C3_MIER                  *(unsigned long *)(LPI2C3_BLOCK + 0x018) // LPI2C3 master interrupt enable register
    #define LPI2C3_MDER                  *(unsigned long *)(LPI2C3_BLOCK + 0x01c) // LPI2C3 master DMA enable register
    #define LPI2C3_MCFGR0                *(unsigned long *)(LPI2C3_BLOCK + 0x020) // LPI2C3 master configuration register 0
    #define LPI2C3_MCFGR1                *(unsigned long *)(LPI2C3_BLOCK + 0x024) // LPI2C3 master configuration register 1
    #define LPI2C3_MCFGR2                *(unsigned long *)(LPI2C3_BLOCK + 0x028) // LPI2C3 master configuration register 2
    #define LPI2C3_MCFGR3                *(unsigned long *)(LPI2C3_BLOCK + 0x02c) // LPI2C3 master configuration register 3
    #define LPI2C3_MDMR                  *(unsigned long *)(LPI2C3_BLOCK + 0x040) // LPI2C3 master data match register
    #define LPI2C3_MCCR0                 *(unsigned long *)(LPI2C3_BLOCK + 0x048) // LPI2C3 master clock configuration register 0
    #define LPI2C3_MCCR1                 *(unsigned long *)(LPI2C3_BLOCK + 0x050) // LPI2C3 master clock configuration register 1
    #define LPI2C3_MFCR                  *(unsigned long *)(LPI2C3_BLOCK + 0x058) // LPI2C3 master FIFO configuration register
    #define LPI2C3_MFSR                  *(volatile unsigned long *)(LPI2C3_BLOCK + 0x05c) // LPI2C3 master FIFO status register (read-only)
    #define LPI2C3_MTDR                  *(volatile unsigned long *)(LPI2C3_BLOCK + 0x060) // LPI2C3 master transmit data register (write-only)
    #define LPI2C3_MRDR                  *(volatile unsigned long *)(LPI2C3_BLOCK + 0x070) // LPI2C3 master receive data register (read-only)
    #define LPI2C3_SCR                   *(unsigned long *)(LPI2C3_BLOCK + 0x110) // LPI2C3 slave control register
    #define LPI2C3_SSR                   *(volatile unsigned long *)(LPI2C3_BLOCK + 0x114) // LPI2C3 slave status register
    #define LPI2C3_SIER                  *(unsigned long *)(LPI2C3_BLOCK + 0x118) // LPI2C3 slave interrupt enable register
    #define LPI2C3_SDER                  *(unsigned long *)(LPI2C3_BLOCK + 0x11c) // LPI2C3 slave DMA enable register
    #define LPI2C3_SCFGR1                *(unsigned long *)(LPI2C3_BLOCK + 0x124) // LPI2C3 slave configuration register 1
    #define LPI2C3_SCFGR2                *(unsigned long *)(LPI2C3_BLOCK + 0x128) // LPI2C3 slave configuration register 2
    #define LPI2C3_SAMR                  *(unsigned long *)(LPI2C3_BLOCK + 0x140) // LPI2C3 slave address match register
    #define LPI2C3_SASR                  *(volatile unsigned long *)(LPI2C3_BLOCK + 0x150) // LPI2C3 slave address status register (read-only)
    #define LPI2C3_STAR                  *(unsigned long *)(LPI2C3_BLOCK + 0x154) // LPI2C3 slave transmit ACK register
    #define LPI2C3_STDR                  *(volatile unsigned long *)(LPI2C3_BLOCK + 0x160) // LPI2C3 slave transmit data register (write-only)
    #define LPI2C3_SRDR                  *(volatile unsigned long *)(LPI2C3_BLOCK + 0x170) // LPI2C3 slave receive data register (read-only)
#endif

#if LPI2C_AVAILABLE > 0
typedef struct stKINETIS_LPI2C_CONTROL
{
    volatile unsigned long  LPI2C_VERID;
    volatile unsigned long  LPI2C_PARAM;
    unsigned long  ulRes0[2];
    unsigned long  LPI2C_MCR;
    volatile unsigned long  LPI2C_MSR;
    unsigned long  LPI2C_MIER;
    unsigned long  LPI2C_MDER;
    unsigned long  LPI2C_MCFGR0;
    unsigned long  LPI2C_MCFGR1;
    unsigned long  LPI2C_MCFGR2;
    unsigned long  LPI2C_MCFGR3;
    unsigned long  ulRes1[4];
    unsigned long  LPI2C_MDMR;
    unsigned long  ulRes2;
    unsigned long  LPI2C_MCCR0;
    unsigned long  ulRes3;
    unsigned long  LPI2C_MCCR1;
    unsigned long  ulRes4;
    unsigned long  LPI2C_MFCR;
    volatile unsigned long  LPI2C_MFSR;
    volatile unsigned long  LPI2C_MTDR;
    unsigned long  ulRes5[3];
    volatile unsigned long  LPI2C_MRDR;
    unsigned long  ulRes6[27];
    unsigned long  LPI2C_SCR;
    volatile unsigned long  LPI2C_SSR;
    unsigned long  LPI2C_SIER;
    unsigned long  LPI2C_SDER;
    unsigned long  ulRes7;
    unsigned long  LPI2C_SCFGR1;
    unsigned long  LPI2C_SCFGR2;
    unsigned long  ulRes8[4];
    unsigned long  LPI2C_SAMR;
    unsigned long  ulRes9[3];
    volatile unsigned long  LPI2C_SASR;
    unsigned long  LPI2C_STAR;
    unsigned long  ulRes10[2];
    volatile unsigned long  LPI2C_STDR;
    unsigned long  ulRes11[3];
    volatile unsigned long  LPI2C_SRDR;
} KINETIS_LPI2C_CONTROL;
#endif

// CAN Configuration module
//
#define CAN0_MCR             *(volatile unsigned long *)(CAN0_BASE_ADD + 0x0) // CAN Module Configuration Register
  #define CAN_MDIS           0x80000000                                  // module disable
  #define CAN_FRZ            0x40000000                                  // freeze enable
  #define CAN_RFEN           0x20000000                                  // rx-fifo enable
  #define CAN_HALT           0x10000000                                  // halt FlexCAN
  #define CAN_NOTRDY         0x08000000                                  // FlexCAN not ready (read-only)
  #define CAN_WAKMSK         0x04000000                                  // wake up interrupt mask
  #define CAN_SOFTRST        0x02000000                                  // resets registers affected by the soft-reset
  #define CAN_FRZACK         0x01000000                                  // freeze mode acknowledge
  #define CAN_SUPV           0x00800000                                  // supervisor mode
  #define CAN_SLFWAK         0x00400000                                  // self wake up
  #define CAN_WRNEN          0x00200000                                  // warning interrupt enable
  #define CAN_LPMACK         0x00100000                                  // low power mode acknowledge
  #define CAN_SRXDIS         0x00020000                                  // self reception disable
  #define CAN_IRMQ           0x00010000                                  // Individual Rx Masking and Queue enable
  #define CAN_LPRIOEN        0x00002000                                  // local priority enable
  #define CAN_AEN            0x00001000                                  // abort enable
  #define CAN_IDAM_A         0x00000000                                  // ID acceptance modes - one full ID
  #define CAN_IDAM_B         0x00000100                                  // ID acceptance modes - two full standard or two partial
  #define CAN_IDAM_C         0x00000200                                  // ID acceptance modes - four partial 8-bit standard
  #define CAN_IDAM_D         0x00000300                                  // ID acceptance modes - all frames rejected
  #define CAN_MAXMB_MASK     0x0000007f                                  // ID acceptance modes 
#define CAN0_CTRL1           *(volatile unsigned long *)(CAN0_BASE_ADD + 0x4) // CAN Control Register 1
  #define CAN_DIV_3          (0x02 << 24)
  #define EXTAL_CLK_SOURCE   0                                           // use crystal source for clock (lower jitter than PLL)
  #define RJW_0              (0 << 22)
  #define RJW_1              (1 << 22)
  #define RJW_2              (2 << 22)
  #define RJW_3              (3 << 22)
  #define PHASE_BUF_SEG1_LEN1 (0 << 19)
  #define PHASE_BUF_SEG1_LEN2 (1 << 19)
  #define PHASE_BUF_SEG1_LEN3 (2 << 19)
  #define PHASE_BUF_SEG1_LEN4 (3 << 19)
  #define PHASE_BUF_SEG1_LEN5 (4 << 19)
  #define PHASE_BUF_SEG1_LEN6 (5 << 19)
  #define PHASE_BUF_SEG1_LEN7 (6 << 19)
  #define PHASE_BUF_SEG1_LEN8 (7 << 19)
  #define PHASE_BUF_SEG2_LEN1 (0 << 16)
  #define PHASE_BUF_SEG2_LEN2 (1 << 16)
  #define PHASE_BUF_SEG2_LEN3 (2 << 16)
  #define PHASE_BUF_SEG2_LEN4 (3 << 16)
  #define PHASE_BUF_SEG2_LEN5 (4 << 16)
  #define PHASE_BUF_SEG2_LEN6 (5 << 16)
  #define PHASE_BUF_SEG2_LEN7 (6 << 16)
  #define PHASE_BUF_SEG2_LEN8 (7 << 16)
  #define BOFFMSK            0x00008000                                  // Bus off interrupt mask
  #define ERRMSK             0x00004000                                  // Error interrupt mask
  #define CLK_SRC_PERIPH_CLK 0x00002000                                  // Clock source is the peripheral clock
  #define LPB                0x00001000                                  // Loop Back Mode
  #define TWRNMSK            0x00000800                                  // Tx warning Interrupt mask
  #define RWRNMSK            0x00000400                                  // Rx warning Interrupt mask
  #define SMP                0x00000080                                  // Sampling Mode - three samples decide rx value
  #define BOFFREC            0x00000040                                  // Bus off recovery mode disable
  #define TSYN               0x00000020                                  // Timer synchronisation
  #define LBUF               0x00000010                                  // Lowest number buffer transmitted first
  #define LOM                0x00000008                                  // Listen-only mode
  #define PROPSEG_BIT_TIME1  (0)
  #define PROPSEG_BIT_TIME2  (1)
  #define PROPSEG_BIT_TIME3  (2)
  #define PROPSEG_BIT_TIME4  (3)
  #define PROPSEG_BIT_TIME5  (4)
  #define PROPSEG_BIT_TIME6  (5)
  #define PROPSEG_BIT_TIME7  (6)
  #define PROPSEG_BIT_TIME8  (7)
#define CAN0_TIMER           *(volatile unsigned long *)(CAN0_BASE_ADD + 0x8) // CAN Free running timer

#define CAN0_RXGMASK         *(unsigned long *)(CAN0_BASE_ADD + 0x10)    // CAN Rx Global mask
#define CAN0_RX14MASK        *(unsigned long *)(CAN0_BASE_ADD + 0x14)    // CAN Rx Buffer 14 mask
#define CAN0_RX15MASK        *(unsigned long *)(CAN0_BASE_ADD + 0x18)    // CAN Rx Buffer 15 mask
#define CAN0_ECR             *(volatile unsigned long *)(CAN0_BASE_ADD + 0x1c) // CAN Error Counter Register
#define CAN0_ESR1            *(volatile unsigned long *)(CAN0_BASE_ADD + 0x20) // CAN Error and Status 1 Register
  #define BIT1ERROR          0x00008000
  #define BIT0ERROR          0x00004000
  #define CAN_ACK_ERR        0x00002000
  #define CAN_CRC_ERR        0x00001000
  #define CAN_FRM_ERR        0x00000800
  #define CAN_STF_ERR        0x00000400
  #define TXWRN              0x00000200
  #define RXWRN              0x00000100
  #define CAN_BUS_IDLE       0x00000080
  #define CAN_ERROR_PASSIVE  0x00000010
  #define BOFFINT            0x00000004
  #define ERRINT             0x00000002
#define CAN0_IMASK2          *(unsigned long *)(CAN0_BASE_ADD + 0x24)    // CAN Interrupt Mask Register 2
#define CAN0_IMASK1          *(unsigned long *)(CAN0_BASE_ADD + 0x28)    // CAN Interrupt Mask Register 1
#define CAN0_IFLAG2          *(volatile unsigned long *)(CAN0_BASE_ADD + 0x2c) // CAN Interrupt Flag Register 2
#define CAN0_IFLAG1          *(volatile unsigned long *)(CAN0_BASE_ADD + 0x30) // CAN Interrupt Flag Register 1
  #define CAN_BUF_0_INT      0x00000001
  #define CAN_BUF_1_INT      0x00000002
  #define CAN_BUF_2_INT      0x00000004
  #define CAN_BUF_3_INT      0x00000008
  #define CAN_BUF_4_INT      0x00000010
  #define CAN_BUF_5_INT      0x00000020
  #define CAN_BUF_6_INT      0x00000040
  #define CAN_BUF_7_INT      0x00000080
  #define CAN_BUF_8_INT      0x00000100
  #define CAN_BUF_9_INT      0x00000200
  #define CAN_BUF_10_INT     0x00000400
  #define CAN_BUF_11_INT     0x00000800
  #define CAN_BUF_12_INT     0x00001000
  #define CAN_BUF_13_INT     0x00002000
  #define CAN_BUF_14_INT     0x00004000
  #define CAN_BUF_15_INT     0x00008000
#define CAN0_CTRL2           *(unsigned long *)(CAN0_BASE_ADD + 0x34)    // CAN Control Register 2
#define CAN0_ESR2            *(volatile unsigned long *)(CAN0_BASE_ADD + 0x38) // CAN Error and Status Register 2

#define CAN0_CRCR            *(volatile unsigned long *)(CAN0_BASE_ADD + 0x44) // CAN CRC Register
#define CAN0_RXFGMASK        *(unsigned long *)(CAN0_BASE_ADD + 0x48)    // CAN FIFO Global mask Register
#define CAN0_RXFIR           *(volatile unsigned long *)(CAN0_BASE_ADD + 0x4c) // CAN FIFI Information Register (read-only)

  #define CAN_ALL_BUFFERS_INT (CAN_BUF_0_INT | CAN_BUF_1_INT | CAN_BUF_2_INT | CAN_BUF_3_INT | CAN_BUF_4_INT | CAN_BUF_5_INT | CAN_BUF_6_INT | CAN_BUF_7_INT | CAN_BUF_8_INT | CAN_BUF_9_INT | CAN_BUF_10_INT | CAN_BUF_11_INT | CAN_BUF_12_INT | CAN_BUF_13_INT | CAN_BUF_14_INT | CAN_BUF_15_INT)

#define MAX_TX_CAN_TRIES     5                                           // let the controller try this many times before declaring a transmission error

#define MB_RX_INACTIVE       0x00000000
#define MB_RX_EMPTY          0x04000000
#define MB_RX_FULL           0x02000000
#define MB_RX_OVERRUN        0x06000000
#define MB_RX_BUSY_BIT       0x01000000
#define MB_TX_INACTIVE       0x08000000
#define MB_TX_SEND_ONCE      0x0c000000
#define MB_TX_SEND_ON_REQ    0x0a000000

#define CAN_CODE_FIELD       0x0f000000                                 // CODE field mask
#define CAN_RX_CODE_FIELD    0x07000000

#define SRR                  0x00400000                                 // Substitute remote request
#define IDE                  0x00200000                                 // ID extended bit
#define RTR                  0x00100000                                 // Remote transmission request

#define CAN_LENGTH_AND_TIME  0x000fffff
#define CAN_KEEP_CONTENTS    0x00ffffff
#define CAN_EXTENDED_MASK    0x1fffffff
#define CAN_STANDARD_MASK    0x7ff
#define CAN_STANDARD_BITMASK 0x1ffc0000
#define CAN_STANDARD_SHIFT   18

#define FLEXCAN0_DBG1        *(unsigned long *)(CAN0_BASE_ADD + 0x58)    // flexcan debug 1 register (read-only)
#define FLEXCAN0_DBG2        *(unsigned long *)(CAN0_BASE_ADD + 0x5c)    // flexcan debug 2 register (read-only)

#define MBUFF0_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x80)   // CAN Message Buffer 0 (16 bytes)
#define MBUFF1_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x90)   // CAN Message Buffer 1 (16 bytes)
#define MBUFF2_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xa0)   // CAN Message Buffer 2 (16 bytes)
#define MBUFF3_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xb0)   // CAN Message Buffer 3 (16 bytes)
#define MBUFF4_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xc0)   // CAN Message Buffer 4 (16 bytes)
#define MBUFF5_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xd0)   // CAN Message Buffer 5 (16 bytes)
#define MBUFF6_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xe0)   // CAN Message Buffer 6 (16 bytes)
#define MBUFF7_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0xf0)   // CAN Message Buffer 7 (16 bytes)
#define MBUFF8_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x100)  // CAN Message Buffer 8 (16 bytes)
#define MBUFF9_ADD_0         (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x110)  // CAN Message Buffer 9 (16 bytes)
#define MBUFF10_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x120)  // CAN Message Buffer 10 (16 bytes)
#define MBUFF11_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x130)  // CAN Message Buffer 11 (16 bytes)
#define MBUFF12_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x140)  // CAN Message Buffer 12 (16 bytes)
#define MBUFF13_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x150)  // CAN Message Buffer 13 (16 bytes)
#define MBUFF14_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x160)  // CAN Message Buffer 14 (16 bytes)
#define MBUFF15_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x170)  // CAN Message Buffer 15 (16 bytes)
#define MBUFF16_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x174)  // CAN Message Buffer 16 (16 bytes)
#define MBUFF17_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x178)  // CAN Message Buffer 17 (16 bytes)
#define MBUFF18_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x17c)  // CAN Message Buffer 18 (16 bytes)
#define MBUFF19_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x180)  // CAN Message Buffer 19 (16 bytes)
#define MBUFF20_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x184)  // CAN Message Buffer 20 (16 bytes)
#define MBUFF21_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x188)  // CAN Message Buffer 21 (16 bytes)
#define MBUFF22_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x18c)  // CAN Message Buffer 22 (16 bytes)
#define MBUFF23_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x190)  // CAN Message Buffer 23 (16 bytes)
#define MBUFF24_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x194)  // CAN Message Buffer 24 (16 bytes)
#define MBUFF25_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x198)  // CAN Message Buffer 25 (16 bytes)
#define MBUFF26_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x19c)  // CAN Message Buffer 26 (16 bytes)
#define MBUFF27_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1a0)  // CAN Message Buffer 27 (16 bytes)
#define MBUFF28_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1a4)  // CAN Message Buffer 28 (16 bytes)
#define MBUFF29_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1a8)  // CAN Message Buffer 29 (16 bytes)
#define MBUFF30_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1ac)  // CAN Message Buffer 30 (16 bytes)
#define MBUFF31_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1b0)  // CAN Message Buffer 31 (16 bytes)
#define MBUFF32_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1b4)  // CAN Message Buffer 32 (16 bytes)
#define MBUFF33_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1b8)  // CAN Message Buffer 33 (16 bytes)
#define MBUFF34_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1bc)  // CAN Message Buffer 34 (16 bytes)
#define MBUFF35_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1c0)  // CAN Message Buffer 35 (16 bytes)
#define MBUFF36_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1c4)  // CAN Message Buffer 36 (16 bytes)
#define MBUFF37_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1c8)  // CAN Message Buffer 37 (16 bytes)
#define MBUFF38_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1cc)  // CAN Message Buffer 38 (16 bytes)
#define MBUFF39_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1d0)  // CAN Message Buffer 39 (16 bytes)
#define MBUFF40_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1d4)  // CAN Message Buffer 40 (16 bytes)
#define MBUFF41_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1d8)  // CAN Message Buffer 41 (16 bytes)
#define MBUFF42_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1dc)  // CAN Message Buffer 42 (16 bytes)
#define MBUFF43_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1e0)  // CAN Message Buffer 43 (16 bytes)
#define MBUFF44_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1e4)  // CAN Message Buffer 44 (16 bytes)
#define MBUFF45_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1e8)  // CAN Message Buffer 45 (16 bytes)
#define MBUFF46_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1ec)  // CAN Message Buffer 46 (16 bytes)
#define MBUFF47_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1f0)  // CAN Message Buffer 47 (16 bytes)
#define MBUFF48_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1f4)  // CAN Message Buffer 48 (16 bytes)
#define MBUFF49_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1f8)  // CAN Message Buffer 49 (16 bytes)
#define MBUFF50_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x1fc)  // CAN Message Buffer 50 (16 bytes)
#define MBUFF51_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x200)  // CAN Message Buffer 51 (16 bytes)
#define MBUFF52_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x204)  // CAN Message Buffer 52 (16 bytes)
#define MBUFF53_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x208)  // CAN Message Buffer 53 (16 bytes)
#define MBUFF54_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x20c)  // CAN Message Buffer 54 (16 bytes)
#define MBUFF55_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x200)  // CAN Message Buffer 55 (16 bytes)
#define MBUFF56_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x204)  // CAN Message Buffer 56 (16 bytes)
#define MBUFF57_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x208)  // CAN Message Buffer 57 (16 bytes)
#define MBUFF58_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x20c)  // CAN Message Buffer 58 (16 bytes)
#define MBUFF59_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x210)  // CAN Message Buffer 59 (16 bytes)
#define MBUFF60_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x214)  // CAN Message Buffer 60 (16 bytes)
#define MBUFF61_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x218)  // CAN Message Buffer 61 (16 bytes)
#define MBUFF62_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x21c)  // CAN Message Buffer 62 (16 bytes)
#define MBUFF63_ADD_0        (KINETIS_CAN_BUF *)(CAN0_BASE_ADD + 0x220)  // CAN Message Buffer 63 (16 bytes)

#define CAN0_RXIMR0          *(unsigned long *)(CAN0_BASE_ADD + 0x880)   // CAN Rx Individual Mask Register 0
#define CAN0_RXIMR1          *(unsigned long *)(CAN0_BASE_ADD + 0x884)   // CAN Rx Individual Mask Register 1
#define CAN0_RXIMR2          *(unsigned long *)(CAN0_BASE_ADD + 0x888)   // CAN Rx Individual Mask Register 2
#define CAN0_RXIMR3          *(unsigned long *)(CAN0_BASE_ADD + 0x88c)   // CAN Rx Individual Mask Register 3
#define CAN0_RXIMR4          *(unsigned long *)(CAN0_BASE_ADD + 0x890)   // CAN Rx Individual Mask Register 4
#define CAN0_RXIMR5          *(unsigned long *)(CAN0_BASE_ADD + 0x894)   // CAN Rx Individual Mask Register 5
#define CAN0_RXIMR6          *(unsigned long *)(CAN0_BASE_ADD + 0x898)   // CAN Rx Individual Mask Register 6
#define CAN0_RXIMR7          *(unsigned long *)(CAN0_BASE_ADD + 0x89c)   // CAN Rx Individual Mask Register 7
#define CAN0_RXIMR8          *(unsigned long *)(CAN0_BASE_ADD + 0x8a0)   // CAN Rx Individual Mask Register 8
#define CAN0_RXIMR9          *(unsigned long *)(CAN0_BASE_ADD + 0x8a4)   // CAN Rx Individual Mask Register 9
#define CAN0_RXIMR10         *(unsigned long *)(CAN0_BASE_ADD + 0x8a8)   // CAN Rx Individual Mask Register 10
#define CAN0_RXIMR11         *(unsigned long *)(CAN0_BASE_ADD + 0x8ac)   // CAN Rx Individual Mask Register 11
#define CAN0_RXIMR12         *(unsigned long *)(CAN0_BASE_ADD + 0x8b0)   // CAN Rx Individual Mask Register 12
#define CAN0_RXIMR13         *(unsigned long *)(CAN0_BASE_ADD + 0x8b4)   // CAN Rx Individual Mask Register 13
#define CAN0_RXIMR14         *(unsigned long *)(CAN0_BASE_ADD + 0x8b8)   // CAN Rx Individual Mask Register 14
#define CAN0_RXIMR15         *(unsigned long *)(CAN0_BASE_ADD + 0x8bc)   // CAN Rx Individual Mask Register 15
#define CAN0_RXIMR16         *(unsigned long *)(CAN0_BASE_ADD + 0x8c0)   // CAN Rx Individual Mask Register 16
#define CAN0_RXIMR17         *(unsigned long *)(CAN0_BASE_ADD + 0x8cc)   // CAN Rx Individual Mask Register 17
#define CAN0_RXIMR18         *(unsigned long *)(CAN0_BASE_ADD + 0x8c8)   // CAN Rx Individual Mask Register 18
#define CAN0_RXIMR19         *(unsigned long *)(CAN0_BASE_ADD + 0x8cc)   // CAN Rx Individual Mask Register 19
#define CAN0_RXIMR20         *(unsigned long *)(CAN0_BASE_ADD + 0x8d0)   // CAN Rx Individual Mask Register 20
#define CAN0_RXIMR21         *(unsigned long *)(CAN0_BASE_ADD + 0x8d4)   // CAN Rx Individual Mask Register 21
#define CAN0_RXIMR22         *(unsigned long *)(CAN0_BASE_ADD + 0x8d8)   // CAN Rx Individual Mask Register 22
#define CAN0_RXIMR23         *(unsigned long *)(CAN0_BASE_ADD + 0x8dc)   // CAN Rx Individual Mask Register 23
#define CAN0_RXIMR24         *(unsigned long *)(CAN0_BASE_ADD + 0x8e0)   // CAN Rx Individual Mask Register 24
#define CAN0_RXIMR25         *(unsigned long *)(CAN0_BASE_ADD + 0x8e4)   // CAN Rx Individual Mask Register 25
#define CAN0_RXIMR26         *(unsigned long *)(CAN0_BASE_ADD + 0x8e8)   // CAN Rx Individual Mask Register 26
#define CAN0_RXIMR27         *(unsigned long *)(CAN0_BASE_ADD + 0x8ec)   // CAN Rx Individual Mask Register 27
#define CAN0_RXIMR28         *(unsigned long *)(CAN0_BASE_ADD + 0x8f0)   // CAN Rx Individual Mask Register 28
#define CAN0_RXIMR29         *(unsigned long *)(CAN0_BASE_ADD + 0x8f4)   // CAN Rx Individual Mask Register 29
#define CAN0_RXIMR30         *(unsigned long *)(CAN0_BASE_ADD + 0x8f8)   // CAN Rx Individual Mask Register 30
#define CAN0_RXIMR31         *(unsigned long *)(CAN0_BASE_ADD + 0x8fc)   // CAN Rx Individual Mask Register 31
#define CAN0_RXIMR32         *(unsigned long *)(CAN0_BASE_ADD + 0x900)   // CAN Rx Individual Mask Register 32
#define CAN0_RXIMR33         *(unsigned long *)(CAN0_BASE_ADD + 0x904)   // CAN Rx Individual Mask Register 33
#define CAN0_RXIMR34         *(unsigned long *)(CAN0_BASE_ADD + 0x908)   // CAN Rx Individual Mask Register 34
#define CAN0_RXIMR35         *(unsigned long *)(CAN0_BASE_ADD + 0x90c)   // CAN Rx Individual Mask Register 35
#define CAN0_RXIMR36         *(unsigned long *)(CAN0_BASE_ADD + 0x910)   // CAN Rx Individual Mask Register 36
#define CAN0_RXIMR37         *(unsigned long *)(CAN0_BASE_ADD + 0x914)   // CAN Rx Individual Mask Register 37
#define CAN0_RXIMR38         *(unsigned long *)(CAN0_BASE_ADD + 0x918)   // CAN Rx Individual Mask Register 38
#define CAN0_RXIMR39         *(unsigned long *)(CAN0_BASE_ADD + 0x91c)   // CAN Rx Individual Mask Register 39
#define CAN0_RXIMR40         *(unsigned long *)(CAN0_BASE_ADD + 0x920)   // CAN Rx Individual Mask Register 40
#define CAN0_RXIMR41         *(unsigned long *)(CAN0_BASE_ADD + 0x924)   // CAN Rx Individual Mask Register 41
#define CAN0_RXIMR42         *(unsigned long *)(CAN0_BASE_ADD + 0x928)   // CAN Rx Individual Mask Register 42
#define CAN0_RXIMR43         *(unsigned long *)(CAN0_BASE_ADD + 0x92c)   // CAN Rx Individual Mask Register 43
#define CAN0_RXIMR44         *(unsigned long *)(CAN0_BASE_ADD + 0x930)   // CAN Rx Individual Mask Register 44
#define CAN0_RXIMR45         *(unsigned long *)(CAN0_BASE_ADD + 0x934)   // CAN Rx Individual Mask Register 45
#define CAN0_RXIMR46         *(unsigned long *)(CAN0_BASE_ADD + 0x938)   // CAN Rx Individual Mask Register 46
#define CAN0_RXIMR47         *(unsigned long *)(CAN0_BASE_ADD + 0x93c)   // CAN Rx Individual Mask Register 47
#define CAN0_RXIMR48         *(unsigned long *)(CAN0_BASE_ADD + 0x940)   // CAN Rx Individual Mask Register 48
#define CAN0_RXIMR49         *(unsigned long *)(CAN0_BASE_ADD + 0x94c)   // CAN Rx Individual Mask Register 49
#define CAN0_RXIMR50         *(unsigned long *)(CAN0_BASE_ADD + 0x948)   // CAN Rx Individual Mask Register 50
#define CAN0_RXIMR51         *(unsigned long *)(CAN0_BASE_ADD + 0x94c)   // CAN Rx Individual Mask Register 51
#define CAN0_RXIMR52         *(unsigned long *)(CAN0_BASE_ADD + 0x950)   // CAN Rx Individual Mask Register 52
#define CAN0_RXIMR53         *(unsigned long *)(CAN0_BASE_ADD + 0x954)   // CAN Rx Individual Mask Register 53
#define CAN0_RXIMR54         *(unsigned long *)(CAN0_BASE_ADD + 0x958)   // CAN Rx Individual Mask Register 54
#define CAN0_RXIMR55         *(unsigned long *)(CAN0_BASE_ADD + 0x95c)   // CAN Rx Individual Mask Register 55
#define CAN0_RXIMR56         *(unsigned long *)(CAN0_BASE_ADD + 0x960)   // CAN Rx Individual Mask Register 56
#define CAN0_RXIMR57         *(unsigned long *)(CAN0_BASE_ADD + 0x964)   // CAN Rx Individual Mask Register 57
#define CAN0_RXIMR58         *(unsigned long *)(CAN0_BASE_ADD + 0x968)   // CAN Rx Individual Mask Register 58
#define CAN0_RXIMR59         *(unsigned long *)(CAN0_BASE_ADD + 0x96c)   // CAN Rx Individual Mask Register 59
#define CAN0_RXIMR60         *(unsigned long *)(CAN0_BASE_ADD + 0x970)   // CAN Rx Individual Mask Register 60
#define CAN0_RXIMR61         *(unsigned long *)(CAN0_BASE_ADD + 0x974)   // CAN Rx Individual Mask Register 61
#define CAN0_RXIMR62         *(unsigned long *)(CAN0_BASE_ADD + 0x978)   // CAN Rx Individual Mask Register 62
#define CAN0_RXIMR63         *(unsigned long *)(CAN0_BASE_ADD + 0x97c)   // CAN Rx Individual Mask Register 63

#define CAN0_GFWR            *(unsigned long *)(CAN0_BASE_ADD + 0x9e0)   // CAN glitch filter width register

#if NUMBER_OF_CAN_INTERFACES > 1
    #define CAN1_MCR         *(volatile unsigned long *)(CAN1_BASE_ADD + 0x0) // CAN Module Configuration Register (supervisor only)
    #define CAN1_CTRL1       *(volatile unsigned long *)(CAN1_BASE_ADD + 0x4) // CAN Control Register 1
    #define CAN1_TIMER       *(volatile unsigned long *)(CAN1_BASE_ADD + 0x8) // CAN Free running timer
    #define CAN1_RXGMASK     *(unsigned long *)(CAN1_BASE_ADD + 0x10)    // CAN Rx Global mask
    #define CAN1_RX14MASK    *(unsigned long *)(CAN1_BASE_ADD + 0x14)    // CAN Rx Buffer 14 mask
    #define CAN1_RX15MASK    *(unsigned long *)(CAN1_BASE_ADD + 0x18)    // CAN Rx Buffer 15 mask
    #define CAN1_ECR         *(volatile unsigned long *)(CAN1_BASE_ADD + 0x1c) // CAN Error Counter Register
    #define CAN1_ESR1        *(volatile unsigned long *)(CAN1_BASE_ADD + 0x20) // CAN Error and Status 1 Register
    #define CAN1_IMASK2      *(unsigned long *)(CAN1_BASE_ADD + 0x24)    // CAN Interrupt Mask Register 2
    #define CAN1_IMASK1      *(unsigned long *)(CAN1_BASE_ADD + 0x28)    // CAN Interrupt Mask Register 1
    #define CAN1_IFLAG2      *(unsigned long *)(CAN1_BASE_ADD + 0x2c)    // CAN Interrupt Flag Register 1
    #define CAN1_IFLAG1      *(unsigned long *)(CAN1_BASE_ADD + 0x30)    // CAN Interrupt Flag Register 1
    #define CAN1_CTRL2       *(unsigned long *)(CAN1_BASE_ADD + 0x34)    // CAN Control Register 2
    #define CAN1_ESR2        *(volatile unsigned long *)(CAN1_BASE_ADD + 0x38) // CAN Error and Status Register 2

    #define CAN1_CRCR        *(volatile unsigned long *)(CAN1_BASE_ADD + 0x44) // CAN CRC Register
    #define CAN1_RXFGMASK    *(unsigned long *)(CAN1_BASE_ADD + 0x48)    // CAN FIFO Global mask Register
    #define CAN1_RXFIR       *(volatile unsigned long *)(CAN1_BASE_ADD + 0x4c) // CAN FIFI Information Register (read-only)

    #define FLEXCAN1_DBG1    *(unsigned long *)(CAN1_BASE_ADD + 0x58)    // flexcan debug 1 register (read-only)
    #define FLEXCAN1_DBG2    *(unsigned long *)(CAN1_BASE_ADD + 0x5c)    // flexcan debug 2 register (read-only)

    #define MBUFF0_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x80)   // CAN Message Buffer 0 (16 bytes)
    #define MBUFF1_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x90)   // CAN Message Buffer 1 (16 bytes)
    #define MBUFF2_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xa0)   // CAN Message Buffer 2 (16 bytes)
    #define MBUFF3_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xb0)   // CAN Message Buffer 3 (16 bytes)
    #define MBUFF4_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xc0)   // CAN Message Buffer 4 (16 bytes)
    #define MBUFF5_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xd0)   // CAN Message Buffer 5 (16 bytes)
    #define MBUFF6_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xe0)   // CAN Message Buffer 6 (16 bytes)
    #define MBUFF7_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0xf0)   // CAN Message Buffer 7 (16 bytes)
    #define MBUFF8_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x100)  // CAN Message Buffer 8 (16 bytes)
    #define MBUFF9_ADD_1     (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x110)  // CAN Message Buffer 9 (16 bytes)
    #define MBUFF10_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x120)  // CAN Message Buffer 10 (16 bytes)
    #define MBUFF11_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x130)  // CAN Message Buffer 11 (16 bytes)
    #define MBUFF12_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x140)  // CAN Message Buffer 12 (16 bytes)
    #define MBUFF13_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x150)  // CAN Message Buffer 13 (16 bytes)
    #define MBUFF14_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x160)  // CAN Message Buffer 14 (16 bytes)
    #define MBUFF15_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x170)  // CAN Message Buffer 15 (16 bytes)
    #define MBUFF16_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x174)  // CAN Message Buffer 16 (16 bytes)
    #define MBUFF17_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x178)  // CAN Message Buffer 17 (16 bytes)
    #define MBUFF18_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x17c)  // CAN Message Buffer 18 (16 bytes)
    #define MBUFF19_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x180)  // CAN Message Buffer 19 (16 bytes)
    #define MBUFF20_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x184)  // CAN Message Buffer 20 (16 bytes)
    #define MBUFF21_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x188)  // CAN Message Buffer 21 (16 bytes)
    #define MBUFF22_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x18c)  // CAN Message Buffer 22 (16 bytes)
    #define MBUFF23_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x190)  // CAN Message Buffer 23 (16 bytes)
    #define MBUFF24_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x194)  // CAN Message Buffer 24 (16 bytes)
    #define MBUFF25_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x198)  // CAN Message Buffer 25 (16 bytes)
    #define MBUFF26_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x19c)  // CAN Message Buffer 26 (16 bytes)
    #define MBUFF27_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1a0)  // CAN Message Buffer 27 (16 bytes)
    #define MBUFF28_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1a4)  // CAN Message Buffer 28 (16 bytes)
    #define MBUFF29_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1a8)  // CAN Message Buffer 29 (16 bytes)
    #define MBUFF30_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1ac)  // CAN Message Buffer 30 (16 bytes)
    #define MBUFF31_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1b0)  // CAN Message Buffer 31 (16 bytes)
    #define MBUFF32_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1b4)  // CAN Message Buffer 32 (16 bytes)
    #define MBUFF33_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1b8)  // CAN Message Buffer 33 (16 bytes)
    #define MBUFF34_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1bc)  // CAN Message Buffer 34 (16 bytes)
    #define MBUFF35_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1c0)  // CAN Message Buffer 35 (16 bytes)
    #define MBUFF36_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1c4)  // CAN Message Buffer 36 (16 bytes)
    #define MBUFF37_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1c8)  // CAN Message Buffer 37 (16 bytes)
    #define MBUFF38_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1cc)  // CAN Message Buffer 38 (16 bytes)
    #define MBUFF39_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1d0)  // CAN Message Buffer 39 (16 bytes)
    #define MBUFF40_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1d4)  // CAN Message Buffer 40 (16 bytes)
    #define MBUFF41_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1d8)  // CAN Message Buffer 41 (16 bytes)
    #define MBUFF42_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1dc)  // CAN Message Buffer 42 (16 bytes)
    #define MBUFF43_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1e0)  // CAN Message Buffer 43 (16 bytes)
    #define MBUFF44_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1e4)  // CAN Message Buffer 44 (16 bytes)
    #define MBUFF45_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1e8)  // CAN Message Buffer 45 (16 bytes)
    #define MBUFF46_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1ec)  // CAN Message Buffer 46 (16 bytes)
    #define MBUFF47_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1f0)  // CAN Message Buffer 47 (16 bytes)
    #define MBUFF48_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1f4)  // CAN Message Buffer 48 (16 bytes)
    #define MBUFF49_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1f8)  // CAN Message Buffer 49 (16 bytes)
    #define MBUFF50_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x1fc)  // CAN Message Buffer 50 (16 bytes)
    #define MBUFF51_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x200)  // CAN Message Buffer 51 (16 bytes)
    #define MBUFF52_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x204)  // CAN Message Buffer 52 (16 bytes)
    #define MBUFF53_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x208)  // CAN Message Buffer 53 (16 bytes)
    #define MBUFF54_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x20c)  // CAN Message Buffer 54 (16 bytes)
    #define MBUFF55_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x200)  // CAN Message Buffer 55 (16 bytes)
    #define MBUFF56_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x204)  // CAN Message Buffer 56 (16 bytes)
    #define MBUFF57_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x208)  // CAN Message Buffer 57 (16 bytes)
    #define MBUFF58_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x20c)  // CAN Message Buffer 58 (16 bytes)
    #define MBUFF59_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x210)  // CAN Message Buffer 59 (16 bytes)
    #define MBUFF60_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x214)  // CAN Message Buffer 60 (16 bytes)
    #define MBUFF61_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x218)  // CAN Message Buffer 61 (16 bytes)
    #define MBUFF62_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x21c)  // CAN Message Buffer 62 (16 bytes)
    #define MBUFF63_ADD_1    (KINETIS_CAN_BUF *)(CAN1_BASE_ADD + 0x220)  // CAN Message Buffer 63 (16 bytes)

    #define CAN1_RXIMR0      *(unsigned long *)(CAN1_BASE_ADD + 0x880)   // CAN Rx Individual Mask Register 0
    #define CAN1_RXIMR1      *(unsigned long *)(CAN1_BASE_ADD + 0x884)   // CAN Rx Individual Mask Register 1
    #define CAN1_RXIMR2      *(unsigned long *)(CAN1_BASE_ADD + 0x888)   // CAN Rx Individual Mask Register 2
    #define CAN1_RXIMR3      *(unsigned long *)(CAN1_BASE_ADD + 0x88c)   // CAN Rx Individual Mask Register 3
    #define CAN1_RXIMR4      *(unsigned long *)(CAN1_BASE_ADD + 0x890)   // CAN Rx Individual Mask Register 4
    #define CAN1_RXIMR5      *(unsigned long *)(CAN1_BASE_ADD + 0x894)   // CAN Rx Individual Mask Register 5
    #define CAN1_RXIMR6      *(unsigned long *)(CAN1_BASE_ADD + 0x898)   // CAN Rx Individual Mask Register 6
    #define CAN1_RXIMR7      *(unsigned long *)(CAN1_BASE_ADD + 0x89c)   // CAN Rx Individual Mask Register 7
    #define CAN1_RXIMR8      *(unsigned long *)(CAN1_BASE_ADD + 0x8a0)   // CAN Rx Individual Mask Register 8
    #define CAN1_RXIMR9      *(unsigned long *)(CAN1_BASE_ADD + 0x8a4)   // CAN Rx Individual Mask Register 9
    #define CAN1_RXIMR10     *(unsigned long *)(CAN1_BASE_ADD + 0x8a8)   // CAN Rx Individual Mask Register 10
    #define CAN1_RXIMR11     *(unsigned long *)(CAN1_BASE_ADD + 0x8ac)   // CAN Rx Individual Mask Register 11
    #define CAN1_RXIMR12     *(unsigned long *)(CAN1_BASE_ADD + 0x8b0)   // CAN Rx Individual Mask Register 12
    #define CAN1_RXIMR13     *(unsigned long *)(CAN1_BASE_ADD + 0x8b4)   // CAN Rx Individual Mask Register 13
    #define CAN1_RXIMR14     *(unsigned long *)(CAN1_BASE_ADD + 0x8b8)   // CAN Rx Individual Mask Register 14
    #define CAN1_RXIMR15     *(unsigned long *)(CAN1_BASE_ADD + 0x8bc)   // CAN Rx Individual Mask Register 15
    #define CAN1_RXIMR16     *(unsigned long *)(CAN1_BASE_ADD + 0x8c0)   // CAN Rx Individual Mask Register 16
    #define CAN1_RXIMR17     *(unsigned long *)(CAN1_BASE_ADD + 0x8cc)   // CAN Rx Individual Mask Register 17
    #define CAN1_RXIMR18     *(unsigned long *)(CAN1_BASE_ADD + 0x8c8)   // CAN Rx Individual Mask Register 18
    #define CAN1_RXIMR19     *(unsigned long *)(CAN1_BASE_ADD + 0x8cc)   // CAN Rx Individual Mask Register 19
    #define CAN1_RXIMR20     *(unsigned long *)(CAN1_BASE_ADD + 0x8d0)   // CAN Rx Individual Mask Register 20
    #define CAN1_RXIMR21     *(unsigned long *)(CAN1_BASE_ADD + 0x8d4)   // CAN Rx Individual Mask Register 21
    #define CAN1_RXIMR22     *(unsigned long *)(CAN1_BASE_ADD + 0x8d8)   // CAN Rx Individual Mask Register 22
    #define CAN1_RXIMR23     *(unsigned long *)(CAN1_BASE_ADD + 0x8dc)   // CAN Rx Individual Mask Register 23
    #define CAN1_RXIMR24     *(unsigned long *)(CAN1_BASE_ADD + 0x8e0)   // CAN Rx Individual Mask Register 24
    #define CAN1_RXIMR25     *(unsigned long *)(CAN1_BASE_ADD + 0x8e4)   // CAN Rx Individual Mask Register 25
    #define CAN1_RXIMR26     *(unsigned long *)(CAN1_BASE_ADD + 0x8e8)   // CAN Rx Individual Mask Register 26
    #define CAN1_RXIMR27     *(unsigned long *)(CAN1_BASE_ADD + 0x8ec)   // CAN Rx Individual Mask Register 27
    #define CAN1_RXIMR28     *(unsigned long *)(CAN1_BASE_ADD + 0x8f0)   // CAN Rx Individual Mask Register 28
    #define CAN1_RXIMR29     *(unsigned long *)(CAN1_BASE_ADD + 0x8f4)   // CAN Rx Individual Mask Register 29
    #define CAN1_RXIMR30     *(unsigned long *)(CAN1_BASE_ADD + 0x8f8)   // CAN Rx Individual Mask Register 30
    #define CAN1_RXIMR31     *(unsigned long *)(CAN1_BASE_ADD + 0x8fc)   // CAN Rx Individual Mask Register 31
    #define CAN1_RXIMR32     *(unsigned long *)(CAN1_BASE_ADD + 0x900)   // CAN Rx Individual Mask Register 32
    #define CAN1_RXIMR33     *(unsigned long *)(CAN1_BASE_ADD + 0x904)   // CAN Rx Individual Mask Register 33
    #define CAN1_RXIMR34     *(unsigned long *)(CAN1_BASE_ADD + 0x908)   // CAN Rx Individual Mask Register 34
    #define CAN1_RXIMR35     *(unsigned long *)(CAN1_BASE_ADD + 0x90c)   // CAN Rx Individual Mask Register 35
    #define CAN1_RXIMR36     *(unsigned long *)(CAN1_BASE_ADD + 0x910)   // CAN Rx Individual Mask Register 36
    #define CAN1_RXIMR37     *(unsigned long *)(CAN1_BASE_ADD + 0x914)   // CAN Rx Individual Mask Register 37
    #define CAN1_RXIMR38     *(unsigned long *)(CAN1_BASE_ADD + 0x918)   // CAN Rx Individual Mask Register 38
    #define CAN1_RXIMR39     *(unsigned long *)(CAN1_BASE_ADD + 0x91c)   // CAN Rx Individual Mask Register 39
    #define CAN1_RXIMR40     *(unsigned long *)(CAN1_BASE_ADD + 0x920)   // CAN Rx Individual Mask Register 40
    #define CAN1_RXIMR41     *(unsigned long *)(CAN1_BASE_ADD + 0x924)   // CAN Rx Individual Mask Register 41
    #define CAN1_RXIMR42     *(unsigned long *)(CAN1_BASE_ADD + 0x928)   // CAN Rx Individual Mask Register 42
    #define CAN1_RXIMR43     *(unsigned long *)(CAN1_BASE_ADD + 0x92c)   // CAN Rx Individual Mask Register 43
    #define CAN1_RXIMR44     *(unsigned long *)(CAN1_BASE_ADD + 0x930)   // CAN Rx Individual Mask Register 44
    #define CAN1_RXIMR45     *(unsigned long *)(CAN1_BASE_ADD + 0x934)   // CAN Rx Individual Mask Register 45
    #define CAN1_RXIMR46     *(unsigned long *)(CAN1_BASE_ADD + 0x938)   // CAN Rx Individual Mask Register 46
    #define CAN1_RXIMR47     *(unsigned long *)(CAN1_BASE_ADD + 0x93c)   // CAN Rx Individual Mask Register 47
    #define CAN1_RXIMR48     *(unsigned long *)(CAN1_BASE_ADD + 0x940)   // CAN Rx Individual Mask Register 48
    #define CAN1_RXIMR49     *(unsigned long *)(CAN1_BASE_ADD + 0x94c)   // CAN Rx Individual Mask Register 49
    #define CAN1_RXIMR50     *(unsigned long *)(CAN1_BASE_ADD + 0x948)   // CAN Rx Individual Mask Register 50
    #define CAN1_RXIMR51     *(unsigned long *)(CAN1_BASE_ADD + 0x94c)   // CAN Rx Individual Mask Register 51
    #define CAN1_RXIMR52     *(unsigned long *)(CAN1_BASE_ADD + 0x950)   // CAN Rx Individual Mask Register 52
    #define CAN1_RXIMR53     *(unsigned long *)(CAN1_BASE_ADD + 0x954)   // CAN Rx Individual Mask Register 53
    #define CAN1_RXIMR54     *(unsigned long *)(CAN1_BASE_ADD + 0x958)   // CAN Rx Individual Mask Register 54
    #define CAN1_RXIMR55     *(unsigned long *)(CAN1_BASE_ADD + 0x95c)   // CAN Rx Individual Mask Register 55
    #define CAN1_RXIMR56     *(unsigned long *)(CAN1_BASE_ADD + 0x960)   // CAN Rx Individual Mask Register 56
    #define CAN1_RXIMR57     *(unsigned long *)(CAN1_BASE_ADD + 0x964)   // CAN Rx Individual Mask Register 57
    #define CAN1_RXIMR58     *(unsigned long *)(CAN1_BASE_ADD + 0x968)   // CAN Rx Individual Mask Register 58
    #define CAN1_RXIMR59     *(unsigned long *)(CAN1_BASE_ADD + 0x96c)   // CAN Rx Individual Mask Register 59
    #define CAN1_RXIMR60     *(unsigned long *)(CAN1_BASE_ADD + 0x970)   // CAN Rx Individual Mask Register 60
    #define CAN1_RXIMR61     *(unsigned long *)(CAN1_BASE_ADD + 0x974)   // CAN Rx Individual Mask Register 61
    #define CAN1_RXIMR62     *(unsigned long *)(CAN1_BASE_ADD + 0x978)   // CAN Rx Individual Mask Register 62
    #define CAN1_RXIMR63     *(unsigned long *)(CAN1_BASE_ADD + 0x97c)   // CAN Rx Individual Mask Register 63

    #define CAN1_GFWR        *(unsigned long *)(CAN1_BASE_ADD + 0x9e0)   // CAN glitch filter width register
#endif

#if NUMBER_OF_CAN_INTERFACES > 2
    #define CAN2_MCR         *(volatile unsigned long *)(CAN2_BASE_ADD + 0x0) // CAN Module Configuration Register (supervisor only)
    #define CAN2_CTRL1       *(volatile unsigned long *)(CAN2_BASE_ADD + 0x4) // CAN Control Register 1
    #define CAN2_TIMER       *(volatile unsigned long *)(CAN2_BASE_ADD + 0x8) // CAN Free running timer
    #define CAN2_RXGMASK     *(unsigned long *)(CAN2_BASE_ADD + 0x10)    // CAN Rx Global mask
    #define CAN2_RX14MASK    *(unsigned long *)(CAN2_BASE_ADD + 0x14)    // CAN Rx Buffer 14 mask
    #define CAN2_RX15MASK    *(unsigned long *)(CAN2_BASE_ADD + 0x18)    // CAN Rx Buffer 15 mask
    #define CAN2_ECR         *(volatile unsigned long *)(CAN2_BASE_ADD + 0x1c) // CAN Error Counter Register
    #define CAN2_ESR1        *(volatile unsigned long *)(CAN2_BASE_ADD + 0x20) // CAN Error and Status 1 Register
    #define CAN2_IMASK2      *(unsigned long *)(CAN2_BASE_ADD + 0x24)    // CAN Interrupt Mask Register 2
    #define CAN2_IMASK1      *(unsigned long *)(CAN2_BASE_ADD + 0x28)    // CAN Interrupt Mask Register 1
    #define CAN2_IFLAG2      *(unsigned long *)(CAN2_BASE_ADD + 0x2c)    // CAN Interrupt Flag Register 1
    #define CAN2_IFLAG1      *(unsigned long *)(CAN2_BASE_ADD + 0x30)    // CAN Interrupt Flag Register 1
    #define CAN2_CTRL2       *(unsigned long *)(CAN2_BASE_ADD + 0x34)    // CAN Control Register 2
    #define CAN2_ESR2        *(volatile unsigned long *)(CAN2_BASE_ADD + 0x38) // CAN Error and Status Register 2

    #define CAN2_CRCR        *(volatile unsigned long *)(CAN2_BASE_ADD + 0x44) // CAN CRC Register
    #define CAN2_RXFGMASK    *(unsigned long *)(CAN2_BASE_ADD + 0x48)    // CAN FIFO Global mask Register
    #define CAN2_RXFIR       *(volatile unsigned long *)(CAN2_BASE_ADD + 0x4c) // CAN FIFI Information Register (read-only)

    #define FLEXCAN2_DBG1    *(unsigned long *)(CAN2_BASE_ADD + 0x58)    // flexcan debug 1 register (read-only)
    #define FLEXCAN2_DBG2    *(unsigned long *)(CAN2_BASE_ADD + 0x5c)    // flexcan debug 2 register (read-only)

    #define MBUFF0_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x80)   // CAN Message Buffer 0 (16 bytes)
    #define MBUFF1_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x90)   // CAN Message Buffer 1 (16 bytes)
    #define MBUFF2_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0xa0)   // CAN Message Buffer 2 (16 bytes)
    #define MBUFF3_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0xb0)   // CAN Message Buffer 3 (16 bytes)
    #define MBUFF4_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0xc0)   // CAN Message Buffer 4 (16 bytes)
    #define MBUFF5_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0xd0)   // CAN Message Buffer 5 (16 bytes)
    #define MBUFF6_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0xe0)   // CAN Message Buffer 6 (16 bytes)
    #define MBUFF7_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0xf0)   // CAN Message Buffer 7 (16 bytes)
    #define MBUFF8_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x100)  // CAN Message Buffer 8 (16 bytes)
    #define MBUFF9_ADD_2     (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x110)  // CAN Message Buffer 9 (16 bytes)
    #define MBUFF10_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x120)  // CAN Message Buffer 10 (16 bytes)
    #define MBUFF11_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x130)  // CAN Message Buffer 11 (16 bytes)
    #define MBUFF12_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x140)  // CAN Message Buffer 12 (16 bytes)
    #define MBUFF13_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x150)  // CAN Message Buffer 13 (16 bytes)
    #define MBUFF14_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x160)  // CAN Message Buffer 14 (16 bytes)
    #define MBUFF15_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x170)  // CAN Message Buffer 15 (16 bytes)
    #define MBUFF16_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x174)  // CAN Message Buffer 16 (16 bytes)
    #define MBUFF17_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x178)  // CAN Message Buffer 17 (16 bytes)
    #define MBUFF18_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x17c)  // CAN Message Buffer 18 (16 bytes)
    #define MBUFF19_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x180)  // CAN Message Buffer 19 (16 bytes)
    #define MBUFF20_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x184)  // CAN Message Buffer 20 (16 bytes)
    #define MBUFF21_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x188)  // CAN Message Buffer 21 (16 bytes)
    #define MBUFF22_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x18c)  // CAN Message Buffer 22 (16 bytes)
    #define MBUFF23_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x190)  // CAN Message Buffer 23 (16 bytes)
    #define MBUFF24_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x194)  // CAN Message Buffer 24 (16 bytes)
    #define MBUFF25_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x198)  // CAN Message Buffer 25 (16 bytes)
    #define MBUFF26_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x19c)  // CAN Message Buffer 26 (16 bytes)
    #define MBUFF27_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1a0)  // CAN Message Buffer 27 (16 bytes)
    #define MBUFF28_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1a4)  // CAN Message Buffer 28 (16 bytes)
    #define MBUFF29_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1a8)  // CAN Message Buffer 29 (16 bytes)
    #define MBUFF30_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1ac)  // CAN Message Buffer 30 (16 bytes)
    #define MBUFF31_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1b0)  // CAN Message Buffer 31 (16 bytes)
    #define MBUFF32_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1b4)  // CAN Message Buffer 32 (16 bytes)
    #define MBUFF33_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1b8)  // CAN Message Buffer 33 (16 bytes)
    #define MBUFF34_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1bc)  // CAN Message Buffer 34 (16 bytes)
    #define MBUFF35_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1c0)  // CAN Message Buffer 35 (16 bytes)
    #define MBUFF36_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1c4)  // CAN Message Buffer 36 (16 bytes)
    #define MBUFF37_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1c8)  // CAN Message Buffer 37 (16 bytes)
    #define MBUFF38_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1cc)  // CAN Message Buffer 38 (16 bytes)
    #define MBUFF39_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1d0)  // CAN Message Buffer 39 (16 bytes)
    #define MBUFF40_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1d4)  // CAN Message Buffer 40 (16 bytes)
    #define MBUFF41_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1d8)  // CAN Message Buffer 41 (16 bytes)
    #define MBUFF42_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1dc)  // CAN Message Buffer 42 (16 bytes)
    #define MBUFF43_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1e0)  // CAN Message Buffer 43 (16 bytes)
    #define MBUFF44_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1e4)  // CAN Message Buffer 44 (16 bytes)
    #define MBUFF45_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1e8)  // CAN Message Buffer 45 (16 bytes)
    #define MBUFF46_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1ec)  // CAN Message Buffer 46 (16 bytes)
    #define MBUFF47_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1f0)  // CAN Message Buffer 47 (16 bytes)
    #define MBUFF48_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1f4)  // CAN Message Buffer 48 (16 bytes)
    #define MBUFF49_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1f8)  // CAN Message Buffer 49 (16 bytes)
    #define MBUFF50_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x1fc)  // CAN Message Buffer 50 (16 bytes)
    #define MBUFF51_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x200)  // CAN Message Buffer 51 (16 bytes)
    #define MBUFF52_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x204)  // CAN Message Buffer 52 (16 bytes)
    #define MBUFF53_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x208)  // CAN Message Buffer 53 (16 bytes)
    #define MBUFF54_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x20c)  // CAN Message Buffer 54 (16 bytes)
    #define MBUFF55_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x200)  // CAN Message Buffer 55 (16 bytes)
    #define MBUFF56_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x204)  // CAN Message Buffer 56 (16 bytes)
    #define MBUFF57_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x208)  // CAN Message Buffer 57 (16 bytes)
    #define MBUFF58_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x20c)  // CAN Message Buffer 58 (16 bytes)
    #define MBUFF59_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x210)  // CAN Message Buffer 59 (16 bytes)
    #define MBUFF60_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x214)  // CAN Message Buffer 60 (16 bytes)
    #define MBUFF61_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x218)  // CAN Message Buffer 61 (16 bytes)
    #define MBUFF62_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x21c)  // CAN Message Buffer 62 (16 bytes)
    #define MBUFF63_ADD_2    (KINETIS_CAN_BUF *)(CAN2_BASE_ADD + 0x220)  // CAN Message Buffer 63 (16 bytes)

    #define CAN2_RXIMR0      *(unsigned long *)(CAN2_BASE_ADD + 0x880)   // CAN Rx Individual Mask Register 0
    #define CAN2_RXIMR1      *(unsigned long *)(CAN2_BASE_ADD + 0x884)   // CAN Rx Individual Mask Register 1
    #define CAN2_RXIMR2      *(unsigned long *)(CAN2_BASE_ADD + 0x888)   // CAN Rx Individual Mask Register 2
    #define CAN2_RXIMR3      *(unsigned long *)(CAN2_BASE_ADD + 0x88c)   // CAN Rx Individual Mask Register 3
    #define CAN2_RXIMR4      *(unsigned long *)(CAN2_BASE_ADD + 0x890)   // CAN Rx Individual Mask Register 4
    #define CAN2_RXIMR5      *(unsigned long *)(CAN2_BASE_ADD + 0x894)   // CAN Rx Individual Mask Register 5
    #define CAN2_RXIMR6      *(unsigned long *)(CAN2_BASE_ADD + 0x898)   // CAN Rx Individual Mask Register 6
    #define CAN2_RXIMR7      *(unsigned long *)(CAN2_BASE_ADD + 0x89c)   // CAN Rx Individual Mask Register 7
    #define CAN2_RXIMR8      *(unsigned long *)(CAN2_BASE_ADD + 0x8a0)   // CAN Rx Individual Mask Register 8
    #define CAN2_RXIMR9      *(unsigned long *)(CAN2_BASE_ADD + 0x8a4)   // CAN Rx Individual Mask Register 9
    #define CAN2_RXIMR10     *(unsigned long *)(CAN2_BASE_ADD + 0x8a8)   // CAN Rx Individual Mask Register 10
    #define CAN2_RXIMR11     *(unsigned long *)(CAN2_BASE_ADD + 0x8ac)   // CAN Rx Individual Mask Register 11
    #define CAN2_RXIMR12     *(unsigned long *)(CAN2_BASE_ADD + 0x8b0)   // CAN Rx Individual Mask Register 12
    #define CAN2_RXIMR13     *(unsigned long *)(CAN2_BASE_ADD + 0x8b4)   // CAN Rx Individual Mask Register 13
    #define CAN2_RXIMR14     *(unsigned long *)(CAN2_BASE_ADD + 0x8b8)   // CAN Rx Individual Mask Register 14
    #define CAN2_RXIMR15     *(unsigned long *)(CAN2_BASE_ADD + 0x8bc)   // CAN Rx Individual Mask Register 15
    #define CAN2_RXIMR16     *(unsigned long *)(CAN2_BASE_ADD + 0x8c0)   // CAN Rx Individual Mask Register 16
    #define CAN2_RXIMR17     *(unsigned long *)(CAN2_BASE_ADD + 0x8cc)   // CAN Rx Individual Mask Register 17
    #define CAN2_RXIMR18     *(unsigned long *)(CAN2_BASE_ADD + 0x8c8)   // CAN Rx Individual Mask Register 18
    #define CAN2_RXIMR19     *(unsigned long *)(CAN2_BASE_ADD + 0x8cc)   // CAN Rx Individual Mask Register 19
    #define CAN2_RXIMR20     *(unsigned long *)(CAN2_BASE_ADD + 0x8d0)   // CAN Rx Individual Mask Register 20
    #define CAN2_RXIMR21     *(unsigned long *)(CAN2_BASE_ADD + 0x8d4)   // CAN Rx Individual Mask Register 21
    #define CAN2_RXIMR22     *(unsigned long *)(CAN2_BASE_ADD + 0x8d8)   // CAN Rx Individual Mask Register 22
    #define CAN2_RXIMR23     *(unsigned long *)(CAN2_BASE_ADD + 0x8dc)   // CAN Rx Individual Mask Register 23
    #define CAN2_RXIMR24     *(unsigned long *)(CAN2_BASE_ADD + 0x8e0)   // CAN Rx Individual Mask Register 24
    #define CAN2_RXIMR25     *(unsigned long *)(CAN2_BASE_ADD + 0x8e4)   // CAN Rx Individual Mask Register 25
    #define CAN2_RXIMR26     *(unsigned long *)(CAN2_BASE_ADD + 0x8e8)   // CAN Rx Individual Mask Register 26
    #define CAN2_RXIMR27     *(unsigned long *)(CAN2_BASE_ADD + 0x8ec)   // CAN Rx Individual Mask Register 27
    #define CAN2_RXIMR28     *(unsigned long *)(CAN2_BASE_ADD + 0x8f0)   // CAN Rx Individual Mask Register 28
    #define CAN2_RXIMR29     *(unsigned long *)(CAN2_BASE_ADD + 0x8f4)   // CAN Rx Individual Mask Register 29
    #define CAN2_RXIMR30     *(unsigned long *)(CAN2_BASE_ADD + 0x8f8)   // CAN Rx Individual Mask Register 30
    #define CAN2_RXIMR31     *(unsigned long *)(CAN2_BASE_ADD + 0x8fc)   // CAN Rx Individual Mask Register 31
    #define CAN2_RXIMR32     *(unsigned long *)(CAN2_BASE_ADD + 0x900)   // CAN Rx Individual Mask Register 32
    #define CAN2_RXIMR33     *(unsigned long *)(CAN2_BASE_ADD + 0x904)   // CAN Rx Individual Mask Register 33
    #define CAN2_RXIMR34     *(unsigned long *)(CAN2_BASE_ADD + 0x908)   // CAN Rx Individual Mask Register 34
    #define CAN2_RXIMR35     *(unsigned long *)(CAN2_BASE_ADD + 0x90c)   // CAN Rx Individual Mask Register 35
    #define CAN2_RXIMR36     *(unsigned long *)(CAN2_BASE_ADD + 0x910)   // CAN Rx Individual Mask Register 36
    #define CAN2_RXIMR37     *(unsigned long *)(CAN2_BASE_ADD + 0x914)   // CAN Rx Individual Mask Register 37
    #define CAN2_RXIMR38     *(unsigned long *)(CAN2_BASE_ADD + 0x918)   // CAN Rx Individual Mask Register 38
    #define CAN2_RXIMR39     *(unsigned long *)(CAN2_BASE_ADD + 0x91c)   // CAN Rx Individual Mask Register 39
    #define CAN2_RXIMR40     *(unsigned long *)(CAN2_BASE_ADD + 0x920)   // CAN Rx Individual Mask Register 40
    #define CAN2_RXIMR41     *(unsigned long *)(CAN2_BASE_ADD + 0x924)   // CAN Rx Individual Mask Register 41
    #define CAN2_RXIMR42     *(unsigned long *)(CAN2_BASE_ADD + 0x928)   // CAN Rx Individual Mask Register 42
    #define CAN2_RXIMR43     *(unsigned long *)(CAN2_BASE_ADD + 0x92c)   // CAN Rx Individual Mask Register 43
    #define CAN2_RXIMR44     *(unsigned long *)(CAN2_BASE_ADD + 0x930)   // CAN Rx Individual Mask Register 44
    #define CAN2_RXIMR45     *(unsigned long *)(CAN2_BASE_ADD + 0x934)   // CAN Rx Individual Mask Register 45
    #define CAN2_RXIMR46     *(unsigned long *)(CAN2_BASE_ADD + 0x938)   // CAN Rx Individual Mask Register 46
    #define CAN2_RXIMR47     *(unsigned long *)(CAN2_BASE_ADD + 0x93c)   // CAN Rx Individual Mask Register 47
    #define CAN2_RXIMR48     *(unsigned long *)(CAN2_BASE_ADD + 0x940)   // CAN Rx Individual Mask Register 48
    #define CAN2_RXIMR49     *(unsigned long *)(CAN2_BASE_ADD + 0x94c)   // CAN Rx Individual Mask Register 49
    #define CAN2_RXIMR50     *(unsigned long *)(CAN2_BASE_ADD + 0x948)   // CAN Rx Individual Mask Register 50
    #define CAN2_RXIMR51     *(unsigned long *)(CAN2_BASE_ADD + 0x94c)   // CAN Rx Individual Mask Register 51
    #define CAN2_RXIMR52     *(unsigned long *)(CAN2_BASE_ADD + 0x950)   // CAN Rx Individual Mask Register 52
    #define CAN2_RXIMR53     *(unsigned long *)(CAN2_BASE_ADD + 0x954)   // CAN Rx Individual Mask Register 53
    #define CAN2_RXIMR54     *(unsigned long *)(CAN2_BASE_ADD + 0x958)   // CAN Rx Individual Mask Register 54
    #define CAN2_RXIMR55     *(unsigned long *)(CAN2_BASE_ADD + 0x95c)   // CAN Rx Individual Mask Register 55
    #define CAN2_RXIMR56     *(unsigned long *)(CAN2_BASE_ADD + 0x960)   // CAN Rx Individual Mask Register 56
    #define CAN2_RXIMR57     *(unsigned long *)(CAN2_BASE_ADD + 0x964)   // CAN Rx Individual Mask Register 57
    #define CAN2_RXIMR58     *(unsigned long *)(CAN2_BASE_ADD + 0x968)   // CAN Rx Individual Mask Register 58
    #define CAN2_RXIMR59     *(unsigned long *)(CAN2_BASE_ADD + 0x96c)   // CAN Rx Individual Mask Register 59
    #define CAN2_RXIMR60     *(unsigned long *)(CAN2_BASE_ADD + 0x970)   // CAN Rx Individual Mask Register 60
    #define CAN2_RXIMR61     *(unsigned long *)(CAN2_BASE_ADD + 0x974)   // CAN Rx Individual Mask Register 61
    #define CAN2_RXIMR62     *(unsigned long *)(CAN2_BASE_ADD + 0x978)   // CAN Rx Individual Mask Register 62
    #define CAN2_RXIMR63     *(unsigned long *)(CAN2_BASE_ADD + 0x97c)   // CAN Rx Individual Mask Register 63

    #define CAN2_GFWR        *(unsigned long *)(CAN2_BASE_ADD + 0x9e0)   // CAN glitch filter width register
#endif

#define NUMBER_CAN_MESSAGE_BUFFERS 64                                    // each CAN controller has 64 message buffers that can be used as either tx or rx mailboxes


typedef struct stKINETIS_CAN_CONTROL
{
    volatile unsigned long CAN_MCR;
    volatile unsigned long CAN_CTRL1;
    volatile unsigned long CAN_TIMER;
    unsigned long res0;
    volatile unsigned long CAN_RXGMASK;
    volatile unsigned long CAN_RX14MASK;
    volatile unsigned long CAN_RX15MASK;
    volatile unsigned long CAN_ECR;
    volatile unsigned long CAN_ESR1;
    unsigned long CAN_IMASK2;
    unsigned long CAN_IMASK1;
    volatile unsigned long CAN_IFLAG2;
    volatile unsigned long CAN_IFLAG1;
    unsigned long CAN_CTRL2;
    volatile unsigned long CAN_ESR2;
    unsigned long res1[2];
    volatile unsigned long CAN_CRCR;
    unsigned long CAN_RXFGMASK;
    volatile unsigned long CAN_RXFIR; // 0x4c
    unsigned long res2[12];
    KINETIS_CAN_BUF CAN_MBUFF0;
    KINETIS_CAN_BUF CAN_MBUFF1;
    KINETIS_CAN_BUF CAN_MBUFF2;
    KINETIS_CAN_BUF CAN_MBUFF3;
    KINETIS_CAN_BUF CAN_MBUFF4;
    KINETIS_CAN_BUF CAN_MBUFF5;
    KINETIS_CAN_BUF CAN_MBUFF6;
    KINETIS_CAN_BUF CAN_MBUFF7;
    KINETIS_CAN_BUF CAN_MBUFF8;
    KINETIS_CAN_BUF CAN_MBUFF9;
    KINETIS_CAN_BUF CAN_MBUFF10;
    KINETIS_CAN_BUF CAN_MBUFF11;
    KINETIS_CAN_BUF CAN_MBUFF12;
    KINETIS_CAN_BUF CAN_MBUFF13;
    KINETIS_CAN_BUF CAN_MBUFF14;
    KINETIS_CAN_BUF CAN_MBUFF15;
    KINETIS_CAN_BUF CAN_MBUFF16;
    KINETIS_CAN_BUF CAN_MBUFF17;
    KINETIS_CAN_BUF CAN_MBUFF18;
    KINETIS_CAN_BUF CAN_MBUFF19;
    KINETIS_CAN_BUF CAN_MBUFF20;
    KINETIS_CAN_BUF CAN_MBUFF21;
    KINETIS_CAN_BUF CAN_MBUFF22;
    KINETIS_CAN_BUF CAN_MBUFF23;
    KINETIS_CAN_BUF CAN_MBUFF24;
    KINETIS_CAN_BUF CAN_MBUFF25;
    KINETIS_CAN_BUF CAN_MBUFF26;
    KINETIS_CAN_BUF CAN_MBUFF27;
    KINETIS_CAN_BUF CAN_MBUFF28;
    KINETIS_CAN_BUF CAN_MBUFF29;
    KINETIS_CAN_BUF CAN_MBUFF30;
    KINETIS_CAN_BUF CAN_MBUFF31;
    KINETIS_CAN_BUF CAN_MBUFF32;
    KINETIS_CAN_BUF CAN_MBUFF33;
    KINETIS_CAN_BUF CAN_MBUFF34;
    KINETIS_CAN_BUF CAN_MBUFF35;
    KINETIS_CAN_BUF CAN_MBUFF36;
    KINETIS_CAN_BUF CAN_MBUFF37;
    KINETIS_CAN_BUF CAN_MBUFF38;
    KINETIS_CAN_BUF CAN_MBUFF39;
    KINETIS_CAN_BUF CAN_MBUFF40;
    KINETIS_CAN_BUF CAN_MBUFF41;
    KINETIS_CAN_BUF CAN_MBUFF42;
    KINETIS_CAN_BUF CAN_MBUFF43;
    KINETIS_CAN_BUF CAN_MBUFF44;
    KINETIS_CAN_BUF CAN_MBUFF45;
    KINETIS_CAN_BUF CAN_MBUFF46;
    KINETIS_CAN_BUF CAN_MBUFF47;
    KINETIS_CAN_BUF CAN_MBUFF48;
    KINETIS_CAN_BUF CAN_MBUFF49;
    KINETIS_CAN_BUF CAN_MBUFF50;
    KINETIS_CAN_BUF CAN_MBUFF51;
    KINETIS_CAN_BUF CAN_MBUFF52;
    KINETIS_CAN_BUF CAN_MBUFF53;
    KINETIS_CAN_BUF CAN_MBUFF54;
    KINETIS_CAN_BUF CAN_MBUFF55;
    KINETIS_CAN_BUF CAN_MBUFF56;
    KINETIS_CAN_BUF CAN_MBUFF57;
    KINETIS_CAN_BUF CAN_MBUFF58;
    KINETIS_CAN_BUF CAN_MBUFF59;
    KINETIS_CAN_BUF CAN_MBUFF60;
    KINETIS_CAN_BUF CAN_MBUFF61;
    KINETIS_CAN_BUF CAN_MBUFF62;
    KINETIS_CAN_BUF CAN_MBUFF63;
    unsigned long res3[256];
    unsigned long CAN_RXIMR0;
    unsigned long CAN_RXIMR1;
    unsigned long CAN_RXIMR2;
    unsigned long CAN_RXIMR3;
    unsigned long CAN_RXIMR4;
    unsigned long CAN_RXIMR5;
    unsigned long CAN_RXIMR6;
    unsigned long CAN_RXIMR7;
    unsigned long CAN_RXIMR8;
    unsigned long CAN_RXIMR9;
    unsigned long CAN_RXIMR10;
    unsigned long CAN_RXIMR11;
    unsigned long CAN_RXIMR12;
    unsigned long CAN_RXIMR13;
    unsigned long CAN_RXIMR14;
    unsigned long CAN_RXIMR15;
    unsigned long CAN_RXIMR16;
    unsigned long CAN_RXIMR17;
    unsigned long CAN_RXIMR18;
    unsigned long CAN_RXIMR19;
    unsigned long CAN_RXIMR20;
    unsigned long CAN_RXIMR21;
    unsigned long CAN_RXIMR22;
    unsigned long CAN_RXIMR23;
    unsigned long CAN_RXIMR24;
    unsigned long CAN_RXIMR25;
    unsigned long CAN_RXIMR26;
    unsigned long CAN_RXIMR27;
    unsigned long CAN_RXIMR28;
    unsigned long CAN_RXIMR29;
    unsigned long CAN_RXIMR30;
    unsigned long CAN_RXIMR31;
    unsigned long CAN_RXIMR32;
    unsigned long CAN_RXIMR33;
    unsigned long CAN_RXIMR34;
    unsigned long CAN_RXIMR35;
    unsigned long CAN_RXIMR36;
    unsigned long CAN_RXIMR37;
    unsigned long CAN_RXIMR38;
    unsigned long CAN_RXIMR39;
    unsigned long CAN_RXIMR40;
    unsigned long CAN_RXIMR41;
    unsigned long CAN_RXIMR42;
    unsigned long CAN_RXIMR43;
    unsigned long CAN_RXIMR44;
    unsigned long CAN_RXIMR45;
    unsigned long CAN_RXIMR46;
    unsigned long CAN_RXIMR47;
    unsigned long CAN_RXIMR48;
    unsigned long CAN_RXIMR49;
    unsigned long CAN_RXIMR50;
    unsigned long CAN_RXIMR51;
    unsigned long CAN_RXIMR52;
    unsigned long CAN_RXIMR53;
    unsigned long CAN_RXIMR54;
    unsigned long CAN_RXIMR55;
    unsigned long CAN_RXIMR56;
    unsigned long CAN_RXIMR57;
    unsigned long CAN_RXIMR58;
    unsigned long CAN_RXIMR59;
    unsigned long CAN_RXIMR60;
    unsigned long CAN_RXIMR61;
    unsigned long CAN_RXIMR62;
    unsigned long CAN_RXIMR63;
} KINETIS_CAN_CONTROL;


// LPUARTs
//
#if LPUARTS_AVAILABLE > 0                                                // low power UART
    #define LPUART0_VERID                *(volatile unsigned long *)(LPUART0_BLOCK + 0x00) // LPUART 0 version ID register (read-only)
    #define LPUART0_PARAM                *(volatile unsigned long *)(LPUART0_BLOCK + 0x04) // LPUART 0 parameter register (read-only)
    #define LPUART0_GLOBAL               *(unsigned long *)(LPUART0_BLOCK + 0x08) // LPUART 0 global register
        #define LPUART_GLOBAL_RST        0x00000002                      // module in reset state
    #define LPUART0_PINCFG               *(unsigned long *)(LPUART0_BLOCK + 0x0c) // LPUART 0 pin configuration register
        #define LPUART_PINCFG_TRGSEL_NONE 0x00000000                     // no input trigger
        #define LPUART_PINCFG_TRGSEL_RXD  0x00000001                     // input trigger is used instead of RXD pin input
        #define LPUART_PINCFG_TRGSEL_CTS  0x00000002                     // input trigger is used instead of CTS pin input
        #define LPUART_PINCFG_TRGSEL_TXDE 0x00000003                     // input trigger is used to modulate the TXD pin output
    #define LPUART0_BAUD                 *(unsigned long *)(LPUART0_BLOCK + 0x10) // LPUART 0 baud rate register
        #define LPUART_BAUD_SBR          0x00001fff                      // baud rate modulo divisor mask
        #define LPUART_BAUD_SBNS_1       0x00000000                      // 1 stop bits
        #define LPUART_BAUD_SBNS_2       0x00002000                      // 2 stop bits
        #define LPUART_BAUD_RXEDGIE      0x00004000                      // RX input active edge interrupt enable
        #define LPUART_BAUD_LBKDIE       0x00008000                      // LIN break detect interrupt enable
        #define LPUART_BAUD_RESYNCDIS    0x00010000                      // resynchronisation disable
        #define LPUART_BAUD_BOTHEDGE     0x00020000                      // both edge sampling
        #define LPUART_BAUD_MATCFG_ADDR  0x00000000
        #define LPUART_BAUD_MATCFG_IDLE  0x00040000
        #define LPUART_BAUD_MATCFG_ON_OFF 0x00080000
        #define LPUART_BAUD_MATCFG_CTS   0x000c0000
        #define LPUART_BAUD_RIDMAE       0x00100000                      // receiver idle DMA enable (data register returns 0x000033ff and does not pull data from the FIFO)
        #define LPUART_BAUD_RDMAE        0x00200000                      // receiver DMA enable
        #define LPUART_BAUD_TDMAE        0x00800000                      // transmitter DMA enable
        #define LPUART_BAUD_OSR_4        0x03000000                      // over sampling ratio x4 (change only when rx and tx are disabled) - requires BOTHEDGE to be used
        #define LPUART_BAUD_OSR_5        0x04000000                      // over sampling ratio x5 - requires BOTHEDGE to be used
        #define LPUART_BAUD_OSR_6        0x05000000                      // over sampling ratio x6 - requires BOTHEDGE to be used
        #define LPUART_BAUD_OSR_7        0x06000000                      // over sampling ratio x7 - requires BOTHEDGE to be used
        #define LPUART_BAUD_OSR_8        0x07000000                      // over sampling ratio x8
        #define LPUART_BAUD_OSR_16       0x0f000000                      // over sampling ratio x16
        #define LPUART_BAUD_OSR_32       0x1f000000                      // over sampling ratio x32
        #define LPUART_BAUD_M10          0x20000000                      // 10-bit mode select
        #define LPUART_BAUD_MAEN2        0x40000000                      // match address mode enable 2
        #define LPUART_BAUD_MAEN1        0x80000000                      // match address mode enable 1
    #define LPUART0_STAT                 *(volatile unsigned long *)(LPUART0_BLOCK + 0x14) // LPUART 0 Status Register
        #define LPUART_STAT_MA2F         0x00004000                      // match 2 flag (write '1' to clear)
        #define LPUART_STAT_MA1F         0x00008000                      // match 1 flag (write '1' to clear)
        #define LPUART_STAT_PF           0x00010000                      // parity error flag (write '1' to clear)
        #define LPUART_STAT_FE           0x00020000                      // framing error flag (write '1' to clear)
        #define LPUART_STAT_NF           0x00040000                      // noise flag (write '1' to clear)
        #define LPUART_STAT_OR           0x00080000                      // receiver overrun flag (write '1' to clear)
        #define LPUART_STAT_IDLE         0x00100000                      // idle line flag (write '1' to clear)
        #define LPUART_STAT_RDRF         0x00200000                      // receive data register full flag (read-only)
        #define LPUART_STAT_TC           0x00400000                      // transmission complete flag (read-only)
        #define LPUART_STAT_TDRE         0x00800000                      // transmit data register empty flag (read-only)
        #define LPUART_STAT_RAF          0x01000000                      // receive active flag (read-only)
        #define LPUART_STAT_LBKDE        0x02000000                      // LIN break detection enable
        #define LPUART_STAT_BRK13        0x04000000                      // break character generation length
        #define LPUART_STAT_RWUID        0x08000000                      // receive wakeup idle detect
        #define LPUART_STAT_RXINV        0x10000000                      // receive data inversion
        #define LPUART_STAT_MSBF         0x20000000                      // MSB first
        #define LPUART_STAT_RXEDGIF      0x40000000                      // LPUART_RX pin active edge interrupt flag (write '1' to clear)
        #define LPUART_STAT_LBKDIF       0x80000000                      // LIN break detect interrupt flag (write '1' to clear)
    #define LPUART0_CTRL_ADD             (unsigned long *)(LPUART0_BLOCK + 0x18)
    #define LPUART0_CTRL                 *(volatile unsigned long *)(LPUART0_BLOCK + 0x18) // LPUART 0 Control Register
        #define LPUART_CTRL_PT_EVEN      0x00000000                      // parity even
        #define LPUART_CTRL_PT_ODD       0x00000001                      // parity odd
        #define LPUART_CTRL_PE           0x00000002                      // parity enable
        #define LPUART_CTRL_ILT          0x00000004                      // idle line type select
        #define LPUART_CTRL_WAKE         0x00000008                      // receiver wakeup method select
        #define LPUART_CTRL_M            0x00000010                      // 9 bit mode select
        #define LPUART_CTRL_RSRC         0x00000020                      // receiver source select
        #define LPUART_CTRL_DOZEEN       0x00000040                      // doze enable
        #define LPUART_CTRL_LOOPS        0x00000080                      // loop mode select
        #define LPUART_CTRL_IDLECFG_1    0x00000000                      // idle configuration - 1 idle characters
        #define LPUART_CTRL_IDLECFG_2    0x00000100                      // idle configuration - 2 idle characters
        #define LPUART_CTRL_IDLECFG_4    0x00000200                      // idle configuration - 4 idle characters
        #define LPUART_CTRL_IDLECFG_8    0x00000300                      // idle configuration - 8 idle characters
        #define LPUART_CTRL_IDLECFG_16   0x00000400                      // idle configuration - 16 idle characters
        #define LPUART_CTRL_IDLECFG_32   0x00000500                      // idle configuration - 32 idle characters
        #define LPUART_CTRL_IDLECFG_64   0x00000600                      // idle configuration - 64 idle characters
        #define LPUART_CTRL_IDLECFG_128  0x00000700                      // idle configuration - 128 idle characters
        #define LPUART_CTRL_MA2IE        0x00004000                      // match 2 interrupt enable
        #define LPUART_CTRL_MA1IE        0x00008000                      // match 1 interrupt enable
        #define LPUART_CTRL_SBK          0x00010000                      // send break
        #define LPUART_CTRL_RWU          0x00020000                      // receiver wakeup control
        #define LPUART_CTRL_RE           0x00040000                      // receiver enable
        #define LPUART_CTRL_TE           0x00080000                      // transmitter enable
        #define LPUART_CTRL_ILIE         0x00100000                      // idle line interrupt enable
        #define LPUART_CTRL_RIE          0x00200000                      // receiver interrupt enable
        #define LPUART_CTRL_TCIE         0x00400000                      // transmit complete interrupt enable
        #define LPUART_CTRL_TIE          0x00800000                      // transmit interrupt enable
        #define LPUART_CTRL_PEIE         0x01000000                      // parity error interrupt enable
        #define LPUART_CTRL_FEIE         0x02000000                      // framing error interrupt enable
        #define LPUART_CTRL_NEIE         0x04000000                      // noise error interrupt enable
        #define LPUART_CTRL_ORIE         0x08000000                      // overrun interrupt enable
        #define LPUART_CTRL_TXINV        0x10000000                      // transmit data inversion
        #define LPUART_CTRL_TXDIR        0x20000000                      // LPUART_TX pin direction in single-wire mode
        #define LPUART_CTRL_R9T8         0x40000000                      // receive bit 9 / transmit bit 8
        #define LPUART_CTRL_R8T9         0x80000000                      // receive bit 8 / transmit bit 9
    #define LPUART0_DATA                 *(volatile unsigned long *)(LPUART0_BLOCK + 0x1c) // LPUART 0 Data Register
        #define LPUART_DATA_MASK         0x000003ff                      // data word mask
        #define LPUART_DATA_IDLINE       0x00000800                      // idle line
        #define LPUART_DATA_RXEMPT       0x00001000                      // receive buffer empty
        #define LPUART_DATA_FRETSC       0x00002000                      // frame error / transmit special character
        #define LPUART_DATA_PARITYE      0x00004000                      // the current received data word was received with a parity error
        #define LPUART_DATA_NOISY        0x00008000                      // the current received data word was received with noise
    #define LPUART0_MATCH                *(unsigned long *)(LPUART0_BLOCK + 0x20) // LPUART 0 Match Address Register
        #define LPUART_MATCH_MA1_MASK    0x000003ff                      // match address 1 mask
        #define LPUART_MATCH_MA2_MASK    0x03ff0000                      // match address 2 mask
    #define LPUART0_MODIR                *(unsigned long *)(LPUART0_BLOCK + 0x24) // LPUART 0 modem IrDA register
        #define LPUART_MODIR_TXCTSE      0x00000001                      // transmitter clear-to-send enable
        #define LPUART_MODIR_TXRTSE      0x00000002                      // transmitter request-to-send enable
        #define LPUART_MODIR_TXRTSPOL    0x00000004                      // transmitter request-to-send polarity
        #define LPUART_MODIR_RXRTSE      0x00000008                      // receiver request-to-send enable
        #define LPUART_MODIR_TXCTSC      0x00000010                      // transmit CTS configuration
        #define LPUART_MODIR_TXCTSSRC    0x00000020                      // transmitter CTS source
        #define LPUART_MODIR_TNP_1       0x00000000                      // transmitter narrow pulse 1/OSR
        #define LPUART_MODIR_TNP_2       0x00010000                      // transmitter narrow pulse 2/OSR
        #define LPUART_MODIR_TNP_3       0x00020000                      // transmitter narrow pulse 3/OSR
        #define LPUART_MODIR_TNP_4       0x00030000                      // transmitter narrow pulse 4/OSR
        #define LPUART_MODIR_IREN        0x00040000                      // infrared enable
        #define LPUART0_FIFO             *(unsigned long *)(LPUART0_BLOCK + 0x28) // LPUART 0 FIFO register
        #define LPUART0_WATER            *(unsigned long *)(LPUART0_BLOCK + 0x2c) // LPUART 0 watermark register

    #if LPUARTS_AVAILABLE > 1
        #define LPUART1_VERID            *(volatile unsigned long *)(LPUART1_BLOCK + 0x00) // LPUART 1 version ID register (read-only)
        #define LPUART1_PARAM            *(volatile unsigned long *)(LPUART1_BLOCK + 0x04) // LPUART 1 parameter register (read-only)
        #define LPUART1_GLOBAL           *(unsigned long *)(LPUART1_BLOCK + 0x08) // LPUART 1 global register
        #define LPUART1_PINCFG           *(unsigned long *)(LPUART1_BLOCK + 0x0c) // LPUART 1 pin configuration register
        #define LPUART1_BAUD             *(unsigned long *)(LPUART1_BLOCK + 0x10) // LPUART 1 Baud Rate Register
        #define LPUART1_STAT             *(volatile unsigned long *)(LPUART1_BLOCK + 0x14) // LPUART 1 Status Register
        #define LPUART1_CTRL             *(volatile unsigned long *)(LPUART1_BLOCK + 0x18) // LPUART 1 Control Register
        #define LPUART1_DATA             *(volatile unsigned long *)(LPUART1_BLOCK + 0x1c) // LPUART 1 Data Register
        #define LPUART1_MATCH            *(unsigned long *)(LPUART1_BLOCK + 0x20) // LPUART 1 Match Address Register
        #define LPUART1_MODIR            *(unsigned long *)(LPUART1_BLOCK + 0x24) // LPUART 1 modem IrDA register
        #define LPUART1_FIFO             *(unsigned long *)(LPUART1_BLOCK + 0x28) // LPUART 1 FIFO register
        #define LPUART1_WATER            *(unsigned long *)(LPUART1_BLOCK + 0x2c) // LPUART 1 watermark register
    #endif
    #if LPUARTS_AVAILABLE > 2
        #define LPUART2_VERID            *(volatile unsigned long *)(LPUART2_BLOCK + 0x00) // LPUART 2 version ID register (read-only)
        #define LPUART2_PARAM            *(volatile unsigned long *)(LPUART2_BLOCK + 0x04) // LPUART 2 parameter register (read-only)
        #define LPUART2_GLOBAL           *(unsigned long *)(LPUART2_BLOCK + 0x08) // LPUART 2 global register
        #define LPUART2_PINCFG           *(unsigned long *)(LPUART2_BLOCK + 0x0c) // LPUART 2 pin configuration register
        #define LPUART2_BAUD             *(unsigned long *)(LPUART2_BLOCK + 0x10) // LPUART 2 Baud Rate Register
        #define LPUART2_STAT             *(volatile unsigned long *)(LPUART2_BLOCK + 0x14) // LPUART 2 Status Register
        #define LPUART2_CTRL             *(volatile unsigned long *)(LPUART2_BLOCK + 0x18) // LPUART 2 Control Register
        #define LPUART2_DATA             *(volatile unsigned long *)(LPUART2_BLOCK + 0x1c) // LPUART 2 Data Register
        #define LPUART2_MATCH            *(unsigned long *)(LPUART2_BLOCK + 0x20) // LPUART 2 Match Address Register
        #define LPUART2_MODIR            *(unsigned long *)(LPUART2_BLOCK + 0x24) // LPUART 2 modem IrDA register
        #define LPUART2_FIFO             *(unsigned long *)(LPUART2_BLOCK + 0x28) // LPUART 2 FIFO register
        #define LPUART2_WATER            *(unsigned long *)(LPUART2_BLOCK + 0x2c) // LPUART 2 watermark register
    #endif
    #if LPUARTS_AVAILABLE > 3
        #define LPUART3_VERID            *(volatile unsigned long *)(LPUART3_BLOCK + 0x00) // LPUART 3 version ID register (read-only)
        #define LPUART3_PARAM            *(volatile unsigned long *)(LPUART3_BLOCK + 0x04) // LPUART 3 parameter register (read-only)
        #define LPUART3_GLOBAL           *(unsigned long *)(LPUART3_BLOCK + 0x08) // LPUART 3 global register
        #define LPUART3_PINCFG           *(unsigned long *)(LPUART3_BLOCK + 0x0c) // LPUART 3 pin configuration register
        #define LPUART3_BAUD             *(unsigned long *)(LPUART3_BLOCK + 0x10) // LPUART 3 Baud Rate Register
        #define LPUART3_STAT             *(volatile unsigned long *)(LPUART3_BLOCK + 0x14) // LPUART 3 Status Register
        #define LPUART3_CTRL             *(volatile unsigned long *)(LPUART3_BLOCK + 0x18) // LPUART 3 Control Register
        #define LPUART3_DATA             *(volatile unsigned long *)(LPUART3_BLOCK + 0x1c) // LPUART 3 Data Register
        #define LPUART3_MATCH            *(unsigned long *)(LPUART3_BLOCK + 0x20) // LPUART 3 Match Address Register
        #define LPUART3_MODIR            *(unsigned long *)(LPUART3_BLOCK + 0x24) // LPUART 3 modem IrDA register
        #define LPUART3_FIFO             *(unsigned long *)(LPUART3_BLOCK + 0x28) // LPUART 3 FIFO register
        #define LPUART3_WATER            *(unsigned long *)(LPUART3_BLOCK + 0x2c) // LPUART 3 watermark register
    #endif
    #if LPUARTS_AVAILABLE > 4
        #define LPUART4_VERID            *(volatile unsigned long *)(LPUART4_BLOCK + 0x00) // LPUART 4 version ID register (read-only)
        #define LPUART4_PARAM            *(volatile unsigned long *)(LPUART4_BLOCK + 0x04) // LPUART 4 parameter register (read-only)
        #define LPUART4_GLOBAL           *(unsigned long *)(LPUART4_BLOCK + 0x08) // LPUART 4 global register
        #define LPUART4_PINCFG           *(unsigned long *)(LPUART4_BLOCK + 0x0c) // LPUART 4 pin configuration register
        #define LPUART4_BAUD             *(unsigned long *)(LPUART4_BLOCK + 0x10) // LPUART 4 Baud Rate Register
        #define LPUART4_STAT             *(volatile unsigned long *)(LPUART4_BLOCK + 0x14) // LPUART 4 Status Register
        #define LPUART4_CTRL             *(volatile unsigned long *)(LPUART4_BLOCK + 0x18) // LPUART 4 Control Register
        #define LPUART4_DATA             *(volatile unsigned long *)(LPUART4_BLOCK + 0x1c) // LPUART 4 Data Register
        #define LPUART4_MATCH            *(unsigned long *)(LPUART4_BLOCK + 0x20) // LPUART 4 Match Address Register
        #define LPUART4_MODIR            *(unsigned long *)(LPUART4_BLOCK + 0x24) // LPUART 4 modem IrDA register
        #define LPUART4_FIFO             *(unsigned long *)(LPUART4_BLOCK + 0x28) // LPUART 4 FIFO register
        #define LPUART4_WATER            *(unsigned long *)(LPUART4_BLOCK + 0x2c) // LPUART 4 watermark register
    #endif
    #if LPUARTS_AVAILABLE > 5
        #define LPUART5_VERID            *(volatile unsigned long *)(LPUART5_BLOCK + 0x00) // LPUART 5 version ID register (read-only)
        #define LPUART5_PARAM            *(volatile unsigned long *)(LPUART5_BLOCK + 0x04) // LPUART 5 parameter register (read-only)
        #define LPUART5_GLOBAL           *(unsigned long *)(LPUART5_BLOCK + 0x08) // LPUART 5 global register
        #define LPUART5_PINCFG           *(unsigned long *)(LPUART5_BLOCK + 0x0c) // LPUART 5 pin configuration register
        #define LPUART5_BAUD             *(unsigned long *)(LPUART5_BLOCK + 0x10) // LPUART 5 Baud Rate Register
        #define LPUART5_STAT             *(volatile unsigned long *)(LPUART5_BLOCK + 0x14) // LPUART 5 Status Register
        #define LPUART5_CTRL             *(volatile unsigned long *)(LPUART5_BLOCK + 0x18) // LPUART 5 Control Register
        #define LPUART5_DATA             *(volatile unsigned long *)(LPUART5_BLOCK + 0x1c) // LPUART 5 Data Register
        #define LPUART5_MATCH            *(unsigned long *)(LPUART5_BLOCK + 0x20) // LPUART 5 Match Address Register
        #define LPUART5_MODIR            *(unsigned long *)(LPUART5_BLOCK + 0x24) // LPUART 5 modem IrDA register
        #define LPUART5_FIFO             *(unsigned long *)(LPUART5_BLOCK + 0x28) // LPUART 5 FIFO register
        #define LPUART5_WATER            *(unsigned long *)(LPUART5_BLOCK + 0x2c) // LPUART 5 watermark register
    #endif
    #if LPUARTS_AVAILABLE > 6
        #define LPUART6_VERID            *(volatile unsigned long *)(LPUART6_BLOCK + 0x00) // LPUART 6 version ID register (read-only)
        #define LPUART6_PARAM            *(volatile unsigned long *)(LPUART6_BLOCK + 0x04) // LPUART 6 parameter register (read-only)
        #define LPUART6_GLOBAL           *(unsigned long *)(LPUART6_BLOCK + 0x08) // LPUART 6 global register
        #define LPUART6_PINCFG           *(unsigned long *)(LPUART6_BLOCK + 0x0c) // LPUART 6 pin configuration register
        #define LPUART6_BAUD             *(unsigned long *)(LPUART6_BLOCK + 0x10) // LPUART 6 Baud Rate Register
        #define LPUART6_STAT             *(volatile unsigned long *)(LPUART6_BLOCK + 0x14) // LPUART 6 Status Register
        #define LPUART6_CTRL             *(volatile unsigned long *)(LPUART6_BLOCK + 0x18) // LPUART 6 Control Register
        #define LPUART6_DATA             *(volatile unsigned long *)(LPUART6_BLOCK + 0x1c) // LPUART 6 Data Register
        #define LPUART6_MATCH            *(unsigned long *)(LPUART6_BLOCK + 0x20) // LPUART 6 Match Address Register
        #define LPUART6_MODIR            *(unsigned long *)(LPUART6_BLOCK + 0x24) // LPUART 6 modem IrDA register
        #define LPUART6_FIFO             *(unsigned long *)(LPUART6_BLOCK + 0x28) // LPUART 6 FIFO register
        #define LPUART6_WATER            *(unsigned long *)(LPUART6_BLOCK + 0x2c) // LPUART 6 watermark register
    #endif
    #if LPUARTS_AVAILABLE > 7
        #define LPUART7_VERID            *(volatile unsigned long *)(LPUART7_BLOCK + 0x00) // LPUART 7 version ID register (read-only)
        #define LPUART7_PARAM            *(volatile unsigned long *)(LPUART7_BLOCK + 0x04) // LPUART 7 parameter register (read-only)
        #define LPUART7_GLOBAL           *(unsigned long *)(LPUART7_BLOCK + 0x08) // LPUART 7 global register
        #define LPUART7_PINCFG           *(unsigned long *)(LPUART7_BLOCK + 0x0c) // LPUART 7 pin configuration register
        #define LPUART7_BAUD             *(unsigned long *)(LPUART7_BLOCK + 0x10) // LPUART 7 Baud Rate Register
        #define LPUART7_STAT             *(volatile unsigned long *)(LPUART7_BLOCK + 0x14) // LPUART 7 Status Register
        #define LPUART7_CTRL             *(volatile unsigned long *)(LPUART7_BLOCK + 0x18) // LPUART 7 Control Register
        #define LPUART7_DATA             *(volatile unsigned long *)(LPUART7_BLOCK + 0x1c) // LPUART 7 Data Register
        #define LPUART7_MATCH            *(unsigned long *)(LPUART7_BLOCK + 0x20) // LPUART 7 Match Address Register
        #define LPUART7_MODIR            *(unsigned long *)(LPUART7_BLOCK + 0x24) // LPUART 7 modem IrDA register
        #define LPUART7_FIFO             *(unsigned long *)(LPUART7_BLOCK + 0x28) // LPUART 7 FIFO register
        #define LPUART7_WATER            *(unsigned long *)(LPUART7_BLOCK + 0x2c) // LPUART 7 watermark register
    #endif

    typedef struct stKINETIS_LPUART_CONTROL
    {
        volatile unsigned long  LPUART_VERID;
        volatile unsigned long  LPUART_PARAM;
        unsigned long  LPUART_GLOBAL;
        unsigned long  LPUART_PINCFG;
        unsigned long LPUART_BAUD;
        volatile unsigned long LPUART_STAT;
        volatile unsigned long LPUART_CTRL;
        volatile unsigned long LPUART_DATA;
        unsigned long LPUART_MATCH;
        unsigned long LPUART_MODIR;
        unsigned long LPUART_FIFO;
        unsigned long LPUART_WATER;
    } KINETIS_LPUART_CONTROL;

    #define KINETIS_UART_CONTROL     KINETIS_LPUART_CONTROL              // iMX doesn't have UARTs and this ensures driver code compatibility

    // Macro to directly change the baud rate of a LPUART - the user must know the LPUART clock's speed and be sure that the LPUART has already been powered up
    //
    #define SET_LPUART_BAUD(ref, baud_rate, uart_clock)           LPUART##ref##_BAUD = ((LPUART##ref##_BAUD & ~LPUART_BAUD_SBR) | ((((uart_clock/8/baud_rate) + 1)/2) | LPUART_BAUD_OSR_16))
#endif

// Macro to directly change the baud rate of a UART - the user must know the UART clock's speed and be sure that the UART has already been powered up
// - SET_KUART_BAUD() is for use with the full UART as found in K parts and some KL part channels
// - SET_UART_BAUD() is for use with UARTs that have no fraction divider, such as in most KL parts
//
#define SET_KUART_BAUD(ref, baud_rate, uart_clock) UART##ref##_C4 = (unsigned char)(((float)((((float)uart_clock/(float)16/(float)baud_rate) - (int)(uart_clock/16/baud_rate)) * 32)) + (float)0.5); UART##ref##_BDH = (unsigned char)(((uart_clock/16/baud_rate) >> 8) & 0x1f); UART##ref##_BDL = (unsigned char)(uart_clock/16/baud_rate)
#define SET_UART_BAUD(ref, baud_rate, uart_clock)  UART##ref##_BDH = (unsigned char)(((((uart_clock/8/baud_rate) + 1)/2) >> 8) & 0x1f); UART##ref##_BDL = (unsigned char)(((uart_clock/8/baud_rate) + 1)/2)

// Flex SPI
//
#define FLEX_SPI_MCR0        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x000)  // flex spi module control register 0
    #define FLEX_SPI_MCR0_SWRESET                    0x00000001          // software reset of module (auto-cleared when reset completes)
    #define FLEX_SPI_MCR0_MDIS                       0x00000002          // module disable
    #define FLEX_SPI_MCR0_RXCLKSRC_INTERNAL_LOOPBACK 0x00000000          // dummy read strobe generated by FlexSPI controller and loopback internally (operation limited to 60MHz in this configuration)
    #define FLEX_SPI_MCR0_RXCLKSRC_DQS_LOOPBACK      0x00000010          // dummy read strobe generated by FlexSPI controller and loopback from DQS pad (operation up to 133MHz in this configuration)
    #define FLEX_SPI_MCR0_RXCLKSRC_STROBE            0x00000030          // flash provided read strobe and input from DQS pad
    #define FLEX_SPI_MCR0_ARDFEN                     0x00000040          // enable AHB bus read access to IP RX FIFO
    #define FLEX_SPI_MCR0_ATDFEN                     0x00000080          // enable AHB bus write access to IP TX FIFO
    #define FLEX_SPI_MCR0_HSEN                       0x00000800          // half speed serial flash access enable
    #define FLEX_SPI_MCR0_DOZEEN                     0x00001000          // doze mode enable
    #define FLEX_SPI_MCR0_COMBINATION_EN             0x00002000          // support flash octal mode access by combining port A and B data pins
    #define FLEX_SPI_MCR0_SCKFREERUN_EN              0x00004000          // SCK output free-running
    #define FLEX_SPI_MCR0_RESERVED_ONE               0x00008000          // reserved bit
    #define FLEX_SPI_MCR0_IPGRANTWAIT_MASK           0x00ff0000          // time out wait cycle for IP command grant
    #define FLEX_SPI_MCR0_AHBGRANTWAIT_MASK          0xff000000          // timeout wait cycle for AHB command grant
#define FLEX_SPI_MCR1        *(unsigned long *)(FLEX_SPI_BLOCK + 0x004)  // flex spi module control register 1
    #define FLEX_SPI_MCR1_AHBBUSWAIT_MASK            0x0000ffff          // AHB read/write access to serial flash memory space timeout (never set to 0)
    #define FLEX_SPI_MCR1_SEQWAIT_MASK               0xffff0000          // command sequence execution timeout (never set to 0)
    #define FLEX_SPI_MCR1_SEQWAIT_SHIFT              16
#define FLEX_SPI_MCR2        *(unsigned long *)(FLEX_SPI_BLOCK + 0x008)  // flex spi module control register 2
    #define FLEX_SPI_MCR2_RESERVED                   0x000001f7
    #define FLEX_SPI_MCR2_CLFAHBBUFOPT               0x00000800
    #define FLEX_SPI_MCR2_CLRLEARNPHASE              0x00004000
    #define FLEX_SPI_MCR2_SAMEDEVICEEN               0x00008000
    #define FLEX_SPI_MCR2_SCKBDIFFOPT                0x00080000
    #define FLEX_SPI_MCR2_RESUMEWAIT_MASK            0xff000000
    #define FLEX_SPI_MCR2_RESUMEWAIT_DEFAULT         0x20000000
#define FLEX_SPI_AHBCR       *(unsigned long *)(FLEX_SPI_BLOCK + 0x00c)  // flex spi AHB bus control register
    #define FLEX_SPI_AHBCR_APAREN       0x00000001
    #define FLEX_SPI_AHBCR_CACHABLEEN   0x00000008
    #define FLEX_SPI_AHBCR_BUFFERABLEEN 0x00000010
    #define FLEX_SPI_AHBCR_PREFETCHEN   0x00000020
    #define FLEX_SPI_AHBCR_READADDROPT  0x00000040                       // AHB read address option bit - removes AHB burst start address alignment limitation (FlexSPI will fetch more data than AHB burst required to meet the alignment requirement)
#define FLEX_SPI_INTEN       *(unsigned long *)(FLEX_SPI_BLOCK + 0x010)  // flex spi interrupt enable register
#define FLEX_SPI_INTR        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x014) // flex spi interrupt register (write '1' to clear)
    #define FLEX_SPI_INTR_IPCMDDONE     0x00000001                       // IP triggered command sequence finished (with or without errors)
    #define FLEX_SPI_INTR_IPCMDGE       0x00000002                       // IP triggered command sequences grant timeout interrupt
    #define FLEX_SPI_INTR_AHBCMDGE      0x00000004                       // AHB triggered command sequences grant timeout interrupt
    #define FLEX_SPI_INTR_IPCMDERR      0x00000008                       // IP triggered command sequences error detected interrupt
    #define FLEX_SPI_INTR_AHBCMDERR     0x00000010                       // AHB triggered command sequences error detected interrupt
    #define FLEX_SPI_INTR_IPRXWA        0x00000020                       // watermark available interrupt
    #define FLEX_SPI_INTR_IPTXWE        0x00000040                       // watermark empty interrupt
    #define FLEX_SPI_INTR_SCKSTOPBYRD   0x00000100                       // SCK is stopped during command sequence because Async RX FIFO full interrupt
    #define FLEX_SPI_INTR_SCKSTOPBYWR   0x00000200                       // SCK is stopped during command sequence because Async TX FIFO empty interrupt
    #define FLEX_SPI_INTR_AHBBUSTIMEOUT 0x00000400                       // AHB bus timeout interrupt
    #define FLEX_SPI_INTR_SEQTIMEOUT    0x00000800                       // sequence execution timeout interrupt
#define FLEX_SPI_LUTKEY      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x018) // flex spi LUT key register
    #define FLEX_SPI_LUTKEY_KEY         0x5af05af0                       // key to lock or unlock LUT (always reads this value)
#define FLEX_SPI_LUTCR       *(unsigned long *)(FLEX_SPI_BLOCK + 0x01c)  // flex spi LUT control register
    #define FLEX_SPI_LUTCR_LOCK         0x00000001                       // lock LUT
    #define FLEX_SPI_LUTCR_UNLOCK       0x00000002                       // unlock LUT
#define FLEX_SPI_AHBRXBUF0CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x020) // flex spi AHB rx buffer 0 control register 0
    #define FLEX_SPI_AHBRXBUFnCR0_BUFSZ_MASK    0x000000ff               // AHB receive buffer size in 64 bits
    #define FLEX_SPI_AHBRXBUFnCR0_BUFSZ_DEFAULT 0x00000020
    #define FLEX_SPI_AHBRXBUFnCR0_MSTRID_MASK   0x000f0000
    #define FLEX_SPI_AHBRXBUFnCR0_MSTRID_0      0x00000000
    #define FLEX_SPI_AHBRXBUFnCR0_MSTRID_1      0x00010000
    #define FLEX_SPI_AHBRXBUFnCR0_MSTRID_2      0x00020000
    #define FLEX_SPI_AHBRXBUFnCR0_MSTRID_3      0x00030000
    #define FLEX_SPI_AHBRXBUFnCR0_PRIORITY_MASK 0x03000000
    #define FLEX_SPI_AHBRXBUFnCR0_PREFETCHEN    0x80000000
#define FLEX_SPI_AHBRXBUF1CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x024) // flex spi AHB rx buffer 1 control register 0
#define FLEX_SPI_AHBRXBUF2CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x028) // flex spi AHB rx buffer 1 control register 0
#define FLEX_SPI_AHBRXBUF3CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x02c) // flex spi AHB rx buffer 1 control register 0
#define FLEX_SPI_FLSHA1CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x060)  // flex spi flash A1 control register 0
#define FLEX_SPI_FLSHA2CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x064)  // flex spi flash A2 control register 0
#define FLEX_SPI_FLSHB1CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x068)  // flex spi flash B1 control register 0
#define FLEX_SPI_FLSHB2CR0   *(unsigned long *)(FLEX_SPI_BLOCK + 0x06c)  // flex spi flash B2 control register 0
#define FLEX_SPI_FLSHA1CR1   *(unsigned long *)(FLEX_SPI_BLOCK + 0x070)  // flex spi flash A1 control register 1
    #define FLEX_SPI_FLSHnCR1_TCSS_MASK         0x0000008f               // chip select setup time (serial root clock cycles + 1/2)
    #define FLEX_SPI_FLSHnCR1_TCSH_MASK         0x000003e0               // chip select hold time (serial root clock cycles)
    #define FLEX_SPI_FLSHnCR1_WA                0x00000400               // word addressable
    #define FLEX_SPI_FLSHnCR1_CAS_MASK          0x00007800               // column address size
    #define FLEX_SPI_FLSHnCR1_CSINTERVALUNIT    0x00008000               // chip select interval unit
    #define FLEX_SPI_FLSHnCR1_CSINTERVALMASK    0xffff0000               // chip select interval
#define FLEX_SPI_FLSHA2CR1   *(unsigned long *)(FLEX_SPI_BLOCK + 0x074)  // flex spi flash A2 control register 1
#define FLEX_SPI_FLSHB1CR1   *(unsigned long *)(FLEX_SPI_BLOCK + 0x078)  // flex spi flash B1 control register 1
#define FLEX_SPI_FLSHB2CR1   *(unsigned long *)(FLEX_SPI_BLOCK + 0x07c)  // flex spi flash B2 control register 1
#define FLEX_SPI_FLSHA1CR2   *(unsigned long *)(FLEX_SPI_BLOCK + 0x080)  // flex spi flash A1 control register 2
#define FLEX_SPI_FLSHA2CR2   *(unsigned long *)(FLEX_SPI_BLOCK + 0x084)  // flex spi flash A2 control register 2
    #define FLEX_SPI_FLSHnCR2_ARDSEQID_MASK     0x0000000f               // sequence index for AHB read triggered command in LUT
    #define FLEX_SPI_FLSHnCR2_ARDSEQNUM_MASK    0x000000e0               // sequence number for AHB read triggered command in LUT
    #define FLEX_SPI_FLSHnCR2_AWRSEQID_MASK     0x00000f00               // sequence index for AHB write triggered command
    #define FLEX_SPI_FLSHnCR2_AWRSEQNUM_MASK    0x0000e000               // sequence number for AHB write triggered command
    #define FLEX_SPI_FLSHnCR2_AWRWAIT_MASK      0x0fff0000               // 
    #define FLEX_SPI_FLSHnCR2_AWRWAITUIT_MASK   0x70000000               // 
    #define FLEX_SPI_FLSHnCR2_CLRINSTRPTR       0x80000000               // 
#define FLEX_SPI_FLSHB1CR2   *(unsigned long *)(FLEX_SPI_BLOCK + 0x088)  // flex spi flash B1 control register 2
#define FLEX_SPI_FLSHB2CR2   *(unsigned long *)(FLEX_SPI_BLOCK + 0x08c)  // flex spi flash B2 control register 2
    #define FLEX_SPI_FLSHCR2_CLRINSTRPTR                    0x80000000   // clear instruction pointer which is internally saved pointer by JMP_ON_CS (used for AHB read access to external flash supporting XIP)
#define FLEX_SPI_FLSHCR4     *(unsigned long *)(FLEX_SPI_BLOCK + 0x094)  // flex spi flash control register 4
    #define FLEX_SPI_FLSHCR4_WMOPT1                         0x00000001   // write mask option bit 1
    #define FLEX_SPI_FLSHCR4_WMENA                          0x00000004   // write mask enable bit for flash device on port A
    #define FLEX_SPI_FLSHCR4_WMENB                          0x00000008   // write mask enable bit for flash device on port B
#define FLEX_SPI_IPCR0       *(unsigned long *)(FLEX_SPI_BLOCK + 0x0a0)  // flex spi IP control register 0
#define FLEX_SPI_IPCR1       *(unsigned long *)(FLEX_SPI_BLOCK + 0x0a4)  // flex spi IP control register 1
    #define FLEX_SPI_IPCR1_IDATSZ_MASK                      0x0000ffff   // flash read/program data size (in bytes) for IP command
    #define FLEX_SPI_IPCR1_ISEQID_MASK                      0x000f0000   // sequence index in LUT (mask) for IP command
    #define FLEX_SPI_IPCR1_ISEQID_SHIFT                     16
    #define FLEX_SPI_IPCR1_ISEQNUM_MASK                     0x0f000000   // sequence number (mask) for IP command
    #define FLEX_SPI_IPCR1_ISEQNUM_SHIFT                    24
    #define FLEX_SPI_IPCR1_IPAREN                           0x80000000   // flash will be accessed in parallel mode rather than in individual mode
#define FLEX_SPI_IPCMD       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0b0) // flex spi IP command register
    #define FLEX_SPI_IPCMD_TRG                          0x00000001       // trigger an IP command
#define FLEX_SPI_IPRXFCR     *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0b8) // flex spi IP RX FIFO control register
    #define FLEX_SPI_IPRXFCR_CLRIPRXF                   0x00000001       // clear all valid data entries in the IP rx FIFO
    #define FLEX_SPI_IPRXFCR_RXDMAEN                    0x00000002       // IP rx FIFO filled by DMA
    #define FLEX_SPI_IPRXFCR_RXWMRK_MASK                0x0000003c       // watermark level ((RXWMRK + 1) * 64 bits)
    #define FLEX_SPI_IPRXFCR_RXWMRK_SHIFT               2
#define FLEX_SPI_IPTXFCR     *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0bc) // flex spi IP TX FIFO control register
    #define FLEX_SPI_IPTXFCR_CLRIPTXF                   0x00000001       // clear all valid data entries in the IP tx FIFO
    #define FLEX_SPI_IPTXFCR_TXDMAEN                    0x00000002       // IP tx FIFO filled by DMA
    #define FLEX_SPI_IPTXFCR_TXWMRK_MASK                0x0000003c       // watermark level ((TXWMRK + 1) * 64 bits)
    #define FLEX_SPI_IPTXFCR_TXWMRK_SHIFT               2
#define FLEX_SPI_DLLACR      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0c0)  // flex spi DLL control register A
    #define FLEX_SPI_DLLnCR_DLLEN                       0x00000001       // DLL calibration enable
    #define FLEX_SPI_DLLnCR_DLLRESET                    0x00000002       // DLL reset (software needs to set and then clear this bit)
    #define FLEX_SPI_DLLnCR_SLVDLYTARGET_MASK           0x00000078       // delay target for slave delay line
    #define FLEX_SPI_DLLnCR_OVRDEN                      0x00000100       // slave clock delay line delay cell number selection override enable
    #define FLEX_SPI_DLLnCR_OVRDVAL_MASK                0x00007e00       // slave clock delay line delay cell number selection override value
#define FLEX_SPI_DLLBCR      *(unsigned long *)(FLEX_SPI_BLOCK + 0x0c4)  // flex spi DLL control register B
#define FLEX_SPI_STS0        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0e0) // flex spi status register 0 (read-only)
    #define FLEX_SPI_STS0_SEQIDLE                       0x00000001       // command sequence executing on FlexSPI interface
    #define FLEX_SPI_STS0_ARBIDLE                       0x00000002       // arbitrator idle
    #define FLEX_SPI_STS0_ARBCMDSRC_AHB_READ            0x00000000       // trigger source of current command was a read from AHB
    #define FLEX_SPI_STS0_ARBCMDSRC_AHB_WRITE           0x00000004       // trigger source of current command was a write to AHB
    #define FLEX_SPI_STS0_ARBCMDSRC_IP_CMD              0x00000008       // trigger source of current command was an IP command
    #define FLEX_SPI_STS0_ARBCMDSRC_RESUMED             0x0000000c       // trigger source of current command was a resume from suspended
#define FLEX_SPI_STS1        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0e4) // flex spi status register 1 (read-only)
#define FLEX_SPI_STS2        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0e8) // flex spi status register 2 (read-only)
    #define FLEX_SPI_STS2_ASLVLOCK                      0x00000001
    #define FLEX_SPI_STS2_AREFLOCK                      0x00000002
    #define FLEX_SPI_STS2_ASLVSEL_MASK                  0x000000fc
    #define FLEX_SPI_STS2_AREFSEL_MASK                  0x00003f00
    #define FLEX_SPI_STS2_BSLVLOCK                      0x00010000
    #define FLEX_SPI_STS2_BREFLOCK                      0x00020000
    #define FLEX_SPI_STS2_BSLVSEL_MASK                  0x00fc0000
    #define FLEX_SPI_STS2_BREFSEL_MASK                  0x3f000000
#define FLEX_SPI_AHBSPNDSTS  *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0ec) // flex spi AHB suspend status register (read-only)
#define FLEX_SPI_IPRXFSTS    *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0f0) // flex spi rx FIFO status register (read-only)
    #define FLEX_SPI_IPRXFSTS_FILL_MASK  0x000000ff                      // valid data entries (x64 bits)
    #define FLEX_SPI_IPRXFSTS_DCNTR_MASK 0xffff0000                      // total read data counter (x64 bits)
#define FLEX_SPI_IPTXFSTS    *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x0f4) // flex spi tx FIFO status register (read-only)
    #define FLEX_SPI_IPTXFSTS_FILL_MASK  0x000000ff                      // valid data entries (x64 bits)
    #define FLEX_SPI_IPTXFSTS_DCNTR_MASK 0xffff0000                      // total read data counter (x64 bits)
#define FLEX_SPI_RFDR0_ADD   (volatile unsigned long *)(FLEX_SPI_BLOCK + 0x100)
#define FLEX_SPI_RFDR0       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x100) // flex spi IP rx FIFO data register 0 (read-only)
#define FLEX_SPI_RFDR1       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x104) // flex spi IP rx FIFO data register 1 (read-only)
#define FLEX_SPI_RFDR2       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x108) // flex spi IP rx FIFO data register 2 (read-only)
#define FLEX_SPI_RFDR3       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x10c) // flex spi IP rx FIFO data register 3 (read-only)
#define FLEX_SPI_RFDR4       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x110) // flex spi IP rx FIFO data register 4 (read-only)
#define FLEX_SPI_RFDR5       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x114) // flex spi IP rx FIFO data register 5 (read-only)
#define FLEX_SPI_RFDR6       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x118) // flex spi IP rx FIFO data register 6 (read-only)
#define FLEX_SPI_RFDR7       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x11c) // flex spi IP rx FIFO data register 7 (read-only)
#define FLEX_SPI_RFDR8       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x120) // flex spi IP rx FIFO data register 8 (read-only)
#define FLEX_SPI_RFDR9       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x124) // flex spi IP rx FIFO data register 9 (read-only)
#define FLEX_SPI_RFDR10      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x128) // flex spi IP rx FIFO data register 10 (read-only)
#define FLEX_SPI_RFDR11      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x12c) // flex spi IP rx FIFO data register 11 (read-only)
#define FLEX_SPI_RFDR12      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x130) // flex spi IP rx FIFO data register 12 (read-only)
#define FLEX_SPI_RFDR13      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x134) // flex spi IP rx FIFO data register 13 (read-only)
#define FLEX_SPI_RFDR14      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x138) // flex spi IP rx FIFO data register 14 (read-only)
#define FLEX_SPI_RFDR15      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x13c) // flex spi IP rx FIFO data register 15 (read-only)
#define FLEX_SPI_RFDR16      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x140) // flex spi IP rx FIFO data register 16 (read-only)
#define FLEX_SPI_RFDR17      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x144) // flex spi IP rx FIFO data register 17 (read-only)
#define FLEX_SPI_RFDR18      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x148) // flex spi IP rx FIFO data register 18 (read-only)
#define FLEX_SPI_RFDR19      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x14c) // flex spi IP rx FIFO data register 19 (read-only)
#define FLEX_SPI_RFDR20      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x150) // flex spi IP rx FIFO data register 20 (read-only)
#define FLEX_SPI_RFDR21      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x154) // flex spi IP rx FIFO data register 21 (read-only)
#define FLEX_SPI_RFDR22      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x158) // flex spi IP rx FIFO data register 22 (read-only)
#define FLEX_SPI_RFDR23      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x15c) // flex spi IP rx FIFO data register 23 (read-only)
#define FLEX_SPI_RFDR24      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x160) // flex spi IP rx FIFO data register 24 (read-only)
#define FLEX_SPI_RFDR25      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x164) // flex spi IP rx FIFO data register 25 (read-only)
#define FLEX_SPI_RFDR26      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x168) // flex spi IP rx FIFO data register 26 (read-only)
#define FLEX_SPI_RFDR27      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x16c) // flex spi IP rx FIFO data register 27 (read-only)
#define FLEX_SPI_RFDR28      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x170) // flex spi IP rx FIFO data register 28 (read-only)
#define FLEX_SPI_RFDR29      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x174) // flex spi IP rx FIFO data register 29 (read-only)
#define FLEX_SPI_RFDR30      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x178) // flex spi IP rx FIFO data register 30 (read-only)
#define FLEX_SPI_RFDR31      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x17c) // flex spi IP rx FIFO data register 31 (read-only)
#define FLEX_SPI_TFDR0_ADD   (volatile unsigned long *)(FLEX_SPI_BLOCK + 0x180)
#define FLEX_SPI_TFDR0       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x180) // flex spi IP tx FIFO data register 0 (write-only)
#define FLEX_SPI_TFDR1       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x184) // flex spi IP tx FIFO data register 1 (write-only)
#define FLEX_SPI_TFDR2       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x188) // flex spi IP tx FIFO data register 2 (write-only)
#define FLEX_SPI_TFDR3       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x18c) // flex spi IP tx FIFO data register 3 (write-only)
#define FLEX_SPI_TFDR4       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x190) // flex spi IP tx FIFO data register 4 (write-only)
#define FLEX_SPI_TFDR5       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x194) // flex spi IP tx FIFO data register 5 (write-only)
#define FLEX_SPI_TFDR6       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x198) // flex spi IP tx FIFO data register 6 (write-only)
#define FLEX_SPI_TFDR7       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x19c) // flex spi IP tx FIFO data register 7 (write-only)
#define FLEX_SPI_TFDR8       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1a0) // flex spi IP tx FIFO data register 8 (write-only)
#define FLEX_SPI_TFDR9       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1a4) // flex spi IP tx FIFO data register 9 (write-only)
#define FLEX_SPI_TFDR10      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1a8) // flex spi IP tx FIFO data register 10 (write-only)
#define FLEX_SPI_TFDR11      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1ac) // flex spi IP tx FIFO data register 11 (write-only)
#define FLEX_SPI_TFDR12      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1b0) // flex spi IP tx FIFO data register 12 (write-only)
#define FLEX_SPI_TFDR13      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1b4) // flex spi IP tx FIFO data register 13 (write-only)
#define FLEX_SPI_TFDR14      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1b8) // flex spi IP tx FIFO data register 14 (write-only)
#define FLEX_SPI_TFDR15      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1bc) // flex spi IP tx FIFO data register 15 (write-only)
#define FLEX_SPI_TFDR16      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1c0) // flex spi IP tx FIFO data register 16 (write-only)
#define FLEX_SPI_TFDR17      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1c4) // flex spi IP tx FIFO data register 17 (write-only)
#define FLEX_SPI_TFDR18      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1c8) // flex spi IP tx FIFO data register 18 (write-only)
#define FLEX_SPI_TFDR19      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1cc) // flex spi IP tx FIFO data register 19 (write-only)
#define FLEX_SPI_TFDR20      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1d0) // flex spi IP tx FIFO data register 20 (write-only)
#define FLEX_SPI_TFDR21      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1d4) // flex spi IP tx FIFO data register 21 (write-only)
#define FLEX_SPI_TFDR22      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1d8) // flex spi IP tx FIFO data register 22 (write-only)
#define FLEX_SPI_TFDR23      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1dc) // flex spi IP tx FIFO data register 23 (write-only)
#define FLEX_SPI_TFDR24      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1e0) // flex spi IP tx FIFO data register 24 (write-only)
#define FLEX_SPI_TFDR25      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1e4) // flex spi IP tx FIFO data register 25 (write-only)
#define FLEX_SPI_TFDR26      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1e8) // flex spi IP tx FIFO data register 26 (write-only)
#define FLEX_SPI_TFDR27      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1ec) // flex spi IP tx FIFO data register 27 (write-only)
#define FLEX_SPI_TFDR28      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1f0) // flex spi IP tx FIFO data register 28 (write-only)
#define FLEX_SPI_TFDR29      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1f4) // flex spi IP tx FIFO data register 29 (write-only)
#define FLEX_SPI_TFDR30      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1f8) // flex spi IP tx FIFO data register 30 (write-only)
#define FLEX_SPI_TFDR31      *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x1fc) // flex spi IP tx FIFO data register 31 (write-only)
#define FLEX_SPI_LUT0_ADD    (volatile unsigned long *)(FLEX_SPI_BLOCK + 0x200)
#define FLEX_SPI_LUT0        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x200) // flex spi LUT 0
    #define FLEX_SPI_LUT_OPERAND0        0x000000ff
    #define FLEX_SPI_LUT_OPERAND0_SHIFT  0
    #define FLEX_SPI_LUT_NUM_PADS0       0x00000300
    #define FLEX_SPI_LUT_NUM_PADS0_SHIFT 8
    #define FLEX_SPI_LUT_OPCODE0         0x0000fc00
    #define FLEX_SPI_LUT_OPCODE0_SHIFT   10
    #define FLEX_SPI_LUT_OPERAND1        0x00ff0000
    #define FLEX_SPI_LUT_OPERAND1_SHIFT  16
    #define FLEX_SPI_LUT_NUM_PADS1       0x03000000
    #define FLEX_SPI_LUT_NUM_PADS1_SHIFT 24
    #define FLEX_SPI_LUT_OPCODE1         0xfc000000
    #define FLEX_SPI_LUT_OPCODE1_SHIFT   26
#define FLEX_SPI_LUT1        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x204) // flex spi LUT 1
#define FLEX_SPI_LUT2        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x208) // flex spi LUT 2
#define FLEX_SPI_LUT3        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x20c) // flex spi LUT 3
#define FLEX_SPI_LUT4        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x210) // flex spi LUT 4
#define FLEX_SPI_LUT5        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x214) // flex spi LUT 5
#define FLEX_SPI_LUT6        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x218) // flex spi LUT 6
#define FLEX_SPI_LUT7        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x21c) // flex spi LUT 7
#define FLEX_SPI_LUT8        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x220) // flex spi LUT 8
#define FLEX_SPI_LUT9        *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x224) // flex spi LUT 9
#define FLEX_SPI_LUT10       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x228) // flex spi LUT 10
#define FLEX_SPI_LUT11       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x22c) // flex spi LUT 11
#define FLEX_SPI_LUT12       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x230) // flex spi LUT 12
#define FLEX_SPI_LUT13       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x234) // flex spi LUT 13
#define FLEX_SPI_LUT14       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x238) // flex spi LUT 14
#define FLEX_SPI_LUT15       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x23c) // flex spi LUT 15
#define FLEX_SPI_LUT16       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x240) // flex spi LUT 16
#define FLEX_SPI_LUT17       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x244) // flex spi LUT 17
#define FLEX_SPI_LUT18       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x248) // flex spi LUT 18
#define FLEX_SPI_LUT19       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x24c) // flex spi LUT 19
#define FLEX_SPI_LUT20       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x250) // flex spi LUT 20
#define FLEX_SPI_LUT21       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x254) // flex spi LUT 21
#define FLEX_SPI_LUT22       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x258) // flex spi LUT 22
#define FLEX_SPI_LUT23       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x25c) // flex spi LUT 23
#define FLEX_SPI_LUT24       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x260) // flex spi LUT 24
#define FLEX_SPI_LUT25       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x264) // flex spi LUT 25
#define FLEX_SPI_LUT26       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x268) // flex spi LUT 26
#define FLEX_SPI_LUT27       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x26c) // flex spi LUT 27
#define FLEX_SPI_LUT28       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x270) // flex spi LUT 28
#define FLEX_SPI_LUT29       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x274) // flex spi LUT 29
#define FLEX_SPI_LUT30       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x278) // flex spi LUT 30
#define FLEX_SPI_LUT31       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x27c) // flex spi LUT 31
#define FLEX_SPI_LUT32       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x280) // flex spi LUT 32
#define FLEX_SPI_LUT33       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x284) // flex spi LUT 33
#define FLEX_SPI_LUT34       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x288) // flex spi LUT 34
#define FLEX_SPI_LUT35       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x28c) // flex spi LUT 35
#define FLEX_SPI_LUT36       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x290) // flex spi LUT 36
#define FLEX_SPI_LUT37       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x294) // flex spi LUT 37
#define FLEX_SPI_LUT38       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x298) // flex spi LUT 38
#define FLEX_SPI_LUT39       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x29c) // flex spi LUT 39
#define FLEX_SPI_LUT40       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2a0) // flex spi LUT 40
#define FLEX_SPI_LUT41       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2a4) // flex spi LUT 41
#define FLEX_SPI_LUT42       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2a8) // flex spi LUT 42
#define FLEX_SPI_LUT43       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2ac) // flex spi LUT 43
#define FLEX_SPI_LUT44       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2b0) // flex spi LUT 44
#define FLEX_SPI_LUT45       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2b4) // flex spi LUT 45
#define FLEX_SPI_LUT46       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2b8) // flex spi LUT 46
#define FLEX_SPI_LUT47       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2bc) // flex spi LUT 47
#define FLEX_SPI_LUT48       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2c0) // flex spi LUT 48
#define FLEX_SPI_LUT49       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2c4) // flex spi LUT 49
#define FLEX_SPI_LUT50       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2c8) // flex spi LUT 50
#define FLEX_SPI_LUT51       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2cc) // flex spi LUT 51
#define FLEX_SPI_LUT52       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2d0) // flex spi LUT 52
#define FLEX_SPI_LUT53       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2d4) // flex spi LUT 53
#define FLEX_SPI_LUT54       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2d8) // flex spi LUT 54
#define FLEX_SPI_LUT55       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2dc) // flex spi LUT 55
#define FLEX_SPI_LUT56       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2e0) // flex spi LUT 56
#define FLEX_SPI_LUT57       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2e4) // flex spi LUT 57
#define FLEX_SPI_LUT58       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2e8) // flex spi LUT 58
#define FLEX_SPI_LUT59       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2ec) // flex spi LUT 59
#define FLEX_SPI_LUT60       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2f0) // flex spi LUT 60
#define FLEX_SPI_LUT61       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2f4) // flex spi LUT 61
#define FLEX_SPI_LUT62       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2f8) // flex spi LUT 62
#define FLEX_SPI_LUT63       *(volatile unsigned long *)(FLEX_SPI_BLOCK + 0x2fc) // flex spi LUT 63

#define FLEX_SPI_LUT_ENTRIES 64

#if FLEX_SPI_INTERFACES > 1
    #define FLEX_SPI2_MCR0        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x000)  // flex spi2 module control register 0
    #define FLEX_SPI2_MCR1        *(unsigned long *)(FLEX_SPI2_BLOCK + 0x004)  // flex spi2 module control register 1
    #define FLEX_SPI2_MCR2        *(unsigned long *)(FLEX_SPI2_BLOCK + 0x008)  // flex spi2 module control register 2
    #define FLEX_SPI2_AHBCR       *(unsigned long *)(FLEX_SPI2_BLOCK + 0x00c)  // flex spi2 AHB bus control register
    #define FLEX_SPI2_INTEN       *(unsigned long *)(FLEX_SPI2_BLOCK + 0x010)  // flex spi2 interrupt enable register
    #define FLEX_SPI2_INTR        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x014) // flex spi2 interrupt register (write '1' to clear)
    #define FLEX_SPI2_LUTKEY      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x018) // flex spi2 LUT key register
    #define FLEX_SPI2_LUTCR       *(unsigned long *)(FLEX_SPI2_BLOCK + 0x01c)  // flex spi2 LUT control register
    #define FLEX_SPI2_AHBRXBUF0CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x020) // flex spi2 AHB rx buffer 0 control register 0
    #define FLEX_SPI2_AHBRXBUF1CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x024) // flex spi2 AHB rx buffer 1 control register 0
    #define FLEX_SPI2_AHBRXBUF2CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x028) // flex spi2 AHB rx buffer 1 control register 0
    #define FLEX_SPI2_AHBRXBUF3CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x02c) // flex spi2 AHB rx buffer 1 control register 0
    #define FLEX_SPI2_FLSHA1CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x060)  // flex spi2 flash A1 control register 0
    #define FLEX_SPI2_FLSHA2CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x064)  // flex spi2 flash A2 control register 0
    #define FLEX_SPI2_FLSHB1CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x068)  // flex spi2 flash B1 control register 0
    #define FLEX_SPI2_FLSHB2CR0   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x06c)  // flex spi2 flash B2 control register 0
    #define FLEX_SPI2_FLSHA1CR1   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x070)  // flex spi2 flash A1 control register 1
    #define FLEX_SPI2_FLSHA2CR1   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x074)  // flex spi2 flash A2 control register 1
    #define FLEX_SPI2_FLSHB1CR1   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x078)  // flex spi2 flash B1 control register 1
    #define FLEX_SPI2_FLSHB2CR1   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x07c)  // flex spi2 flash B2 control register 1
    #define FLEX_SPI2_FLSHA1CR2   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x080)  // flex spi2 flash A1 control register 2
    #define FLEX_SPI2_FLSHA2CR2   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x084)  // flex spi2 flash A2 control register 2
    #define FLEX_SPI2_FLSHB1CR2   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x088)  // flex spi2 flash B1 control register 2
    #define FLEX_SPI2_FLSHB2CR2   *(unsigned long *)(FLEX_SPI2_BLOCK + 0x08c)  // flex spi2 flash B2 control register 2
    #define FLEX_SPI2_FLSHCR4     *(unsigned long *)(FLEX_SPI2_BLOCK + 0x094)  // flex spi2 flash control register 4
    #define FLEX_SPI2_IPCR0       *(unsigned long *)(FLEX_SPI2_BLOCK + 0x0a0)  // flex spi2 IP control register 0
    #define FLEX_SPI2_IPCR1       *(unsigned long *)(FLEX_SPI2_BLOCK + 0x0a4)  // flex spi2 IP control register 1
    #define FLEX_SPI2_IPCMD       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0b0) // flex spi2 IP command register
    #define FLEX_SPI2_IPRXFCR     *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0b8) // flex spi2 IP RX FIFO control register
    #define FLEX_SPI2_IPTXFCR     *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0bc) // flex spi2 IP TX FIFO control register
    #define FLEX_SPI2_DLLACR      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0c0)  // flex spi2 DLL control register A
    #define FLEX_SPI2_DLLBCR      *(unsigned long *)(FLEX_SPI2_BLOCK + 0x0c4)  // flex spi2 DLL control register B
    #define FLEX_SPI2_STS0        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0e0) // flex spi2 status register 0 (read-only)
    #define FLEX_SPI2_STS1        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0e4) // flex spi2 status register 1 (read-only)
    #define FLEX_SPI2_STS2        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0e8) // flex spi2 status register 2 (read-only)
    #define FLEX_SPI2_AHBSPNDSTS  *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0ec) // flex spi2 AHB suspend status register (read-only)
    #define FLEX_SPI2_IPRXFSTS    *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0f0) // flex spi2 rx FIFO status register (read-only)
    #define FLEX_SPI2_IPTXFSTS    *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x0f4) // flex spi2 tx FIFO status register (read-only)
    #define FLEX_SPI2_RFDR0_ADD   (volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x100)
    #define FLEX_SPI2_RFDR0       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x100) // flex spi2 IP rx FIFO data register 0 (read-only)
    #define FLEX_SPI2_RFDR1       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x104) // flex spi2 IP rx FIFO data register 1 (read-only)
    #define FLEX_SPI2_RFDR2       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x108) // flex spi2 IP rx FIFO data register 2 (read-only)
    #define FLEX_SPI2_RFDR3       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x10c) // flex spi2 IP rx FIFO data register 3 (read-only)
    #define FLEX_SPI2_RFDR4       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x110) // flex spi2 IP rx FIFO data register 4 (read-only)
    #define FLEX_SPI2_RFDR5       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x114) // flex spi2 IP rx FIFO data register 5 (read-only)
    #define FLEX_SPI2_RFDR6       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x118) // flex spi2 IP rx FIFO data register 6 (read-only)
    #define FLEX_SPI2_RFDR7       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x11c) // flex spi2 IP rx FIFO data register 7 (read-only)
    #define FLEX_SPI2_RFDR8       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x120) // flex spi2 IP rx FIFO data register 8 (read-only)
    #define FLEX_SPI2_RFDR9       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x124) // flex spi2 IP rx FIFO data register 9 (read-only)
    #define FLEX_SPI2_RFDR10      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x128) // flex spi2 IP rx FIFO data register 10 (read-only)
    #define FLEX_SPI2_RFDR11      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x12c) // flex spi2 IP rx FIFO data register 11 (read-only)
    #define FLEX_SPI2_RFDR12      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x130) // flex spi2 IP rx FIFO data register 12 (read-only)
    #define FLEX_SPI2_RFDR13      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x134) // flex spi2 IP rx FIFO data register 13 (read-only)
    #define FLEX_SPI2_RFDR14      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x138) // flex spi2 IP rx FIFO data register 14 (read-only)
    #define FLEX_SPI2_RFDR15      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x13c) // flex spi2 IP rx FIFO data register 15 (read-only)
    #define FLEX_SPI2_RFDR16      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x140) // flex spi2 IP rx FIFO data register 16 (read-only)
    #define FLEX_SPI2_RFDR17      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x144) // flex spi2 IP rx FIFO data register 17 (read-only)
    #define FLEX_SPI2_RFDR18      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x148) // flex spi2 IP rx FIFO data register 18 (read-only)
    #define FLEX_SPI2_RFDR19      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x14c) // flex spi2 IP rx FIFO data register 19 (read-only)
    #define FLEX_SPI2_RFDR20      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x150) // flex spi2 IP rx FIFO data register 20 (read-only)
    #define FLEX_SPI2_RFDR21      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x154) // flex spi2 IP rx FIFO data register 21 (read-only)
    #define FLEX_SPI2_RFDR22      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x158) // flex spi2 IP rx FIFO data register 22 (read-only)
    #define FLEX_SPI2_RFDR23      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x15c) // flex spi2 IP rx FIFO data register 23 (read-only)
    #define FLEX_SPI2_RFDR24      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x160) // flex spi2 IP rx FIFO data register 24 (read-only)
    #define FLEX_SPI2_RFDR25      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x164) // flex spi2 IP rx FIFO data register 25 (read-only)
    #define FLEX_SPI2_RFDR26      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x168) // flex spi2 IP rx FIFO data register 26 (read-only)
    #define FLEX_SPI2_RFDR27      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x16c) // flex spi2 IP rx FIFO data register 27 (read-only)
    #define FLEX_SPI2_RFDR28      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x170) // flex spi2 IP rx FIFO data register 28 (read-only)
    #define FLEX_SPI2_RFDR29      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x174) // flex spi2 IP rx FIFO data register 29 (read-only)
    #define FLEX_SPI2_RFDR30      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x178) // flex spi2 IP rx FIFO data register 30 (read-only)
    #define FLEX_SPI2_RFDR31      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x17c) // flex spi2 IP rx FIFO data register 31 (read-only)
    #define FLEX_SPI2_TFDR0_ADD   (volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x180)
    #define FLEX_SPI2_TFDR0       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x180) // flex spi2 IP tx FIFO data register 0 (write-only)
    #define FLEX_SPI2_TFDR1       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x184) // flex spi2 IP tx FIFO data register 1 (write-only)
    #define FLEX_SPI2_TFDR2       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x188) // flex spi2 IP tx FIFO data register 2 (write-only)
    #define FLEX_SPI2_TFDR3       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x18c) // flex spi2 IP tx FIFO data register 3 (write-only)
    #define FLEX_SPI2_TFDR4       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x190) // flex spi2 IP tx FIFO data register 4 (write-only)
    #define FLEX_SPI2_TFDR5       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x194) // flex spi2 IP tx FIFO data register 5 (write-only)
    #define FLEX_SPI2_TFDR6       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x198) // flex spi2 IP tx FIFO data register 6 (write-only)
    #define FLEX_SPI2_TFDR7       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x19c) // flex spi2 IP tx FIFO data register 7 (write-only)
    #define FLEX_SPI2_TFDR8       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1a0) // flex spi2 IP tx FIFO data register 8 (write-only)
    #define FLEX_SPI2_TFDR9       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1a4) // flex spi2 IP tx FIFO data register 9 (write-only)
    #define FLEX_SPI2_TFDR10      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1a8) // flex spi2 IP tx FIFO data register 10 (write-only)
    #define FLEX_SPI2_TFDR11      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1ac) // flex spi2 IP tx FIFO data register 11 (write-only)
    #define FLEX_SPI2_TFDR12      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1b0) // flex spi2 IP tx FIFO data register 12 (write-only)
    #define FLEX_SPI2_TFDR13      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1b4) // flex spi2 IP tx FIFO data register 13 (write-only)
    #define FLEX_SPI2_TFDR14      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1b8) // flex spi2 IP tx FIFO data register 14 (write-only)
    #define FLEX_SPI2_TFDR15      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1bc) // flex spi2 IP tx FIFO data register 15 (write-only)
    #define FLEX_SPI2_TFDR16      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1c0) // flex spi2 IP tx FIFO data register 16 (write-only)
    #define FLEX_SPI2_TFDR17      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1c4) // flex spi2 IP tx FIFO data register 17 (write-only)
    #define FLEX_SPI2_TFDR18      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1c8) // flex spi2 IP tx FIFO data register 18 (write-only)
    #define FLEX_SPI2_TFDR19      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1cc) // flex spi2 IP tx FIFO data register 19 (write-only)
    #define FLEX_SPI2_TFDR20      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1d0) // flex spi2 IP tx FIFO data register 20 (write-only)
    #define FLEX_SPI2_TFDR21      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1d4) // flex spi2 IP tx FIFO data register 21 (write-only)
    #define FLEX_SPI2_TFDR22      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1d8) // flex spi2 IP tx FIFO data register 22 (write-only)
    #define FLEX_SPI2_TFDR23      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1dc) // flex spi2 IP tx FIFO data register 23 (write-only)
    #define FLEX_SPI2_TFDR24      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1e0) // flex spi2 IP tx FIFO data register 24 (write-only)
    #define FLEX_SPI2_TFDR25      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1e4) // flex spi2 IP tx FIFO data register 25 (write-only)
    #define FLEX_SPI2_TFDR26      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1e8) // flex spi2 IP tx FIFO data register 26 (write-only)
    #define FLEX_SPI2_TFDR27      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1ec) // flex spi2 IP tx FIFO data register 27 (write-only)
    #define FLEX_SPI2_TFDR28      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1f0) // flex spi2 IP tx FIFO data register 28 (write-only)
    #define FLEX_SPI2_TFDR29      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1f4) // flex spi2 IP tx FIFO data register 29 (write-only)
    #define FLEX_SPI2_TFDR30      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1f8) // flex spi2 IP tx FIFO data register 30 (write-only)
    #define FLEX_SPI2_TFDR31      *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x1fc) // flex spi2 IP tx FIFO data register 31 (write-only)
    #define FLEX_SPI2_LUT0_ADD    (volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x200)
    #define FLEX_SPI2_LUT0        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x200) // flex spi2 LUT 0
    #define FLEX_SPI2_LUT1        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x204) // flex spi2 LUT 1
    #define FLEX_SPI2_LUT2        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x208) // flex spi2 LUT 2
    #define FLEX_SPI2_LUT3        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x20c) // flex spi2 LUT 3
    #define FLEX_SPI2_LUT4        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x210) // flex spi2 LUT 4
    #define FLEX_SPI2_LUT5        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x214) // flex spi2 LUT 5
    #define FLEX_SPI2_LUT6        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x218) // flex spi2 LUT 6
    #define FLEX_SPI2_LUT7        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x21c) // flex spi2 LUT 7
    #define FLEX_SPI2_LUT8        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x220) // flex spi2 LUT 8
    #define FLEX_SPI2_LUT9        *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x224) // flex spi2 LUT 9
    #define FLEX_SPI2_LUT10       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x228) // flex spi2 LUT 10
    #define FLEX_SPI2_LUT11       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x22c) // flex spi2 LUT 11
    #define FLEX_SPI2_LUT12       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x230) // flex spi2 LUT 12
    #define FLEX_SPI2_LUT13       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x234) // flex spi2 LUT 13
    #define FLEX_SPI2_LUT14       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x238) // flex spi2 LUT 14
    #define FLEX_SPI2_LUT15       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x23c) // flex spi2 LUT 15
    #define FLEX_SPI2_LUT16       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x240) // flex spi2 LUT 16
    #define FLEX_SPI2_LUT17       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x244) // flex spi2 LUT 17
    #define FLEX_SPI2_LUT18       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x248) // flex spi2 LUT 18
    #define FLEX_SPI2_LUT19       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x24c) // flex spi2 LUT 19
    #define FLEX_SPI2_LUT20       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x250) // flex spi2 LUT 20
    #define FLEX_SPI2_LUT21       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x254) // flex spi2 LUT 21
    #define FLEX_SPI2_LUT22       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x258) // flex spi2 LUT 22
    #define FLEX_SPI2_LUT23       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x25c) // flex spi2 LUT 23
    #define FLEX_SPI2_LUT24       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x260) // flex spi2 LUT 24
    #define FLEX_SPI2_LUT25       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x264) // flex spi2 LUT 25
    #define FLEX_SPI2_LUT26       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x268) // flex spi2 LUT 26
    #define FLEX_SPI2_LUT27       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x26c) // flex spi2 LUT 27
    #define FLEX_SPI2_LUT28       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x270) // flex spi2 LUT 28
    #define FLEX_SPI2_LUT29       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x274) // flex spi2 LUT 29
    #define FLEX_SPI2_LUT30       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x278) // flex spi2 LUT 30
    #define FLEX_SPI2_LUT31       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x27c) // flex spi2 LUT 31
    #define FLEX_SPI2_LUT32       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x280) // flex spi2 LUT 32
    #define FLEX_SPI2_LUT33       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x284) // flex spi2 LUT 33
    #define FLEX_SPI2_LUT34       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x288) // flex spi2 LUT 34
    #define FLEX_SPI2_LUT35       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x28c) // flex spi2 LUT 35
    #define FLEX_SPI2_LUT36       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x290) // flex spi2 LUT 36
    #define FLEX_SPI2_LUT37       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x294) // flex spi2 LUT 37
    #define FLEX_SPI2_LUT38       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x298) // flex spi2 LUT 38
    #define FLEX_SPI2_LUT39       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x29c) // flex spi2 LUT 39
    #define FLEX_SPI2_LUT40       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2a0) // flex spi2 LUT 40
    #define FLEX_SPI2_LUT41       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2a4) // flex spi2 LUT 41
    #define FLEX_SPI2_LUT42       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2a8) // flex spi2 LUT 42
    #define FLEX_SPI2_LUT43       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2ac) // flex spi2 LUT 43
    #define FLEX_SPI2_LUT44       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2b0) // flex spi2 LUT 44
    #define FLEX_SPI2_LUT45       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2b4) // flex spi2 LUT 45
    #define FLEX_SPI2_LUT46       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2b8) // flex spi2 LUT 46
    #define FLEX_SPI2_LUT47       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2bc) // flex spi2 LUT 47
    #define FLEX_SPI2_LUT48       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2c0) // flex spi2 LUT 48
    #define FLEX_SPI2_LUT49       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2c4) // flex spi2 LUT 49
    #define FLEX_SPI2_LUT50       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2c8) // flex spi2 LUT 50
    #define FLEX_SPI2_LUT51       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2cc) // flex spi2 LUT 51
    #define FLEX_SPI2_LUT52       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2d0) // flex spi2 LUT 52
    #define FLEX_SPI2_LUT53       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2d4) // flex spi2 LUT 53
    #define FLEX_SPI2_LUT54       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2d8) // flex spi2 LUT 54
    #define FLEX_SPI2_LUT55       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2dc) // flex spi2 LUT 55
    #define FLEX_SPI2_LUT56       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2e0) // flex spi2 LUT 56
    #define FLEX_SPI2_LUT57       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2e4) // flex spi2 LUT 57
    #define FLEX_SPI2_LUT58       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2e8) // flex spi2 LUT 58
    #define FLEX_SPI2_LUT59       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2ec) // flex spi2 LUT 59
    #define FLEX_SPI2_LUT60       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2f0) // flex spi2 LUT 60
    #define FLEX_SPI2_LUT61       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2f4) // flex spi2 LUT 61
    #define FLEX_SPI2_LUT62       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2f8) // flex spi2 LUT 62
    #define FLEX_SPI2_LUT63       *(volatile unsigned long *)(FLEX_SPI2_BLOCK + 0x2fc) // flex spi2 LUT 63
#endif

typedef struct st_iMX_FLEX_SPI
{
    volatile unsigned long MCR0;
    unsigned long MCR1;
    unsigned long MCR2;
    unsigned long AHBCR;
    unsigned long INTEN;
    volatile unsigned long INTR;
    volatile unsigned long LUTKEY;
    unsigned long LUTCR;
    unsigned long AHBRXBUF0CR0;
    unsigned long AHBRXBUF1CR0;
    unsigned long AHBRXBUF2CR0;
    unsigned long AHBRXBUF3CR0;
    unsigned long ulRes0[12];
    unsigned long FLSHA1CR0;
    unsigned long FLSHA2CR0;
    unsigned long FLSHB1CR0;
    unsigned long FLSHB2CR0;
    unsigned long FLSHA1CR1;
    unsigned long FLSHA2CR1;
    unsigned long FLSHB1CR1;
    unsigned long FLSHB2CR1;
    unsigned long FLSHA1CR2;
    unsigned long FLSHA2CR2;
    unsigned long FLSHB1CR2;
    unsigned long FLSHB2CR2;
    unsigned long ulRes1[1];
    unsigned long FLSHCR4;
    unsigned long ulRes2[2];
    unsigned long IPCR0;
    unsigned long IPCR1;
    unsigned long ulRes3[2];
    unsigned long IPCMD;
    unsigned long ulRes4[1];
    volatile unsigned long IPRXFCR;
    volatile unsigned long IPTXFCR;
    volatile unsigned long DLLACR;
    unsigned long DLLBCR;
    unsigned long ulRes5[6];
    volatile unsigned long STS0;
    volatile unsigned long STS1;
    volatile unsigned long STS2;
    volatile unsigned long AHBSPNDSTS;
    volatile unsigned long IPRXFSTS;
    volatile unsigned long IPTXFSTS;
    unsigned long ulRes6[2];
    volatile unsigned long RFDR0;
    volatile unsigned long RFDR1;
    volatile unsigned long RFDR2;
    volatile unsigned long RFDR3;
    volatile unsigned long RFDR4;
    volatile unsigned long RFDR5;
    volatile unsigned long RFDR6;
    volatile unsigned long RFDR7;
    volatile unsigned long RFDR8;
    volatile unsigned long RFDR9;
    volatile unsigned long RFDR10;
    volatile unsigned long RFDR11;
    volatile unsigned long RFDR12;
    volatile unsigned long RFDR13;
    volatile unsigned long RFDR14;
    volatile unsigned long RFDR15;
    volatile unsigned long RFDR16;
    volatile unsigned long RFDR17;
    volatile unsigned long RFDR18;
    volatile unsigned long RFDR19;
    volatile unsigned long RFDR20;
    volatile unsigned long RFDR21;
    volatile unsigned long RFDR22;
    volatile unsigned long RFDR23;
    volatile unsigned long RFDR24;
    volatile unsigned long RFDR25;
    volatile unsigned long RFDR26;
    volatile unsigned long RFDR27;
    volatile unsigned long RFDR28;
    volatile unsigned long RFDR29;
    volatile unsigned long RFDR30;
    volatile unsigned long RFDR31;
    volatile unsigned long TFDR0;
    volatile unsigned long TFDR1;
    volatile unsigned long TFDR2;
    volatile unsigned long TFDR3;
    volatile unsigned long TFDR4;
    volatile unsigned long TFDR5;
    volatile unsigned long TFDR6;
    volatile unsigned long TFDR7;
    volatile unsigned long TFDR8;
    volatile unsigned long TFDR9;
    volatile unsigned long TFDR10;
    volatile unsigned long TFDR11;
    volatile unsigned long TFDR12;
    volatile unsigned long TFDR13;
    volatile unsigned long TFDR14;
    volatile unsigned long TFDR15;
    volatile unsigned long TFDR16;
    volatile unsigned long TFDR17;
    volatile unsigned long TFDR18;
    volatile unsigned long TFDR19;
    volatile unsigned long TFDR20;
    volatile unsigned long TFDR21;
    volatile unsigned long TFDR22;
    volatile unsigned long TFDR23;
    volatile unsigned long TFDR24;
    volatile unsigned long TFDR25;
    volatile unsigned long TFDR26;
    volatile unsigned long TFDR27;
    volatile unsigned long TFDR28;
    volatile unsigned long TFDR29;
    volatile unsigned long TFDR30;
    volatile unsigned long TFDR31;
    volatile unsigned long LUT0;
    volatile unsigned long LUT1;
    volatile unsigned long LUT2;
    volatile unsigned long LUT3;
    volatile unsigned long LUT4;
    volatile unsigned long LUT5;
    volatile unsigned long LUT6;
    volatile unsigned long LUT7;
    volatile unsigned long LUT8;
    volatile unsigned long LUT9;
    volatile unsigned long LUT10;
    volatile unsigned long LUT11;
    volatile unsigned long LUT12;
    volatile unsigned long LUT13;
    volatile unsigned long LUT14;
    volatile unsigned long LUT15;
    volatile unsigned long LUT16;
    volatile unsigned long LUT17;
    volatile unsigned long LUT18;
    volatile unsigned long LUT19;
    volatile unsigned long LUT20;
    volatile unsigned long LUT21;
    volatile unsigned long LUT22;
    volatile unsigned long LUT23;
    volatile unsigned long LUT24;
    volatile unsigned long LUT25;
    volatile unsigned long LUT26;
    volatile unsigned long LUT27;
    volatile unsigned long LUT28;
    volatile unsigned long LUT29;
    volatile unsigned long LUT30;
    volatile unsigned long LUT31;
    volatile unsigned long LUT32;
    volatile unsigned long LUT33;
    volatile unsigned long LUT34;
    volatile unsigned long LUT35;
    volatile unsigned long LUT36;
    volatile unsigned long LUT37;
    volatile unsigned long LUT38;
    volatile unsigned long LUT39;
    volatile unsigned long LUT40;
    volatile unsigned long LUT41;
    volatile unsigned long LUT42;
    volatile unsigned long LUT43;
    volatile unsigned long LUT44;
    volatile unsigned long LUT45;
    volatile unsigned long LUT46;
    volatile unsigned long LUT47;
    volatile unsigned long LUT48;
    volatile unsigned long LUT49;
    volatile unsigned long LUT50;
    volatile unsigned long LUT51;
    volatile unsigned long LUT52;
    volatile unsigned long LUT53;
    volatile unsigned long LUT54;
    volatile unsigned long LUT55;
    volatile unsigned long LUT56;
    volatile unsigned long LUT57;
    volatile unsigned long LUT58;
    volatile unsigned long LUT59;
    volatile unsigned long LUT60;
    volatile unsigned long LUT61;
    volatile unsigned long LUT62;
    volatile unsigned long LUT63;
} iMX_FLEX_SPI;


//#define _SUPRESS_REPEAT_DATA                                           // repeated data not supressed due to problems when flashing memory at the same time

typedef struct stKINETIS_USB_BD
{
    unsigned long  ulUSB_BDControl;                                      // this is saved in little-endian format
    unsigned char *ptrUSB_BD_Data;                                       // this is saved in little-endian format
} KINETIS_USB_BD;

#define TOK_PID_0             0x00000004                                 // big-endian long word defines
#define BDT_STALL             0x00000004                                 // issue STALL handshake
#define TOK_PID_1             0x00000008
#define DTS                   0x00000008                                 // Data Toggle Synchronisation
#define TOK_PID_2             0x00000010
#define NINC                  0x00000010                                 // No INCrement bit - DMA engine doesn't increment address after each byte transfer
#define TOK_PID_3             0x00000020
#define KEEP_OWNERSHIP        0x00000020                                 // KEEP ownership at USB-FS
#define DATA_1                0x00000040
#define OWN                   0x00000080                                 // USB-FS has exclusive ownership of the buffer descriptor
#define USB_BYTE_CNT_MASK     0x03ff0000    
#define USB_CNT_SHIFT         16
#define RX_PID_MASK           (TOK_PID_3 | TOK_PID_2 | TOK_PID_1 | TOK_PID_0)
#define RX_PID_SHIFT          2
#define USB_USER_FLAG_1       0x10000000                                 // these are not used by the USB controller and may be allocated for driver use
#define USB_USER_FLAG_2       0x20000000
#define USB_USER_FLAG_3       0x30000000
#define USB_USER_FLAG_4       0x80000000

#define CONTROL_DATA_TOGGLE_REVERSED   USB_USER_FLAG_1                   // used to signal that a control endpoint is presently receiving DATA1 OUT frames in the even receiver buffer


// BDT construction
// 4 BDs per endpoint
// Rx - even
// Rx - odd
// Tx - even
// Tx - odd
#define USB_BD_SIZE          sizeof(KINETIS_USB_BD)                      // size in bytes of a single USB buffer descriptor
#define ENDPOINT_BD_SIZE     (4 * USB_BD_SIZE)
#define OFFSET_RX_EVEN       0                                           // offset in long word steps
#define OFFSET_RX_ODD        1
#define OFFSET_TX_EVEN       2
#define OFFSET_TX_ODD        3

typedef struct stKINETIS_USB_ENDPOINT_BD
{
    KINETIS_USB_BD usb_bd_rx_even;
    KINETIS_USB_BD usb_bd_rx_odd;
    KINETIS_USB_BD usb_bd_tx_even;
    KINETIS_USB_BD usb_bd_tx_odd;
} KINETIS_USB_ENDPOINT_BD;

typedef struct stUSB_END_POINT
{
    unsigned long ulNextRxData0;
    unsigned long ulNextTxData0;
    unsigned long ulEndpointSize;                                        // contains size of endpoint plus some control flags
} USB_END_POINT;

#define ALTERNATE_TX_BUFFER    DATA_1                                    // any bit not clashing with the length in the buffer descriptor control word (used as SW flag)
#define RX_DATA_TOGGLE         OWN                                       // any bit not clashing with DATA_1 in the buffer descriptor control word (used as SW flag)

#define USB_FIFO_BUFFER_DEPTH  2                                         // Kinetis has two rx and tx buffers per endpoint

#define NUMBER_OF_USBHS_ENDPOINTS 8                                      // 8 high speed end points available
#define NUMBER_OF_USB_ENDPOINTS   (NUMBER_OF_USBHS_ENDPOINTS)

typedef struct stUSB_HS_TRANSFER_OVERLAY
{
    unsigned long ulNextdTD_pointer;                                     // next dTD in the linked list - this is the only field that software may modify when the dTD is active
    volatile unsigned long ul_dtToken;                                   // number of bytes to be transfered (maximum of 16k is recommended due to complications with larger sizes)
    volatile unsigned long ulBufferPointerPage[5];                       // individual pages of a data buffer
    unsigned char *ptrBufferStart;                                       // this location is defined by software and used to keep a pointer to the start of the first page buffer
} USB_HS_TRANSFER_OVERLAY;


// Device endpoint queue header is 64 bytes in size (including padding at the end)
//
typedef struct stKINETIS_USBHS_ENDPOINT_QUEUE_HEADER
{
    volatile unsigned long ulCapabilities;                               // should not be written when the endpoint is active
    volatile USB_HS_TRANSFER_OVERLAY *CurrentdTD_pointer;                // this is used and modified by the controller
    USB_HS_TRANSFER_OVERLAY dTD;                                         // the transfer overlay is copied to the queue header overlay by the controller and software shoudl not write this area again until a transfer expires
    unsigned char ucSetupBuffer[8];                                      // dedicated storage area for fixed length 8 byte setup token content (only used by rx queue head)
    USB_HS_TRANSFER_OVERLAY *my_dTD;                                     // this location is defined by software and used to keep track of the transfer block belonging to the queue header
    unsigned long ulEndpointLength;                                      // this location is defined by software and used to store the endpoint's buffer length
    unsigned long ulBufferLength;                                        // this location is defined by software and used to store the length of the endpoint's buffer
    unsigned long ulRes2[1];
} KINETIS_USBHS_ENDPOINT_QUEUE_HEADER;

#define ENDPOINT_QUEUE_HEADER_CTL_IOS                 0x00008000         // (ulCapabilities) interrupt on setup reception
#define ENDPOINT_QUEUE_HEADER_MAX_PACKET_LEN_SHIFT    16
#define ENDPOINT_QUEUE_HEADER_MAX_PACKET_LEN_MASK     0x07ff0000         // (ulCapabilities) max length mask - maximum value that may be used is 1024
#define ENDPOINT_QUEUE_HEADER_ZLT                     0x20000000         // (ulCapabilities) disable zero length packet
#define ENDPOINT_QUEUE_HEADER_MULT_1                  0x40000000         // (ulCapabilities) execute 1 ISO transaction [wMaxPacketSize 1..1024]
#define ENDPOINT_QUEUE_HEADER_MULT_2                  0x80000000         // (ulCapabilities) execute 2 ISO transactions [wMaxPacketSize 513..1024]
#define ENDPOINT_QUEUE_HEADER_MULT_3                  0xc0000000         // (ulCapabilities) execute 3 ISO transactions [wMaxPacketSize 683..1024]
#define ENDPOINT_QUEUE_HEADER_NEXT_ADD_MASK           0xffffffe0         // (ulNextdTD_pointer) next dTD pointer mask
#define ENDPOINT_QUEUE_HEADER_NEXT_INVALID            0x00000001         // (ulNextdTD_pointer) next is invalid - no more entries
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_MASK       0x000000ff         // (ul_dtToken)
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_TR_ERROR   0x00000008         // (ul_dtToken) transaction error - set by device
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_DB_ERROR   0x00000020         // (ul_dtToken) data buffer error - set by device
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_HALTED     0x00000040         // (ul_dtToken) halted - set by device (also active is cleared by device)
#define ENDPOINT_QUEUE_HEADER_TOKEN_STATUS_ACTIVE     0x00000080         // (ul_dtToken) active - set by processor
#define ENDPOINT_QUEUE_HEADER_TOKEN_MULTO_1           0x00000400         // (ul_dtToken) multiplier override - only used by isochronous IN endpoints
#define ENDPOINT_QUEUE_HEADER_TOKEN_MULTO_2           0x00000800
#define ENDPOINT_QUEUE_HEADER_TOKEN_MULTO_3           0x00000c00
#define ENDPOINT_QUEUE_HEADER_TOKEN_IOC               0x00008000         // (ul_dtToken) interrupt on complete
#define ENDPOINT_QUEUE_HEADER_TOKEN_TOTAL_BYTES_SHIFT 16                 // (ul_dtToken)
#define ENDPOINT_QUEUE_HEADER_BUFFER_POINTER_MASK     0xfffff000         // (ulBufferPointerPage) pointer to 4k page offset in memory
#define ENDPOINT_QUEUE_HEADER_BUFFER_FRAME_MASK       0x000007ff         // (ulBufferPointerPage) frame buffer number mask when packet finishes
#define ENDPOINT_QUEUE_HEADER_BUFFER_OFFSET_MASK      0x00000fff         // (ulBufferPointerPage) current offset into the 4k buffer where the packet begins



typedef struct stUSB_HS_HOST_TRANSFER_OVERLAY                            // queue element transfer descriptor (qTD) - 32 byte length
{
    volatile unsigned char *ptrNext_qTD;                                 // pointer to another transfer element descriptor
    volatile unsigned char *ptrAlternateNext_qTD;                        // alternate next qTD pointer
    volatile unsigned long  ulControl;                                   // qTD token with details for execution of USB transaction
    volatile unsigned long ulBufferPointerPage[5];                       // individual pages of a data buffer (page 0 can be byte aligned but pages 1,2,3,4 mst be 4k aligned)
} USB_HS_HOST_TRANSFER_OVERLAY;

#define HOST_OVERLAY_CONTROL_DT                       0x80000000         // data toggle control (depends on the data toggle control bit in the queue head)
#define HOST_OVERLAY_CONTROL_TOTAL_BYTES_MASK         0x7fff0000         // total number of bytes to be moved with this transfer descriptor (decremented by the controller) - max. 0x5000 (5 x 4k)
#define HOST_OVERLAY_CONTROL_TOTAL_BYTES__SHIFT       16
#define HOST_OVERLAY_CONTROL_IOC                      0x00008000         // interrupt on complete
#define HOST_OVERLAY_CONTROL_C_PAGE_MASK              0x00007000         // current page - index into the qTD buffer pointer list (0..4)
#define HOST_OVERLAY_CONTROL_C_ERR_MASK               0x00000c00         // error counter mask
#define HOST_OVERLAY_CONTROL_PID_CODE_OUT             0x00000000         // PID code for an OUT PID
#define HOST_OVERLAY_CONTROL_PID_CODE_IN              0x00000100         // PID code for an IN PID
#define HOST_OVERLAY_CONTROL_PID_CODE_SETUP           0x00000200         // PID code for an SETUP PID
#define HOST_OVERLAY_CONTROL_PID_CODE_MASK            0x00000300
#define HOST_OVERLAY_CONTROL_STATUS_ACTIVE            0x00000080         // this qTD operation is in progess
#define HOST_OVERLAY_CONTROL_STATUS_HALTED            0x00000040         // halted due to error
#define HOST_OVERLAY_CONTROL_STATUS_DATA_BUFFER_ERROR 0x00000020         // error due to overrun of incoming data
#define HOST_OVERLAY_CONTROL_STATUS_BABBLE            0x00000010         // babble detected (also halt state will be set)
#define HOST_OVERLAY_CONTROL_STATUS_TRANSACTION_ERROR 0x00000008         // timeout, CRC, Bad PID, etc. error detected as part of transaction
#define HOST_OVERLAY_CONTROL_STATUS_MISSED_uFRAME     0x00000004         // missed micro-frame
#define HOST_OVERLAY_CONTROL_STATUS_SPLITXSTATE       0x00000002         // split transaction state
#define HOST_OVERLAY_CONTROL_STATUSPING               0x00000001         // ping state
#define HOST_OVERLAY_CONTROL_STATUS_MASK              0x000000ff

// Host endpoint queue header is 64 bytes in size (including padding at the end)
//
typedef struct stKINETIS_USBHS_HOST_ENDPOINT_QUEUE_HEADER
{
    unsigned long ulQueueheadWord0;                                      // queue head horizontal link pointer with type and terminate
    unsigned long ulHostCharacteristics;                                 // characteristics
    unsigned long ulHostCapabilities;                                    // capabilities
    volatile unsigned char *ptrCurrent_qTD;                              // current element transaction descriptor link pointer ([31..5]
    USB_HS_HOST_TRANSFER_OVERLAY host_transfer_overlay;                  // transfer overlay-queue head

    USB_HS_HOST_TRANSFER_OVERLAY *my_HostdTD;                            // this location is defined by software and used to keep track of the transfer block belonging to the queue header
    unsigned long ulBuffer0;                                             // location used by software to keep track of the first data buffer
    unsigned long ulFirmwareFlags;                                       // location used by the software for control purposes
    unsigned long ulRes0;
} KINETIS_USBHS_HOST_ENDPOINT_QUEUE_HEADER;

#define PERIODIC_ENDPOINT_IGNORE                      0x00000001         // firmware flags
#define ASYNC_ENDPOINT_IGNORE                         0x00000002         // ignore this endpoint when handling async interrupts

#define HOST_QUEUE_HEAD_HORIZONTAL_LINK_POINTER_MASK  0xffffffe0         // queue head horizontal link pointer address (32 byte aligned)
#define HOST_QUEUE_HEAD_WORD0_TYPE_iTD                0x00000000         // item type - isochronous transfer descriptor
#define HOST_QUEUE_HEAD_WORD0_TYPE_QH                 0x00000002         // item type - queue head
#define HOST_QUEUE_HEAD_WORD0_TYPE_QsiTD              0x00000004         // item type - split transaction isochronous transfer descriptor
#define HOST_QUEUE_HEAD_WORD0_TYPE_FSTN               0x00000006         // item type - frame span traversal node
#define HOST_QUEUE_HEAD_WORD0_T                       0x00000001         // terminate (last QH pointer is invalid) used only by periodic list

#define HOST_CHARACTERISTICS_RL_MASK                  0xf0000000         // nak count reload mask
#define HOST_CHARACTERISTICS_C                        0x08000000         // control endpoint flag (set only for non-HS control endpoints)
#define HOST_CHARACTERISTICS_MAX_PACKET_LENGTH_MASK   0x07ff0000         // maximum packet length (1024 max.)
#define HOST_CHARACTERISTICS_MAX_PACKET_LENGTH_SHIFT  16
#define HOST_CHARACTERISTICS_H                        0x00008000         // head of reclamation list flag
#define HOST_CHARACTERISTICS_DTC                      0x00004000         // data toggle control
#define HOST_CHARACTERISTICS_EP_SPEED_FS              0x00000000         // endpoint speed 12 MBit/s
#define HOST_CHARACTERISTICS_EP_SPEED_LS              0x00001000         // endpoint speed 1.5 MBit/s
#define HOST_CHARACTERISTICS_EP_SPEED_HS              0x00002000         // endpoint speed 480 MBit/s
#define HOST_CHARACTERISTICS_EP_SPEED_MASK            0x00003000         // endpoint speed mask
#define HOST_CHARACTERISTICS_ENDPOINT_MASK            0x00000f00         // endpoint number mask
#define HOST_CHARACTERISTICS_ENDPOINT_SHIFT           8
#define HOST_CHARACTERISTICS_I                        0x00000080         // inactive on next transaction (used only by periodic scheduling of full and low-speed endpoints)
#define HOST_CHARACTERISTICS_DEVICE_ADDRESS_MASK      0x0000007f         // device address mask

#define HOST_CAPABILITIES_MULT_1_TRANSACTION          0x40000000         // high-bandwidth pipe multiplier - one transaction to be issued for this endpoint per micro-frame
#define HOST_CAPABILITIES_MULT_2_TRANSACTIONS         0x80000000         // high-bandwidth pipe multiplier - two transactions to be issued for this endpoint per micro-frame
#define HOST_CAPABILITIES_MULT_3_TRANSACTIONS         0xc0000000         // high-bandwidth pipe multiplier - three transactions to be issued for this endpoint per micro-frame
#define HOST_CAPABILITIES_PORT_NUMBER_MASK            0x3f800000         // port number used only for full or low speed devices - used in split transfer protocol
#define HOST_CAPABILITIES_HUB_ADDRESS_MASK            0x007f0000         // hub address used only for full or low speed devices - used in split transfer protocol
#define HOST_CAPABILITIES_uFRAME_C_MASK               0x0000ff00         // split completion mask
#define HOST_CAPABILITIES_uFRAME_S_MASK               0x000000ff         // interrupt schedule mask

#define HOST_OVERLAY_TERMINATE                        0x00000001


    #define USB_AUTO_TX                                                  // enable multiple frame transmission controlled by the high speed controller
    #define USB_DEVICE_FS    0
    #define USB_DEVICE_HS    1

    // MACRO for setting frame length to buffer descriptor
    //
    #define SET_FRAME_LENGTH(x)     ((x << USB_CNT_SHIFT) & USB_BYTE_CNT_MASK)

    // MACRO for transmitting USB data from generic USB routines
    //
    #define FNSEND_USB_DATA(pData, Len, iEndpoint, ptrUSB_HW)    fnTxUSBHS(pData, Len, iEndpoint, ptrUSB_HW)

    // MACRO for transmitting zero data packet to control endpoints from generic USB routines
    //
    #define FNSEND_ZERO_DATA(ptrUSB_HW, iEndpoint) \
    if (ptrUSB_HW->ucDeviceType == USB_DEVICE_HS) { \
        fnTxUSBHS(0, 0, iEndpoint, ptrUSB_HW); \
    } \
    else { \
        *ptrUSB_HW->ptr_ulUSB_BDControl = (unsigned long)(OWN | DTS | ptrUSB_HW->ptrEndpoint->ulNextTxData0); \
        _SIM_USB(0, USB_SIM_TX, iEndpoint, ptrUSB_HW); \
        ptrUSB_HW->ptrEndpoint->ulNextTxData0 ^= DATA_1; \
        ptrUSB_HW->ptrEndpoint->ulEndpointSize ^= ALTERNATE_TX_BUFFER; \
    }

    // MACRO for extracting frame length from a buffer descriptor
    //
    #define GET_FRAME_LENGTH()      (unsigned short)((ptUSB_BD->ulUSB_BDControl & USB_BYTE_CNT_MASK) >> USB_CNT_SHIFT)


#if defined USB_HOST_SUPPORT
    #if defined _WINDOWS
        extern void fnAddToken(unsigned char ucToken);
        extern void fnResetUSB_buffers(int iChannel);                    // simulator function
        #define _RESET_USB_BUFFERS(iChannel) fnResetUSB_buffers(iChannel)
    #else
        #define _RESET_USB_BUFFERS(iChannel)
    #endif
    // Reset the buffer use and toggle before sending
    //
    #if (HSUSB_CONTROLLERS > 1)
        #define fnPrepareSetup(ptrUSB_HW)        _RESET_USB_BUFFERS(ptrUSB_HW->ucController)
    #else
        #define fnPrepareSetup(ptrUSB_HW)        _RESET_USB_BUFFERS(0)
    #endif

    #define fnSetUSB_device_address(address)  fnSetHSUSB_device_add(address, ptrUSB_HW) // set the device address

    #define _USB_HOST_MODE()          ((ptrUSB_HW->ucModeType & USB_HOST_MODE) != 0)
#else
    #define _USB_HOST_MODE()          (0)
#endif

#define SET_CONTROL_DIRECTION(a,b)                                       // direction control not needed by Kinetis
#define CLEAR_SETUP(a)                                                   // for compatibility with generic driver
#define VALIDATE_NEW_CONFIGURATION()


// USBHS
//
#define USBHS0_ID            *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x000) // Peripheral ID Register (read-only)
#define USBHS0_HWGENERAL     *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x004) // General Hardware Parameters Register (read-only)
#define USBHS0_HWHOST        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x008) // Host Hardware Parameters Register (read-only)
#define USBHS0_HWDEVICE      *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x00c) // Device Hardware Parameters Register (read-only)
#define USBHS0_HWTXBUF       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x010) // Transmit Buffer Hardware Parameters Register (read-only)
#define USBHS0_HWRXBUF       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x014) // Receive Buffer Hardware Parameters Register (read-only) - reads zero

#define USBHS0_GPTIMER0LD    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x080) // General Purpose Timer 0 Load Register
#define USBHS0_GPTIMER0CTL   *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x084) // General Purpose Timer 0 Control Register
    #define USBHS_GPTIMERCTL_GPTCNT_MASK    0x00ffffff                   // current value of the running timer
    #define USBHS_GPTIMERCTL_MODE_SINGLE    0x00000000                   // single shot mode (stops after counting down to zero)
    #define USBHS_GPTIMERCTL_MODE_REPEAT    0x01000000                   // repeat mode (reloads and restarts automatically)
    #define USBHS_GPTIMERCTL_RST            0x40000000                   // write '1' to load counter value from USBHS_GPTIMERxLD
    #define USBHS_GPTIMERCTL_RUN            0x80000000                   // timer run enabled
#define USBHS0_GPTIMER1LD    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x088) // General Purpose Timer 1 Load Register
#define USBHS0_GPTIMER1CTL   *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x08c) // General Purpose Timer 1 Control Register
#define USBHS0_USB_SBUSCFG   *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x090) // System Bus Interface Configuration Register

#define USBHS0_HCIVERSION    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x100) // Host Controller Version and Capabilities Register (read-only)
  #define USBHS_HCIVERSION_CAPLENGTH_MASK   0x000000ff
  #define USBHS_HCIVERSION_HCIVERSION_SHIFT 16
#define USBHS0_HCSPARAMS     *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x104) // Host Controller Structural Parameters Register (read-only)
#define USBHS0_HCCPARAMS     *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x108) // Host Controller Capability Parameters Register (read-only)

#define USBHS0_DCIVERSION    *(volatile unsigned short *)(USBHS_BASE1_ADD + 0x122) // Device Controller Interface Version (read-only)
#define USBHS0_DCCPARAMS     *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x124) // Device Controller Capability Parameters (read-only)
  #define USBHS_DCCPARAMS_DEN_MASK 0x0000001f                            // device endpoint number
  #define USBHS_DCCPARAMS_DC       0x00000080                            // device capable of USB2.0 device
  #define USBHS_DCCPARAMS_HC       0x00000100                            // device capable of EHCI compatible USB2.0 host

#define USBHS0_USBCMD        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x140) // USB Command Register
  #define USBHS_USBCMD_RS        0x00000001                              // run/stop
  #define USBHS_USBCMD_RST       0x00000002                              // controller reset
  #define USBHS_USBCMD_FS_1024   0x00000000                              // frame list size 1024 elements (4096 bytes)
  #define USBHS_USBCMD_FS_512    0x00000004                              // frame list size 512 elements (2048 bytes)
  #define USBHS_USBCMD_FS_256    0x00000008                              // frame list size 256 elements (1024 bytes)
  #define USBHS_USBCMD_FS_128    0x0000000c                              // frame list size 128 elements (512 bytes)
  #define USBHS_USBCMD_FS_64     0x00008000                              // frame list size 64 elements (256 bytes)
  #define USBHS_USBCMD_FS_32     0x00008004                              // frame list size 32 elements (128 bytes)
  #define USBHS_USBCMD_FS_16     0x00008008                              // frame list size 16 elements (64 bytes)
  #define USBHS_USBCMD_FS_8      0x0000800c                              // frame list size 8 elements (32 bytes)
  #define USBHS_USBCMD_PSE       0x00000010                              // periodic schedule enable
  #define USBHS_USBCMD_ASE       0x00000020                              // asynchronous schedule enable
  #define USBHS_USBCMD_IAA       0x00000040                              // interrupt on asynch advance doorbell
  #define USBHS_USBCMD_ASP1      0x00000100                              // asynchronous schedule park mode count - 1 (zero is not allowed when park mode is enabled)
  #define USBHS_USBCMD_ASP2      0x00000200                              // asynchronous schedule park mode count - 2
  #define USBHS_USBCMD_ASP3      0x00000300                              // asynchronous schedule park mode count - 3
  #define USBHS_USBCMD_ASPE      0x00000800                              // asynchronous schedule park mode enabled
  #define USBHS_USBCMD_SUTW      0x00002000                              // setup TripWire
  #define USBHS_USBCMD_ATDTW     0x00004000                              // add dTD TripWire
  #define USBHS_USBCMD_FS2       0x00008000                              // frame list size 2
  #define USBHS_USBCMD_ITC_IMM   0x00000000                              // interrupt threshold control - immediate
  #define USBHS_USBCMD_ITC_1_MF  0x00010000                              // interrupt threshold control - maximum rate 1 microframe
  #define USBHS_USBCMD_ITC_2_MF  0x00020000                              // interrupt threshold control - maximum rate 2 microframes
  #define USBHS_USBCMD_ITC_4_MF  0x00040000                              // interrupt threshold control - maximum rate 4 microframes
  #define USBHS_USBCMD_ITC_8_MF  0x00080000                              // interrupt threshold control - maximum rate 8 microframes
  #define USBHS_USBCMD_ITC_16_MF 0x00100000                              // interrupt threshold control - maximum rate 16 microframes
  #define USBHS_USBCMD_ITC_32_MF 0x00200000                              // interrupt threshold control - maximum rate 32 microframes
  #define USBHS_USBCMD_ITC_64_MF 0x00400000                              // interrupt threshold control - maximum rate 64 microframes
#define USBHS0_USBSTS        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x144) // USB Status Register
  #define USBHS_USBSTS_UI     0x00000001                                 // USB interrupt
  #define USBHS_USBSTS_UEI    0x00000002                                 // USB error interrupt
  #define USBHS_USBSTS_PCI    0x00000004                                 // port change detect interrupt
  #define USBHS_USBSTS_FRI    0x00000008                                 // frame list rollover interrupt
  #define USBHS_USBSTS_SEI    0x00000010                                 // system error interrupt
  #define USBHS_USBSTS_AAI    0x00000020                                 // async advance interrupt
  #define USBHS_USBSTS_URI    0x00000040                                 // USB reset interrupt
  #define USBHS_USBSTS_SRI    0x00000080                                 // SOF-received interrupt
  #define USBHS_USBSTS_SLI    0x00000100                                 // sleep (DC suspend) interrupt
  #define USBHS_USBSTS_ULPII  0x00000400                                 // ULPI interrupt
  #define USBHS_USBSTS_HCH    0x00001000                                 // HC halted (read-only) - host mode only
  #define USBHS_USBSTS_RCL    0x00002000                                 // reclamation (read-only) - host mode only
  #define USBHS_USBSTS_PS     0x00004000                                 // periodic schedule status (read-only) - host mode only
  #define USBHS_USBSTS_AS     0x00008000                                 // asynchronous schedule status (read-only) - host mode only
  #define USBHS_USBSTS_NAKI   0x00010000                                 // nak interrupt
  #define USBHS_USBSTS_TI0    0x01000000                                 // general purpose timer 0 interrupt
  #define USBHS_USBSTS_TI1    0x02000000                                 // general purpose timer 1 interrupt
#define USBHS0_USBINTR       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x148) // USB Interrupt Enable Register
  #define USBHS_USBINTR_UE    0x00000001                                 // USB interrupt enable
  #define USBHS_USBINTR_UEE   0x00000002                                 // USB error interrupt enable
  #define USBHS_USBINTR_PCE   0x00000004                                 // port change detect interrupt enable
  #define USBHS_USBINTR_FRE   0x00000008                                 // frame list rollover interrupt enable
  #define USBHS_USBINTR_SEE   0x00000010                                 // system error interrupt enable
  #define USBHS_USBINTR_AAE   0x00000020                                 // async advance interrupt enable
  #define USBHS_USBINTR_URE   0x00000040                                 // USB reset interrupt enable
  #define USBHS_USBINTR_SRE   0x00000080                                 // SOF-received interrupt enable
  #define USBHS_USBINTR_SLE   0x00000100                                 // sleep (DC suspend) interrupt enable
  #define USBHS_USBINTR_ULPIE 0x00000400                                 // ULPI interrupt enable
  #define USBHS_USBINTR_NAKE  0x00010000                                 // nak interrupt enable
  #define USBHS_USBINTR_UAIE  0x00040000                                 // USB host asychronous interrupt enable
  #define USBHS_USBINTR_UPIE  0x00080000                                 // USB host periodic interrupt enable
  #define USBHS_USBINTR_TIE0  0x01000000                                 // general purpose timer 0 interrupt enable
  #define USBHS_USBINTR_TIE1  0x02000000                                 // general purpose timer 1 interrupt enable
#define USBHS0_FRINDEX       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x14c) // Frame Index Register

#define USBHS0_PERIODICLISTBASE *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x154) // Periodic Frame List Base Address Register
#define USBHS0_DEVICEADDR    USBHS0_PERIODICLISTBASE                     // device address register
  #define USBHS_DEVICEADDR_USBADRA      0x01000000                       // device address advance
  #define USBHS_DEVICEADDR_USBADR_MASK  0xfe000000                       // device address mask
  #define USBHS_DEVICEADDR_USBADR_SHIFT 25                               // device address shift
#define USBHS0_ASYNCLISTADDR *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x158) // Current Asynchronous List Address Register
#define USBHS0_EPLISTADDR    USBHS0_ASYNCLISTADDR                        // Endpoint List Address Register
#define USBHS0_TTCTRL        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x15c) // Host TT Asynchronous Buffer Control
#define USBHS0_BURSTSIZE     *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x160) // Master Interface Data Burst Size Register
#define USBHS0_TXFILLTUNING  *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x164) // Transmit FIFO Tuning Control Register

#define USBHS0_ULPI_VIEWPORT *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x170) // ULPI Register Access

#define USBHS0_ENDPTNAK      *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x178) // Endpoint NAK Register
#define USBHS0_ENDPTNAKEN    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x17c) // Endpoint NAK Enable Register
#define USBHS0_CONFIGFLAG    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x180) // Configure Flag Register (read-only)
#define USBHS0_PORTSC1       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x184) // Port Status and Control Register
  #define USBHS_PORTSC1_CCS      0x00000001                              // current connect status (read-only)
  #define USBHS_PORTSC1_CSC      0x00000002                              // connect status changed (write '1' to clear and 0 if USBHS_PORTSC1_PP is 0)
  #define USBHS_PORTSC1_PE       0x00000004                              // port enabled
  #define USBHS_PORTSC1_PEC      0x00000008                              // port disabled
  #define USBHS_PORTSC1_OCA      0x00000010                              // over current active (read-only)
  #define USBHS_PORTSC1_OCC      0x00000020                              // over current change detected (write '1' to clear)
  #define USBHS_PORTSC1_FPR      0x00000040                              // force port resume
  #define USBHS_PORTSC1_SUSP     0x00000080                              // port in suspend mode (read-only in device mode)
  #define USBHS_PORTSC1_PR       0x00000100                              // port reset (used in host mode [self-clearing and cleared if USBHS_PORTSC1_PP is 0] - read-only in decice mode)
  #define USBHS_PORTSC1_HSP      0x00000200                              // high speed port (read-only)
  #define USBHS_PORTSC1_LS_SE0   0x00000000                              // line-state - SE0 (read-only
  #define USBHS_PORTSC1_LS_J     0x00000400                              // line-state - J-state (read-only
  #define USBHS_PORTSC1_LS_K     0x00000800                              // line-state - K-state (read-only
  #define USBHS_PORTSC1_PP       0x00001000                              // port power
  #define USBHS_PORTSC1_PO       0x00000000                              // port owner - not supported
  #define USBHS_PORTSC1_PIC_OFF  0x00000000                              // port indicator control - off
  #define USBHS_PORTSC1_PIC_AMBER 0x00004000                             // port indicator control - amber
  #define USBHS_PORTSC1_PIC_GREEN 0x00008000                             // port indicator control - green
  #define USBHS_PORTSC1_PTC_OFF  0x00000000                              // port test control - off
  #define USBHS_PORTSC1_PTC_J    0x00010000                              // port test control - J_STATE
  #define USBHS_PORTSC1_PTC_K    0x00020000                              // port test control - K_STATE
  #define USBHS_PORTSC1_PTC_NAK  0x00030000                              // port test control - SEQ_NAK
  #define USBHS_PORTSC1_PTC_PAC  0x00040000                              // port test control - packet
  #define USBHS_PORTSC1_PTC_HS   0x00050000                              // port test control - force enable high speed
  #define USBHS_PORTSC1_PTC_FS   0x00060000                              // port test control - force enable full speed
  #define USBHS_PORTSC1_PTC_LS   0x00070000                              // port test control - force enable low speed
  #define USBHS_PORTSC1_WKCN     0x00100000                              // wake on connect enable
  #define USBHS_PORTSC1_WKDS     0x00200000                              // wake on disconnect enable
  #define USBHS_PORTSC1_WKOC     0x00400000                              // wake on over-current enable
  #define USBHS_PORTSC1_PHCD     0x00800000                              // phy low power suspend
  #define USBHS_PORTSC1_PFSC     0x01000000                              // port force full-speed contact
  #define USBHS_PORTSC1_PTS_2    0x02000000                              // 
  #define USBHS_PORTSC1_PSPD_FS  0x00000000                              // port speed - full speed (read-only)
  #define USBHS_PORTSC1_PSPD_LS  0x04000000                              // port speed - low speed (read-only)
  #define USBHS_PORTSC1_PSPD_HS  0x08000000                              // port speed - high speed (read-only)
  #define USBHS_PORTSC1_PSPD_MASK 0x0c000000                             // port speed mask
  #define USBHS_PORTSC1_PTW_16   0x10000000                              // parallel transceiver width (16 bit UTMT interface at 30MHz) - default
  #define USBHS_PORTSC1_PTW_8    0x00000000                              // parallel transceiver width (8 bit UTMT interface at 60MHz)
  #define USBHS_PORTSC1_STS      0x20000000                              // serial transceiver select
  #define USBHS_PORTSC1_PTS_1    0xc0000000                              // 
    #define USBHS_PORTSC1_WRITE_ONE_TO_CLEAR_MASK (USBHS_PORTSC1_CSC | USBHS_PORTSC1_PEC | USBHS_PORTSC1_OCC)
    #if defined _WINDOWS
        #define CLEAR_PORTSC1_FLAGS(ref, flags)      USBHS##ref##_PORTSC1 &= ~(flags & USBHS_PORTSC1_WRITE_ONE_TO_CLEAR_MASK)
    #else
        #define CLEAR_PORTSC1_FLAGS(ref, flags)      USBHS##ref##_PORTSC1 = ((USBHS##ref##_PORTSC1 & ~USBHS_PORTSC1_WRITE_ONE_TO_CLEAR_MASK) | flags) // write '1 to clear only specified flags
    #endif
#define USBHS0_OTGSC         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1a4) // On-the-Go Status and Control Register (available only in OTG mode)
  #define USBHS_OTGSC_VD           0x00000001                            // VBUS discharge - discharge VBus through register
  #define USBHS_OTGSC_VC           0x00000002                            // VBUS charge - charge VBus (used for VBus pulsing during SRP)
  #define USBHS_OTGSC_OT           0x00000008                            // OTG termination charge - used in device mode to control the DM termination
  #define USBHS_OTGSC_DP           0x00000010                            // data pulsing - DP pull-up asserted for data pulsing during SRP
  #define USBHS_OTGSC_IDPU         0x00000020                            // ID pull-up - ID input only sampled when on (default is on - '1')
  #define USBHS_OTGSC_ID           0x00000100                            // USB ID: '0' = A device, '1' = B device (read-only)
  #define USBHS_OTGSC_AVV          0x00000200                            // A VBus valid - VBus is above A VBus valid threshold (read-only)
  #define USBHS_OTGSC_ASV          0x00000400                            // A session valid - VBus is above A session valid threshold (read-only)
  #define USBHS_OTGSC_BSV          0x00000800                            // B session valid - VBus is above B session valid threshold (read-only)
  #define USBHS_OTGSC_BSE          0x00001000                            // B session - VBus is below B session end threshold (read-only)
  #define USBHS_OTGSC_TOG_1MS      0x00002000                            // 1 ms timer toggle (read-only)
  #define USBHS_OTGSC_DPS          0x00004000                            // data bus pulsing status (read-only)
  #define USBHS_OTGSC_IDIS         0x00010000                            // USB ID interrupt status (write '1' to clear)
  #define USBHS_OTGSC_AVVIS        0x00020000                            // A VBus valid interrupt status (write '1' to clear)
  #define USBHS_OTGSC_ASVIS        0x00040000                            // A session valid interrupt status (write '1' to clear)
  #define USBHS_OTGSC_BSVIS        0x00080000                            // B session valid interrupt status (write '1' to clear)
  #define USBHS_OTGSC_BSEIS        0x00100000                            // B session end interrupt status (write '1' to clear)
  #define USBHS_OTGSC_STATUS_1MS   0x00200000                            // 1ms timer interrupt status (write '1' to clear)
  #define USBHS_OTGSC_DPIS         0x00400000                            // data pulse interrupt status (write '1' to clear) - detected only in USBMODE.CM = Host(11) and PORTSC1(0)[PP] = 0
  #define USBHS_OTGSC_IDIE         0x01000000                            // USB ID interrupt enable
  #define USBHS_OTGSC_AVVIE        0x02000000                            // A VBus valid  interrupt enable
  #define USBHS_OTGSC_ASVIE        0x04000000                            // A session valid interrupt enable
  #define USBHS_OTGSC_BSVIE        0x08000000                            // B session valid interrupt enable
  #define USBHS_OTGSC_BSEIE        0x10000000                            // B session end interrupt enable
  #define USBHS_OTGSC_EN_1MS       0x20000000                            // 1 ms timer interrupt enable
  #define USBHS_OTGSC_DPIE         0x40000000                            // data pulse interrupt enable
  #define USBHS0_USBMODE       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1a8) // USB Mode Register
  #define USBHS_USBMODE_CM_IDLE    0x00000000                            // idle mode
  #define USBHS_USBMODE_CM_DEVICE  0x00000002                            // device mode
  #define USBHS_USBMODE_CM_HOST    0x00000003                            // host mode
  #define USBHS_USBMODE_CM_HOST_FLAG 0x00000001                          // host mode identification flag (used by firmware to identify that the host mode is active)
  #define USBHS_USBMODE_ES_LITTLE  0x00000000                            // endian select - little-endian
  #define USBHS_USBMODE_ES_BIG     0x00000004                            // endian select - big-endian
  #define USBHS_USBMODE_SLOM       0x00000008                            // setup lock-out mode
  #define USBHS_USBMODE_RESERVED_BITS 0x00005000
#define USBHS0_EPSETUPSR     *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1ac) // Endpoint Setup Status Register (device mode only) (write '1' to clear)
  #define USBHS_EPSETUPSR_SETUP0   0x00000001
  #define USBHS_EPSETUPSR_SETUP1   0x00000002
  #define USBHS_EPSETUPSR_SETUP2   0x00000004
  #define USBHS_EPSETUPSR_SETUP3   0x00000008
  #define USBHS_EPSETUPSR_SETUP4   0x00000010
  #define USBHS_EPSETUPSR_SETUP5   0x00000020
  #define USBHS_EPSETUPSR_SETUP6   0x00000040
  #define USBHS_EPSETUPSR_SETUP7   0x00000080
  #define USBHS_EPSETUPSR_SETUP8   0x00000100
  #define USBHS_EPSETUPSR_SETUP9   0x00000200
  #define USBHS_EPSETUPSR_SETUP10  0x00000400
  #define USBHS_EPSETUPSR_SETUP11  0x00000800
  #define USBHS_EPSETUPSR_SETUP12  0x00001000
  #define USBHS_EPSETUPSR_SETUP13  0x00002000
  #define USBHS_EPSETUPSR_SETUP14  0x00004000
  #define USBHS_EPSETUPSR_SETUP15  0x00008000
#define USBHS0_EPPRIME       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1b0) // Endpoint Initialisation Register
  #define USBHS_EPPRIME_PERB0      0x00000001                            // prime endpoint receive buffers
  #define USBHS_EPPRIME_PERB1      0x00000002
  #define USBHS_EPPRIME_PERB2      0x00000004
  #define USBHS_EPPRIME_PERB3      0x00000008
  #define USBHS_EPPRIME_PERB4      0x00000010
  #define USBHS_EPPRIME_PERB5      0x00000020
  #define USBHS_EPPRIME_PERB6      0x00000040
  #define USBHS_EPPRIME_PERB7      0x00000080
  #define USBHS_EPPRIME_PERB8      0x00000100
  #define USBHS_EPPRIME_PERB9      0x00000200
  #define USBHS_EPPRIME_PERB10     0x00000400
  #define USBHS_EPPRIME_PERB11     0x00000800
  #define USBHS_EPPRIME_PERB12     0x00001000
  #define USBHS_EPPRIME_PERB13     0x00002000
  #define USBHS_EPPRIME_PERB14     0x00004000
  #define USBHS_EPPRIME_PERB15     0x00008000
  #define USBHS_EPPRIME_PETB0      0x00010000                            // prime endpoint transmit buffers
  #define USBHS_EPPRIME_PETB1      0x00020000
  #define USBHS_EPPRIME_PETB2      0x00040000
  #define USBHS_EPPRIME_PETB3      0x00080000
  #define USBHS_EPPRIME_PETB4      0x00100000
  #define USBHS_EPPRIME_PETB5      0x00200000
  #define USBHS_EPPRIME_PETB6      0x00400000
  #define USBHS_EPPRIME_PETB7      0x00800000
  #define USBHS_EPPRIME_PETB8      0x01000000
  #define USBHS_EPPRIME_PETB9      0x02000000
  #define USBHS_EPPRIME_PETB10     0x04000000
  #define USBHS_EPPRIME_PETB11     0x08000000
  #define USBHS_EPPRIME_PETB12     0x10000000
  #define USBHS_EPPRIME_PETB13     0x20000000
  #define USBHS_EPPRIME_PETB14     0x40000000
  #define USBHS_EPPRIME_PETB15     0x80000000
#define USBHS0_EPFLUSH       *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1b4) // Endpoint Flush Register
  #define USBHS_EPFLUSH_FERB0      0x00000001                            // flush endpoint receive buffers
  #define USBHS_EPFLUSH_FERB1      0x00000002
  #define USBHS_EPFLUSH_FERB2      0x00000004
  #define USBHS_EPFLUSH_FERB3      0x00000008
  #define USBHS_EPFLUSH_FERB4      0x00000010
  #define USBHS_EPFLUSH_FERB5      0x00000020
  #define USBHS_EPFLUSH_FERB6      0x00000040
  #define USBHS_EPFLUSH_FERB7      0x00000080
  #define USBHS_EPFLUSH_FERB8      0x00000100
  #define USBHS_EPFLUSH_FERB9      0x00000200
  #define USBHS_EPFLUSH_FERB10     0x00000400
  #define USBHS_EPFLUSH_FERB11     0x00000800
  #define USBHS_EPFLUSH_FERB12     0x00001000
  #define USBHS_EPFLUSH_FERB13     0x00002000
  #define USBHS_EPFLUSH_FERB14     0x00004000
  #define USBHS_EPFLUSH_FERB15     0x00008000
  #define USBHS_EPFLUSH_FETB0      0x00010000                            // flush endpoint transmit buffers
  #define USBHS_EPFLUSH_FETB1      0x00020000
  #define USBHS_EPFLUSH_FETB2      0x00040000
  #define USBHS_EPFLUSH_FETB3      0x00080000
  #define USBHS_EPFLUSH_FETB4      0x00100000
  #define USBHS_EPFLUSH_FETB5      0x00200000
  #define USBHS_EPFLUSH_FETB6      0x00400000
  #define USBHS_EPFLUSH_FETB7      0x00800000
  #define USBHS_EPFLUSH_FETB8      0x01000000
  #define USBHS_EPFLUSH_FETB9      0x02000000
  #define USBHS_EPFLUSH_FETB10     0x04000000
  #define USBHS_EPFLUSH_FETB11     0x08000000
  #define USBHS_EPFLUSH_FETB12     0x10000000
  #define USBHS_EPFLUSH_FETB13     0x20000000
  #define USBHS_EPFLUSH_FETB14     0x40000000
  #define USBHS_EPFLUSH_FETB15     0x80000000
#define USBHS0_EPSR          *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1b8) // Endpoint Status Register (read-only)
#define USBHS0_EPCOMPLETE    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1bc) // Endpoint Complete Register (device mode only) (write '1' to clear)
  #define USBHS_EPCOMPLETE_ERCE0   0x00000001                            // flush endpoint receive buffers
  #define USBHS_EPCOMPLETE_ERCE1   0x00000002
  #define USBHS_EPCOMPLETE_ERCE2   0x00000004
  #define USBHS_EPCOMPLETE_ERCE3   0x00000008
  #define USBHS_EPCOMPLETE_ERCE4   0x00000010
  #define USBHS_EPCOMPLETE_ERCE5   0x00000020
  #define USBHS_EPCOMPLETE_ERCE6   0x00000040
  #define USBHS_EPCOMPLETE_ERCE7   0x00000080
  #define USBHS_EPCOMPLETE_ERCE8   0x00000100
  #define USBHS_EPCOMPLETE_ERCE9   0x00000200
  #define USBHS_EPCOMPLETE_ERCE10  0x00000400
  #define USBHS_EPCOMPLETE_ERCE11  0x00000800
  #define USBHS_EPCOMPLETE_ERCE12  0x00001000
  #define USBHS_EPCOMPLETE_ERCE13  0x00002000
  #define USBHS_EPCOMPLETE_ERCE14  0x00004000
  #define USBHS_EPCOMPLETE_ERCE15  0x00008000
  #define USBHS_EPCOMPLETE_ETCE0   0x00010000                            // flush endpoint transmit buffers
  #define USBHS_EPCOMPLETE_ETCE1   0x00020000
  #define USBHS_EPCOMPLETE_ETCE2   0x00040000
  #define USBHS_EPCOMPLETE_ETCE3   0x00080000
  #define USBHS_EPCOMPLETE_ETCE4   0x00100000
  #define USBHS_EPCOMPLETE_ETCE5   0x00200000
  #define USBHS_EPCOMPLETE_ETCE6   0x00400000
  #define USBHS_EPCOMPLETE_ETCE7   0x00800000
  #define USBHS_EPCOMPLETE_ETCE8   0x01000000
  #define USBHS_EPCOMPLETE_ETCE9   0x02000000
  #define USBHS_EPCOMPLETE_ETCE10  0x04000000
  #define USBHS_EPCOMPLETE_ETCE11  0x08000000
  #define USBHS_EPCOMPLETE_ETCE12  0x10000000
  #define USBHS_EPCOMPLETE_ETCE13  0x20000000
  #define USBHS_EPCOMPLETE_ETCE14  0x40000000
  #define USBHS_EPCOMPLETE_ETCE15  0x80000000
#define USBHS0_EPCR0_ADDR     (volatile unsigned long *)(USBHS_BASE1_ADD + 0x1c0) // endpoint 0 is fixed in control mode and is always enabled
#define USBHS0_EPCR0         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1c0) // Endpoint Control Register 0
  #define USBHS_EPCR_RXS      0x00000001                                 // rx endpoint stall (read-write)
  #define USBHS_EPCR_RXD      0x00000002                                 // rx endpoint data source (should never be set)
  #define USBHS_EPCR_RXT_CON  0x00000000                                 // rx endpoint type control
  #define USBHS_EPCR_RXT_ISO  0x00000004                                 // rx endpoint type isochronous (not endpoint 0)
  #define USBHS_EPCR_RXT_BULK 0x00000008                                 // rx endpoint type bulk (not endpoint 0)
  #define USBHS_EPCR_RXT_INT  0x0000000c                                 // rx endpoint type interrupt (not endpoint 0)
  #define USBHS_EPCR_RXI      0x00000020                                 // rx data toggle inhibit (used only for test purposes)
  #define USBHS_EPCR_RXR      0x00000040                                 // rx data toggle reset (write '1' to synchronise - self-clearing)
  #define USBHS_EPCR_RXE      0x00000080                                 // rx endpoint enable
  #define USBHS_EPCR_TXS      0x00010000                                 // tx endpoint stall
  #define USBHS_EPCR_TXD      0x00020000                                 // tx endpoint data source (should never be set)
  #define USBHS_EPCR_TXT_CON  0x00000000                                 // tx endpoint type control
  #define USBHS_EPCR_TXT_ISO  0x00040000                                 // tx endpoint type isochronous (not endpoint 0)
  #define USBHS_EPCR_TXT_BULK 0x00080000                                 // tx endpoint type bulk (not endpoint 0)
  #define USBHS_EPCR_TXT_INT  0x000c0000                                 // tx endpoint type interrupt (not endpoint 0)
  #define USBHS_EPCR_TXI      0x00200000                                 // tx data toggle inhibit (used only for test purposes - not endpoint 0)
  #define USBHS_EPCR_TXR      0x00400000                                 // tx data toggle reset (write '1' to synchronise - self-clearing - not endpoint 0)
  #define USBHS_EPCR_TXE      0x00800000                                 // tx endpoint enable (read-only on endpoint 0)
#define USBHS0_EPCR1         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1c4) // Endpoint Control Register 1
#define USBHS0_EPCR2         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1c8) // Endpoint Control Register 2
#define USBHS0_EPCR3         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1cc) // Endpoint Control Register 3
#define USBHS0_EPCR4         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1d0) // Endpoint Control Register 4
#define USBHS0_EPCR5         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1d4) // Endpoint Control Register 5
#define USBHS0_EPCR6         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1d8) // Endpoint Control Register 6
#define USBHS0_EPCR7         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1dc) // Endpoint Control Register 7
#define USBHS0_EPCR8         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1e0) // Endpoint Control Register 8
#define USBHS0_EPCR9         *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1e4) // Endpoint Control Register 9
#define USBHS0_EPCR10        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1e8) // Endpoint Control Register 10
#define USBHS0_EPCR11        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1ec) // Endpoint Control Register 11
#define USBHS0_EPCR12        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1f0) // Endpoint Control Register 12
#define USBHS0_EPCR13        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1f4) // Endpoint Control Register 13
#define USBHS0_EPCR14        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1f8) // Endpoint Control Register 14
#define USBHS0_EPCR15        *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x1fc) // Endpoint Control Register 15
#define USBHS0_USBGENCTRL    *(volatile unsigned long *)(USBHS_BASE1_ADD + 0x200) // USB General Control Register

#if HSUSB_CONTROLLERS > 1
    #define USBHS1_ID            *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x000) // Peripheral ID Register (read-only)
    #define USBHS1_HWGENERAL     *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x004) // General Hardware Parameters Register (read-only)
    #define USBHS1_HWHOST        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x008) // Host Hardware Parameters Register (read-only)
    #define USBHS1_HWDEVICE      *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x00c) // Device Hardware Parameters Register (read-only)
    #define USBHS1_HWTXBUF       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x010) // Transmit Buffer Hardware Parameters Register (read-only)
    #define USBHS1_HWRXBUF       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x014) // Receive Buffer Hardware Parameters Register (read-only) - reads zero

    #define USBHS1_GPTIMER0LD    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x080) // General Purpose Timer 0 Load Register
    #define USBHS1_GPTIMER0CTL   *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x084) // General Purpose Timer 0 Control Register
    #define USBHS1_GPTIMER1LD    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x088) // General Purpose Timer 1 Load Register
    #define USBHS1_GPTIMER1CTL   *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x08c) // General Purpose Timer 1 Control Register
    #define USBHS1_USB_SBUSCFG   *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x090) // System Bus Interface Configuration Register

    #define USBHS1_HCIVERSION    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x100) // Host Controller Version and Capabilities Register (read-only)
    #define USBHS1_HCSPARAMS     *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x104) // Host Controller Structural Parameters Register (read-only)
    #define USBHS1_HCCPARAMS     *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x108) // Host Controller Capability Parameters Register (read-only)

    #define USBHS1_DCIVERSION    *(volatile unsigned short *)(USBHS_BASE2_ADD + 0x122) // Device Controller Interface Version (read-only)
    #define USBHS1_DCCPARAMS     *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x124) // Device Controller Capability Parameters (read-only)

    #define USBHS1_USBCMD        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x140) // USB Command Register
    #define USBHS1_USBSTS        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x144) // USB Status Register
    #define USBHS1_USBINTR       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x148) // USB Interrupt Enable Register
    #define USBHS1_FRINDEX       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x14c) // Frame Index Register

    #define USBHS1_PERIODICLISTBASE *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x154) // Periodic Frame List Base Address Register
    #define USBHS1_DEVICEADDR    USBHS1_PERIODICLISTBASE                 // device address register
    #define USBHS1_ASYNCLISTADDR *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x158) // Current Asynchronous List Address Register
    #define USBHS1_EPLISTADDR    USBHS1_ASYNCLISTADDR                    // Endpoint List Address Register
    #define USBHS1_TTCTRL        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x15c) // Host TT Asynchronous Buffer Control
    #define USBHS1_BURSTSIZE     *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x160) // Master Interface Data Burst Size Register
    #define USBHS1_TXFILLTUNING  *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x164) // Transmit FIFO Tuning Control Register

    #define USBHS1_ULPI_VIEWPORT *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x170) // ULPI Register Access

    #define USBHS1_ENDPTNAK      *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x178) // Endpoint NAK Register
    #define USBHS1_ENDPTNAKEN    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x17c) // Endpoint NAK Enable Register
    #define USBHS1_CONFIGFLAG    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x180) // Configure Flag Register (read-only)
    #define USBHS1_PORTSC1       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x184) // Port Status and Control Register
    #define USBHS1_OTGSC         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1a4) // On-the-Go Status and Control Register
    #define USBHS1_USBMODE       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1a8) // USB Mode Register
    #define USBHS1_EPSETUPSR     *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1ac) // Endpoint Setup Status Register (device mode only) (write '1' to clear)
    #define USBHS1_EPPRIME       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1b0) // Endpoint Initialisation Register
    #define USBHS1_EPFLUSH       *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1b4) // Endpoint Flush Register
    #define USBHS1_EPSR          *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1b8) // Endpoint Status Register (read-only)
    #define USBHS1_EPCOMPLETE    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1bc) // Endpoint Complete Register (device mode only) (write '1' to clear)
    #define USBHS1_EPCR0_ADDR     (volatile unsigned long *)(USBHS_BASE2_ADD + 0x1c0) // endpoint 0 is fixed in control mode and is always enabled
    #define USBHS1_EPCR0         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1c0) // Endpoint Control Register 0
    #define USBHS1_EPCR1         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1c4) // Endpoint Control Register 1
    #define USBHS1_EPCR2         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1c8) // Endpoint Control Register 2
    #define USBHS1_EPCR3         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1cc) // Endpoint Control Register 3
    #define USBHS1_EPCR4         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1d0) // Endpoint Control Register 4
    #define USBHS1_EPCR5         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1d4) // Endpoint Control Register 5
    #define USBHS1_EPCR6         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1d8) // Endpoint Control Register 6
    #define USBHS1_EPCR7         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1dc) // Endpoint Control Register 7
    #define USBHS1_EPCR8         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1e0) // Endpoint Control Register 8
    #define USBHS1_EPCR9         *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1e4) // Endpoint Control Register 9
    #define USBHS1_EPCR10        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1e8) // Endpoint Control Register 10
    #define USBHS1_EPCR11        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1ec) // Endpoint Control Register 11
    #define USBHS1_EPCR12        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1f0) // Endpoint Control Register 12
    #define USBHS1_EPCR13        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1f4) // Endpoint Control Register 13
    #define USBHS1_EPCR14        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1f8) // Endpoint Control Register 14
    #define USBHS1_EPCR15        *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x1fc) // Endpoint Control Register 15
    #define USBHS1_USBGENCTRL    *(volatile unsigned long *)(USBHS_BASE2_ADD + 0x200) // USB General Control Register
#endif

typedef struct stKINETIS_USBHS
{
    volatile unsigned long ID;
    volatile unsigned long HWGENERAL;
    volatile unsigned long HWHOST;
    volatile unsigned long HWDEVICE;
    volatile unsigned long HWTXBUF;
    volatile unsigned long HWRXBUF;
    unsigned long ulRes1[0x1a];
    volatile unsigned long GPTIMER0LD;
    volatile unsigned long GPTIMER0CTL;
    volatile unsigned long GPTIMER1LD;
    volatile unsigned long GPTIMER1CTL;
    volatile unsigned long USB_SBUSCFG;
    unsigned long ulRes2[0x1b];
    volatile unsigned long HCIVERSION;
    volatile unsigned long HCSPARAMS;
    volatile unsigned long HCCPARAMS;
    unsigned long ulRes3[0x5];
    unsigned short usRes4;
    volatile unsigned short DCIVERSION;
    volatile unsigned long DCCPARAMS;
    unsigned long ulRes5[0x6];
    volatile unsigned long USBCMD;
    volatile unsigned long USBSTS;
    volatile unsigned long USBINTR;
    volatile unsigned long FRINDEX;
    unsigned long ulRes6;
    volatile unsigned long PERIODICLISTBASE_DEVICEADDR;
    volatile unsigned long ASYNCLISTADDR_EPLISTADDR;
    volatile unsigned long TTCTRL;
    volatile unsigned long BURSTSIZE;
    volatile unsigned long TXFILLTUNING;
    unsigned long ulRes7[0x2];
    volatile unsigned long ULPI_VIEWPORT;
    unsigned long ulRes8;
    volatile unsigned long ENDPTNAK;
    volatile unsigned long ENDPTNAKEN;
    volatile unsigned long CONFIGFLAG;
    volatile unsigned long PORTSC1;
    unsigned long ulRes9[0x7];
    volatile unsigned long OTGSC;
    volatile unsigned long USBMODE;
    volatile unsigned long EPSETUPSR;
    volatile unsigned long EPPRIME;
    volatile unsigned long EPFLUSH;
    volatile unsigned long EPSR;
    volatile unsigned long EPCOMPLETE;
    volatile unsigned long EPCR0;
    volatile unsigned long EPCR1;
    volatile unsigned long EPCR2;
    volatile unsigned long EPCR3;
    volatile unsigned long EPCR4;
    volatile unsigned long EPCR5;
    volatile unsigned long EPCR6;
    volatile unsigned long EPCR7;
} KINETIS_USBHS;


// This hardware specific structure allows generic USB routines to control specific hardware using macros
//
typedef struct stUSB_HW
{
    unsigned long  ulRxControl;
    volatile unsigned long *ptr_ulUSB_BDControl;                         // pointer to the presently valid tx buffer descriptor control entry
    USB_END_POINT *ptrEndpoint;
    unsigned char **ptrTxDatBuffer;                                      // pointer to the next transmission buffer pointer
    unsigned char **ptrRxDatBuffer;                                      // pointer to the next reception buffer pointer
    unsigned short usLength;                                             // length information
    unsigned char  ucUSBAddress;                                         // our USB address
    unsigned char  ucDeviceType;                                         // used to distinguish between LS, FS and HS device operation
    KINETIS_USBHS_ENDPOINT_QUEUE_HEADER *ptrQueueHeader;
#if defined USB_HOST_SUPPORT
    unsigned long *ptr_ulUSB_Rx_BDControl;                               // pointer to the presently valid rx buffer descriptor control entry
    unsigned long *ptr_ulUSB_Alt_Rx_BDControl;                           // pointer to the alternative rx buffer descriptor control entry
    unsigned char **ptrUSB_BD_EvenData;                                  // pointer to the even buffer pointer
    unsigned char  ucModeType;                                           // used to distinguish between device and host mode
    unsigned char  ucDeviceSpeed;                                        // the speed of the device attached to the host
    unsigned char  ucBufferUsage;                                        // used by host to follow receive buffer usage
    volatile unsigned char ucUSB_HostEvent[NUMBER_OF_HOST_ENDPOINTS * 2];// event to be generated when the present transaction completes
    unsigned char *ptrRx[NUMBER_OF_HOST_ENDPOINTS];                      // buffer dedicated to receiving setup responses (and general data)
    unsigned short usEndpointLength[NUMBER_OF_HOST_ENDPOINTS];           // specific endpoint data length presently being used
#endif
    KINETIS_USBHS *ptrHSUSB;                                             // the controller's HW register base address
#if (HSUSB_CONTROLLERS > 1)
    unsigned char  ucController;                                         // the controller index that this USB hardware stuct belongs to
#endif
} USB_HW;

#if defined USB_HOST_SUPPORT
    extern void fnSetHSUSB_device_add(unsigned char address, USB_HW *ptrUSB_HW);
    extern void fnHostReleaseBuffer(int iEndpoint, unsigned char ucTransferType, USB_HW *ptrUSB_HW);
#endif

// Non-core USB OTG registers
//
#define USBNC_USB_OTG1_CTRL      *(volatile unsigned long *)(USBHS_NON_CORE_BASE1_ADD + 0x00) // USB OTG1 control register
#if HSUSB_CONTROLLERS > 1
    #define USBNC_USB_OTG2_CTRL  *(volatile unsigned long *)(USBHS_NON_CORE_BASE1_ADD + 0x04) // USB OTG2 control register
#endif
#define USBNC_USB_OTG1_PHY_CTRL_0 *(volatile unsigned long *)(USBHS_NON_CORE_BASE1_ADD + 0x18) // OTG1 UTMI PHY control 0 register
#if HSUSB_CONTROLLERS > 1
    #define USBNC_USB_OTG2_PHY_CTRL_0 *(volatile unsigned long *)(USBHS_NON_CORE_BASE1_ADD + 0x1c) // OTG2 UTMI PHY control 0 register
#endif

#define USBHS_PHY_ADD     USBHS_PHY1_ADD
#define USBPHY1_PWD       *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x000) // USB1 PHY power down register
    #define USBPHY_PWD_RSVD0_MASK 0x000003ff
    #define USBPHY_PWD_TXPWDFS    0x00000400
    #define USBPHY_PWD_TXPWDIBIAS 0x00000800
    #define USBPHY_PWD_TXPWDV2I   0x00001000
    #define USBPHY_PWD_RSVD1_MASK 0x0001f000
    #define USBPHY_PWD_RXPWDENV   0x00020000
    #define USBPHY_PWD_RXPWD1PT1  0x00040000
    #define USBPHY_PWD_RXPWDDIFF  0x00080000
    #define USBPHY_PWD_RXPWDRX    0x00100000
#define USBPHY1_PWD_SET   *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x004) // USB1 PHY power down set register
#define USBPHY1_PWD_CLR   *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x008) // USB1 PHY power down clear register
#define USBPHY1_PWD_TOG   *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x00c) // USB1 PHY power down toggle register
#define USBPHY1_TX        *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x010) // USB1 PHY transmit control register
    #define USBPHY_TX_DCAL_VALUE      0x0000000c
    #define USBPHY_TX_DCAL_MASK       0x0000000f
    #define USBPHY_TX_RSVD0_VALUE     0x00000000
    #define USBPHY_TX_RSVD0_MASK      0x000000f0
    #define USBPHY_TX_TXCAL45DN_VALUE 0x00000600
    #define USBPHY_TX_TXCAL45DN_MASK  0x00000f00
    #define USBPHY_TX_RSVD1_VALUE     0x00000000
    #define USBPHY_TX_RSVD1_MASK      0x0000f000
    #define USBPHY_TX_TXCAL45DP_VALUE 0x00060000
    #define USBPHY_TX_TXCAL45DP_MASK  0x000f0000                          
    #define USBPHY_TX_EDGECTRL_VALUE  0x10000000                         // value to be used
    #define USBPHY_TX_EDGECTRL_MASK   0x1c000000
#define USBPHY1_TX_SET    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x014) // USB1 PHY transmit control set register
#define USBPHY1_TX_CLR    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x018) // USB1 PHY transmit control clear register
#define USBPHY1_TX_TOG    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x01c) // USB1 PHY transmit control toggle register
#define USBPHY1_RX        *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x020) // USB1 PHY receive control register
#define USBPHY1_RX_SET    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x024) // USB1 PHY receive control set register
#define USBPHY1_RX_CLR    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x028) // USB1 PHY receive control clear register
#define USBPHY1_RX_TOG    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x02c) // USB1 PHY receive control toggle register
#define USBPHY1_CTRL      *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x030) // USB1 PHY general control register
    #define USBPHY_CTRL_ENHOSTDISCONDETECT   0x00000002                  //
    #define USBPHY_CTRL_HOSTDISCONDETECT_IRQ 0x00000008                  //
    #define USBPHY_CTRL_ENDEVPLUGINDET    0x00000010                     //
    #define USBPHY_CTRL_DEVPLUGIN_IRQ     0x00001000                     //
    #define USBPHY_CTRL_ENUTMILEVEL2      0x00004000                     // enable UTMI+ level 2 for LS device support
    #define USBPHY_CTRL_ENUTMILEVEL3      0x00008000                     // enable UTMI+ level 3 for external FS hub with LS device support
    #define USBPHY_CTRL_AUTORESUME_EN     0x00040000                     //
    #define USBPHY_CTRL_ENAUTOCLR_CLKGATE 0x00080000                     //
    #define USBPHY_CTRL_ENAUTOCLR_PHY_PWD 0x00100000                     //
    #define USBPHY_CTRL_ENDPDMCHG_WKUP    0x00200000                     //
    #define USBPHY_CTRL_FSDLL_RST_EN      0x01000000                     //
    #define USBPHY_CTRL_OTG_ID_VALUE      0x08000000                     // (read-only)
    #define USBPHY_CTRL_HOST_FORCE_LS_SE0 0x10000000                     //
    #define USBPHY_CTRL_UTMI_SUSPENDM     0x20000000                     // (read-only)
    #define USBPHY_CTRL_CLKGATE           0x40000000                     // gate clocks to UTMI when '0'
    #define USBPHY_CTRL_SFTRST            0x80000000                     // write '1' to soft reset and '0' to release from reset state
#define USBPHY1_CTRL_SET   *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x034) // USB1 PHY general control set register
#define USBPHY1_CTRL_CLR   *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x038) // USB1 PHY general control clear register
#define USBPHY1_CTRL_TOG   *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x03c) // USB1 PHY general control toggle register
#define USBPHY1_STATUS     *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x040) // USB1 PHY status register
#define USBPHY1_DEBUG      *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x050) // USB1 PHY debug register
#define USBPHY1_DEBUG_SET  *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x054) // USB1 PHY debug set register
#define USBPHY1_DEBUG_CLR  *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x058) // USB1 PHY debug clear register
#define USBPHY1_DEBUG_TOG  *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x05c) // USB1 PHY debug toggle register
#define USBPHY1_DEBUG0_STATUS *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x060) // UTMI1 debug 0 status register
#define USBPHY1_DEBUG1     *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x070) // UTMI1 debug 1 status register
#define USBPHY1_DEBUG1_SET *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x074) // UTMI1 debug 1 status set register
#define USBPHY1_DEBUG1_CLR *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x078) // UTMI1 debug 1 status clear register
#define USBPHY1_DEBUG1_TOG *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x07c) // UTMI1 debug 1 status toggle register
#define USBPHY1_VERSION    *(volatile unsigned long *)(USBHS_PHY1_ADD + 0x080) // UTMI1 RTL version register (read-only)

#if HSUSB_CONTROLLERS > 1
    #define USBPHY2_PWD       *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x000) // USB2 PHY power down register
    #define USBPHY2_PWD_SET   *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x004) // USB2 PHY power down set register
    #define USBPHY2_PWD_CLR   *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x008) // USB2 PHY power down clear register
    #define USBPHY2_PWD_TOG   *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x00c) // USB2 PHY power down toggle register
    #define USBPHY2_TX        *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x010) // USB2 PHY transmit control register
    #define USBPHY2_TX_SET    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x014) // USB2 PHY transmit control set register
    #define USBPHY2_TX_CLR    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x018) // USB2 PHY transmit control clear register
    #define USBPHY2_TX_TOG    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x01c) // USB2 PHY transmit control toggle register
    #define USBPHY2_RX        *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x020) // USB2 PHY receive control register
    #define USBPHY2_RX_SET    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x024) // USB2 PHY receive control set register
    #define USBPHY2_RX_CLR    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x028) // USB2 PHY receive control clear register
    #define USBPHY2_RX_TOG    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x02c) // USB2 PHY receive control toggle register
    #define USBPHY2_CTRL      *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x030) // USB2 PHY general control register
    #define USBPHY2_CTRL_SET   *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x034) // USB2 PHY general control set register
    #define USBPHY2_CTRL_CLR   *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x038) // USB2 PHY general control clear register
    #define USBPHY2_CTRL_TOG   *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x03c) // USB2 PHY general control toggle register
    #define USBPHY2_STATUS     *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x040) // USB2 PHY status register
    #define USBPHY2_DEBUG      *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x050) // USB2 PHY debug register
    #define USBPHY2_DEBUG_SET  *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x054) // USB2 PHY debug set register
    #define USBPHY2_DEBUG_CLR  *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x058) // USB2 PHY debug clear register
    #define USBPHY2_DEBUG_TOG  *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x05c) // USB2 PHY debug toggle register
    #define USBPHY2_DEBUG0_STATUS *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x060) // UTMI2 debug 0 status register
    #define USBPHY2_DEBUG1     *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x070) // UTMI2 debug 1 status register
    #define USBPHY2_DEBUG1_SET *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x074) // UTMI2 debug 1 status set register
    #define USBPHY2_DEBUG1_CLR *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x078) // UTMI2 debug 1 status clear register
    #define USBPHY2_DEBUG1_TOG *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x07c) // UTMI2 debug 1 status toggle register
    #define USBPHY2_VERSION    *(volatile unsigned long *)(USBHS_PHY2_ADD + 0x080) // UTMI2 RTL version register (read-only)
#endif

typedef struct st_USBPHY
{
    volatile unsigned long USBPHY_PWD;
    volatile unsigned long USBPHY_PWD_SET;
    volatile unsigned long USBPHY_PWD_CLR;
    volatile unsigned long USBPHY_PWD_TOG;
    volatile unsigned long USBPHY_TX;
    volatile unsigned long USBPHY_TX_SET;
    volatile unsigned long USBPHY_TX_CLR;
    volatile unsigned long USBPHY_TX_TOG;
    volatile unsigned long USBPHY_RX;
    volatile unsigned long USBPHY_RX_SET;
    volatile unsigned long USBPHY_RX_CLR;
    volatile unsigned long USBPHY_RX_TOG;
    volatile unsigned long USBPHY_CTRL;
    volatile unsigned long USBPHY_CTRL_SET;
    volatile unsigned long USBPHY_CTRL_CLR;
    volatile unsigned long USBPHY_CTRL_TOG;
    volatile unsigned long USBPHY_STATUS;
    unsigned long ulRes0[3];
    volatile unsigned long USBPHY_DEBUG;
    volatile unsigned long USBPHY_DEBUG_SET;
    volatile unsigned long USBPHY_DEBUG_CLR;
    volatile unsigned long USBPHY_DEBUG_TOG;
    volatile unsigned long USBPHY_DEBUG0_STATUS;
    unsigned long ulRes1[3];
    volatile unsigned long USBPHY_DEBUG1;
    volatile unsigned long USBPHY_DEBUG1_SET;
    volatile unsigned long USBPHY_DEBUG1_CLR;
    volatile unsigned long USBPHY_DEBUG1_TOG;
    volatile unsigned long USBPHY_VERSION;
} USBPHY;

// Comparator
//
#if defined KINETIS_KE
    #define ACMP0_CS             *(volatile unsigned char *)(ACMP0_BLOCK + 0x0) // ACMP 0 control and status register
    #define ACMP0_C0             *(unsigned char *)(ACMP0_BLOCK + 0x1)   // ACMP 0 control register 0
    #define ACMP0_C1             *(unsigned char *)(ACMP0_BLOCK + 0x2)   // ACMP 0 control register 1
    #define ACMP0_C2             *(unsigned char *)(ACMP0_BLOCK + 0x3)   // ACMP 0 control register 2

    #define ACMP1_CS             *(volatile unsigned char *)(ACMP1_BLOCK + 0x0) // ACMP 1 control and status register
    #define ACMP1_C0             *(unsigned char *)(ACMP1_BLOCK + 0x1)   // ACMP 1 control register 0
    #define ACMP1_C1             *(unsigned char *)(ACMP1_BLOCK + 0x2)   // ACMP 1 control register 1
    #define ACMP1_C2             *(unsigned char *)(ACMP1_BLOCK + 0x3)   // ACMP 1 control register 2
#else
    #if NUMBER_OF_COMPARATORS > 0
        #define CMP0_CR0         *(unsigned char *)(CMP0_BLOCK + 0x0)    // CMP 0 control register 0
            #define CMP_CR0_FILTER_1_SAMPLE   0x10                       // no filter
            #define CMP_CR0_FILTER_2_SAMPLE   0x20                       // 2 samples must agree
            #define CMP_CR0_FILTER_3_SAMPLE   0x30                       // 3 samples must agree
            #define CMP_CR0_FILTER_4_SAMPLE   0x40                       // 4 samples must agree
            #define CMP_CR0_FILTER_5_SAMPLE   0x50                       // 5 samples must agree
            #define CMP_CR0_FILTER_6_SAMPLE   0x60                       // 6 samples must agree
            #define CMP_CR0_FILTER_7_SAMPLE   0x70                       // 7 samples must agree
            #define CMP_CR0_HYSTCTR_LEVEL_0   0x00                       // hysterisis level 0
            #define CMP_CR0_HYSTCTR_LEVEL_1   0x01                       // hysterisis level 1
            #define CMP_CR0_HYSTCTR_LEVEL_2   0x02                       // hysterisis level 2
            #define CMP_CR0_HYSTCTR_LEVEL_3   0x03                       // hysterisis level 3
        #define CMP0_CR1         *(unsigned char *)(CMP0_BLOCK + 0x1)    // CMP 0 control register 1
            #define CMP_CR1_EN                0x01                       // enable comparator
            #define CMP_CR1_OPE               0x02                       // CMPO enabled (if pin is configured)
            #define CMP_CR1_COS_FILTERED      0x00                       // CMPO connected to filtered comparator output
            #define CMP_CR1_COS_UNFILTERED    0x04                       // CMPO connected to unfiltered comparator output
            #define CMP_CR1_INV               0x08                       // invert the comparator output
            #define CMP_CR1_PMODE_LS          0x00                       // power mode low speed
            #define CMP_CR1_PMODE_HS          0x10                       // power mode high speed
            #define CMP_CR1_WE                0x40                       // window mode (should not be enabled together with sample mode)
            #define CMP_CR1_SE                0x80                       // sample mode (should not be enabled together with window mode)
        #define CMP0_FPR         *(unsigned char *)(CMP0_BLOCK + 0x2)    // CMP 0 filter period register
        #define CMP0_SCR         *(volatile unsigned char *)(CMP0_BLOCK + 0x3) // CMP 0 status and control register
            #define CMP_SCR_COUT              0x01                       // present COUT state (read-only)
            #define CMP_SCR_CFF               0x02                       // analog comparator flag falling edge detected on COUT (write '1' to clear)
            #define CMP_SCR_CRF               0x04                       // analog comparator flag rising edge detected on COUT (write '1' to clear)
            #define CMP_SCR_IEF               0x08                       // comparator interrupt enable falling
            #define CMP_SCR_IER               0x10                       // comparator interrupt enable rising
            #define CMP_SCR_DMA               0x40                       // DMA enabled (on rising an/or falling, according to interrupt settings)
        #define CMP0_DACCR       *(unsigned char *)(CMP0_BLOCK + 0x4)    // CMP 0 DAC control register
            #define CMP_DACCR_VOSEL_MASK      0x3f                       // 0..63 (1 is 1/64th, 63 is 64/64th)
            #define CMP_DACCR_VRSEL_VREF_OUT  0x00                       // select VREF_OUT as supply voltage to DAC ladder network
            #define CMP_DACCR_VRSEL_VDD       0x40                       // select VDD as supply voltage to DAC ladder network
            #define CMP_DACCR_DACEN           0x80                       // DAC enable
        #define CMP0_MUXCR       *(unsigned char *)(CMP0_BLOCK + 0x5)    // CMP 0 MUX control register
            #define CMP_MUXCR_MSEL_IN0        0x00                       // minus input 0 connected
            #define CMP_MUXCR_MSEL_IN1        0x01                       // minus input 1 connected
            #define CMP_MUXCR_MSEL_IN2        0x02                       // minus input 2 connected
            #define CMP_MUXCR_MSEL_IN3        0x03                       // minus input 3 connected
            #define CMP_MUXCR_MSEL_IN4        0x04                       // minus input 4 connected
            #define CMP_MUXCR_MSEL_IN5        0x05                       // minus input 5connected
            #define CMP_MUXCR_MSEL_IN6        0x06                       // minus input 6 connected
            #define CMP_MUXCR_MSEL_IN7        0x07                       // minus input 7 connected
            #define CMP_MUXCR_MSEL            0x07                       // minus input MUX control
            #define CMP_MUXCR_PSEL_IN0        0x00                       // plus input 0 connected
            #define CMP_MUXCR_PSEL_IN1        0x08                       // plus input 1 connected
            #define CMP_MUXCR_PSEL_IN2        0x10                       // plus input 2 connected
            #define CMP_MUXCR_PSEL_IN3        0x18                       // plus input 3 connected
            #define CMP_MUXCR_PSEL_IN4        0x20                       // plus input 4 connected
            #define CMP_MUXCR_PSEL_IN5        0x28                       // plus input 5connected
            #define CMP_MUXCR_PSEL_IN6        0x30                       // plus input 6 connected
            #define CMP_MUXCR_PSEL_IN7        0x38                       // plus input 7 connected
            #define CMP_MUXCR_PSEL            0x38                       // plus input MUX control
            #define CMP_MUXCR_PSTM            0x80                       // pass through mode enable
    #endif
    #if NUMBER_OF_COMPARATORS > 1
        #define CMP1_CR0         *(unsigned char *)(CMP1_BLOCK + 0x0)    // CMP 1 control register 0
        #define CMP1_CR1         *(unsigned char *)(CMP1_BLOCK + 0x1)    // CMP 1 control register 1
        #define CMP1_FPR         *(unsigned char *)(CMP1_BLOCK + 0x2)    // CMP 1 filter period register
        #define CMP1_SCR         *(volatile unsigned char *)(CMP1_BLOCK + 0x3) // CMP 1 status and control register
        #define CMP1_DACCR       *(unsigned char *)(CMP1_BLOCK + 0x4)    // CMP 1 DAC control register
        #define CMP1_MUXCR       *(unsigned char *)(CMP1_BLOCK + 0x5)    // CMP 1 MUX control register
    #endif
    #if NUMBER_OF_COMPARATORS > 2
        #define CMP2_CR0         *(unsigned char *)(CMP2_BLOCK + 0x0)    // CMP 2 control register 0
        #define CMP2_CR1         *(unsigned char *)(CMP2_BLOCK + 0x1)    // CMP 2 control register 1
        #define CMP2_FPR         *(unsigned char *)(CMP2_BLOCK + 0x2)    // CMP 2 filter period register
        #define CMP2_SCR         *(volatile unsigned char *)(CMP2_BLOCK + 0x3) // CMP 2 status and control register
        #define CMP2_DACCR       *(unsigned char *)(CMP2_BLOCK + 0x4)    // CMP 2 DAC control register
        #define CMP2_MUXCR       *(unsigned char *)(CMP2_BLOCK + 0x5)    // CMP 2 MUX control register
    #endif
    #if NUMBER_OF_COMPARATORS > 3
        #define CMP3_CR0         *(unsigned char *)(CMP3_BLOCK + 0x0)    // CMP 3 control register 0
        #define CMP3_CR1         *(unsigned char *)(CMP3_BLOCK + 0x1)    // CMP 3 control register 1
        #define CMP3_FPR         *(unsigned char *)(CMP3_BLOCK + 0x2)    // CMP 3 filter period register
        #define CMP3_SCR         *(volatile unsigned char *)(CMP3_BLOCK + 0x3) // CMP 3 status and control register
        #define CMP3_DACCR       *(unsigned char *)(CMP3_BLOCK + 0x4)    // CMP 3 DAC control register
        #define CMP3_MUXCR       *(unsigned char *)(CMP3_BLOCK + 0x5)    // CMP 3 MUX control register
    #endif

    typedef struct _PACK stKINETIS_COMPARATOR
    {
        unsigned char CMP_CR0;
        unsigned char CMP_CR1;
        unsigned char CMP_FPR;
        volatile unsigned char CMP_SCR;
        unsigned char CMP_DACCR;
        unsigned char CMP_MUXCR;
        unsigned char res[2];
    } KINETIS_COMPARATOR;
#endif

// VREF
//
#define VREF_TRM             *(unsigned char *)(VREF_ADD + 0x0)          // VREF Trim Register
  #define VREF_TRM_TRIP_MASK 0x3f
#define VREF_SC              *(volatile unsigned char *)(VREF_ADD + 0x1) // VREF Status and Control Register
  #define VREF_SC_MODE_LV_BG 0x00                                        // bandgap on only
  #define VREF_SC_MODE_LV_LP 0x01                                        // low-power buffer enabled
  #define VREF_SC_MODE_LV_TR 0x02                                        // tight-regulation buffer enabled
  #define VREF_SC_VREFST     0x04                                        // internal voltage reference stable (read-only)
  #define VREF_SC_REGEN      0x40                                        // enable internal 1.75V regulator
  #define VREF_SC_VREFEN     0x80                                        // enable module





// Low Power Options and modes
//
#define RUN_MODE                  0                                      // no low power operation (normal run)
#define WAIT_MODE                 1                                      // automatic wait mode operation (normal wait)
#define STOP_MODE                 2                                      // automatic stop mode operation (normal stop)
#define MAX_LP_MODES              STOP_MODE                              // lowest power mode for KE devices

#define LOW_POWER_OPTIONS         0                                      // no options

// Random number generator
//
#if defined TRUE_RANDOM_NUMBER_GENERATOR
    #define TRNG0_MCTL           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x00) // TRNG0 miscellaneous control
        #define TRNG_MCTL_SAMP_MODE_VON_NEUMANN 0x00000000               // use Von Neumann data into both entropy shifter and statistical checker (writable only when TRNG_MCTL_PRGM is set)
        #define TRNG_MCTL_SAMP_MODE_RAW         0x00000001               // use raw data into both entropy shifter and statistical checker
        #define TRNG_MCTL_SAMP_MODE_RAW_STAT    0x00000002               // use Von Neumann data into entropy shifter and use raw data into statistical checker
        #define TRNG_MCTL_OSC_DIV_1 0x00000000                           // use ring oscillator with no divide (writable only when TRNG_MCTL_PRGM is set)
        #define TRNG_MCTL_OSC_DIV_2 0x00000004                           // use ring oscillator with divide by 2
        #define TRNG_MCTL_OSC_DIV_4 0x00000008                           // use ring oscillator with divide by 4
        #define TRNG_MCTL_OSC_DIV_8 0x0000000c                           // use ring oscillator with divide by 8
        #define TRNG_MCTL_TRNG_ACC  0x00000020                           // TRNG access mode
        #define TRNG_MCTL_RST_DEF   0x00000040                           // reset defaults (write-only)
        #define TRNG_MCTL_FOR_SCLK  0x00000080                           // force system clock
        #define TRNG_MCTL_FCT_FAIL  0x00000100                           // frequency count fail (read-only)
        #define TRNG_MCTL_FCT_VAL   0x00000200                           // frequency count valid (read-only)
        #define TRNG_MCTL_ENT_VAL   0x00000400                           // entropy valid (read-only)
        #define TRNG_MCTL_TST_OUT   0x00000800                           // test point inside ring oscillator (read-only)
        #define TRNG_MCTL_ERR       0x00001000                           // error (write '1' to clear)
        #define TRNG_MCTL_TSTOP_OK  0x00002000                           // OK to stop (read-only)
        #define TRNG_MCTL_PRGM      0x00010000                           // programming mode select
        #define TRNG_MCTL_PRGM_RUN  0x00000000                           // run mode select
    #define TRNG0_SCMISC         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x04) // TRNG0 statistical check miscellaneous (writable only when TRNG_MCTL_PRGM is set)
        #define TRNG_SCMISC_LRUN_MAX_MASK 0x000000ff                     // long run max limit - default 0x22
        #define TRNG_SCMISC_RTY_CT_MASK   0x000f0000                     // retry count (1..15) - default 1
    #define TRNG0_PKRRNG         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x08) // TRNG0 poker range
        #define TRNG_PKRRNG_PKR_RNG_MASK  0x0000ffff                     // poker range - default 0x09a3
    #define TRNG0_PKRMAX         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x0c) // TRNG0 poker maximum limit
        #define TRNG_PKRMAX_PKR_MAX_MASK  0x00ffffff                     // poker maximum limit - default 0x006920
    #define TRNG0_PKRSQ          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x0c) // TRNG0 poker square calculation result (read-only)
    #define TRNG0_SDCTL          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x10) // TRNG0 seed control
        #define TRNG_SDCTL_SAMP_SIZE_MASK 0x0000ffff                     // sample size mask - default 0x09c4
        #define TRNG_SDCTL_ENT_DLY_MASK   0xffff0000                     // entropy delay mask - default 0x0c80
    #define TRNG0_SBLIM          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x14) // TRNG0 sparse bit limit
    #define TRNG0_TOTSAM         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x14) // TRNG0 total samples (read-only)
    #define TRNG0_FRQMIN         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x18) // TRNG0 frequency count minimum limit
    #define TRNG0_FRQMAX         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x1c) // TRNG0 frequency count maximum limit
    #define TRNG0_FRQCNT         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x1c) // TRNG0 frequency count (read-only)
    #define TRNG0_SCML           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x20) // TRNG0 statistical check monobit limit
    #define TRNG0_SCMC           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x20) // TRNG0 statistical check monobit count (read-only)
    #define TRNG0_SCR1L          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x24) // TRNG0 statistical check run length 1 limit
    #define TRNG0_SCR1C          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x24) // TRNG0 statistical check run length 1 count (read-only)
    #define TRNG0_SCR2L          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x28) // TRNG0 statistical check run length 2 limit
    #define TRNG0_SCR2C          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x28) // TRNG0 statistical check run length 2 count (read-only)
    #define TRNG0_SCR3L          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x2c) // TRNG0 statistical check run length 3 limit
    #define TRNG0_SCR3C          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x2c) // TRNG0 statistical check run length 3 count (read-only)
    #define TRNG0_SCR4L          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x30) // TRNG0 statistical check run length 4 limit
    #define TRNG0_SCR4C          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x30) // TRNG0 statistical check run length 4 count (read-only)
    #define TRNG0_SCR5L          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x34) // TRNG0 statistical check run length 5 limit
    #define TRNG0_SCR5C          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x34) // TRNG0 statistical check run length 5 count (read-only)
    #define TRNG0_SCR6L          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x38) // TRNG0 statistical check run length 6 limit
    #define TRNG0_SCR6C          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x38) // TRNG0 statistical check run length 6 count (read-only)
    #define TRNG0_STATUS         *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x3c) // TRNG0 status (read-only)
    #define TRNG0_ENT0_ADD       (volatile unsigned long *)(TRNG0_BASE_ADD + 0x40)
    #define TRNG0_ENT0           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x40) // TRNG0 entropy read 0 (read-only)
    #define TRNG0_ENT1           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x44) // TRNG0 entropy read 1 (read-only)
    #define TRNG0_ENT2           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x48) // TRNG0 entropy read 2 (read-only)
    #define TRNG0_ENT3           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x4c) // TRNG0 entropy read 3 (read-only)
    #define TRNG0_ENT4           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x50) // TRNG0 entropy read 4 (read-only)
    #define TRNG0_ENT5           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x54) // TRNG0 entropy read 5 (read-only)
    #define TRNG0_ENT6           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x58) // TRNG0 entropy read 6 (read-only)
    #define TRNG0_ENT7           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x5c) // TRNG0 entropy read 7 (read-only)
    #define TRNG0_ENT8           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x60) // TRNG0 entropy read 8 (read-only)
    #define TRNG0_ENT9           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x64) // TRNG0 entropy read 9 (read-only)
    #define TRNG0_ENT10          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x68) // TRNG0 entropy read 10 (read-only)
    #define TRNG0_ENT11          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x6c) // TRNG0 entropy read 11 (read-only)
    #define TRNG0_ENT12          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x70) // TRNG0 entropy read 12 (read-only)
    #define TRNG0_ENT13          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x74) // TRNG0 entropy read 13 (read-only)
    #define TRNG0_ENT14          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x78) // TRNG0 entropy read 14 (read-only)
    #define TRNG0_ENT15          *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x7c) // TRNG0 entropy read 15 (read-only) - this must be read last to trigger the next random number generation
    #define TRNG0_PKRCNT10       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x80) // TRNG0 statistical check poker count 1 and 0 (read-only)
    #define TRNG0_PKRCNT32       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x84) // TRNG0 statistical check poker count 3 and 2 (read-only)
    #define TRNG0_PKRCNT54       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x88) // TRNG0 statistical check poker count 5 and 4 (read-only)
    #define TRNG0_PKRCNT76       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x8c) // TRNG0 statistical check poker count 7 and 6 (read-only)
    #define TRNG0_PKRCNT98       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x90) // TRNG0 statistical check poker count 9 and 8 (read-only)
    #define TRNG0_PKRCNTBA       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x94) // TRNG0 statistical check poker count b and a (read-only)
    #define TRNG0_PKRCNTDC       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x98) // TRNG0 statistical check poker count d and c (read-only)
    #define TRNG0_PKRCNTFE       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0x9c) // TRNG0 statistical check poker count f and e (read-only)
    #define TRNG0_SEC_CFG        *(volatile unsigned long *)(TRNG0_BASE_ADD + 0xa0) // TRNG0 security configuration
    #define TRNG0_INT_CTRL       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0xa4) // TRNG0 interrupt control
    #define TRNG0_INT_MASK       *(volatile unsigned long *)(TRNG0_BASE_ADD + 0xa8) // TRNG0 mask
    #define TRNG0_INT_STATUS     *(volatile unsigned long *)(TRNG0_BASE_ADD + 0xac) // TRNG0 interrupt status
    #define TRNG0_VID1           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0xf0) // TRNG0 version ID (MS)
    #define TRNG0_VID2           *(volatile unsigned long *)(TRNG0_BASE_ADD + 0xf4) // TRNG0 version ID (LS)
#endif


// Fast Ethernet Controller
//
#define EIR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0x4) // Ethernet Interrupt Event Register (write '1' to clear)
#define EIMR                 *(unsigned long *)(EMAC_BASE_ADD + 0x8)     // Ethernet Interrupt Mask Register
  #define BABR               0x40000000                                  // Babbling receive error interrupt/mask
  #define BABT               0x20000000                                  // Babbling transmit error interrupt/mask
  #define GRA                0x10000000                                  // Graceful Stop Complete interrupt/mask
  #define TXF                0x08000000                                  // Transmit Frame interrupt/mask
  #define TXB                0x04000000                                  // Transmit Buffer interrupt/mask
  #define RXF                0x02000000                                  // Receive Frame interrupt/mask
  #define RXB                0x01000000                                  // Receive Buffer interrupt/mask
  #define MII                0x00800000                                  // MII interrupt/mask
  #define EBERR              0x00400000                                  // Ethernet Bus Error interrupt/mask
  #define LC                 0x00200000                                  // Late Collision interrupt/mask
  #define RL                 0x00100000                                  // Collision Retry Limit interrupt/mask
  #define UN                 0x00080000                                  // Transmit FIFO Underrun
  #define EIMR_PLR           0x00040000                                  // payload receive error
  #define EIMR_WAKEUP        0x00020000                                  // node wakeup request indication
  #define EIMR_TS_AVAIL      0x00010000                                  // transmit timestamp available
  #define EIMR_TS_TIMER      0x00008000                                  // timestamp timer
#define RDAR                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x10) // Receive Descriptor Active Register
#define TDAR                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x14) // Transmit Descriptor Active Register
  #define TDAR_TDAR          0x00000000                                  // 0x01000000 but any value written is adequate
#define ECR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0x24) // Ethernet Control Register
  #define RESET_FEC          0x00000001                                  // issue MAC reset (self-clearing)
  #define ETHER_EN           0x00000002                                  // enable Ethernet operation
  #define ETHER_MAGICEN      0x00000004                                  // enable magic package detection
  #define ETHER_SLEEP        0x00000008                                  // enable sleep mode
  #define ETHER_EN1588       0x00000010                                  // enable enhanced functionality
  #define ETHER_DBGEN        0x00000040                                  // enter freeze mode when debugging
  #define ETHER_DBSWP        0x00000100                                  // enable descriptor byte swapping to support little-endian devices
#define MMFR                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x40) // MII Data Register
  #define MII_TA             0x00020000
  #define MII_ST             0x40000000
  #define WRITE_OP           0x10000000
  #define READ_OP            0x20000000

  #define MII_WRITE (MII_TA | MII_ST | WRITE_OP)
  #define MII_READ  (MII_TA | MII_ST | READ_OP)
#define MSCR                 *(unsigned long *)(EMAC_BASE_ADD + 0x44)    // MII Speed Control Register
  #define MSCR_HOLDTIME_MASK 0x00000700
  #define DIS_PREAMBLE       0x00000080
  #define MII_SPEED_60MHZ    (0xd << 1)                                  // correct setting for 60MHz system
#define MIBC                 *(volatile unsigned long *)(EMAC_BASE_ADD + 0x64) // MII Control/Status Register
  #define MIB_DISABLE        0x80000000
  #define MIB_IDLE           0x40000000
  #define MIB_CLEAR          0x20000000
#define RCR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0x84) // Receive Control Register
  #define RCR_GRS            0x80000000                                  // graceful receive stopped (read-only)
  #define RCR_NLC            0x40000000                                  // payload length check
  #define MAX_FRAME_LENGTH   0x05ee0000                                  // 1518 bytes
  #define RCR_CFEN           0x00008000                                  // mac control frames enable
  #define CRCFWD             0x00004000                                  // strip CRC from frame and don't pass to user
  #define PAUFWD             0x00004000                                  // forward pause frames to application
  #define PADEN              0x00001000                                  // remove padding from received frames (disables CRCFWD)
  #define RMII_10T           0x00000200                                  // 10 base T in RMII 
  #define RMII_MODE          0x00000100                                  // RMII mode
  #define FCE                0x00000020                                  // Pause flow control
  #define BC_REJ             0x00000010                                  // Reject Broadcast
  #define PROM               0x00000008                                  // Promiscuous
  #define FEC_MII_MODE       0x00000004                                  // MII mode
  #define DRT                0x00000002                                  // Half duplex
  #define LOOP               0x00000001                                  // Loopback  
#define TCR                  *(volatile unsigned long *)(EMAC_BASE_ADD + 0xc4) // Transmit Control Register
  #define FDEN               0x00000004                                  // Full duplex
#define PALR                 *(unsigned long *)(EMAC_BASE_ADD + 0xe4)    // Physical Address Low Register
#define PAUR                 *(unsigned long *)(EMAC_BASE_ADD + 0xe8)    // Physical Address High and Type Field Register
#define OPD                  *(unsigned long *)(EMAC_BASE_ADD + 0xec)    // Op-code and Pause Duration
  #define PAUSE_DURATION     0x00000001
#define IAUR                 *(unsigned long *)(EMAC_BASE_ADD + 0x118)   // Hash table upper 32 bits
#define IALR                 *(unsigned long *)(EMAC_BASE_ADD + 0x11c)   // Hash table lower 32 bits
#define GAUR                 *(unsigned long *)(EMAC_BASE_ADD + 0x120)   // Group Hash table upper 32 bits
#define GALR                 *(unsigned long *)(EMAC_BASE_ADD + 0x124)   // Group Hash table lower 32 bits
#define ENET_TFWR            *(unsigned long *)(EMAC_BASE_ADD + 0x144)   // Transmit FIFO Watermark
  #define TFWR_TFWR_64       0x00000000                                  // transmission starts when 64 bytes have been written
  #define TFWR_TFWR_128      0x00000002                                  // transmission starts when 128 bytes have been written (or frame complete)
  #define TFWR_TFWR_192      0x00000003                                  // transmission starts when 192 bytes have been written (or frame complete)
  #define TFWR_TFWR_4032     0x0000003f                                  // transmission starts when 4032 bytes have been written (or frame complete)
  #define TFWR_STRFWD        0x00000100                                  // store and forward enable
#define ERDSR                *(unsigned long *)(EMAC_BASE_ADD + 0x180)   // Pointer to Receive Descriptor Ring
#define ETDSR                *(unsigned long *)(EMAC_BASE_ADD + 0x184)   // Pointer to Transmit Descriptor Ring
#define EMRBR                *(unsigned long *)(EMAC_BASE_ADD + 0x188)   // Maximum Receive Buffer Size

#define ENET_RSFL            *(unsigned long *)(EMAC_BASE_ADD + 0x190)   // Receive FIFO Section Full Threshold
#define ENET_RSEM            *(unsigned long *)(EMAC_BASE_ADD + 0x194)   // Receive FIFO Section Empty Threshold
#define ENET_RAEM            *(unsigned long *)(EMAC_BASE_ADD + 0x198)   // Receive FIFO Almost Empty Threshold
#define ENET_RAFL            *(unsigned long *)(EMAC_BASE_ADD + 0x19c)   // Receive FIFO Almost Full Threshold
#define ENET_TSEM            *(unsigned long *)(EMAC_BASE_ADD + 0x1a0)   // Transmit FIFO Section Empty Threshold
#define ENET_TAEM            *(unsigned long *)(EMAC_BASE_ADD + 0x1a4)   // Transmit FIFO Almost Empty Threshold
#define ENET_TAFL            *(unsigned long *)(EMAC_BASE_ADD + 0x1a8)   // Transmit FIFO Almost Full Threshold
#define ENET_TIPG            *(unsigned long *)(EMAC_BASE_ADD + 0x1ac)   // Transmit Inter-Packet Gap
#define ENET_FTRL            *(unsigned long *)(EMAC_BASE_ADD + 0x1b0)   // Transmit Truncation Length

#define ENET_TACC            *(unsigned long *)(EMAC_BASE_ADD + 0x1c0)   // Transmit Accelerator Function Configuration
  #define TACC_SHIFT16       0x00000001                                  // insert 16 bit shift to align frames to 32 bit boundaries
  #define TACC_IPCHK         0x00000008                                  // enables insertion of IP header checksum
  #define TACC_PROCHK        0x00000010                                  // enables insertion of protocol checksum
#define ENET_RACC            *(unsigned long *)(EMAC_BASE_ADD + 0x1c4)   // Receive Accelerator Function Configuration
  #define RACC_PADREM        0x00000001                                  // enable padding removal for short reception frames
  #define RACC_IPDIS         0x00000002                                  // enable discard of received frames with bad IP checksums
  #define RACC_PRODIS        0x00000004                                  // enable discard of received frames with bad protocol checksums
  #define RACC_LINEDIS       0x00000040                                  // enable discard of received frames with MAC errors
  #define RACC_SHIFT16       0x00000080                                  // insert 16 bit shift to align frames to 32 bit boundaries

#define MIBRAM_ADD           (volatile unsigned long *)(EMAC_BASE_ADD + 0x200)
#define MIB_RAM_SIZE         228                                         // occupied (memory space is for 512 entries)

#define RMON_T_DROP          *MIBRAM_ADD                                 // count of frames not counted correctly
#define RMON_T_PACKETS       *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x04) // count of TX packets
#define RMON_T_BC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x08) // count of TX broadcast packets
#define RMON_T_MC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x0c) // count of TX multicast packets
#define RMON_T_CRC_ALIGN     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x10) // count of TX packets with CRC Align error
#define RMON_T_UNDERSIZE     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x14) // count of TX packets < 64 bytes with good CRC
#define RMON_T_OVERSIZE      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x18) // count of TX packets > MAX_FL bytes with good CRC
#define RMON_T_FRAG          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x1c) // count of TX packets < 64 bytes with bad CRC
#define RMON_T_JAB           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x20) // count of TX packets > MAX_FL bytes with bad CRC
#define RMON_T_COL           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x24) // count of TX collisions
#define RMON_T_P64           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x28) // count of TX 64 byte packets
#define RMON_T_P65TO127      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x2c) // count of TX 65 to 127 byte packets
#define RMON_T_P128TO255     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x30) // count of TX 128 to 255 byte packets
#define RMON_T_P256TO511     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x34) // count of TX 256 to 511 byte packets
#define RMON_T_P512TO1023    *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x38) // count of TX 512 to 1023 byte packets
#define RMON_T_P1024TO2047   *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x3c) // count of TX 1024 to 2047 byte packets
#define RMON_T_P_GTE2048     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x40) // count of TX >2048 byte packets
#define RMON_T_OCTETS        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x44) // count of TX octets
#define IEEE_T_DROP          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x48) // count of TX frame not counted correctly
#define IEEE_T_FRAME_OK      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x4c) // count of TX frames transmitted OK
#define IEEE_T_1COL          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x50) // count of TX frames transmitted with single collision
#define IEEE_T_MCOL          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x54) // count of TX frames transmitted with multiple collision
#define IEEE_T_DEF           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x58) // count of TX frames transmitted after deferral delay
#define IEEE_T_LCOL          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x5c) // count of TX frames transmitted with late collision
#define IEEE_T_EXCOL         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x60) // count of TX frames transmitted with excessive collisions
#define IEEE_T_MACERR        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x64) // count of TX frames transmitted with TX FIFO underrun
#define IEEE_T_CSERR         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x68) // count of TX frames transmitted with carrier sense error
#define IEEE_T_SQE           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x6c) // count of TX frames transmitted with SQE error
#define IEEE_T_FDFXC         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x70) // count of TX flow control pause frames transmitted
#define IEEE_T_OCTETS_OK_ADD  (volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x74)
#define IEEE_T_OCTETS_OK     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x74) // count of TX octets transmitted without error

#define RMON_R_PACKETS_ADD    (volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x84)
#define RMON_R_PACKETS       *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x84) // count of RX packets
#define RMON_R_BC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x88) // count of RX broadcast packets
#define RMON_R_MC_PKT        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x8c) // count of RX multicast packets
#define RMON_R_CRC_ALIGN     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x90) // count of RX packets with CRC Align error
#define RMON_R_UNDERSIZE     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x94) // count of RX packets < 64 bytes with good CRC
#define RMON_R_OVERSIZE      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x98) // count of RX packets > MAX_FL bytes with good CRC
#define RMON_R_FRAG          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0x9c) // count of RX packets < 64 bytes with bad CRC
#define RMON_R_JAB           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xa0) // count of RX packets > MAX_FL bytes with bad CRC
#define RMON_R_P64           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xa8) // count of RX 64 byte packets
#define RMON_R_P65TO127      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xac) // count of RX 65 to 127 byte packets
#define RMON_R_P128TO255     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xb0) // count of RX 128 to 255 byte packets
#define RMON_R_P256TO511     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xb4) // count of RX 256 to 511 byte packets
#define RMON_R_P512TO1023    *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xb8) // count of RX 512 to 1023 byte packets
#define RMON_R_P1024TO2047   *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xbc) // count of RX 1024 to 2047 byte packets
#define RMON_R_P_GTE2048     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xc0) // count of RX >2048 byte packets
#define RMON_R_OCTETS        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xc4) // count of RX octets
#define IEEE_R_DROP          *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xc8) // count of RX frame not counted correctly
#define IEEE_R_FRAME_OK      *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xcc) // count of RX frames received OK
#define IEEE_R_CRC           *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xd0) // count of RX frames received with CRC error
#define IEEE_R_ALIGN         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xd4) // count of RX frames received with alignment error
#define IEEE_R_MACERR        *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xd8) // count of RX receive FIFO overflows
#define IEEE_R_FDFXC         *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xdc) // count of RX flow control pause frames received
#define IEEE_R_OCTETS_OK     *(volatile unsigned long*)(EMAC_BASE_ADD + 0x200 + 0xe0) // count of RX octets received without error

#define ENET_ATCR            *(unsigned long *)(EMAC_BASE_ADD + 0x400)   // Timer Control Register
#define ENET_ATVR            *(unsigned long *)(EMAC_BASE_ADD + 0x404)   // Timer Value Register
#define ENET_ATOFF           *(unsigned long *)(EMAC_BASE_ADD + 0x408)   // Timer Offset Register
#define ENET_ATPER           *(unsigned long *)(EMAC_BASE_ADD + 0x40c)   // Timer Period Register
#define ENET_ATCOR           *(unsigned long *)(EMAC_BASE_ADD + 0x410)   // Timer Correction Register
#define ENET_ATINC           *(unsigned long *)(EMAC_BASE_ADD + 0x414)   // Time-Stamping Clock Period Register
#define ENET_ATSTMP          *(volatile unsigned long *)(EMAC_BASE_ADD + 0x418) // Timestamp of Last Transmitted Frame (read-only)

#define ENET_TGSR            *(volatile unsigned long *)(EMAC_BASE_ADD + 0x604) // Timer Global Status Register
#define ENET_TCSR0           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x608) // Timer Control Status Register 0
#define ENET_TCCR0           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x60c) // Timer Compare Capture Register 0
#define ENET_TCSR1           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x610) // Timer Control Status Register 1
#define ENET_TCCR1           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x614) // Timer Compare Capture Register 1
#define ENET_TCSR2           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x618) // Timer Control Status Register 2
#define ENET_TCCR2           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x61c) // Timer Compare Capture Register 2
#define ENET_TCSR3           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x620) // Timer Control Status Register 3
#define ENET_TCCR3           *(volatile unsigned long *)(EMAC_BASE_ADD + 0x624) // Timer Compare Capture Register 3

typedef struct stKINETIS_FAST_ENET
{
    unsigned long ulRes;
    volatile unsigned long ENET_EIR;
    unsigned long  ENET_EIMR;
    unsigned long ulRes0;
    volatile unsigned long ENET_RDAR;
    volatile unsigned long ENET_TDAR;
    unsigned long ulRes1[3];
    volatile unsigned long ENET_ECR;
    unsigned long ulRes2[6];
    volatile unsigned long ENET_MMFR;
    unsigned long ENET_MSCR;
    unsigned long ulRes3[7];
    volatile unsigned long ENET_MIBC;
    unsigned long ulRes4[7];
    volatile unsigned long ENET_RCR;
    unsigned long ulRes5[15];
    volatile unsigned long ENET_TCR;
    unsigned long ulRes6[7];
    unsigned long ENET_PALR;
    unsigned long ENET_PAUR;
    unsigned long ENET_OPD;
    unsigned long ulRes7[10];
    unsigned long ENET_IAUR;
    unsigned long ENET_IALR;
    unsigned long ENET_GAUR;
    unsigned long ENET_GALR;
    unsigned long ulRes8[7];
    unsigned long _ENET_TFWR;
    unsigned long ulRes9[14];
    unsigned long ENET_ERDSR;
    unsigned long ENET_ETDSR;
    unsigned long ENET_EMRBR;
    unsigned long ulRes10;
    unsigned long _ENET_RSFL;
    unsigned long _ENET_RSEM;
    unsigned long _ENET_RAEM;
    unsigned long _ENET_RAFL;
    unsigned long _ENET_TSEM;
    unsigned long _ENET_TAEM;
    unsigned long _ENET_TAFL;
    unsigned long _ENET_TIPG;
    unsigned long _ENET_FTRL;
    unsigned long ulRes11[3];
    unsigned long _ENET_TACC;
    unsigned long _ENET_RACC;
    unsigned long ulRes12[14];
    unsigned long ulMIB[512/sizeof(unsigned long)];                      // counters
    unsigned long _ENET_ATCR;
    unsigned long _ENET_ATVR;
    unsigned long _ENET_ATOFF;
    unsigned long _ENET_ATPER;
    unsigned long _ENET_ATCOR;
    unsigned long _ENET_ATINC;
    unsigned long _ENET_ATSTMP;
    unsigned long ulRes13[122];
    unsigned long _ENET_TGSR;
    unsigned long _ENET_TCSR0;
    unsigned long _ENET_TCCR0;
    unsigned long _ENET_TCSR1;
    unsigned long _ENET_TCCR1;
    unsigned long _ENET_TCSR2;
    unsigned long _ENET_TCCR2;
    unsigned long _ENET_TCSR3;
    unsigned long _ENET_TCCR3;
} KINETIS_FAST_ENET;


#if defined ETHER_DBSWP                                                  // natural little-endian
    typedef struct stKINETIS_FEC_BD
    {
        volatile unsigned short usBDLength;
        volatile unsigned short usBDControl;
        unsigned char *ptrBD_Data;
    #if defined EMAC_ENHANCED                                            // additional fields available in enhanced mode
        volatile unsigned long  ulBDControlEnhanced;
        volatile unsigned short usPayloadCS;                             // only receiver
        volatile unsigned short usRxInfoHeaderProt;                      // only receiver
        volatile unsigned long  ulBDU;
        volatile unsigned long  ul1588_timestamp;
        unsigned long  ulRes[2];
    #endif
    } KINETIS_FEC_BD;

    #define EMPTY_BUFFER         0x8000                                  // RX BD Control bits
    #define RECEIVE_OWNERSHIP_1  0x4000                                  // can be optionally used by software
    #define WRAP_BIT_RX          0x2000
    #define RECEIVE_OWNERSHIP_2  0x1000                                  // can be optionally used by software
    #define LAST_IN_FRAME_RX     0x0800
    #define RECEIVE_MISS         0x0100                                  // received due to promiscuous mode only
    #define RECEIVE_BROADCAST    0x0080                                  // received due to broadcast address
    #define RECEIVE_MULTICAST    0x0040                                  // received due to multicast address
    #define RECEIVE_LENGTH_VIOL  0x0020                                  // receive frame length violation
    #define RECEIVE_NON_OCTET_AL 0x0010                                  // non-octet aligned frame
    #define RECEIVE_CRC_ERROR    0x0004                                  // receive CRC or frame error
    #define OVERRUN_FRAME        0x0002
    #define TRUNCATED_FRAME      0x0001

    // Enhanced
    //
    #define RX_MAC_ERROR         0x80000000
    #define RX_PHY_ERROR         0x04000000
    #define RX_COLLISION         0x02000000
    #define RX_UNICAST           0x01000000
    #define RX_GEN_INTERRUPT     0x00800000
    #define RX_IP_CS_ERROR       0x00000020
    #define RX_PROT_CS_ERROR     0x00000010
    #define RX_VLAN              0x00000004
    #define RX_IPV6              0x00000002
    #define RX_IPV4_FRAG         0x00000001

    #define RX_HEADER_LEN_MASK   0xf800
    #define RX_PROT_TYPE_MASK    0x00ff


    #define READY_TX             0x8000                                  // TX BD Control bits
    #define TRANSMIT_OWNERSHIP_1 0x4000                                  // can be optionally used by software
    #define WRAP_BIT_TX          0x2000
    #define TRANSMIT_OWNERSHIP_2 0x1000                                  // can be optionally used by software
    #define LAST_IN_FRAME_TX     0x0800
    #define TX_CRC               0x0400
    #define TX_ABC               0x0200                                  // append bad CRC - not supported in enhanced mode

    // Enhanced
    //
    #define TX_GENERATE_INT      0x40000000
    #define TX_ADD_TIMESTAMP     0x20000000
    #define TX_INSERT_PROT_CS    0x10000000
    #define TX_INSERT_IP_CS      0x08000000
    #define TX_ERROR_OCCURRED    0x00008000
    #define TX_UNDERFLOW_ERROR   0x00002000
    #define TX_EXCESS_COLLISIONS 0x00001000
    #define TX_FRAME_ERROR       0x00000800
    #define TX_LATE_COLLISION    0x00000400
    #define TX_OVERFLOW_ERROR    0x00000200
    #define TX_TIMESTAMP_ERROR   0x00000100

    #define BD_UPDATE_DONE       0x80000000                              // rx and tx
#else                                                                    // big-endian representation
    typedef struct stKINETIS_FEC_BD
    {
        volatile unsigned short usBDControl;
        volatile unsigned short usBDLength;
        unsigned char *ptrBD_Data;
    #if defined EMAC_ENHANCED                                            // additional fields available in enhanced mode
        volatile unsigned long  ulBDControlEnhanced;
        volatile unsigned short usRxInfoHeaderProt;                      // only receiver
        volatile unsigned short usPayloadCS;                             // only receiver
        volatile unsigned long  ulBDU;
        volatile unsigned long  ul1588_timestamp;
        unsigned long  ulRes[2];
    #endif
    } KINETIS_FEC_BD;

    #define EMPTY_BUFFER         0x0080                                  // RX BD Control bits
    #define RECEIVE_OWNERSHIP_1  0x0040                                  // can be optionally used by software
    #define WRAP_BIT_RX          0x0020
    #define RECEIVE_OWNERSHIP_2  0x0010                                  // can be optionally used by software
    #define LAST_IN_FRAME_RX     0x0008
    #define RECEIVE_MISS         0x0001                                  // received due to promiscuous mode only
    #define RECEIVE_BROADCAST    0x8000                                  // received due to broadcast address
    #define RECEIVE_MULTICAST    0x4000                                  // received due to multicast address
    #define RECEIVE_LENGTH_VIOL  0x2000                                  // receive frame length violation
    #define RECEIVE_NON_OCTET_AL 0x1000                                  // non-octet aligned frame
    #define RECEIVE_CRC_ERROR    0x0400                                  // receive CRC or frame error
    #define OVERRUN_FRAME        0x0200
    #define TRUNCATED_FRAME      0x0100

    // Enhanced
    //
    #define RX_MAC_ERROR         0x00000080
    #define RX_PHY_ERROR         0x00000004
    #define RX_COLLISION         0x00000002
    #define RX_UNICAST           0x00000001
    #define RX_GEN_INTERRUPT     0x00008000
    #define RX_IP_CS_ERROR       0x20000000
    #define RX_PROT_CS_ERROR     0x10000000
    #define RX_VLAN              0x04000000
    #define RX_IPV6              0x02000000
    #define RX_IPV4_FRAG         0x01000000

    #define RX_HEADER_LEN_MASK   0x00f8
    #define RX_PROT_TYPE_MASK    0xff00


    #define READY_TX             0x0080                                  // TX BD Control bits
    #define TRANSMIT_OWNERSHIP_1 0x0040                                  // can be optionally used by software
    #define WRAP_BIT_TX          0x0020
    #define TRANSMIT_OWNERSHIP_2 0x0010                                  // can be optionally used by software
    #define LAST_IN_FRAME_TX     0x0008
    #define TX_CRC               0x0004
    #define TX_ABC               0x0002                                  // append bad CRC - not supported in enhanced mode

    // Enhanced
    //
    #define TX_GENERATE_INT      0x00000040
    #define TX_ADD_TIMESTAMP     0x00000020
    #define TX_INSERT_PROT_CS    0x00000010
    #define TX_INSERT_IP_CS      0x00000008
    #define TX_ERROR_OCCURRED    0x00800000
    #define TX_UNDERFLOW_ERROR   0x00200000
    #define TX_EXCESS_COLLISIONS 0x00100000
    #define TX_FRAME_ERROR       0x00080000
    #define TX_LATE_COLLISION    0x00040000
    #define TX_OVERFLOW_ERROR    0x00020000
    #define TX_TIMESTAMP_ERROR   0x00010000

    #define BD_UPDATE_DONE       0x00000080                              // rx and tx
#endif


// PHY registers symbolic names
// (located in MII memory map, accessible through MDIO)
//
#define PHY_REG_CR      0x00                                             // Control Register 
#define PHY_REG_SR      0x01                                             // Status Register
#define PHY_REG_ID1     0x02                                             // PHY Identification Register 1 
#define PHY_REG_ID2     0x03                                             // PHY Identification Register 2
#define PHY_REG_ANAR    0x04                                             // Auto-Negotiation Advertisement Register 
#define PHY_REG_ANLPAR  0x05                                             // Auto-Negotiation Link Partner Ability Register 
#define PHY_REG_ER      0x06                                             // Auto-Negotiation Expansion Register 
#define PHY_REG_NPTR    0x07                                             // Auto-Negotiation Next Page Transfer Register
#define PHY_REG_ICR     0x10                                             // Interrupt Control Register 
  #define PHY_ACKIE 0x4000                                               // acknowledge bit received interrupt enable
  #define PHY_PRIE  0x2000                                               // Page received interrupt enable
  #define PHY_LCIE  0x1000                                               // Link changed interrupt enable
  #define PHY_ANIE  0x0800                                               // Auto negotiate changed interrupt enable
  #define PHY_PDFIE 0x0400                                               // Parallel detect fault interrupt enable
  #define PHY_RFIE  0x0200                                               // Remote fault interrupt enable
  #define PHY_JABIE 0x0100                                               // Jabber interrupt enable

  #define PHY_ACKR  0x0040                                               // acknowledge bit received
  #define PHY_PGR   0x0020                                               // Page received 
  #define PHY_LKC   0x0010                                               // Link changed
  #define PHY_ANC   0x0008                                               // Auto negotiate changed
  #define PHY_PDF   0x0004                                               // Parallel detect fault 
  #define PHY_RMTF  0x0002                                               // Remote fault 
  #define PHY_JABI  0x0001                                               // Jabber interrupt 

#define PHY_REG_PSR     0x11                                             // Proprietary Status Register
#define PHY_REG_PCR     0x12                                             // Proprietary Control Register 
#define PHY_REG_10BTBC  0x13                                             // 10Base-T Bypass Control Register 
#define PHY_REG_100BXBC 0x14                                             // 100Base-X Bypass Control Register 
#define PHY_REG_ADDR    0x15                                             // Test & Trim Control Register 
#define PHY_REG_DSPRC   0x17                                             // DSP Reset Control 
#define PHY_REG_DSPRR1  0x18                                             // 100Base-X DSP Read Registers 
#define PHY_REG_DSPRR2  0x19
#define PHY_REG_DSPRR3  0x1a
#define PHY_REG_DSPWR1  0x1b                                             // 100Base-X DSP Write Registers 
#define PHY_REG_DSPWR2  0x1c                              
#define PHY_REG_DSPWR3  0x1d
#define PHY_REG_CTRL1   0x1e
#define PHY_REG_CTRL2   0x1f

#define KSZ8051_CTRL2_RMII_50MHZ_CLK                 0x0080

// External PHY specific registers (Micrel)
//
#define KS8041_BASIC_STATUS_REGISTER                  0x1
  #define PHY_SUPPORT_EXTENDED_CAPABILITIES           0x0001
  #define PHY_JABBER_DETECTED                         0x0002
  #define PHY_LINK_IS_UP                              0x0004
  #define PHY_AUTO_NEGOTIATION_CAPABLE                0x0008
  #define PHY_REMOTE_FAULT_DETECTED                   0x0010
  #define PHY_AUTO_NEGOTIATION_COMPLETE               0x0020
  #define PHY_NO_PREAMBLE                             0x0040
  #define PHY_10MEG_HALF_DUPLEX                       0x0800
  #define PHY_10MEG_FULL_DUPLEX                       0x1000
  #define PHY_100MEG_HALF_DUPLEX                      0x2000
  #define PHY_100MEG_FULL_DUPLEX                      0x4000
  #define PHY_100MEG_T4_CAPABLE                       0x8000

#define KS8041_RXER_COUNTER_REGISTER                  0x15
#define KS8041_INTERRUPT_CONTROL_STATUS_REGISTER      0x1b
  #define PHY_LINK_UP_INT_ENABLE                      0x0100
  #define PHY_REMOTE_FAULT_INT_ENABLE                 0x0200
  #define PHY_LINK_DOWN_INT_ENABLE                    0x0400
  #define PHY_LINK_PARTNER_ACK_INT_ENABLE             0x0800
  #define PHY_PARALLEL_DETECT_FAULT_INT_ENABLE        0x1000
  #define PHY_PAGE_RECEIVED_INT_ENABLE                0x2000
  #define PHY_RECEIVE_ERROR_INT_ENABLE                0x4000
  #define PHY_JABBER_INT_ENABLE                       0x8000
  #define PHY_LINK_UP_INT                             0x0001
  #define PHY_REMOTE_FAULT_INT                        0x0002
  #define PHY_LINK_DOWN_INT                           0x0004
  #define PHY_LINK_PARTNER_ACK_INT                    0x0008
  #define PHY_PARALLEL_DETECT_FAULT_INT               0x0010
  #define PHY_PAGE_RECEIVED_INT                       0x0020
  #define PHY_RECEIVE_ERROR_INT                       0x0040
  #define PHY_JABBER_INT                              0x0080
#if defined PHY_KSZ8031
    #define KS8041_100BASETX_PHY_CONTROL_REGISTER     0x1e
      #define PHY_PHY_IS_ISOLATED                     0x0008
      #define PHY_MODE_MASK                           0x0007
      #define PHY_MODE_AUTONEGOTIATING                0x0000
      #define PHY_MODE_10BASE_T_HALF_DUPLEX           0x0001
      #define PHY_MODE_100BASE_TX_HALF_DUPLEX         0x0002
      #define PHY_MODE_10BASE_T_FULL_DUPLEX           0x0005
      #define PHY_MODE_100BASE_TX_FULL_DUPLEX         0x0006
#else
    #define KS8041_100BASETX_PHY_CONTROL_REGISTER     0x1f
      #define PHY_HP_MDIX                             0x8000
      #define PHY_MDIX_SELECT                         0x4000
      #define PHY_PAIRSWAP_DISABLE                    0x2000
      #define PHY_ENERGY_DETECT                       0x1000
      #define PHY_FORCE_LINK                          0x0800
      #define PHY_POWER_SAVING                        0x0400
      #define PHY_INTERRUPT_ACTIVE_HIGH               0x0200
      #define PHY_ENABLE_JABBER                       0x0100
      #define PHY_AUTONEG_COMPLETE                    0x0080
      #define PHY_ENABLE_FLOW_CONTROL_CAPABLE         0x0040
      #define PHY_PHY_IS_ISOLATED                     0x0020
      #define PHY_MODE_MASK                           0x001c
      #define PHY_MODE_AUTONEGOTIATING                0x0000
      #define PHY_MODE_10BASE_T_HALF_DUPLEX           0x0004
      #define PHY_MODE_100BASE_TX_HALF_DUPLEX         0x0008
      #define PHY_MODE_10BASE_T_FULL_DUPLEX           0x0014
      #define PHY_MODE_100BASE_TX_FULL_DUPLEX         0x0018
      #define PHY_ENABLE_SQE_TEST                     0x0002
      #define PHY_DISABLE_SCRAMBLER                   0x0001
#endif


// 0 - Control Register
//
#define PHY_R0_RESET    0x8000                                           // Reset
#define PHY_R0_LB       0x4000                                           // Loop Back
#define PHY_R0_DR       0x2000                                           // Data Rate (100Mb/s)
#define PHY_R0_ANE      0x1000                                           // Auto-Negotiation Enable
#define PHY_R0_PD       0x0800                                           // Power Down
#define PHY_R0_ISOLATE  0x0400                                           // Isolate (MII is disconnected)
#define PHY_R0_RAN      0x0200                                           // Restart Auto-Negotiation
#define PHY_R0_DPLX     0x0100                                           // Duplex (Full duplex)
#define PHY_R0_CT       0x0080                                           // Collision Test (Enable)

// 4 - Auto Negotiation Advertisement Register
//
#define PHY_R4_NP       0x8000                                           // Next Page (capable of sending next pages)
#define PHY_R4_RF       0x2000                                           // Remote Fault
#define PHY_R4_FC       0x0400                                           // Flow Control
#define PHY_R4_100F     0x0100                                           // 100Base-TX Full Duplex Capable 
#define PHY_R4_100H     0x0080                                           // 100Base-TX Half Duplex Capable
#define PHY_R4_10F      0x0040                                           // 10Base-T Full Duplex Capable 
#define PHY_R4_10H      0x0020                                           // 10Base-T Half Duplex Capable 

// Proprietary Status Register
//
#define PHY_R17_LNK   0x4000    
#define PHY_R17_DPM   0x2000                                             // Duplex Mode
#define PHY_R17_SPD   0x1000                                             // Speed
#define PHY_R17_ANNC  0x0400                                             // Auto-Negotiation Complete
#define PHY_R17_PRCVD 0x0200
#define PHY_R17_ANCM  0x0100                                             // Auto-Negotiation (A-N) Common Operating Mode
#define PHY_R17_PLR   0x0020


#if defined PHY_MULTI_PORT
    extern unsigned short _fnMIIread(unsigned char ucPort, unsigned char _mradr);
    extern void _fnMIIwrite(unsigned char ucPort, unsigned char _mradr, unsigned short _mwdata);
#else
    extern unsigned short _fnMIIread(unsigned char _mradr);
    extern void _fnMIIwrite(unsigned char _mradr, unsigned short _mwdata);
#endif

// DAC
//
#if DAC_CONTROLLERS > 0
    #if defined KINETIS_KE18
        #define DAC0_DAT0                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x00) // data register 0
        #define DAC0_DAT1                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x04) // data register 1
        #define DAC0_DAT2                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x08) // data register 2
        #define DAC0_DAT3                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x0c) // data register 3
        #define DAC0_DAT4                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x10) // data register 4
        #define DAC0_DAT5                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x14) // data register 5
        #define DAC0_DAT6                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x18) // data register 6
        #define DAC0_DAT7                    *(volatile unsigned long *)(DAC0_BASE_ADD + 0x1c) // data register 7
        #define DAC0_STATCTRL                *(volatile unsigned long *)(DAC0_BASE_ADD + 0x20) // data status and control register
            #define DAC_STATCTRL_DACBFRPBF   0x00000001                  // DAC buffer read pointer bottom position flag
            #define DAC_STATCTRL_DACBFRPTF   0x00000002                  // DAC buffer read pointer top position flag
            #define DAC_STATCTRL_DACBFWMF    0x00000004                  // DAC buffer watermark flag
            #define DAC_STATCTRL_DACBBIEN    0x00000100                  // DAC buffer read pointer bottom flag interrupt enable
            #define DAC_STATCTRL_DACBTIEN    0x00000200                  // DAC buffer read pointer top flag interrupt enable
            #define DAC_STATCTRL_DACBWIEN    0x00000400                  // DAC buffer watermark interrupt enable
            #define DAC_STATCTRL_LPEN        0x00000800                  // DAC low pwoer control
            #define DAC_STATCTRL_DACSWTRG    0x00001000                  // DAC software trigger (reads always '0')
            #define DAC_STATCTRL_DACTRGSEL   0x00002000                  // DAC trigger select
            #define DAC_STATCTRL_DACRFS      0x00004000                  // DAC reference select
            #define DAC_STATCTRL_DACEN       0x00008000                  // DAC enable
            #define DAC_STATCTRL_DACBFEN     0x00010000                  // DAC buffer enable
            #define DAC_STATCTRL_DACBFMD_MASK 0x00060000                 // DAC buffer work mode select
            #define DAC_STATCTRL_DACBFWM_MASK 0x00180000                 // DAC buffer watermark select
            #define DAC_STATCTRL_TESTOUTEN   0x00200000                  // DAC test output enable
            #define DAC_STATCTRL_BFOUTEN     0x00400000                  // DAC output buffer enable
            #define DAC_STATCTRL_DMAEN       0x00800000                  // DMA enable
            #define DAC_STATCTRL_DACBFUP     0x0f000000                  // DAC buffer upper limit
            #define DAC_STATCTRL_DACBFRP     0xf0000000                  // DAC buffer read pointer
    #else
        #define DAC0_DAT0L                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x00) // Data Low Register
        #define DAC0_DAT0H                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x01) // Data High Register
        #define DAC0_DAT1L                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x02) // Data Low Register
        #define DAC0_DAT1H                   *(volatile unsigned char *)(DAC0_BASE_ADD + 0x03) // Data High Register
        #if !defined KINETIS_KL || defined KINETIS_KL28
            #define DAC0_DAT2L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x04) // Data Low Register
            #define DAC0_DAT2H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x05) // Data High Register
            #define DAC0_DAT3L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x06) // Data Low Register
            #define DAC0_DAT3H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x07) // Data High Register
            #define DAC0_DAT4L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x08) // Data Low Register
            #define DAC0_DAT4H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x09) // Data High Register
            #define DAC0_DAT5L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0a) // Data Low Register
            #define DAC0_DAT5H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0b) // Data High Register
            #define DAC0_DAT6L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0c) // Data Low Register
            #define DAC0_DAT6H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0d) // Data High Register
            #define DAC0_DAT7L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0e) // Data Low Register
            #define DAC0_DAT7H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x0f) // Data High Register
            #define DAC0_DAT8L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x10) // Data Low Register
            #define DAC0_DAT8H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x11) // Data High Register
            #define DAC0_DAT9L               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x12) // Data Low Register
            #define DAC0_DAT9H               *(volatile unsigned char *)(DAC0_BASE_ADD + 0x13) // Data High Register
            #define DAC0_DAT10L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x14) // Data Low Register
            #define DAC0_DAT10H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x15) // Data High Register
            #define DAC0_DAT11L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x16) // Data Low Register
            #define DAC0_DAT11H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x17) // Data High Register
            #define DAC0_DAT12L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x18) // Data Low Register
            #define DAC0_DAT12H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x19) // Data High Register
            #define DAC0_DAT13L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1a) // Data Low Register
            #define DAC0_DAT13H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1b) // Data High Register
            #define DAC0_DAT14L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1c) // Data Low Register
            #define DAC0_DAT14H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1d) // Data High Register
            #define DAC0_DAT15L              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1e) // Data Low Register
            #define DAC0_DAT15H              *(volatile unsigned char *)(DAC0_BASE_ADD + 0x1f) // Data High Register
        #endif
        #define DAC0_SR                      *(volatile unsigned char*)(DAC0_BASE_ADD + 0x20) // DAC0 Status Register
          #define DAC_SR_DACBFPBF            0x01                        // DAC buffer read pointer is equal to the DACBFUP
          #define DAC_SR_DACBFRPTF           0x02                        // DAC buffer read pointer is zero
          #if !defined KINETIS_KL
              #define DAC_SR_DACBFWMF        0x04                        // DAC buffer read pointer has reached the watermark level
          #endif
        #define DAC0_C0                      *(unsigned char*)(DAC0_BASE_ADD + 0x21) // DAC0 Control Register
          #define DAC_C0_DACBBIEN            0x01                        // DAC buffer read pointer bottom flag interrupt enable
          #define DAC_C0_DACBTIEN            0x02                        // DAC buffer read pointer top flag interrupt enable
         #if !defined KINETIS_KL
          #define DAC_C0_DACBWIEN            0x04                        // DAC watermark interrupt enable
         #endif
          #define DAC_C0_LPEN_HIGH_POWER     0x00                        // DAC high power mode
          #define DAC_C0_LPEN_LOW_POWER      0x08                        // DAC low power mode
          #define DAC_C0_DACSWTRG            0x10                        // (write-only) DAC software trigger valid
          #define DAC_C0_DACTRGSET_HW        0x00                        // DAC hardware trigger select
          #define DAC_C0_DACTRGSET_SW        0x20                        // DAC software trigger select
         #if defined KINETIS_KL
          #define DAC_C0_DACRFS_VREF         0x00                        // DAC reference voltage select - DACREF_1
          #define DAC_C0_DACRFS_VREF2        0x40                        // DAC reference voltage select - DACREF_2
         #else
          #define DAC_C0_DACRFS_VREF         0x00                        // DAC reference voltage select - VREF
          #define DAC_C0_DACRFS_VDDA         0x40                        // DAC reference voltage select - VDDA
         #endif
          #define DAC_C0_DACEN               0x80                        // DAC enable
        #define DAC0_C1                      *(unsigned char*)(DAC0_BASE_ADD + 0x22) // DAC0 Control Register 1
          #define DAC_C1_DACBFEN             0x01                        // DAC buffer enable
          #define DAC_C1_DACBFMD_NORMAL      0x00                        // DAC buffer work mode select - normal mode
         #if !defined KINETIS_KL
          #define DAC_C1_DACBFMD_SWING       0x02                        // DAC buffer work mode select - swing mode
         #endif
          #define DAC_C1_DACBFMD_ONE_TIME_SCAN  0x04                     // DAC buffer work mode select - one-time scan mode
         #if !defined KINETIS_KL
          #define DAC_C1_DACBFWM_1_WORD      0x00                        // DAC watermark select - 1 word
          #define DAC_C1_DACBFWM_2_WORDS     0x08                        // DAC watermark select - 2 words
          #define DAC_C1_DACBFWM_3_WORDS     0x10                        // DAC watermark select - 3 words
          #define DAC_C1_DACBFWM_4_WORDS     0x18                        // DAC watermark select - 4 words
         #endif
          #define DAC_C1_DMAEN               0x80                        // DMA enable select
        #define DAC0_C2                      *(volatile unsigned char*)(DAC0_BASE_ADD + 0x23) // DAC0 Control Register 2
    #endif
#endif
#if DAC_CONTROLLERS > 1
    #define DAC1_DAT0L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x00) // Data Low Register
    #define DAC1_DAT0H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x01) // Data High Register
    #define DAC1_DAT1L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x02) // Data Low Register
    #define DAC1_DAT1H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x03) // Data High Register
    #define DAC1_DAT2L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x04) // Data Low Register
    #define DAC1_DAT2H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x05) // Data High Register
    #define DAC1_DAT3L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x06) // Data Low Register
    #define DAC1_DAT3H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x07) // Data High Register
    #define DAC1_DAT4L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x08) // Data Low Register
    #define DAC1_DAT4H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x09) // Data High Register
    #define DAC1_DAT5L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0a) // Data Low Register
    #define DAC1_DAT5H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0b) // Data High Register
    #define DAC1_DAT6L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0c) // Data Low Register
    #define DAC1_DAT6H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0d) // Data High Register
    #define DAC1_DAT7L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0e) // Data Low Register
    #define DAC1_DAT7H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x0f) // Data High Register
    #define DAC1_DAT8L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x10) // Data Low Register
    #define DAC1_DAT8H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x11) // Data High Register
    #define DAC1_DAT9L                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x12) // Data Low Register
    #define DAC1_DAT9H                   *(volatile unsigned char *)(DAC1_BASE_ADD + 0x13) // Data High Register
    #define DAC1_DAT10L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x14) // Data Low Register
    #define DAC1_DAT10H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x15) // Data High Register
    #define DAC1_DAT11L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x16) // Data Low Register
    #define DAC1_DAT11H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x17) // Data High Register
    #define DAC1_DAT12L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x18) // Data Low Register
    #define DAC1_DAT12H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x19) // Data High Register
    #define DAC1_DAT13L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1a) // Data Low Register
    #define DAC1_DAT13H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1b) // Data High Register
    #define DAC1_DAT14L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1c) // Data Low Register
    #define DAC1_DAT14H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1d) // Data High Register
    #define DAC1_DAT15L                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1e) // Data Low Register
    #define DAC1_DAT15H                  *(volatile unsigned char *)(DAC1_BASE_ADD + 0x1f) // Data High Register
    #define DAC1_SR                      *(volatile unsigned char*)(DAC1_BASE_ADD + 0x20) // DAC1 Status Register
    #define DAC1_C0                      *(unsigned char*)(DAC1_BASE_ADD + 0x21) // DAC1 Control Register
    #define DAC1_C1                      *(unsigned char*)(DAC1_BASE_ADD + 0x22) // DAC1 Control Register 1
    #define DAC1_C2                      *(volatile unsigned char*)(DAC1_BASE_ADD + 0x23) // DAC1 Control Register 2
#endif

// Macros to enable and disable DAC operation
//
#define ENABLE_DAC(DACref)               DAC##DACref##_C0 |= (DAC_C0_DACEN)
#define DISABLE_DAC(DACref)              DAC##DACref##_C0 &= ~(DAC_C0_DACEN)

typedef struct stDAC_REGS
{
    volatile unsigned short DAC_DAT[16];
    volatile unsigned char DAC_SR;
    unsigned char DAC_C0;
    unsigned char DAC_C1;
    unsigned char DAC_C2;
} DAC_REGS;


#define PORT_WIDTH                       32

#define PORT_BIT0                        0x00000001
#define PORT_BIT1                        0x00000002
#define PORT_BIT2                        0x00000004
#define PORT_BIT3                        0x00000008
#define PORT_BIT4                        0x00000010
#define PORT_BIT5                        0x00000020
#define PORT_BIT6                        0x00000040
#define PORT_BIT7                        0x00000080
#define PORT_BIT8                        0x00000100
#define PORT_BIT9                        0x00000200
#define PORT_BIT10                       0x00000400
#define PORT_BIT11                       0x00000800
#define PORT_BIT12                       0x00001000
#define PORT_BIT13                       0x00002000
#define PORT_BIT14                       0x00004000
#define PORT_BIT15                       0x00008000
#define PORT_BIT16                       0x00010000
#define PORT_BIT17                       0x00020000
#define PORT_BIT18                       0x00040000
#define PORT_BIT19                       0x00080000
#define PORT_BIT20                       0x00100000
#define PORT_BIT21                       0x00200000
#define PORT_BIT22                       0x00400000
#define PORT_BIT23                       0x00800000
#define PORT_BIT24                       0x01000000
#define PORT_BIT25                       0x02000000
#define PORT_BIT26                       0x04000000
#define PORT_BIT27                       0x08000000
#define PORT_BIT28                       0x10000000
#define PORT_BIT29                       0x20000000
#define PORT_BIT30                       0x40000000
#define PORT_BIT31                       0x80000000

#define PORT1_BIT0                       0x00000001
#define PORT1_BIT1                       0x00000002
#define PORT1_BIT2                       0x00000004
#define PORT1_BIT3                       0x00000008
#define PORT1_BIT4                       0x00000010
#define PORT1_BIT5                       0x00000020
#define PORT1_BIT6                       0x00000040
#define PORT1_BIT7                       0x00000080
#define PORT1_BIT8                       0x00000100
#define PORT1_BIT9                       0x00000200
#define PORT1_BIT10                      0x00000400
#define PORT1_BIT11                      0x00000800
#define PORT1_BIT12                      0x00001000
#define PORT1_BIT13                      0x00002000
#define PORT1_BIT14                      0x00004000
#define PORT1_BIT15                      0x00008000
#define PORT1_BIT16                      0x00010000
#define PORT1_BIT17                      0x00020000
#define PORT1_BIT18                      0x00040000
#define PORT1_BIT19                      0x00080000
#define PORT1_BIT20                      0x00100000
#define PORT1_BIT21                      0x00200000
#define PORT1_BIT22                      0x00400000
#define PORT1_BIT23                      0x00800000
#define PORT1_BIT24                      0x01000000
#define PORT1_BIT25                      0x02000000
#define PORT1_BIT26                      0x04000000
#define PORT1_BIT27                      0x08000000
#define PORT1_BIT28                      0x10000000
#define PORT1_BIT29                      0x20000000
#define PORT1_BIT30                      0x40000000
#define PORT1_BIT31                      0x80000000

#define PORT2_BIT0                       0x00000001
#define PORT2_BIT1                       0x00000002
#define PORT2_BIT2                       0x00000004
#define PORT2_BIT3                       0x00000008
#define PORT2_BIT4                       0x00000010
#define PORT2_BIT5                       0x00000020
#define PORT2_BIT6                       0x00000040
#define PORT2_BIT7                       0x00000080
#define PORT2_BIT8                       0x00000100
#define PORT2_BIT9                       0x00000200
#define PORT2_BIT10                      0x00000400
#define PORT2_BIT11                      0x00000800
#define PORT2_BIT12                      0x00001000
#define PORT2_BIT13                      0x00002000
#define PORT2_BIT14                      0x00004000
#define PORT2_BIT15                      0x00008000
#define PORT2_BIT16                      0x00010000
#define PORT2_BIT17                      0x00020000
#define PORT2_BIT18                      0x00040000
#define PORT2_BIT19                      0x00080000
#define PORT2_BIT20                      0x00100000
#define PORT2_BIT21                      0x00200000
#define PORT2_BIT22                      0x00400000
#define PORT2_BIT23                      0x00800000
#define PORT2_BIT24                      0x01000000
#define PORT2_BIT25                      0x02000000
#define PORT2_BIT26                      0x04000000
#define PORT2_BIT27                      0x08000000
#define PORT2_BIT28                      0x10000000
#define PORT2_BIT29                      0x20000000
#define PORT2_BIT30                      0x40000000
#define PORT2_BIT31                      0x80000000

#define PORT3_BIT0                       0x00000001
#define PORT3_BIT1                       0x00000002
#define PORT3_BIT2                       0x00000004
#define PORT3_BIT3                       0x00000008
#define PORT3_BIT4                       0x00000010
#define PORT3_BIT5                       0x00000020
#define PORT3_BIT6                       0x00000040
#define PORT3_BIT7                       0x00000080
#define PORT3_BIT8                       0x00000100
#define PORT3_BIT9                       0x00000200
#define PORT3_BIT10                      0x00000400
#define PORT3_BIT11                      0x00000800
#define PORT3_BIT12                      0x00001000
#define PORT3_BIT13                      0x00002000
#define PORT3_BIT14                      0x00004000
#define PORT3_BIT15                      0x00008000
#define PORT3_BIT16                      0x00010000
#define PORT3_BIT17                      0x00020000
#define PORT3_BIT18                      0x00040000
#define PORT3_BIT19                      0x00080000
#define PORT3_BIT20                      0x00100000
#define PORT3_BIT21                      0x00200000
#define PORT3_BIT22                      0x00400000
#define PORT3_BIT23                      0x00800000
#define PORT3_BIT24                      0x01000000
#define PORT3_BIT25                      0x02000000
#define PORT3_BIT26                      0x04000000
#define PORT3_BIT27                      0x08000000
#define PORT3_BIT28                      0x10000000
#define PORT3_BIT29                      0x20000000
#define PORT3_BIT30                      0x40000000
#define PORT3_BIT31                      0x80000000

#define PORT4_BIT0                       0x00000001
#define PORT4_BIT1                       0x00000002
#define PORT4_BIT2                       0x00000004
#define PORT4_BIT3                       0x00000008
#define PORT4_BIT4                       0x00000010
#define PORT4_BIT5                       0x00000020
#define PORT4_BIT6                       0x00000040
#define PORT4_BIT7                       0x00000080
#define PORT4_BIT8                       0x00000100
#define PORT4_BIT9                       0x00000200
#define PORT4_BIT10                      0x00000400
#define PORT4_BIT11                      0x00000800
#define PORT4_BIT12                      0x00001000
#define PORT4_BIT13                      0x00002000
#define PORT4_BIT14                      0x00004000
#define PORT4_BIT15                      0x00008000
#define PORT4_BIT16                      0x00010000
#define PORT4_BIT17                      0x00020000
#define PORT4_BIT18                      0x00040000
#define PORT4_BIT19                      0x00080000
#define PORT4_BIT20                      0x00100000
#define PORT4_BIT21                      0x00200000
#define PORT4_BIT22                      0x00400000
#define PORT4_BIT23                      0x00800000
#define PORT4_BIT24                      0x01000000
#define PORT4_BIT25                      0x02000000
#define PORT4_BIT26                      0x04000000
#define PORT4_BIT27                      0x08000000
#define PORT4_BIT28                      0x10000000
#define PORT4_BIT29                      0x20000000
#define PORT4_BIT30                      0x40000000
#define PORT4_BIT31                      0x80000000

#define PORT5_BIT0                       0x00000001
#define PORT5_BIT1                       0x00000002
#define PORT5_BIT2                       0x00000004
#define PORT5_BIT3                       0x00000008
#define PORT5_BIT4                       0x00000010
#define PORT5_BIT5                       0x00000020
#define PORT5_BIT6                       0x00000040
#define PORT5_BIT7                       0x00000080
#define PORT5_BIT8                       0x00000100
#define PORT5_BIT9                       0x00000200
#define PORT5_BIT10                      0x00000400
#define PORT5_BIT11                      0x00000800
#define PORT5_BIT12                      0x00001000
#define PORT5_BIT13                      0x00002000
#define PORT5_BIT14                      0x00004000
#define PORT5_BIT15                      0x00008000
#define PORT5_BIT16                      0x00010000
#define PORT5_BIT17                      0x00020000
#define PORT5_BIT18                      0x00040000
#define PORT5_BIT19                      0x00080000
#define PORT5_BIT20                      0x00100000
#define PORT5_BIT21                      0x00200000
#define PORT5_BIT22                      0x00400000
#define PORT5_BIT23                      0x00800000
#define PORT5_BIT24                      0x01000000
#define PORT5_BIT25                      0x02000000
#define PORT5_BIT26                      0x04000000
#define PORT5_BIT27                      0x08000000
#define PORT5_BIT28                      0x10000000
#define PORT5_BIT29                      0x20000000
#define PORT5_BIT30                      0x40000000
#define PORT5_BIT31                      0x80000000

#if defined PORT6
    #define FAST_PORT6_BIT0              0x00000001
    #define FAST_PORT6_BIT1              0x00000002
    #define FAST_PORT6_BIT2              0x00000004
    #define FAST_PORT6_BIT3              0x00000008
    #define FAST_PORT6_BIT4              0x00000010
    #define FAST_PORT6_BIT5              0x00000020
    #define FAST_PORT6_BIT6              0x00000040
    #define FAST_PORT6_BIT7              0x00000080
    #define FAST_PORT6_BIT8              0x00000100
    #define FAST_PORT6_BIT9              0x00000200
    #define FAST_PORT6_BIT10             0x00000400
    #define FAST_PORT6_BIT11             0x00000800
    #define FAST_PORT6_BIT12             0x00001000
    #define FAST_PORT6_BIT13             0x00002000
    #define FAST_PORT6_BIT14             0x00004000
    #define FAST_PORT6_BIT15             0x00008000
    #define FAST_PORT6_BIT16             0x00010000
    #define FAST_PORT6_BIT17             0x00020000
    #define FAST_PORT6_BIT18             0x00040000
    #define FAST_PORT6_BIT19             0x00080000
    #define FAST_PORT6_BIT20             0x00100000
    #define FAST_PORT6_BIT21             0x00200000
    #define FAST_PORT6_BIT22             0x00400000
    #define FAST_PORT6_BIT23             0x00800000
    #define FAST_PORT6_BIT24             0x01000000
    #define FAST_PORT6_BIT25             0x02000000
    #define FAST_PORT6_BIT26             0x04000000
    #define FAST_PORT6_BIT27             0x08000000
    #define FAST_PORT6_BIT28             0x10000000
    #define FAST_PORT6_BIT29             0x20000000
    #define FAST_PORT6_BIT30             0x40000000
    #define FAST_PORT6_BIT31             0x80000000
#endif

#if defined PORT7
    #define FAST_PORT7_BIT0              0x00000001
    #define FAST_PORT7_BIT1              0x00000002
    #define FAST_PORT7_BIT2              0x00000004
    #define FAST_PORT7_BIT3              0x00000008
    #define FAST_PORT7_BIT4              0x00000010
    #define FAST_PORT7_BIT5              0x00000020
    #define FAST_PORT7_BIT6              0x00000040
    #define FAST_PORT7_BIT7              0x00000080
    #define FAST_PORT7_BIT8              0x00000100
    #define FAST_PORT7_BIT9              0x00000200
    #define FAST_PORT7_BIT10             0x00000400
    #define FAST_PORT7_BIT11             0x00000800
    #define FAST_PORT7_BIT12             0x00001000
    #define FAST_PORT7_BIT13             0x00002000
    #define FAST_PORT7_BIT14             0x00004000
    #define FAST_PORT7_BIT15             0x00008000
    #define FAST_PORT7_BIT16             0x00010000
    #define FAST_PORT7_BIT17             0x00020000
    #define FAST_PORT7_BIT18             0x00040000
    #define FAST_PORT7_BIT19             0x00080000
    #define FAST_PORT7_BIT20             0x00100000
    #define FAST_PORT7_BIT21             0x00200000
    #define FAST_PORT7_BIT22             0x00400000
    #define FAST_PORT7_BIT23             0x00800000
    #define FAST_PORT7_BIT24             0x01000000
    #define FAST_PORT7_BIT25             0x02000000
    #define FAST_PORT7_BIT26             0x04000000
    #define FAST_PORT7_BIT27             0x08000000
    #define FAST_PORT7_BIT28             0x10000000
    #define FAST_PORT7_BIT29             0x20000000
    #define FAST_PORT7_BIT30             0x40000000
    #define FAST_PORT7_BIT31             0x80000000
#endif

#if defined PORT8
    #define FAST_PORT8_BIT0              0x00000001
    #define FAST_PORT8_BIT1              0x00000002
    #define FAST_PORT8_BIT2              0x00000004
    #define FAST_PORT8_BIT3              0x00000008
    #define FAST_PORT8_BIT4              0x00000010
    #define FAST_PORT8_BIT5              0x00000020
    #define FAST_PORT8_BIT6              0x00000040
    #define FAST_PORT8_BIT7              0x00000080
    #define FAST_PORT8_BIT8              0x00000100
    #define FAST_PORT8_BIT9              0x00000200
    #define FAST_PORT8_BIT10             0x00000400
    #define FAST_PORT8_BIT11             0x00000800
    #define FAST_PORT8_BIT12             0x00001000
    #define FAST_PORT8_BIT13             0x00002000
    #define FAST_PORT8_BIT14             0x00004000
    #define FAST_PORT8_BIT15             0x00008000
    #define FAST_PORT8_BIT16             0x00010000
    #define FAST_PORT8_BIT17             0x00020000
    #define FAST_PORT8_BIT18             0x00040000
    #define FAST_PORT8_BIT19             0x00080000
    #define FAST_PORT8_BIT20             0x00100000
    #define FAST_PORT8_BIT21             0x00200000
    #define FAST_PORT8_BIT22             0x00400000
    #define FAST_PORT8_BIT23             0x00800000
    #define FAST_PORT8_BIT24             0x01000000
    #define FAST_PORT8_BIT25             0x02000000
    #define FAST_PORT8_BIT26             0x04000000
    #define FAST_PORT8_BIT27             0x08000000
    #define FAST_PORT8_BIT28             0x10000000
    #define FAST_PORT8_BIT29             0x20000000
    #define FAST_PORT8_BIT30             0x40000000
    #define FAST_PORT8_BIT31             0x80000000
#endif

#if defined PORT9
    #define FAST_PORT9_BIT0              0x00000001
    #define FAST_PORT9_BIT1              0x00000002
    #define FAST_PORT9_BIT2              0x00000004
    #define FAST_PORT9_BIT3              0x00000008
    #define FAST_PORT9_BIT4              0x00000010
    #define FAST_PORT9_BIT5              0x00000020
    #define FAST_PORT9_BIT6              0x00000040
    #define FAST_PORT9_BIT7              0x00000080
    #define FAST_PORT9_BIT8              0x00000100
    #define FAST_PORT9_BIT9              0x00000200
    #define FAST_PORT9_BIT10             0x00000400
    #define FAST_PORT9_BIT11             0x00000800
    #define FAST_PORT9_BIT12             0x00001000
    #define FAST_PORT9_BIT13             0x00002000
    #define FAST_PORT9_BIT14             0x00004000
    #define FAST_PORT9_BIT15             0x00008000
    #define FAST_PORT9_BIT16             0x00010000
    #define FAST_PORT9_BIT17             0x00020000
    #define FAST_PORT9_BIT18             0x00040000
    #define FAST_PORT9_BIT19             0x00080000
    #define FAST_PORT9_BIT20             0x00100000
    #define FAST_PORT9_BIT21             0x00200000
    #define FAST_PORT9_BIT22             0x00400000
    #define FAST_PORT9_BIT23             0x00800000
    #define FAST_PORT9_BIT24             0x01000000
    #define FAST_PORT9_BIT25             0x02000000
    #define FAST_PORT9_BIT26             0x04000000
    #define FAST_PORT9_BIT27             0x08000000
    #define FAST_PORT9_BIT28             0x10000000
    #define FAST_PORT9_BIT29             0x20000000
    #define FAST_PORT9_BIT30             0x40000000
    #define FAST_PORT9_BIT31             0x80000000
#endif

#if defined iMX_RT1011                                                   // map pads to GPIOs
    #define PIN_GPIO_00_GPIO1_IO00           PORT1_BIT0
    #define PIN_GPIO_01_GPIO1_IO01           PORT1_BIT1
    #define PIN_GPIO_02_GPIO1_IO02           PORT1_BIT2
    #define PIN_GPIO_03_GPIO1_IO03           PORT1_BIT3
    #define PIN_GPIO_04_GPIO1_IO04           PORT1_BIT4
    #define PIN_GPIO_05_GPIO1_IO05           PORT1_BIT5
    #define PIN_GPIO_06_GPIO1_IO06           PORT1_BIT6
    #define PIN_GPIO_07_GPIO1_IO07           PORT1_BIT7
    #define PIN_GPIO_08_GPIO1_IO08           PORT1_BIT8
    #define PIN_GPIO_09_GPIO1_IO09           PORT1_BIT9
    #define PIN_GPIO_10_GPIO1_IO10           PORT1_BIT10
    #define PIN_GPIO_11_GPIO1_IO11           PORT1_BIT11
    #define PIN_GPIO_12_GPIO1_IO12           PORT1_BIT12
    #define PIN_GPIO_13_GPIO1_IO13           PORT1_BIT13
    #define PIN_GPIO_AD_00_GPIO1_IO14        PORT1_BIT14
    #define PIN_GPIO_AD_01_GPIO1_IO15        PORT1_BIT15
    #define PIN_GPIO_AD_02_GPIO1_IO16        PORT1_BIT16
    #define PIN_GPIO_AD_03_GPIO1_IO17        PORT1_BIT17
    #define PIN_GPIO_AD_04_GPIO1_IO18        PORT1_BIT18
    #define PIN_GPIO_AD_05_GPIO1_IO19        PORT1_BIT19
    #define PIN_GPIO_AD_06_GPIO1_IO20        PORT1_BIT20
    #define PIN_GPIO_AD_07_GPIO1_IO21        PORT1_BIT21
    #define PIN_GPIO_AD_08_GPIO1_IO22        PORT1_BIT22
    #define PIN_GPIO_AD_09_GPIO1_IO23        PORT1_BIT23
    #define PIN_GPIO_AD_10_GPIO1_IO24        PORT1_BIT24
    #define PIN_GPIO_AD_11_GPIO1_IO25        PORT1_BIT25
    #define PIN_GPIO_AD_12_GPIO1_IO26        PORT1_BIT26
    #define PIN_GPIO_AD_13_GPIO1_IO27        PORT1_BIT27
    #define PIN_GPIO_AD_14_GPIO1_IO28        PORT1_BIT28

    #define PIN_GPIO_SD_00_GPIO2_IO00        PORT2_BIT0
    #define PIN_GPIO_SD_01_GPIO2_IO01        PORT2_BIT1
    #define PIN_GPIO_SD_02_GPIO2_IO02        PORT2_BIT2
    #define PIN_GPIO_SD_03_GPIO2_IO03        PORT2_BIT3
    #define PIN_GPIO_SD_04_GPIO2_IO04        PORT2_BIT4
    #define PIN_GPIO_SD_05_GPIO2_IO05        PORT2_BIT5
    #define PIN_GPIO_SD_06_GPIO2_IO06        PORT2_BIT6
    #define PIN_GPIO_SD_07_GPIO2_IO07        PORT2_BIT7
    #define PIN_GPIO_SD_08_GPIO2_IO08        PORT2_BIT8
    #define PIN_GPIO_SD_09_GPIO2_IO09        PORT2_BIT9
    #define PIN_GPIO_SD_10_GPIO2_IO10        PORT2_BIT10
    #define PIN_GPIO_SD_11_GPIO2_IO11        PORT2_BIT11
    #define PIN_GPIO_SD_12_GPIO2_IO12        PORT2_BIT12
    #define PIN_GPIO_SD_13_GPIO2_IO13        PORT2_BIT13

    #define PIN_PMIC_ON_REQ_GPIO5_IO00       PORT5_BIT0
#elif defined iMX_RT1015
    #define PIN_GPIO_AD_B0_00_GPIO1_IO00     PORT1_BIT0
    #define PIN_GPIO_AD_B0_01_GPIO1_IO01     PORT1_BIT1
    #define PIN_GPIO_AD_B0_02_GPIO1_IO02     PORT1_BIT2
    #define PIN_GPIO_AD_B0_03_GPIO1_IO03     PORT1_BIT3
    #define PIN_GPIO_AD_B0_04_GPIO1_IO04     PORT1_BIT4
    #define PIN_GPIO_AD_B0_05_GPIO1_IO05     PORT1_BIT5
    #define PIN_GPIO_AD_B0_06_GPIO1_IO06     PORT1_BIT6
    #define PIN_GPIO_AD_B0_07_GPIO1_IO07     PORT1_BIT7
    #define PIN_GPIO_AD_B0_08_GPIO1_IO08     PORT1_BIT8
    #define PIN_GPIO_AD_B0_09_GPIO1_IO09     PORT1_BIT9
    #define PIN_GPIO_AD_B0_10_GPIO1_IO10     PORT1_BIT10
    #define PIN_GPIO_AD_B0_11_GPIO1_IO11     PORT1_BIT11
    #define PIN_GPIO_AD_B0_12_GPIO1_IO12     PORT1_BIT12
    #define PIN_GPIO_AD_B0_13_GPIO1_IO13     PORT1_BIT13
    #define PIN_GPIO_AD_B0_14_GPIO1_IO14     PORT1_BIT14
    #define PIN_GPIO_AD_B0_15_GPIO1_IO15     PORT1_BIT15

    #define PIN_GPIO_AD_B1_10_GPIO1_IO26     PORT1_BIT26
    #define PIN_GPIO_AD_B1_11_GPIO1_IO27     PORT1_BIT27
    #define PIN_GPIO_AD_B1_12_GPIO1_IO28     PORT1_BIT28
    #define PIN_GPIO_AD_B1_13_GPIO1_IO29     PORT1_BIT29
    #define PIN_GPIO_AD_B1_14_GPIO1_IO30     PORT1_BIT30
    #define PIN_GPIO_AD_B1_15_GPIO1_IO31     PORT1_BIT31

    #define PIN_GPIO_EMC_04_GPIO2_IO04       PORT2_BIT4
    #define PIN_GPIO_EMC_05_GPIO2_IO05       PORT2_BIT5
    #define PIN_GPIO_EMC_06_GPIO2_IO06       PORT2_BIT6
    #define PIN_GPIO_EMC_07_GPIO2_IO07       PORT2_BIT7
    #define PIN_GPIO_EMC_08_GPIO2_IO08       PORT2_BIT8
    #define PIN_GPIO_EMC_09_GPIO2_IO09       PORT2_BIT9

    #define PIN_GPIO_EMC_16_GPIO2_IO16       PORT2_BIT16
    #define PIN_GPIO_EMC_17_GPIO2_IO17       PORT2_BIT17
    #define PIN_GPIO_EMC_18_GPIO2_IO18       PORT2_BIT18
    #define PIN_GPIO_EMC_19_GPIO2_IO19       PORT2_BIT19
    #define PIN_GPIO_EMC_20_GPIO2_IO20       PORT2_BIT20
    #define PIN_GPIO_EMC_21_GPIO2_IO21       PORT2_BIT21
    #define PIN_GPIO_EMC_22_GPIO2_IO22       PORT2_BIT22
    #define PIN_GPIO_EMC_23_GPIO2_IO23       PORT2_BIT23
    #define PIN_GPIO_EMC_24_GPIO2_IO24       PORT2_BIT24
    #define PIN_GPIO_EMC_25_GPIO2_IO25       PORT2_BIT25
    #define PIN_GPIO_EMC_26_GPIO2_IO26       PORT2_BIT26
    #define PIN_GPIO_EMC_27_GPIO2_IO27       PORT2_BIT27

    #define PIN_GPIO_EMC_32_GPIO3_IO00       PORT3_BIT0
    #define PIN_GPIO_EMC_33_GPIO3_IO01       PORT3_BIT1
    #define PIN_GPIO_EMC_34_GPIO3_IO02       PORT3_BIT2
    #define PIN_GPIO_EMC_35_GPIO3_IO03       PORT3_BIT3

    #define PIN_GPIO_SD_B1_00_GPIO3_IO20     PORT3_BIT20
    #define PIN_GPIO_SD_B1_01_GPIO3_IO21     PORT3_BIT21
    #define PIN_GPIO_SD_B1_02_GPIO3_IO22     PORT3_BIT22
    #define PIN_GPIO_SD_B1_03_GPIO3_IO23     PORT3_BIT23
    #define PIN_GPIO_SD_B1_04_GPIO3_IO24     PORT3_BIT24
    #define PIN_GPIO_SD_B1_05_GPIO3_IO25     PORT3_BIT25
    #define PIN_GPIO_SD_B1_06_GPIO3_IO26     PORT3_BIT26
    #define PIN_GPIO_SD_B1_07_GPIO3_IO27     PORT3_BIT27
    #define PIN_GPIO_SD_B1_08_GPIO3_IO28     PORT3_BIT28
    #define PIN_GPIO_SD_B1_09_GPIO3_IO29     PORT3_BIT29
    #define PIN_GPIO_SD_B1_10_GPIO3_IO30     PORT3_BIT30
    #define PIN_GPIO_SD_B1_11_GPIO3_IO31     PORT3_BIT31

    #define PIN_PMIC_ON_REQ_GPIO5_IO01       PORT5_BIT1
#elif defined iMX_RT102X
    #define PIN_GPIO_AD_B0_00_GPIO1_IO00     PORT1_BIT0
    #define PIN_GPIO_AD_B0_01_GPIO1_IO01     PORT1_BIT1
    #define PIN_GPIO_AD_B0_02_GPIO1_IO02     PORT1_BIT2
    #define PIN_GPIO_AD_B0_03_GPIO1_IO03     PORT1_BIT3
    #define PIN_GPIO_AD_B0_04_GPIO1_IO04     PORT1_BIT4
    #define PIN_GPIO_AD_B0_05_GPIO1_IO05     PORT1_BIT5
    #define PIN_GPIO_AD_B0_06_GPIO1_IO06     PORT1_BIT6
    #define PIN_GPIO_AD_B0_07_GPIO1_IO07     PORT1_BIT7
    #define PIN_GPIO_AD_B0_08_GPIO1_IO08     PORT1_BIT8
    #define PIN_GPIO_AD_B0_09_GPIO1_IO09     PORT1_BIT9
    #define PIN_GPIO_AD_B0_10_GPIO1_IO10     PORT1_BIT10
    #define PIN_GPIO_AD_B0_11_GPIO1_IO11     PORT1_BIT11
    #define PIN_GPIO_AD_B0_12_GPIO1_IO12     PORT1_BIT12
    #define PIN_GPIO_AD_B0_13_GPIO1_IO13     PORT1_BIT13
    #define PIN_GPIO_AD_B0_14_GPIO1_IO14     PORT1_BIT14
    #define PIN_GPIO_AD_B0_15_GPIO1_IO15     PORT1_BIT15
    #define PIN_GPIO_AD_B1_00_GPIO1_IO16     PORT1_BIT16
    #define PIN_GPIO_AD_B1_01_GPIO1_IO17     PORT1_BIT17
    #define PIN_GPIO_AD_B1_02_GPIO1_IO18     PORT1_BIT18
    #define PIN_GPIO_AD_B1_03_GPIO1_IO19     PORT1_BIT19
    #define PIN_GPIO_AD_B1_04_GPIO1_IO20     PORT1_BIT20
    #define PIN_GPIO_AD_B1_05_GPIO1_IO21     PORT1_BIT21
    #define PIN_GPIO_AD_B1_06_GPIO1_IO22     PORT1_BIT22
    #define PIN_GPIO_AD_B1_07_GPIO1_IO23     PORT1_BIT23
    #define PIN_GPIO_AD_B1_08_GPIO1_IO24     PORT1_BIT24
    #define PIN_GPIO_AD_B1_09_GPIO1_IO25     PORT1_BIT25
    #define PIN_GPIO_AD_B1_10_GPIO1_IO26     PORT1_BIT26
    #define PIN_GPIO_AD_B1_11_GPIO1_IO27     PORT1_BIT27
    #define PIN_GPIO_AD_B1_12_GPIO1_IO28     PORT1_BIT28
    #define PIN_GPIO_AD_B1_13_GPIO1_IO29     PORT1_BIT29
    #define PIN_GPIO_AD_B1_14_GPIO1_IO30     PORT1_BIT30
    #define PIN_GPIO_AD_B1_15_GPIO1_IO31     PORT1_BIT31

    #define PIN_GPIO_EMC_00_GPIO2_IO00       PORT2_BIT0
    #define PIN_GPIO_EMC_01_GPIO2_IO01       PORT2_BIT1
    #define PIN_GPIO_EMC_02_GPIO2_IO02       PORT2_BIT2
    #define PIN_GPIO_EMC_03_GPIO2_IO03       PORT2_BIT3
    #define PIN_GPIO_EMC_04_GPIO2_IO04       PORT2_BIT4
    #define PIN_GPIO_EMC_05_GPIO2_IO05       PORT2_BIT5
    #define PIN_GPIO_EMC_06_GPIO2_IO06       PORT2_BIT6
    #define PIN_GPIO_EMC_07_GPIO2_IO07       PORT2_BIT7
    #define PIN_GPIO_EMC_08_GPIO2_IO08       PORT2_BIT8
    #define PIN_GPIO_EMC_09_GPIO2_IO09       PORT2_BIT9
    #define PIN_GPIO_EMC_10_GPIO2_IO10       PORT2_BIT10
    #define PIN_GPIO_EMC_11_GPIO2_IO11       PORT2_BIT11
    #define PIN_GPIO_EMC_12_GPIO2_IO12       PORT2_BIT12
    #define PIN_GPIO_EMC_13_GPIO2_IO13       PORT2_BIT13
    #define PIN_GPIO_EMC_14_GPIO2_IO14       PORT2_BIT14
    #define PIN_GPIO_EMC_15_GPIO2_IO15       PORT2_BIT15
    #define PIN_GPIO_EMC_16_GPIO2_IO16       PORT2_BIT16
    #define PIN_GPIO_EMC_17_GPIO2_IO17       PORT2_BIT17
    #define PIN_GPIO_EMC_18_GPIO2_IO18       PORT2_BIT18
    #define PIN_GPIO_EMC_19_GPIO2_IO19       PORT2_BIT19
    #define PIN_GPIO_EMC_20_GPIO2_IO20       PORT2_BIT20
    #define PIN_GPIO_EMC_21_GPIO2_IO21       PORT2_BIT21
    #define PIN_GPIO_EMC_22_GPIO2_IO22       PORT2_BIT22
    #define PIN_GPIO_EMC_23_GPIO2_IO23       PORT2_BIT23
    #define PIN_GPIO_EMC_24_GPIO2_IO24       PORT2_BIT24
    #define PIN_GPIO_EMC_25_GPIO2_IO25       PORT2_BIT25
    #define PIN_GPIO_EMC_26_GPIO2_IO26       PORT2_BIT26
    #define PIN_GPIO_EMC_27_GPIO2_IO27       PORT2_BIT27
    #define PIN_GPIO_EMC_28_GPIO2_IO28       PORT2_BIT28
    #define PIN_GPIO_EMC_29_GPIO2_IO29       PORT2_BIT29
    #define PIN_GPIO_EMC_30_GPIO2_IO30       PORT2_BIT30
    #define PIN_GPIO_EMC_31_GPIO2_IO31       PORT2_BIT31

    #define PIN_GPIO_EMC_32_GPIO3_IO00       PORT3_BIT0
    #define PIN_GPIO_EMC_33_GPIO3_IO01       PORT3_BIT1
    #define PIN_GPIO_EMC_34_GPIO3_IO02       PORT3_BIT2
    #define PIN_GPIO_EMC_35_GPIO3_IO03       PORT3_BIT3
    #define PIN_GPIO_EMC_36_GPIO3_IO04       PORT3_BIT4
    #define PIN_GPIO_EMC_37_GPIO3_IO05       PORT3_BIT5
    #define PIN_GPIO_EMC_38_GPIO3_IO06       PORT3_BIT6
    #define PIN_GPIO_EMC_39_GPIO3_IO07       PORT3_BIT7
    #define PIN_GPIO_EMC_40_GPIO3_IO08       PORT3_BIT8
    #define PIN_GPIO_EMC_41_GPIO3_IO09       PORT3_BIT9

    #define PIN_GPIO_SD_B0_00_GPIO3_IO13     PORT3_BIT13
    #define PIN_GPIO_SD_B0_01_GPIO3_IO14     PORT3_BIT14
    #define PIN_GPIO_SD_B0_02_GPIO3_IO15     PORT3_BIT15
    #define PIN_GPIO_SD_B0_03_GPIO3_IO16     PORT3_BIT16
    #define PIN_GPIO_SD_B0_04_GPIO3_IO17     PORT3_BIT17
    #define PIN_GPIO_SD_B0_05_GPIO3_IO18     PORT3_BIT18
    #define PIN_GPIO_SD_B0_06_GPIO3_IO19     PORT3_BIT19
    #define PIN_GPIO_SD_B1_00_GPIO3_IO20     PORT3_BIT20
    #define PIN_GPIO_SD_B1_01_GPIO3_IO21     PORT3_BIT21
    #define PIN_GPIO_SD_B1_02_GPIO3_IO22     PORT3_BIT22
    #define PIN_GPIO_SD_B1_03_GPIO3_IO23     PORT3_BIT23
    #define PIN_GPIO_SD_B1_04_GPIO3_IO24     PORT3_BIT24
    #define PIN_GPIO_SD_B1_05_GPIO3_IO25     PORT3_BIT25
    #define PIN_GPIO_SD_B1_06_GPIO3_IO26     PORT3_BIT26
    #define PIN_GPIO_SD_B1_07_GPIO3_IO27     PORT3_BIT27
    #define PIN_GPIO_SD_B1_08_GPIO3_IO28     PORT3_BIT28
    #define PIN_GPIO_SD_B1_09_GPIO3_IO29     PORT3_BIT29
    #define PIN_GPIO_SD_B1_10_GPIO3_IO30     PORT3_BIT30
    #define PIN_GPIO_SD_B1_11_GPIO3_IO31     PORT3_BIT31

    #define PIN_WAKEUP_GPIO5_IO00            PORT5_BIT0
#elif defined iMX_RT105X || defined iMX_RT106X
    #define PIN_GPIO_AD_B0_00_GPIO1_IO00     PORT1_BIT0
    #define PIN_GPIO_AD_B0_01_GPIO1_IO01     PORT1_BIT1
    #define PIN_GPIO_AD_B0_02_GPIO1_IO02     PORT1_BIT2
    #define PIN_GPIO_AD_B0_03_GPIO1_IO03     PORT1_BIT3
    #define PIN_GPIO_AD_B0_04_GPIO1_IO04     PORT1_BIT4
    #define PIN_GPIO_AD_B0_05_GPIO1_IO05     PORT1_BIT5
    #define PIN_GPIO_AD_B0_06_GPIO1_IO06     PORT1_BIT6
    #define PIN_GPIO_AD_B0_07_GPIO1_IO07     PORT1_BIT7
    #define PIN_GPIO_AD_B0_08_GPIO1_IO08     PORT1_BIT8
    #define PIN_GPIO_AD_B0_09_GPIO1_IO09     PORT1_BIT9
    #define PIN_GPIO_AD_B0_10_GPIO1_IO10     PORT1_BIT10
    #define PIN_GPIO_AD_B0_11_GPIO1_IO11     PORT1_BIT11
    #define PIN_GPIO_AD_B0_12_GPIO1_IO12     PORT1_BIT12
    #define PIN_GPIO_AD_B0_13_GPIO1_IO13     PORT1_BIT13
    #define PIN_GPIO_AD_B0_14_GPIO1_IO14     PORT1_BIT14
    #define PIN_GPIO_AD_B0_15_GPIO1_IO15     PORT1_BIT15
    #define PIN_GPIO_AD_B1_00_GPIO1_IO16     PORT1_BIT16
    #define PIN_GPIO_AD_B1_01_GPIO1_IO17     PORT1_BIT17
    #define PIN_GPIO_AD_B1_02_GPIO1_IO18     PORT1_BIT18
    #define PIN_GPIO_AD_B1_03_GPIO1_IO19     PORT1_BIT19
    #define PIN_GPIO_AD_B1_04_GPIO1_IO20     PORT1_BIT20
    #define PIN_GPIO_AD_B1_05_GPIO1_IO21     PORT1_BIT21
    #define PIN_GPIO_AD_B1_06_GPIO1_IO22     PORT1_BIT22
    #define PIN_GPIO_AD_B1_07_GPIO1_IO23     PORT1_BIT23
    #define PIN_GPIO_AD_B1_08_GPIO1_IO24     PORT1_BIT24
    #define PIN_GPIO_AD_B1_09_GPIO1_IO25     PORT1_BIT25
    #define PIN_GPIO_AD_B1_10_GPIO1_IO26     PORT1_BIT26
    #define PIN_GPIO_AD_B1_11_GPIO1_IO27     PORT1_BIT27
    #define PIN_GPIO_AD_B1_12_GPIO1_IO28     PORT1_BIT28
    #define PIN_GPIO_AD_B1_13_GPIO1_IO29     PORT1_BIT29
    #define PIN_GPIO_AD_B1_14_GPIO1_IO30     PORT1_BIT30
    #define PIN_GPIO_AD_B1_15_GPIO1_IO31     PORT1_BIT31

    #define ADC1_IN0_GPIO_AD_B1_11_GPIO1_IO27    PIN_GPIO_AD_B1_11_GPIO1_IO27
    #define ADC1_IN1_GPIO_AD_B0_12_GPIO1_IO12    PIN_GPIO_AD_B1_12_GPIO1_IO28
    #define ADC1_IN2_GPIO_AD_B0_13_GPIO1_IO13    PIN_GPIO_AD_B0_13_GPIO1_IO13
    #define ADC1_IN3_GPIO_AD_B0_14_GPIO1_IO14    PIN_GPIO_AD_B0_14_GPIO1_IO14
    #define ADC1_IN4_GPIO_AD_B0_15_GPIO1_IO15    PIN_GPIO_AD_B0_15_GPIO1_IO15
    #define ADC1_IN5_GPIO_AD_B1_00_GPIO1_IO16    PIN_GPIO_AD_B1_00_GPIO1_IO16
    #define ADC1_IN6_GPIO_AD_B1_01_GPIO1_IO17    PIN_GPIO_AD_B1_01_GPIO1_IO17
    #define ADC1_IN7_GPIO_AD_B1_02_GPIO1_IO18    PIN_GPIO_AD_B1_02_GPIO1_IO18
    #define ADC1_IN8_GPIO_AD_B1_03_GPIO1_IO19    PIN_GPIO_AD_B1_03_GPIO1_IO19
    #define ADC1_IN9_GPIO_AD_B1_04_GPIO1_IO20    PIN_GPIO_AD_B1_04_GPIO1_IO20
    #define ADC1_IN10_GPIO_AD_B1_05_GPIO1_IO21   PIN_GPIO_AD_B1_05_GPIO1_IO21
    #define ADC1_IN11_GPIO_AD_B1_06_GPIO1_IO22   PIN_GPIO_AD_B1_06_GPIO1_IO22
    #define ADC1_IN12_GPIO_AD_B1_07_GPIO1_IO23   PIN_GPIO_AD_B1_07_GPIO1_IO23
    #define ADC1_IN13_GPIO_AD_B1_08_GPIO1_IO24   PIN_GPIO_AD_B1_08_GPIO1_IO24
    #define ADC1_IN14_GPIO_AD_B1_09_GPIO1_IO25   PIN_GPIO_AD_B1_09_GPIO1_IO25
    #define ADC1_IN15_GPIO_AD_B1_10_GPIO1_IO26   PIN_GPIO_AD_B1_10_GPIO1_IO26

    #define ADC2_IN0_GPIO_AD_B1_11_GPIO1_IO27    PIN_GPIO_AD_B1_11_GPIO1_IO27
    #define ADC2_IN1_GPIO_AD_B1_12_GPIO1_IO28    PIN_GPIO_AD_B1_12_GPIO1_IO28
    #define ADC2_IN2_GPIO_AD_B1_13_GPIO1_IO29    PIN_GPIO_AD_B1_13_GPIO1_IO29
    #define ADC2_IN3_GPIO_AD_B1_14_GPIO1_IO30    PIN_GPIO_AD_B1_14_GPIO1_IO30
    #define ADC2_IN4_GPIO_AD_B1_15_GPIO1_IO31    PIN_GPIO_AD_B1_15_GPIO1_IO31
    #define ADC2_IN5_GPIO_AD_B1_00_GPIO1_IO16    PIN_GPIO_AD_B1_00_GPIO1_IO16
    #define ADC2_IN6_GPIO_AD_B1_01_GPIO1_IO17    PIN_GPIO_AD_B1_01_GPIO1_IO17
    #define ADC2_IN7_GPIO_AD_B1_02_GPIO1_IO18    PIN_GPIO_AD_B1_02_GPIO1_IO18
    #define ADC2_IN8_GPIO_AD_B1_03_GPIO1_IO19    PIN_GPIO_AD_B1_03_GPIO1_IO19
    #define ADC2_IN9_GPIO_AD_B1_04_GPIO1_IO20    PIN_GPIO_AD_B1_04_GPIO1_IO20
    #define ADC2_IN10_GPIO_AD_B1_05_GPIO1_IO21   PIN_GPIO_AD_B1_05_GPIO1_IO21
    #define ADC2_IN11_GPIO_AD_B1_06_GPIO1_IO22   PIN_GPIO_AD_B1_06_GPIO1_IO22
    #define ADC2_IN12_GPIO_AD_B1_07_GPIO1_IO23   PIN_GPIO_AD_B1_07_GPIO1_IO23
    #define ADC2_IN13_GPIO_AD_B1_08_GPIO1_IO24   PIN_GPIO_AD_B1_08_GPIO1_IO24
    #define ADC2_IN14_GPIO_AD_B1_09_GPIO1_IO25   PIN_GPIO_AD_B1_09_GPIO1_IO25
    #define ADC2_IN15_GPIO_AD_B1_10_GPIO1_IO26   PIN_GPIO_AD_B1_10_GPIO1_IO26

    #define PIN_GPIO_B0_00_GPIO2_IO00        PORT2_BIT0
    #define PIN_GPIO_B0_01_GPIO2_IO01        PORT2_BIT1
    #define PIN_GPIO_B0_02_GPIO2_IO02        PORT2_BIT2
    #define PIN_GPIO_B0_03_GPIO2_IO03        PORT2_BIT3
    #define PIN_GPIO_B0_04_GPIO2_IO04        PORT2_BIT4
    #define PIN_GPIO_B0_05_GPIO2_IO05        PORT2_BIT5
    #define PIN_GPIO_B0_06_GPIO2_IO06        PORT2_BIT6
    #define PIN_GPIO_B0_07_GPIO2_IO07        PORT2_BIT7
    #define PIN_GPIO_B0_08_GPIO2_IO08        PORT2_BIT8
    #define PIN_GPIO_B0_09_GPIO2_IO09        PORT2_BIT9
    #define PIN_GPIO_B0_10_GPIO2_IO10        PORT2_BIT10
    #define PIN_GPIO_B0_11_GPIO2_IO11        PORT2_BIT11
    #define PIN_GPIO_B0_12_GPIO2_IO12        PORT2_BIT12
    #define PIN_GPIO_B0_13_GPIO2_IO13        PORT2_BIT13
    #define PIN_GPIO_B0_14_GPIO2_IO14        PORT2_BIT14
    #define PIN_GPIO_B0_15_GPIO2_IO15        PORT2_BIT15
    #define PIN_GPIO_B1_00_GPIO2_IO16        PORT2_BIT16
    #define PIN_GPIO_B1_01_GPIO2_IO17        PORT2_BIT17
    #define PIN_GPIO_B1_02_GPIO2_IO18        PORT2_BIT18
    #define PIN_GPIO_B1_03_GPIO2_IO19        PORT2_BIT19
    #define PIN_GPIO_B1_04_GPIO2_IO20        PORT2_BIT20
    #define PIN_GPIO_B1_05_GPIO2_IO21        PORT2_BIT21
    #define PIN_GPIO_B1_06_GPIO2_IO22        PORT2_BIT22
    #define PIN_GPIO_B1_07_GPIO2_IO23        PORT2_BIT23
    #define PIN_GPIO_B1_08_GPIO2_IO24        PORT2_BIT24
    #define PIN_GPIO_B1_09_GPIO2_IO25        PORT2_BIT25
    #define PIN_GPIO_B1_10_GPIO2_IO26        PORT2_BIT26
    #define PIN_GPIO_B1_11_GPIO2_IO27        PORT2_BIT27
    #define PIN_GPIO_B1_12_GPIO2_IO28        PORT2_BIT28
    #define PIN_GPIO_B1_13_GPIO2_IO29        PORT2_BIT29
    #define PIN_GPIO_B1_14_GPIO2_IO30        PORT2_BIT30
    #define PIN_GPIO_B1_15_GPIO2_IO31        PORT2_BIT31

    #define PIN_GPIO_SD_B1_00_GPIO3_IO00     PORT3_BIT0
    #define PIN_GPIO_SD_B1_01_GPIO3_IO01     PORT3_BIT1
    #define PIN_GPIO_SD_B1_02_GPIO3_IO02     PORT3_BIT2
    #define PIN_GPIO_SD_B1_03_GPIO3_IO03     PORT3_BIT3
    #define PIN_GPIO_SD_B1_04_GPIO3_IO04     PORT3_BIT4
    #define PIN_GPIO_SD_B1_05_GPIO3_IO05     PORT3_BIT5
    #define PIN_GPIO_SD_B1_06_GPIO3_IO06     PORT3_BIT6
    #define PIN_GPIO_SD_B1_07_GPIO3_IO07     PORT3_BIT7
    #define PIN_GPIO_SD_B1_08_GPIO3_IO08     PORT3_BIT8
    #define PIN_GPIO_SD_B1_09_GPIO3_IO09     PORT3_BIT9
    #define PIN_GPIO_SD_B1_10_GPIO3_IO10     PORT3_BIT10
    #define PIN_GPIO_SD_B1_11_GPIO3_IO11     PORT3_BIT11
    #define PIN_GPIO_SD_B0_00_GPIO3_IO12     PORT3_BIT12
    #define PIN_GPIO_SD_B0_01_GPIO3_IO13     PORT3_BIT13
    #define PIN_GPIO_SD_B0_02_GPIO3_IO14     PORT3_BIT14
    #define PIN_GPIO_SD_B0_03_GPIO3_IO15     PORT3_BIT15
    #define PIN_GPIO_SD_B0_04_GPIO3_IO16     PORT3_BIT16
    #define PIN_GPIO_SD_B0_05_GPIO3_IO17     PORT3_BIT17
    #define PIN_GPIO_EMC_32_GPIO3_IO18       PORT3_BIT18
    #define PIN_GPIO_EMC_33_GPIO3_IO19       PORT3_BIT19
    #define PIN_GPIO_EMC_34_GPIO3_IO20       PORT3_BIT20
    #define PIN_GPIO_EMC_35_GPIO3_IO21       PORT3_BIT21
    #define PIN_GPIO_EMC_36_GPIO3_IO22       PORT3_BIT22
    #define PIN_GPIO_EMC_37_GPIO3_IO23       PORT3_BIT23
    #define PIN_GPIO_EMC_38_GPIO3_IO24       PORT3_BIT24
    #define PIN_GPIO_EMC_39_GPIO3_IO25       PORT3_BIT25
    #define PIN_GPIO_EMC_40_GPIO3_IO26       PORT3_BIT26
    #define PIN_GPIO_EMC_41_GPIO3_IO27       PORT3_BIT27

    #define PIN_GPIO_EMC_00_GPIO4_IO00       PORT4_BIT0
    #define PIN_GPIO_EMC_01_GPIO4_IO01       PORT4_BIT1
    #define PIN_GPIO_EMC_02_GPIO4_IO02       PORT4_BIT2
    #define PIN_GPIO_EMC_03_GPIO4_IO03       PORT4_BIT3
    #define PIN_GPIO_EMC_04_GPIO4_IO04       PORT4_BIT4
    #define PIN_GPIO_EMC_05_GPIO4_IO05       PORT4_BIT5
    #define PIN_GPIO_EMC_06_GPIO4_IO06       PORT4_BIT6
    #define PIN_GPIO_EMC_07_GPIO4_IO07       PORT4_BIT7
    #define PIN_GPIO_EMC_08_GPIO4_IO08       PORT4_BIT8
    #define PIN_GPIO_EMC_09_GPIO4_IO09       PORT4_BIT9
    #define PIN_GPIO_EMC_10_GPIO4_IO10       PORT4_BIT10
    #define PIN_GPIO_EMC_11_GPIO4_IO11       PORT4_BIT11
    #define PIN_GPIO_EMC_12_GPIO4_IO12       PORT4_BIT12
    #define PIN_GPIO_EMC_13_GPIO4_IO13       PORT4_BIT13
    #define PIN_GPIO_EMC_14_GPIO4_IO14       PORT4_BIT14
    #define PIN_GPIO_EMC_15_GPIO4_IO15       PORT4_BIT15
    #define PIN_GPIO_EMC_16_GPIO4_IO16       PORT4_BIT16
    #define PIN_GPIO_EMC_17_GPIO4_IO17       PORT4_BIT17
    #define PIN_GPIO_EMC_18_GPIO4_IO18       PORT4_BIT18
    #define PIN_GPIO_EMC_19_GPIO4_IO19       PORT4_BIT19
    #define PIN_GPIO_EMC_20_GPIO4_IO20       PORT4_BIT20
    #define PIN_GPIO_EMC_21_GPIO4_IO21       PORT4_BIT21
    #define PIN_GPIO_EMC_22_GPIO4_IO22       PORT4_BIT22
    #define PIN_GPIO_EMC_23_GPIO4_IO23       PORT4_BIT23
    #define PIN_GPIO_EMC_24_GPIO4_IO24       PORT4_BIT24
    #define PIN_GPIO_EMC_25_GPIO4_IO25       PORT4_BIT25
    #define PIN_GPIO_EMC_26_GPIO4_IO26       PORT4_BIT26
    #define PIN_GPIO_EMC_27_GPIO4_IO27       PORT4_BIT27
    #define PIN_GPIO_EMC_28_GPIO4_IO28       PORT4_BIT28
    #define PIN_GPIO_EMC_29_GPIO4_IO29       PORT4_BIT29
    #define PIN_GPIO_EMC_30_GPIO4_IO30       PORT4_BIT30
    #define PIN_GPIO_EMC_31_GPIO4_IO31       PORT4_BIT31

    #define PIN_WAKEUP_GPIO5_IO00            PORT5_BIT0
    #define PIN_PMIC_ON_REQ_GPIO5_IO01       PORT5_BIT1
    #define PIN_PMIC_STBY_REQ_GPIO5_IO02     PORT5_BIT2
#endif

// Compatibility with Kinetis
//
#define PORT_NO_PULL               (0)                                              // no pull-up/down enabled
#define PORT_PS_DOWN_ENABLE        (IOMUXC_SW_PAD_CTL_PAD_PUS_100k_DOWN | IOMUXC_SW_PAD_CTL_PAD_PUE | IOMUXC_SW_PAD_CTL_PAD_PKE) // pull-down active (note that it is combined with the PORT_PE so that it is enabled)
#define PORT_PS_UP_ENABLE          (IOMUXC_SW_PAD_CTL_PAD_PUS_22k_UP | IOMUXC_SW_PAD_CTL_PAD_PUE | IOMUXC_SW_PAD_CTL_PAD_PKE) // pull-up active (note that it is combined with the PORT_PE so that it is enabled)
#define PORT_SRE_FAST              (IOMUXC_SW_PAD_CTL_PAD_SRE)                      // fast slew-rate if digital output
#define PORT_SRE_SLOW              (0)                                              // slow slew-rate if digital output
#define PORT_PFE                   (0)                                              // not supported (only for interface compatibility)
#define PORT_ODE                   (IOMUXC_SW_PAD_CTL_PAD_ODE)                      // open-drain enabled if digital output
#define PORT_DSE_LOW               (IOMUXC_SW_PAD_CTL_PAD_DSE_1)                    // digital strength low if digital output
#define PORT_DSE_HIGH              (IOMUXC_SW_PAD_CTL_PAD_DSE_7)                    // digital strength high if digital output

// Extended port characteristics
//
#define PORT_NO_HYSTERISIS         0x00000000                                       // no hysterisis enabled
#define PORT_WITH_HYSTERESIS       (IOMUXC_SW_PAD_CTL_PAD_HYS)                      // hysteresis enabled
#define PORT_DSE_OFF               (IOMUXC_SW_PAD_CTL_PAD_DSE_DISABLED)
#define PORT_DSE_1                 (IOMUXC_SW_PAD_CTL_PAD_DSE_1)
#define PORT_DSE_2                 (IOMUXC_SW_PAD_CTL_PAD_DSE_2)
#define PORT_DSE_3                 (IOMUXC_SW_PAD_CTL_PAD_DSE_3)
#define PORT_DSE_MID               (PORT_DSE_3)
#define PORT_DSE_4                 (IOMUXC_SW_PAD_CTL_PAD_DSE_4)
#define PORT_DSE_5                 (IOMUXC_SW_PAD_CTL_PAD_DSE_5)
#define PORT_DSE_6                 (IOMUXC_SW_PAD_CTL_PAD_DSE_6)
#define PORT_DSE_7                 (IOMUXC_SW_PAD_CTL_PAD_DSE_7)
#define PORT_SPEED_LOW             (IOMUXC_SW_PAD_CTL_PAD_SPEED_LOW)
#define PORT_SPEED_MID             (IOMUXC_SW_PAD_CTL_PAD_SPEED_MEDIUM)
#define PORT_SPEED_MAX             (IOMUXC_SW_PAD_CTL_PAD_SPEED_MAX)
#define PORT_PS_UP_ENABLE_LOW      (IOMUXC_SW_PAD_CTL_PAD_PUS_22k_UP | IOMUXC_SW_PAD_CTL_PAD_PUE)
#define PORT_PS_UP_ENABLE_HIGH     (IOMUXC_SW_PAD_CTL_PAD_PUS_100k_UP | IOMUXC_SW_PAD_CTL_PAD_PUE)
#define PORT_PS_UP_ENABLE_MEDIUM   (IOMUXC_SW_PAD_CTL_PAD_PUS_47k_UP | IOMUXC_SW_PAD_CTL_PAD_PUE)
#define PORT_KEEPER                (IOMUXC_SW_PAD_CTL_PAD_PKE)




extern void fnConnectGPIO(int iPortRef, unsigned long ulPortBits, unsigned long ulCharacteristics);
extern void fnSimPers(void);

// Port macros
//

// Configure pins as output, including enabling clock to specified port eg. _CONFIG_PORT_OUTPUT(1, PORT1_BIT16, (PORT_SRE_FAST | PORT_DSE_LOW));
//
#define _CONFIG_PORT_OUTPUT(ref, pins, chars) fnConnectGPIO(PORT##ref, pins, (chars)); GPIO##ref##_GDIR |= (pins); _SIM_PORT_CHANGE(PORT##ref); _SIM_PER_CHANGE

// Configure pins as Input, including enabling clock to specified port eg. _CONFIG_PORT_INPUT(1, PORT1_BIT4, PORT_PS_UP_ENABLE);
//
#define _CONFIG_PORT_INPUT(ref, pins, chars)  fnConnectGPIO(PORT##ref, pins, (chars)); GPIO##ref##_GDIR &= ~(pins); _SIM_PORT_CHANGE(PORT##ref); _SIM_PER_CHANGE

// Configure a peripheral function eg. _CONFIG_PERIPHERAL(B, 2, (PB_2_FTM0_CH0 | PORT_SRE_FAST | PORT_DSE_HIGH));
//
#define _CONFIG_PERIPHERAL(port, function, chars) IOMUXC_SW_MUX_CTL_PAD_##port = port##_##function; IOMUXC_SW_PAD_CTL_PAD_##port = (chars); _SIM_PER_CHANGE

// Configure a peripheral function eg. _CONFIG_PERIPHERAL_LOOPBACK(B, 2, (PB_2_FTM0_CH0 | PORT_SRE_FAST | PORT_DSE_HIGH));
// - the software loopback is set so that the pin is bidirectional or its input value can be read by GPIO
//
#define _CONFIG_PERIPHERAL_LOOPBACK(port, function, chars) IOMUXC_SW_MUX_CTL_PAD_##port = (port##_##function | IOMUXC_SW_MUX_CTL_PAD_SION); IOMUXC_SW_PAD_CTL_PAD_##port = (chars); _SIM_PER_CHANGE

// Write to a port with a mask eg. eg. _WRITE_PORT_MASK(1, 0x1234,  0x0000ffff)
//
#define _WRITE_PORT_MASK(ref, value, mask) GPIO##ref##_DR = ((GPIO##ref##_DR & ~(mask)) | ((value) & (mask))); _SIM_PORT_CHANGE(PORT##ref)

// Write full port width eg. _WRITE_PORT_MASK(1, 0x12345678)
//
#define _WRITE_PORT(ref, value)            GPIO##ref##_DR = (value); _SIM_PORT_CHANGE(PORT##ref)

// Toggle a port with a mask eg. _TOGGLE_PORT(1, PORT1_BIT3)
//
#define _TOGGLE_PORT(ref, mask)            GPIO##ref##_DR_TOGGLE = (mask); _SIM_PORT_CHANGE(PORT##ref)

// Read full port width eg. _READ_PORT(1)
//
#define _READ_PORT(ref)                    (GPIO##ref##_PSR)

// Read from a port with a mask eg. _READ_PORT(1, (PORT1_BIT3 | PORT1_BIT0))
//
#define _READ_PORT_MASK(ref, mask)         (GPIO##ref##_PSR & (mask))

// Configure outputs, including enabling clock to specified port, and then set a value to them - this device sets the value and then drives
// eg. _CONFIG_DRIVE_PORT_OUTPUT_VALUE(1, (PORT1_BIT13), (PORT1_BIT13), (PORT_SRE_SLOW | PORT_DSE_HIGH))
//
#define _CONFIG_DRIVE_PORT_OUTPUT_VALUE(ref, pins, value, chars) fnConnectGPIO(PORT##ref, pins, (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_GPIO | chars)); GPIO##ref##_DR = ((GPIO##ref##_DR & ~(pins)) | (value)); GPIO##ref##_GDIR |= (pins); _SIM_PORT_CHANGE(PORT##ref); _SIM_PER_CHANGE

// Set from inputs to outputs and set a value to them - this is equivalent to _CONFIG_DRIVE_PORT_OUTPUT_VALUE on this device
//
#define _DRIVE_PORT_OUTPUT_VALUE(ref, pins, value)  GPIO##ref##_DR = ((GPIO##ref##_DR & ~(pins)) | (value)); GPIO##ref##_GDIR |= (pins); _SIM_PORT_CHANGE(PORT##ref)

// Set from outputs to inputs eg. _FLOAT_PORT(1, LCD_BUS_BITS)
//
#define _FLOAT_PORT(ref, pins)           GPIO##ref##_GDIR &= ~(pins); _SIM_PORT_CHANGE(PORT##ref)

// Set from inputs to outputs eg. _DRIVE_PORT_OUTPUT(1, LCD_BUS_BITS)
//
#define _DRIVE_PORT_OUTPUT(ref, pins)    GPIO##ref##_GDIR |= (pins); _SIM_PORT_CHANGE(PORT##ref)

// Set and clear individual bits of a port eg. _SETBITS(1, (PORT1_BIT5 | PORT1_BIT19)) / _CLEARBITS(1, (PORT1_BIT5 | PORT1_BIT19))
//
#define _SETBITS(ref, pins)              GPIO##ref##_DR_SET = (pins); _SIM_PORT_CHANGE(PORT##ref)
#define _CLEARBITS(ref, pins)            GPIO##ref##_DR_CLEAR = (pins); _SIM_PORT_CHANGE(PORT##ref)



// eFUSES - warning that blown eFUSEs (changed form '0' to '1') are irreversible!
//
#define BOOT_MODE0_OVERRIDE             (PIN_GPIO_AD_B0_04_GPIO1_IO04)
#define BOOT_MODE1_OVERRIDE             (PIN_GPIO_AD_B0_05_GPIO1_IO05)

#define BOOT_MODE_FUSES                 (0)
#define BOOT_MODE_SERIAL_DOWNLOADER     (BOOT_MODE0_OVERRIDE)
#define BOOT_MODE_INTERNAL              (BOOT_MODE1_OVERRIDE)

#define eFUSE_LOCK                       0x400
    #define eFUSE_LOCK_TEST_WRITE_LOCK         0x00000001
    #define eFUSE_LOCK_TEST_OPERATION_LOCK     0x00000002
    #define eFUSE_LOCK_TEST_LOCK_MASK          0x00000003                // lock writing and overriding tester programmed fuses in corresponding IIM register
    #define eFUSE_LOCK_BOOT_CFG_WRITE_LOCK     0x00000004
    #define eFUSE_LOCK_BOOT_CFG_OPERATION_LOCK 0x00000008
    #define eFUSE_LOCK_BOOT_CFG_LOCK_MASK      0x0000000c                // lock writing and overriding boot related fuses in corresponding IIM register
    #define eFUSE_LOCK_MEM_TRIM_WRITE_LOCK     0x00000010
    #define eFUSE_LOCK_MEM_TRIM_OPERATION_LOCK 0x00000020
    #define eFUSE_LOCK_MEM_TRIM_LOCK_MASK      0x00000030                // lock writing and overriding trimming fuses in corresponding IIM register
    #define eFUSE_LOCK_SJC_RESP_LOCK           0x00000040                // lock sensing, burning and overriding SJC_RESP in corresponding IIM register
    #define eFUSE_LOCK_MAC_ADDR_WRITE_LOCK     0x00000100
    #define eFUSE_LOCK_MAC_ADDR_OPERATION_LOCK 0x00000200
    #define eFUSE_LOCK_MAC_ADDR_LOCK_MASK      0x00000300                // lock writing and overriding MAC_ADDR fuses in corresponding IIM register
    #define eFUSE_LOCK_GP1_WRITE_LOCK          0x00000400
    #define eFUSE_LOCK_GP1_OPERATION_LOCK      0x00000800
    #define eFUSE_LOCK_GP1_LOCK_MASK           0x00000c00                // lock writing and overriding GP1 fuses in corresponding IIM register
    #define eFUSE_LOCK_GP2_WRITE_LOCK          0x00001000
    #define eFUSE_LOCK_GP2_OPERATION_LOCK      0x00002000
    #define eFUSE_LOCK_GP2_LOCK_MASK           0x00003000                // lock writing and overriding GP2 fuses in corresponding IIM register
    #define eFUSE_LOCK_SW_GP1_LOCK             0x00010000                // lock sensing, burning and overriding SW_GP1 in corresponding IIM register
    #define eFUSE_LOCK_ANALOG_WRITE_LOCK       0x00040000
    #define eFUSE_LOCK_ANALOG_OPERATION_LOCK   0x00080000
    #define eFUSE_LOCK_ANALOG_LOCK_MASK        0x000c0000                // lock writing and overriding analog related fuse in corresponding IIM register
    #define eFUSE_LOCK_SW_GP2_LOCK             0x00200000                // lock sensing, burning and overriding SW_GP2 in corresponding IIM register
    #define eFUSE_LOCK_MISC_CONF_LOCK          0x00400000
    #define eFUSE_LOCK_SW_GP2_RLOCK            0x00800000                // lock reading SW_GP2 in corresponding IIM register
    #define eFUSE_LOCK_SW_GP3_RLOCK            0x0c000000                // lock reading SW_GP3 in corresponding IIM register
    #define eFUSE_LOCK_FIELD_RETURN            0x80000000                // NXP reserved modes are enabled, irrespective of DIR_BT_DIS

#define eFUSE_UNIQUE_ID_0                0x410                           // locked by TESTER_LOCK (64 bit unique ID programmed by NXP (used by HAB))
#define eFUSE_UNIQUE_ID_1                0x420                           // locked by TESTER_LOCK

#define eFUSE_SILICON_REV                0x430                           // locked by TESTER_LOCK

#define eFUSE_SPEED_GRADING              0x440                           // locked by TESTER_LOCK
    #define eFUSE_SPEED_GRADING_MASK     0x00030000
    #define eFUSE_SPEED_GRADING_500MHz   0x00010000
    #define eFUSE_SPEED_GRADING_600MHz   0x00020000

#define eFUSE_CFG0                       0x450                           // locked by BOOT_CFG_LOCK
    #define eFUSE_CFG0_BOOT_CFG1_1       0x00000002
    #define eFUSE_CFG0_BOOT_CFG1_2       0x00000004
    #define eFUSE_CFG0_BOOT_CFG1_3       0x00000008
    #define eFUSE_CFG0_BOOT_CFG1_4       0x00000010
    #define eFUSE_CFG0_BOOT_CFG1_5       0x00000020
    #define eFUSE_CFG0_BOOT_CFG1_6       0x00000040
    #define eFUSE_CFG0_BOOT_CFG1_7       0x00000080
    #define eFUSE_CFG0_BOOT_CFG2_0       0x00000100
    #define eFUSE_CFG0_BOOT_CFG2_1       0x00000200
    #define eFUSE_CFG0_BOOT_CFG2_2       0x00000400
    #define eFUSE_CFG0_BOOT_CFG2_3       0x00000800
#define eFUSE_CFG1                       0x460                           // locked by BOOT_CFG_LOCK
    #define uFUSE_BOOT_CFG2_SEC_CONFIG_OPEN              (0x00000000)    // allows any program image, even if authentication fails (shipped value)
    #define uFUSE_BOOT_CFG2_SEC_CONFIG_CLOSED            (0x00000002)    // the program image executes only if authenticated
    #define uFUSE_BOOT_CFG2_BOOT_FREQ_396_132MHz         (0x00000000)    // boot frequency 528MHz core and 132MHz bus
    #define uFUSE_BOOT_CFG2_BOOT_FREQ_528_132MHz         (0x00000004)    // boot frequency 528MHz core and 132MHz bus
    #define uFUSE_BOOT_CFG2_DIR_BT_DIS                   (0x00000008)    // disables the NXP reserved mode - must be set for the secure boot
    #define uFUSE_BOOT_CFG2_BT_FUSE_SEL                  (0x00000010)    // in internal boot mode (BOOT_MODE[1:0] = 10) this fuse determines whether the GPIO input override bits in SBMR are taken or not
    #define uFUSE_BOOT_CFG2_FORCE_COLD_BOOT              (0x00000020)    // force cold boot when core comes out of reset - reflected in SBMR register of SRC (higher level of security)
    #define uFUSE_BOOT_CFG2_BEE_KEY0_SEL_REGISTER        (0x00000000)    // take the AES key selection for BEE_KEY0 from register (default)
    #define uFUSE_BOOT_CFG2_BEE_KEY0_SEL_SW_GP2          (0x00003000)    // take the AES key selection for BEE_KEY0 from SW-GP2
    #define uFUSE_BOOT_CFG2_BEE_KEY1_SEL_REGISTER        (0x00000000)    // take the AES key selection for BEE_KEY1 from register (default)
    #define uFUSE_BOOT_CFG2_BEE_KEY1_SEL_SW_GP2          (0x0000c000)    // take the AES key selection for BEE_KEY1 from SW-GP2
    #define uFUSE_BOOT_CFG2_FORCE_INTERNAL_BOOT          (0x00010000)    // BT_MODE pins are ignore and the boot mode is forced to internal boot
    #define uFUSE_BOOT_CFG2_SDP_DISABLE                  (0x00020000)    // disable serial download support
    #define uFUSE_BOOT_CFG2_SDP_READ_DISABLE             (0x00040000)    // serial download read register is disabled
    #define uFUSE_BOOT_CFG2_DAP_SJC_SWD_SEL_SWD          (0x00000000)    // DAP works in SWD mode (default)
    #define uFUSE_BOOT_CFG2_DAP_SJC_SWD_SEL_JTAG         (0x00080000)    // DAP works in JTAG mode
    #define uFUSE_BOOT_CFG2_SJC_DISABLE                  (0x00100000)    // disable secure JTAG controller
    #define uFUSE_BOOT_CFG2_WDOG_ENABLE                  (0x00200000)    // enable the watchdog
    #define uFUSE_BOOT_CFG2_JTAG_SMODE_JTAG              (0x00000000)    // normal JTAG mode enabled (default)
    #define uFUSE_BOOT_CFG2_JTAG_SMODE_SECURE            (0x00400000)    // secured JTAG mode enabled
    #define uFUSE_BOOT_CFG2_JTAG_SMODE_NO_DEBUG          (0x00c00000)    // no JTAG debug mode
    #define uFUSE_BOOT_CFG2_DLL_ENABLE                   (0x01000000)    // enable DLL for SD/eMMC
    #define uFUSE_BOOT_CFG2_NAND_ECC_DISABLE             (0x02000000)    // disable NAND EEC
    #define uFUSE_BOOT_CFG2_KTE                          (0x04000000)    // kill trace enable
    #define uFUSE_BOOT_CFG2_JTAG_HEO                     (0x08000000)    // HAB JTAG enable is overridden
    #define uFUSE_BOOT_CFG2_PWR_STABLE_CYCLE_SELECTION   (0x20000000)
    #define uFUSE_BOOT_CFG2_SD_PWR_CYCLE_SELECTION_MASK  (0xc0000000)
#define eFUSE_CFG2                       0x470                           // locked by BOOT_CFG_LOCK
    #define uFUSE_BOOT_CFG2_OVERRIDE_PAD                 (0x00000001)
    #define uFUSE_BOOT_CFG2_DISABLE_L1_D_CACHE           (0x00000002)
    #define uFUSE_BOOT_CFG2_DISABLE_L1_I_CACHE           (0x00000004)
    #define uFUSE_BOOT_CFG2_DISABLE_SDMMC_MAN_MODE       (0x00000008)
    #define uFUSE_BOOT_CFG2_DISABLE_UART_MODE            (0x00000010)    // disable UART serial download
    #define uFUSE_BOOT_CFG2_SD2_VOLTAGE_SELECTION        (0x00000020)
    #define uFUSE_BOOT_CFG2_SD1_RST_POLARITY_SELECT      (0x00000040)    // SD1 reset active high
    #define uFUSE_BOOT_CFG2_DLL_OVERRIDE                 (0x00000080)
    #define uFUSE_BOOT_CFG2_USDHC_IOMUX_SRE_ENABLE       (0x00000100)
    #define uFUSE_BOOT_CFG2_USDHC_IOMUX_SION_BIT_ENABLE  (0x00000200)
    #define uFUSE_BOOT_CFG2_POWER_FAILURE_INDICATOR_PIN  (0x00000400)
    #define uFUSE_BOOT_CFG2_ENABLE_47K_PULLUP            (0x00000000)
    #define uFUSE_BOOT_CFG2_ENABLE_22K_PULLUP            (0x00000800)
    #define uFUSE_BOOT_CFG2_USDHC_PAD_PULL_DOWN          (0x00001000)
    #define uFUSE_BOOT_CFG2_OVERRIDE_HYS_BIT_SD_MMC_PADS (0x00002000)
    #define uFUSE_BOOT_CFG2_eMMC_RESET_TO_PRE_IDLE       (0x00004000)
    #define uFUSE_BOOT_CFG2_SD2_RST_POLARITY_SELECT      (0x00008000)
    #define uFUSE_BOOT_CFG2_BOOT_FAILURE_PIN_SELECT_MASK (0x000f0000)
    #define uFUSE_BOOT_CFG2_LPB_BOOT_MASK                (0x00600000)
    #define uFUSE_BOOT_CFG2_USDHC_CMD_OE_PRE_EN          (0x00800000)
    #define uFUSE_BOOT_CFG2_MMC_DLL_DLY_MASK             (0x7f000000)
    #define uFUSE_BOOT_CFG2_OVERRIDE_NAND_PAD_SETTINGS   (0x80000000)

#define eFUSE_USB                        0x4f0                           // locked by ANALOG_LOCK

#define eFUSE_SRK_HASH_0                 0x580                           // 256 bit SRK key (no hardware visibilty)
#define eFUSE_SRK_HASH_1                 0x590
#define eFUSE_SRK_HASH_2                 0x5a0
#define eFUSE_SRK_HASH_3                 0x5b0
#define eFUSE_SRK_HASH_4                 0x5c0
#define eFUSE_SRK_HASH_5                 0x5d0
#define eFUSE_SRK_HASH_6                 0x5e0
#define eFUSE_SRK_HASH_7                 0x5f0

#define eFUSE_SJC_RESPONSE_0             0x600                           // 56 bit response reference for the secure JTAG controller - locked by SJC_RESP_LOCK
#define eFUSE_SJC_RESPONSE_1             0x610

#define eFUSE_MAC1_ADDR_0                0x620                           // 48 bit ethernet MAC address - locked by MAC_ADDR_LOCK
#define eFUSE_MAC1_ADDR_1                0x630

#if !defined iMX_RT106X
    #define eFUSE_GP3                    0x640                           // 32 bit general purpose fuses 3 - locked by GP3_LOCK
#endif

#define eFUSE_GP1                        0x660                           // 32 bit general purpose fuses 1 - locked by GP1_LOCK
#define eFUSE_GP2                        0x670                           // 32 bit general purpose fuses 2 - locked by GP2_LOCK
#define eFUSE_SW_GP1                     0x680                           // 32 bit SW general purpose key 1 - locked by SW_GP1_LOCK
#define eFUSE_SW_GP2_0                   0x690                           // 128 bit SW general purpose key 2 - locked by SW_GP2_LOCK
#define eFUSE_SW_GP2_1                   0x6a0
#define eFUSE_SW_GP2_2                   0x6b0
#define eFUSE_SW_GP2_3                   0x6c0

#define eFUSE_CONFIG0                    0x6d0                           // locked by MISC_CONF_LOCK
    #define eFUSE_CONFIG0_PAD_SETTINGS         0x0000003f
    #define eFUSE_CONFIG0_USB_VBUS             0x00000040                // ROM handles USB VBUS attach/detach events
    #define eFUSE_CONFIG0_BOOT_FAILURE_PIN     0x00000080                // enable boot failure indicator pin
    #define eFUSE_CONFIG0_READ_RETRY_SEQ_ID    0x00000f00
    #define eFUSE_CONFIG0_WDOG_TIMEOUT         0x0000e000
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION    0x000f0000
#if defined iMX_RT105X || defined iMX_RT106X
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOODDIIIIDDOOOO 0x00000000  // 128k DTC, 128k ITC, 256k OC (banks 0..15)
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOODDIIDDOOOOOO 0x00010000  // 128k DTC, 64k  ITC, 320k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDIIIIIIIIDDOO 0x00020000  // 128k DTC, 256k ITC, 128k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOODDDDIOOOOOOOO 0x00030000  // 128k DTC, 32k  ITC, 352k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOODDIIIIOOOOOO 0x00040000  // 64k  DTC, 128k ITC, 320k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOODDIIOOOOOOOO 0x00050000  // 64k  DTC, 64k  ITC, 384k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDIIIIIIIIOOOO 0x00060000  // 64k  DTC, 256k ITC, 192k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOIIIIIIIIIIIIII 0x00070000  // 0k   DTC, 442k ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDDDIIIIDDDDOO 0x00080000  // 256k DTC, 128k ITC, 128k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDDDIIDDDDOOOO 0x00090000  // 256k DTC, 64k  ITC, 192k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDIIIIIIIIDDDD 0x000a0000  // 192k DTC, 256k ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDDDDDDDDDDDDD 0x000b0000  // 448k DTC, 0k   ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOOIIIIOOOOOOOO 0x000c0000  // 0k   DTC, 128k ITC, 384k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOODIOOOOOOOOOOO 0x000d0000  // 32k  DTC, 32k  ITC, 448k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOIIIIIIIIOOOOOO 0x000e0000  // 0k   DTC, 256k ITC, 256k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOOOOOOOOOOOOOO 0x000f0000  // 0k   DTC, 0k   ITC, 512k OC
#elif defined iMX_RT1011
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODI             0x00000000  // 64k  DTC, 32k  ITC, 32k  OC (banks 0..3)
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_ODDI             0x00010000  // 32k  DTC, 32k  ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODD             0x00020000  // 64k  DTC, 0k   ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_ODDD             0x00030000  // 32k  DTC, 0k   ITC, 96k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_ODII             0x00040000  // 32k  DTC, 64k  ITC, 32k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODO             0x00050000  // 96k  DTC, 0k   ITC, 32k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OIII             0x00060000  // 32k  DTC, 96k  ITC, 0k   OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOII             0x00070000  // 64k  DTC, 64k  ITC, 0k   OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOIO             0x00080000  // 96k  DTC, 32k  ITC, 0k   OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOO             0x00090000  // 128k  DTC, 0k  ITC, 0k   OC
#else
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDIIOO         0x00000000  // 64k  DTC, 64k  ITC, 128k OC (banks 0..7)
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDDDII         0x00010000  // 128k DTC, 64k  ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDDDOO         0x00020000  // 128k DTC, 0k   ITC, 128k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOODDDDI         0x00030000  // 128k DTC, 32k  ITC, 96k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDIIII         0x00040000  // 64k  DTC, 128k ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDDDDD         0x00050000  // 128k DTC, 0k   ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDIOOO         0x00060000  // 64k  DTC, 32k  ITC, 160k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODDOOOO         0x00070000  // 64k  DTC, 0k   ITC, 192k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODOIIOO         0x00080000  // 32k  DTC, 64k  ITC, 160k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODOIIII         0x00090000  // 32k  DTC, 128k ITC, 96k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODIIIII         0x000a0000  // 32k  DTC, 160k ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODOOOOO         0x000b0000  // 32k  DTC, 0k   ITC, 224k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOOIIII         0x000c0000  // 0k   DTC, 128k ITC, 128k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OODOIOOO         0x000d0000  // 32k  DTC, 32k  ITC, 192k OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOIIIIII         0x000e0000  // 0k   DTC, 192k ITC, 64k  OC
    #define eFUSE_CONFIG0_FLEXRAM_PARTITION_OOOOOOOO         0x000f0000  // 0k   DTC, 0k   ITC, 256k OC
#endif
    #define eFUSE_CONFIG0_EEPROM_RECOVERY_EN   0x01000000
    #define eFUSE_CONFIG0_LPSPI_PORT_SEL_1     0x00000000
    #define eFUSE_CONFIG0_LPSPI_PORT_SEL_2     0x02000000
    #define eFUSE_CONFIG0_LPSPI_PORT_SEL_3     0x04000000
    #define eFUSE_CONFIG0_LPSPI_PORT_SEL_4     0x06000000
    #define eFUSE_CONFIG0_LPSPI_ADDR_24_BIT    0x00000000
    #define eFUSE_CONFIG0_LPSPI_ADDR_16_BIT    0x08000000
    #define eFUSE_CONFIG0_LPSPI_SPEED_20MHz    0x00000000
    #define eFUSE_CONFIG0_LPSPI_SPEED_10MHz    0x10000000
    #define eFUSE_CONFIG0_LPSPI_SPEED_5MHz     0x20000000
    #define eFUSE_CONFIG0_LPSPI_SPEED_2MHz     0x30000000
    #define eFUSE_CONFIG0_SD_CALIBRATION_STEP  0xc0000000
#define eFUSE_CONFIG1                    0x6e0
    #define eFUSE_CONFIG1_OVERRIDE_BUSY_OFFSET 0x0000000f
    #define eFUSE_CONFIG1_PREAMBLE_DELAY       0x00000070
    #define eFUSE_CONFIG1_BUSY_BIT_OFFSET      0x00000080
    #define eFUSE_CONFIG1_BYPASS_READ_STATUS   0x00003f00
    #define eFUSE_CONFIG1_BYPASS_ECC_READ      0x00004000
    #define eFUSE_CONFIG1_PAGE_READ_TIME       0x00008000
    #define eFUSE_CONFIG1_NAND_READ_CMD_CODE1  0x00ff0000
    #define eFUSE_CONFIG1_NAND_READ_CMD_CODE2  0xff000000

#if defined iMX_RT106X
    #define eFUSE_PATCH0                 0x800
    #define eFUSE_PATCH1                 0x810
    #define eFUSE_PATCH2                 0x820
    #define eFUSE_PATCH3                 0x830
    #define eFUSE_PATCH4                 0x840
    #define eFUSE_PATCH5                 0x850
    #define eFUSE_PATCH6                 0x860
    #define eFUSE_PATCH7                 0x870
    #define eFUSE_GP3                    0x880                           // 128 bit general purpose fuses 3 - locked by GP3_LOCK
    #define eFUSE_GP30                   eFUSE_GP3
    #define eFUSE_GP31                   0x890
    #define eFUSE_GP32                   0x8a0
    #define eFUSE_GP33                   0x8b0
    #define eFUSE_GP40                   0x8c0
    #define eFUSE_GP41                   0x8d0
    #define eFUSE_GP42                   0x8e0
    #define eFUSE_GP43                   0x8f0
#endif

// serial NOR flash boot via flexspi(and GPIO overrides)
//
#define uFUSE_BOOT_CFG1_SERIAL_NOR_ENCRYPTED_XIP                   eFUSE_CFG0_BOOT_CFG1_1

#define uFUSE_BOOT_CFG1_SERIAL_NOR_HOLD_TIME_MSK                   (eFUSE_CFG0_BOOT_CFG1_3 | eFUSE_CFG0_BOOT_CFG1_2) // hold time before read from device - 500us, 1ms, 3ms, 10ms
#define uFUSE_BOOT_CFG1_SERIAL_NOR_HOLD_TIME_500US                 (0x00000000)
#define uFUSE_BOOT_CFG1_SERIAL_NOR_HOLD_TIME_1MS                   (eFUSE_CFG0_BOOT_CFG1_2)
#define uFUSE_BOOT_CFG1_SERIAL_NOR_HOLD_TIME_3MS                   (eFUSE_CFG0_BOOT_CFG1_3)
#define uFUSE_BOOT_CFG1_SERIAL_NOR_HOLD_TIME_10MS                  (eFUSE_CFG0_BOOT_CFG1_3 | eFUSE_CFG0_BOOT_CFG1_2)

#define uFUSE_BOOT_CFG1_SERIAL_NOR_HOLD_TIME_OVERRIDE              (PIN_GPIO_B0_07_GPIO2_IO07 | PIN_GPIO_B0_06_GPIO2_IO06)


#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE_SELECTION           (eFUSE_CFG0_BOOT_CFG1_7 | eFUSE_CFG0_BOOT_CFG1_6 | eFUSE_CFG0_BOOT_CFG1_5 | eFUSE_CFG0_BOOT_CFG1_4)
#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE_FlexSPI_NOR         (0x00000000)   // flexspi (NOR) boot
#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE__SEMC_NAND          eFUSE_CFG0_BOOT_CFG1_4 // SEMC NAND boot
#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE__SEMC_NOR           eFUSE_CFG0_BOOT_CFG1_5 // SEMC NOR boot
#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE__SD                 eFUSE_CFG0_BOOT_CFG1_6 // SD boot
#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE__MMC_eMMC           eFUSE_CFG0_BOOT_CFG1_7 // MMC/eMMC boot
#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE__FlexSPI_NAND       eFUSE_CFG0_BOOT_CFG1_7 // flexspi (serial NAND) boot

#define uFUSE_BOOT_CFG1_SERIAL_NOR_BOOT_DEVICE_SELECTION_OVERRIDE  (PIN_GPIO_B0_11_GPIO2_IO11 | PIN_GPIO_B0_10_GPIO2_IO10 | PIN_GPIO_B0_09_GPIO2_IO09 | PIN_GPIO_B0_08_GPIO2_IO08)


#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_MASK            (eFUSE_CFG0_BOOT_CFG2_2 | eFUSE_CFG0_BOOT_CFG2_1 | eFUSE_CFG0_BOOT_CFG2_0)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_3B_READ         (0x00000000)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_4B_READ         (eFUSE_CFG0_BOOT_CFG2_0)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_HYPER_1V8       (eFUSE_CFG0_BOOT_CFG2_1)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_HYPER_3V3       (eFUSE_CFG0_BOOT_CFG2_1 | eFUSE_CFG0_BOOT_CFG2_0)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_MXIC_OCT_DDR    (eFUSE_CFG0_BOOT_CFG2_2)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_MICRON_OCT_DDR  (eFUSE_CFG0_BOOT_CFG2_2 | eFUSE_CFG0_BOOT_CFG2_0)
#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_3B_READ_SEC_MUX (eFUSE_CFG0_BOOT_CFG2_2 | eFUSE_CFG0_BOOT_CFG2_1 | eFUSE_CFG0_BOOT_CFG2_0)

#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_FLASH_TYPE_OVERRIDE        (PIN_GPIO_B0_14_GPIO2_IO14 | PIN_GPIO_B0_13_GPIO2_IO13 | PIN_GPIO_B0_12_GPIO2_IO12)


#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_INFINITE_LOOP              (eFUSE_CFG0_BOOT_CFG2_3) // infinite loop enable at the start of boot ROM (for debugging) - ignored if DIR_BT_DIS is 1 and FIELD_RETURN is 0

#define uFUSE_BOOT_CFG2_SERIAL_NOR_BOOT_INFINITE_LOOP_OVERRIDE     (PIN_GPIO_B0_15_GPIO2_IO15)



// Macro to clear flags by writing '1' to the bit
//
#if defined _WINDOWS                                                     // clear when simulating
    extern int fnResetNVICInt(int iIrqID);
    #define WRITE_ONE_TO_CLEAR_INTERRUPT(reg, flag, iIrqID)    reg &= ~(flag); fnResetNVICInt(iIrqID)
    #define WRITE_ONE_TO_CLEAR(reg, flag)    reg &= ~(flag)
#else
    #define WRITE_ONE_TO_CLEAR_INTERRUPT(reg, flag, iIrqID)    reg = (flag)
    #define WRITE_ONE_TO_CLEAR(reg, flag)    reg = (flag)
#endif
#if defined _WINDOWS                                                     // clear when simulating
    #define OR_ONE_TO_CLEAR(reg, flag)       reg &= ~(flag)
#else
    #define OR_ONE_TO_CLEAR(reg, flag)       reg |= (flag)
#endif


// Software references used when setting up interrupts
//
#define PORT_INTERRUPT            0
#define TIMER_INTERRUPT           1
#define PIT_INTERRUPT             2
#define PWM_INTERRUPT             3
#define ADC_INTERRUPT             4
#define DAC_INTERRUPT             5

#define LPTMR_INTERRUPT           7
#define KEYBOARD_INTERRUPT        8
#define WAKEUP_INTERRUPT          9
#define I2S_SAI_INTERRUPT         10
#define COMPARATOR_INTERRUPT      11

#define TIMER_SINGLE_SHOT         0x00000000
#define TIMER_CAPTURE_RISING      0x00000002
#define TIMER_CAPTURE_FALLING     0x00000004
#define TIMER_CAPTURE_RISING_FALLING  (TIMER_CAPTURE_RISING | TIMER_CAPTURE_FALLING)
#define TIMER_MS_VALUE            0x00000000
#define TIMER_PERIODIC            0x00000010
#define TIMER_USES_PRESCALER      0x00000020
#define TIMER_FIXED_CLK           0x00000040                             // clock source is the high speed reference clock (ipg_clk_highfreq)
#define TIMER_HS_REF_CLK          (TIMER_FIXED_CLK)
#define TIMER_SYS_CLK             0x00000000                             // default is PERCLK (ipg_clk)
#define TIMER_24M_REF_CLK         0x00000080                             // clock source is the 24MHz oscillator/crystal source (ipg_clk_24M)
#define TIMER_LS_REF_CLK          0x00000800                             // clock source is the low speed reference clock (ipg_clk_32k)

#define TIMER_SQUARE_WAVE         0x00000100
#define TIMER_DONT_DISTURB        0x00000200
#define TIMER_EXT_CLK_0           0x00000400                             // clock source is the GPT external clock input pin
#define TIMER_EXT_CLK_1           TIMER_EXT_CLK_0
#define TIMER_FREEZE              0x00001000
#define TIMER_CONTINUE            0x00002000
#define TIMER_DMA_TRIGGER         0x00004000
#define TIMER_STOP                0x00008000

#define TIMER_PERIOD_OUTPUT       GPT_OM1_TOGGLE                     // toggle the GPTx_COMPARE1 output on each match (generates a square wave) - 0x00100000
#define TIMER_DELAY_SET           GPT_OM1_CLEAR                      // set the GPTx_COMPARE1 output on match - 0x00200000
#define TIMER_DELAY_CLEAR         GPT_OM1_SET                        // clear the GPTx_COMPARE1 output on match - 0x00300000
#define TIMER_DELAY_PULSE         GPT_OM1_PULSE                      // clear the GPTx_COMPARE1 output on match (negative pulse) - 0x00400000



#define TIMER_CLOCK              (PERCLK_CLK_ROOT_FREQUENCY)
#define PWM_CLOCK                (IPG_CLK_ROOT_FREQUENCY)

#define _TPM_PWM_CLOCK  (SYSTEM_CLOCK)
#define TPM_PWM_CLOCK (_TPM_PWM_CLOCK)
#define PWM_FIXED_CLOCK       (TIMER_CLOCK)
#define TIMER_FIXED_CLOCK     (TIMER_CLOCK)


// GPT delays (PERCLK source - default TIMER_SYS_CLK)
//
#define TIMER_US_DELAY(usec)                       (((usec) * (PERCLK_CLK_ROOT_FREQUENCY / 1000)) / 1000)
#define TIMER_US_PRESCALED_DELAY(usec)             ((((usec) * (PERCLK_CLK_ROOT_FREQUENCY / 1000)) / 1000) / pre)
#define TIMER_MS_DELAY(msec)                       ((msec) * (PERCLK_CLK_ROOT_FREQUENCY / 1000))
#define TIMER_MS_PRESCALED_DELAY(msec, pre)        (((msec) * (PERCLK_CLK_ROOT_FREQUENCY / 1000)) / pre)
#define TIMER_FREQUENCY_VALUE(hertz)               (1000000/hertz)

// GPT delays (fixed clock source - TIMER_FIXED_CLK or TIMER_HS_REF_CLK)
//
#define TIMER_FIXED_CLOCK_US_DELAY(usec)           (((usec) * (PERCLK_CLK_ROOT_FREQUENCY / 1000)) / 1000)
#define TIMER_FIXED_CLOCK_MS_DELAY(msec)           ((msec) * (PERCLK_CLK_ROOT_FREQUENCY / 1000))
#define TIMER_FIXED_CLOCK_FREQUENCY_VALUE(hertz)   (1000000/hertz)

// GPT delays (24MHz oscillator source - TIMER_24M_REF_CLK)
//
#define TIMER_24M_CLOCK_US_DELAY(usec)             (((usec) * (24000000 / 1000)) / 1000)
#define TIMER_24M_CLOCK_MS_DELAY(msec)             ((msec) * (24000000 / 1000))
#define TIMER_24M_CLOCK_FREQUENCY_VALUE(hertz)     (1000000/hertz)


typedef struct stPWM_INTERRUPT_SETUP
{
    void             (*int_handler)(void);                               // interrupt handler to be configured (0 to disable PWM time base interrupt)
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // interrupt priority the user wants to set
    unsigned char    pwm_reference;                                      // PWM timer and channel to be used (0..3)
    unsigned short   pwm_value;                                          // PWM percentage value
    unsigned short   pwm_frequency;                                      // base frequency
    unsigned short   pwm_phase_shift;                                    // phase shift (used with combined channel mode on channels n and n+1 where n = 0, 2, 4 etc.)
    unsigned long    pwm_mode;                                           // PWM mode of operation
    void             (*channel_int_handler)(void);                       // channel interrupt handler to be configured (requires also PWM_CHANNEL_INTERRUPT)
    #if !defined DEVICE_WITHOUT_DMA
        unsigned long    ulPWM_buffer_length;                            // length of the buffer used for DMA transfer to PWM
        void             (*dma_int_handler)(void);                       // DMA interrupt handler to be configured
        void            *ptrRegister;                                    // optional destination register (when neither PWM_DMA_CONTROL_PWM nor PWM_DMA_CONTROL_FREQUENCY are required)
        void            *ptrPWM_Buffer;                                  // source buffer for DMA transfer to PWM
        unsigned short   usDmaTriggerSource;                             // source used to trigger DMA transfer - 8 bits used for register configuration and higher bits for additional information
        unsigned char    dma_int_priority;                               // DMA interrupt priority the user wants to set
        unsigned char    ucDmaChannel;                                   // DMA channel to be used
    #endif
} PWM_INTERRUPT_SETUP;

#define _TIMER_0                0x00                                     // used together with pwm_reference to specify the FlexPWM used
#define _TIMER_1                0x08
#define _TIMER_2                0x10
#define _TIMER_3                0x18
#define _FLEX_PWM_A_OUTPUT      0x20
#define _FLEX_PWM_B_OUTPUT      0x40
#define _FLEX_PWM_X_OUTPUT      0x80

#define _FLEX_PWM_1             _TIMER_0                                 // alternative names for compatibility
#if FLEXPWM_AVAILABLE > 1
    #define _FLEX_PWM_2         _TIMER_1
#endif
#if FLEXPWM_AVAILABLE > 1
    #define _FLEX_PWM_3         _TIMER_2
#endif
#if FLEXPWM_AVAILABLE > 1
    #define _FLEX_PWM_4         _TIMER_3
#endif

#define _FLEX_PWM_A_0           (0 | _FLEX_PWM_A_OUTPUT)
#define _FLEX_PWM_A_1           (1 | _FLEX_PWM_A_OUTPUT)
#define _FLEX_PWM_A_2           (2 | _FLEX_PWM_A_OUTPUT)
#define _FLEX_PWM_A_3           (3 | _FLEX_PWM_A_OUTPUT)
#define _FLEX_PWM_B_0           (0 | _FLEX_PWM_B_OUTPUT)
#define _FLEX_PWM_B_1           (1 | _FLEX_PWM_B_OUTPUT)
#define _FLEX_PWM_B_2           (2 | _FLEX_PWM_B_OUTPUT)
#define _FLEX_PWM_B_3           (3 | _FLEX_PWM_B_OUTPUT)
#define _FLEX_PWM_X_0           (0 | _FLEX_PWM_X_OUTPUT)
#define _FLEX_PWM_X_1           (1 | _FLEX_PWM_X_OUTPUT)
#define _FLEX_PWM_X_2           (2 | _FLEX_PWM_X_OUTPUT)
#define _FLEX_PWM_X_3           (3 | _FLEX_PWM_X_OUTPUT)

#define _TIMER_MODULE_MASK      0x18
#define _TIMER_MODULE_SHIFT     3


#define PWM_PRESCALER_128           FLEXPWM_SMCTRL_PRSC_128              // 0x00000070
#define PWM_PRESCALER_64            FLEXPWM_SMCTRL_PRSC_64
#define PWM_PRESCALER_32            FLEXPWM_SMCTRL_PRSC_32
#define PWM_PRESCALER_16            FLEXPWM_SMCTRL_PRSC_16
#define PWM_PRESCALER_8             FLEXPWM_SMCTRL_PRSC_8
#define PWM_PRESCALER_4             FLEXPWM_SMCTRL_PRSC_4
#define PWM_PRESCALER_2             FLEXPWM_SMCTRL_PRSC_2
#define PWM_PRESCALER_1             FLEXPWM_SMCTRL_PRSC_1
#define PWM_EDGE_ALIGNED            0x00000000
#define PWM_CENTER_ALIGNED          0x00000001
#define PWM_EXTERNAL_CLK            0x00000006
#define PWM_FIXED_CLK               0x00000002
#define PWM_SYS_CLK                 0x00000004
#define PWM_POLARITY                0x00000008
#define PWM_DMA_PERIOD_ENABLE       0x00000080
#define PWM_FULL_BUFFER_DMA         0x00000100
#define PWM_HALF_BUFFER_DMA         0x00000200
#define PWM_FULL_BUFFER_DMA_AUTO_REPEAT 0x00000400
#define PWM_NO_OUTPUT               0x00001000                           // run PWM without connecting it to a physical output (for internal timing, for example triggering ADCs)
#define PWM_DMA_CHANNEL_ENABLE      0x00002000                           // enable the channel to trigger DMA
#define PWM_DMA_CONTROL_PWM         0x00000000
#define PWM_DMA_CONTROL_FREQUENCY   0x00004000
#define PWM_TRIGGER_CLOCK_INVERT    0x00008000
#define PWM_DMA_SPECIFY_DESTINATION 0x00010000                           // ptrRegister is to be used (not used with PWM_DMA_CONTROL_FREQUENCY or PWM_DMA_CONTROL_PWM modes)
#define PWM_DMA_SPECIFY_BYTE        0x00020000                           // used with PWM_DMA_SPECIFY_DESTINATION to specify the unit size
#define PWM_DMA_SPECIFY_SHORT_WORD  0x00000000
#define PWM_DMA_SPECIFY_LONG_WORD   0x00040000
#define PWM_CHANNEL_INTERRUPT       0x00080000                           // chanel match interrupt (instead of, or in addition to period interrupt) - cannot be used together with DMA
#define PWM_COMBINED_PHASE_SHIFT    0x00100000

#define PWM_OPTION_MODULATE_LPUART0 0x00200000                           // output the PWM signal on LPUART0 Tx - possible only on TPM1-CH0 or TPM2-CH1
#define PWM_OPTION_MODULATE_LPUART1 0x00400000                           // output the PWM signal on LPUART1 Tx - possible only on TPM1-CH0 or TPM2-CH1


#define PWM_MODE_SETTINGS_MASK     (PWM_PRESCALER_128)



#if defined FTM_FLEXIBLE_CLOCKING
    #define PWM_FIXED_CLOCK_FREQUENCY(frequency, prescaler) (MCGFFCLK/prescaler/frequency)
    #if (((MCGFFCLK/1000000) * 1000000) != MCGFFCLK)                     // if the clock is not an exact MHz value
        #define PWM_TIMER_FIXED_CLOCK_US_DELAY(usec, prescaler) ((unsigned long)(((double)MCGFFCLK/(double)1000000) * usec)/prescaler)
    #else
        #define PWM_TIMER_FIXED_CLOCK_US_DELAY(usec, prescaler) (((MCGFFCLK/1000000) * usec)/prescaler)
    #endif
    #define PWM_TIMER_FIXED_CLOCK_MS_DELAY(msec, prescaler)  (((MCGFFCLK/1000) * msec)/prescaler)
#elif defined PWM_FIXED_CLOCK
    #define PWM_FIXED_CLOCK_FREQUENCY(frequency, prescaler) (PWM_FIXED_CLOCK/prescaler/frequency)
    #if (((PWM_FIXED_CLOCK/1000000) * 1000000) != PWM_FIXED_CLOCK)       // if the clock is not an exact MHz value
        #define PWM_TIMER_FIXED_CLOCK_US_DELAY(usec, prescaler) ((unsigned long)(((double)PWM_FIXED_CLOCK/(double)1000000) * usec)/prescaler)
    #else
        #define PWM_TIMER_FIXED_CLOCK_US_DELAY(usec, prescaler) (((PWM_FIXED_CLOCK/1000000) * usec)/prescaler)
    #endif
    #define PWM_TIMER_FIXED_CLOCK_MS_DELAY(msec, prescaler)  (((PWM_FIXED_CLOCK/1000) * msec)/prescaler)
#endif

#define PWM_FREQUENCY(frequency, prescaler)             (PWM_CLOCK/prescaler/frequency)


#if (((PWM_CLOCK/1000000) * 1000000) != PWM_CLOCK)                       // if the clock is not an exact MHz value
    #define PWM_TIMER_US_DELAY(usec, prescaler)         ((unsigned long)(((double)PWM_CLOCK/(double)1000000) * usec)/prescaler)
#else
    #define PWM_TIMER_US_DELAY(usec, prescaler)         (((PWM_CLOCK/1000000) * usec)/prescaler)
#endif

#define PWM_TIMER_MS_DELAY(msec, prescaler)              (((PWM_CLOCK/1000) * msec)/prescaler)

#define _PWM_PERCENT(percent_pwm, frequency_value)       (unsigned short)((frequency_value * percent_pwm)/100)
#define _PWM_TENTH_PERCENT(percent_pwm, frequency_value) (unsigned short)((frequency_value * percent_pwm)/1000)



// Define interrupt setup structures to suit this processor
//
typedef struct stINTERRUPT_SETUP
{
#if defined PORT_INTERRUPT_USER_DISPATCHER
    void (*int_handler)(int);                                            // interrupt handler to be configured
#else
    void (*int_handler)(void);                                           // interrupt handler to be configured
#endif
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    int_port_bits;                                      // the input bits to be configured to generate this interrupt
    unsigned short   int_port_sense;                                     // PULLUP_ON, PULLDOWN_ON, PULLUP_DOWN_OFF, IRQ_RISING_EDGE etc.
    unsigned char    int_port;                                           // the port (PORT1..PORT5)
#if defined SUPPORT_XBAR
    unsigned char    xbar_output;                                        // when DMA triggering is used this entry specifies the XBAR output that is used as DMA trigger outut (usually restricted from 0..3)
#endif
} INTERRUPT_SETUP;


typedef struct stI2S_SAI_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    ulI2S_SAI_buffer_length;
    unsigned short   usDmaTriggerSource;                                 // 8 bits used for register configuration and higher bits for additional information
    unsigned char    I2S_SAI_mode;
    unsigned char    ucDmaChannel;
    unsigned char    ucSynchBits;
    void            *ptrI2S_SAI_Buffer;
} I2S_SAI_SETUP;

#define I2S_SAI_CONFIG_TX                   0x01
#define I2S_SAI_CONFIG_RX                   0x02
#define I2S_SAI_FULL_BUFFER_DMA             0x04
#define I2S_SAI_HALF_BUFFER_DMA             0x08
#define I2S_SAI_BUFFER_DMA_START            0x10
#define I2S_SAI_FULL_BUFFER_DMA_AUTO_REPEAT 0x20
#define I2S_SAI_ENABLE_TX                   0x40
#define I2S_SAI_ENABLE_RX                   0x80


typedef struct stPIT_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    count_delay;                                        // the delay value
    #if !defined DEVICE_WITHOUT_DMA
    unsigned long    ulPortBits;                                         // optional port bits toggled by PIT DMA trigger
    #endif
    unsigned short   mode;                                               // periodic or single shot
    unsigned char    ucPIT;                                              // PIT reference
    #if !defined DEVICE_WITHOUT_DMA
    unsigned char    ucPortRef;                                          // optional port toggled by PIT DMA trigger
    #endif
} PIT_SETUP;

#define PIT_SINGLE_SHOT     0x0001                                        // configure for single interrupt
#define PIT_PERIODIC        0x0002                                        // configure for periodic interrupt
#define PIT_RETRIGGER       0x0004                                        // force PIT load when periodic
#define PIT_TRIGGER_ADC0_A  0x0008
#define PIT_TRIGGER_ADC0_B  0x0010
#define PIT_TRIGGER_ADC1_A  0x0020
#define PIT_TRIGGER_ADC1_B  0x0040
#define PIT_TRIGGER_ADC2_A  0x0080
#define PIT_TRIGGER_ADC2_B  0x0100
#define PIT_TRIGGER_ADC3_A  0x0200
#define PIT_TRIGGER_ADC3_B  0x0400
#define PIT_TRIGGER_OUT     0x0800                                        // conect the PIT_TRIGGER to output (not available on all PITs)
#define PIT_CHAINED_MODE    0x2000
#define PIT_OUTPUT_DMA_TRIG 0x4000
#define PIT_STOP            0x8000                                        // stop operation

#define PIT_US_DELAY(us_delay)  ((((us_delay) * (PIT_CLOCK/1000))/1000) - 1) // macros for setting PIT interrupt times
#define PIT_MS_DELAY(ms_delay)  (((ms_delay) * (PIT_CLOCK/1000)) - 1) 
#define PIT_S_DELAY(s_delay)    (((s_delay) * (PIT_CLOCK)) - 1)
#define PIT_CHAINED_COUNT(count) (count - 1)

#define PIT_FREERUN_FREQ(Hz)    ((PIT_CLOCK/(Hz)) - 1)

typedef struct stTIMER_INTERRUPT_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set

    unsigned long    timer_value;                                        // the delay value
    unsigned long    timer_mode;                                         // timer mode
    unsigned char    timer_reference;                                    // hardware timer to use (0, 1, 2, 3)
    unsigned char    prescaler;
    unsigned char    capture_channel;
} TIMER_INTERRUPT_SETUP;


#define PORT_MODULE          0xff                                        // used for module referencing rather than ports

#define PULLUP_DOWN_OFF      0x0001
#define PULLUP_ON            0x0002 
#define PULLDOWN_ON          0x0004
#define IRQ_RISING_EDGE      0x0008
#define IRQ_FALLING_EDGE     0x0010
#define IRQ_BOTH_EDGES       (IRQ_RISING_EDGE | IRQ_FALLING_EDGE)
#define IRQ_DISABLE_INT      0x0020
#define IRQ_LOW_LEVEL        0x0040
#define IRQ_HIGH_LEVEL       0x0080
#define ENABLE_PORT_MODE     0x0100                                      // pull-ups are not valid if the port is disabled so allow the pin's GPIO mode to be set if desired
#define PORT_DMA_MODE        0x0200                                      // use port DMA mode rather than interrupt mode
#define PORT_KEEP_PERIPHERAL 0x0400                                      // keep the configured peripheral function and don't change to an input
#define HYSTERESIS_ON        0x0800

#define MODULE_LPTMR0        0x01
#define MODULE_COMP0         0x02
#define MODULE_TSI0          0x10
#define MODULE_RTC_ALARM     0x20
#define MODULE_RTC_SECONDS   0x80

#define WAKEUP_MODULES       (MODULE_LPTMR0 | MODULE_COMP0 | MODULE_TSI0 | MODULE_RTC_ALARM | MODULE_RTC_SECONDS)


typedef struct stRTC_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
#if defined SUPPORT_RTC_us
    unsigned long    ul_us;
#endif
#if defined SUPPORT_RTC_ms
    unsigned short   us_ms;
#endif
    unsigned short   usYear;
    unsigned char    ucMonthOfYear;
    unsigned char    ucDayOfMonth;
    unsigned char    ucDayOfWeek;
    unsigned char    ucHours;
    unsigned char    ucMinutes;
    unsigned char    ucSeconds;
    unsigned char    command;                                            // identifier for command to perform
    unsigned long    ulLocalUTC;                                         // optional UTC field
} RTC_SETUP;


#define RTC_TIME_SETTING     0x01
#define RTC_TICK_SEC         0x02
#define RTC_TICK_MIN         0x03
#define RTC_TICK_HOUR        0x04
#define RTC_TICK_DAY         0x05
#define RTC_ALARM_TIME       0x06
#define RTC_STOPWATCH_GO     0x07
#define RTC_GET_TIME         0x08
#define RTC_CONVERT_TO_UTC   0x09
#define RTC_CONVERT_FROM_UTC 0x0a
#define RTC_GET_ALARM        0x0b
#define RTC_INCREMENT        0x10                                        // used by software RTC
#define RTC_SET_UTC          0x20                                        // use UTC rather than time and date when setting
#define RTC_INITIALISATION   0x40
#define RTC_RETURNED_TIME    0x80
#define RTC_DISABLE          0x80


typedef struct stADC_INTERRUPT_RESULT
{
    signed short     sADC_value;                                         // present ADC sample value
    unsigned char    ucADC_channel;                                      // ADC channel status
    unsigned char    ucADC_flags;                                        // flags
} ADC_INTERRUPT_RESULT;

#if defined KINETIS_KE
    #define ADC_CHANNELS          16                                     // single ended inputs 
#else
    #define ADC_CHANNELS          24                                     // single ended inputs               
    #define ADC_CHANNELS_DIF      4                                      // differential inputs
#endif

typedef struct stADC_RESULTS
{
    signed short     sADC_value[1];                                      // present ADC sample values
    unsigned char    ucADC_status[1];                                    // present ADC channel status
} ADC_RESULTS;

// Define interrupt setup structure to suit this processor
//
typedef struct stADC_SETUP
{
    void (*int_handler)(ADC_INTERRUPT_RESULT *);                         // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set
    unsigned char    int_adc_bit;                                        // the ADC input number (0..31)
    unsigned char    int_adc_int_type;                                   // interrupt type (ADC_END_OF_SCAN_INT, ADC_ZERO_CROSSING_INT, ADC_LOW_LIMIT_INT, ADC_HIGH_LIMIT_INT)
    unsigned long    int_adc_mode;                                       // parallel, sequencial, single-ended, differential, start/stop, etc.
    unsigned short   int_adc_offset;                                     // offset for input
    unsigned short   int_high_level_trigger;                             // trigger when higher than this level
    unsigned short   int_low_level_trigger;                              // trigger when lower than this level
    #if !defined KINETIS_KE || defined KINETIS_KE15 || defined KINETIS_KE18
        #if defined KINETIS_KE15
            unsigned short int_adc_sample;                               // sampling details (sample time from 2 to 256 clocks)
        #else
            unsigned char int_adc_sample;                                // sampling details
        #endif
        unsigned char    pga_gain;                                       // PGA gain setting
        unsigned char    int_adc_bit_b;                                  // the ADC channel B input number (used only in hardware mode with double trigger)
    #endif
    unsigned char    int_adc_controller;                                 // the ADC controller to be used
    ADC_RESULTS     *int_adc_result;                                     // results structure to be filled
    #if !defined DEVICE_WITHOUT_DMA
        void (*dma_int_handler)(void);                                   // interrupt handler to be configured for buffer operation
        unsigned long    ulADC_buffer_length;                            // buffer length
        signed short    *ptrADC_Buffer;                                  // if DMA is specified this is a pointer to the buffer in which the samples will be saved to
        unsigned char    ucDmaChannel;                                   // DMA channel to be used
        unsigned short   usDmaTriggerSource;                             // DMA trigger souce (0 defaults to the channel's ADC conversion completion) - 8 bits used for register configuration and higher bits for additional information
        unsigned char    dma_int_priority;                               // priority the user wants to set for DMA completion interrupt
    #endif
} ADC_SETUP;

#define ADC_FULL_SCALE                  (0xffff)
#define ADC_VOLT                        (unsigned short)((ADC_FULL_SCALE * 1000) / ADC_REFERENCE_VOLTAGE)

#define ADC_ENABLE_INTS                 0x00
#define ADC_END_OF_SCAN_INT             0x01
#define ADC_ZERO_CROSSING_INT_POSITIVE  0x02
#define ADC_ZERO_CROSSING_INT_NEGATIVE  0x04
#define ADC_LOW_LIMIT_INT               0x08
#define ADC_SINGLE_SHOT_CROSSING_INT    0x10
#define ADC_HIGH_LIMIT_INT              0x20
#define ADC_SINGLE_SHOT_TRIGGER_INT     0x40
#define ADC_DISABLE_INTS                0x80

#define ADC_SAMPLE_LONG_PLUS_20         0x00                             // ADC_CFG2_ADLSTS_20
#define ADC_SAMPLE_LONG_PLUS_12         0x01                             // ADC_CFG2_ADLSTS_12
#define ADC_SAMPLE_LONG_PLUS_6          0x02                             // ADC_CFG2_ADLSTS_6
#define ADC_SAMPLE_LONG_PLUS_2          0x03                             // ADC_CFG2_ADLSTS_2
#define ADC_SAMPLE_HIGH_SPEED_CONFIG    0x04                             // ADC_CFG2_ADHSC
#define ADC_SAMPLE_AVERAGING_OFF        0x00
#define ADC_SAMPLE_AVERAGING_4          0x40                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_4) << 4)
#define ADC_SAMPLE_AVERAGING_8          0x50                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_8) << 4)
#define ADC_SAMPLE_AVERAGING_16         0x60                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_16) << 4)
#define ADC_SAMPLE_AVERAGING_32         0x70                             // ((ADC_SC3_AVGE | ADC_SC3_AVGS_32) << 4)


#define ADC_CLOCK_BUS                   0x00000000                       // ADC_CFG1_ADICLK_BUS
#define ADC_CLOCK_BUS_DIV_2             0x00000001                       // ADC_CFG1_ADICLK_BUS2
#define ADC_CLOCK_ALTERNATE_SOURCE      0x00000002                       // ADC_CFG1_ADICLK_ALT
#define ADC_CLOCK_ASYNCHRONOUS          0x00000003                       // ADC_CFG1_ADICLK_ASY
#define ADC_8_BIT_MODE                  0x00000000                       // ADC_CFG1_MODE_8
#define ADC_12_BIT_MODE                 0x00000004                       // ADC_CFG1_MODE_12
#define ADC_10_BIT_MODE                 0x00000008                       // ADC_CFG1_MODE_10
#define ADC_16_BIT_MODE                 0x0000000c                       // ADC_CFG1_MODE_16
#define ADC_WORD_LENGTH_MASK            0x0000000c
#define ADC_SAMPLE_ACTIVATE_LONG        0x00000010                       // ADC_CFG1_ADLSMP_LONG
#define ADC_CLOCK_DIVIDE_1              0x00000000                       // ADC_CFG1_ADIV_1
#define ADC_CLOCK_DIVIDE_2              0x00000020                       // ADC_CFG1_ADIV_2
#define ADC_CLOCK_DIVIDE_4              0x00000040                       // ADC_CFG1_ADIV_4
#define ADC_CLOCK_DIVIDE_8              0x00000060                       // ADC_CFG1_ADIV_8
#define ADC_LOW_POWER_CONFIG            0x00000080                       // ADC_CFG1_ADLPC
#define ADC_REFERENCE_VREF              0x00000000
#define ADC_REFERENCE_VALT              0x00000100                       // (ADC_SC2_REFSEL_ALT << 8)
#define ADC_SW_TRIGGERED                0x00000000
#define ADC_HW_TRIGGERED                0x00004000                       // (ADC_SC2_ADTRG_HW << 8)
#define ADC_FULL_BUFFER_DMA_AUTO_REPEAT 0x00010000
#define ADC_CHECK_CONVERSION            0x00080000
#define ADC_CALIBRATE                   0x00100000
#define ADC_READ_ONLY                   0x00200000
#define ADC_CONFIGURE_CHANNEL           0x00400000
#define ADC_CONFIGURE_ADC               0x00800000
#define ADC_GET_RESULT                  0x01000000
#define ADC_DISABLE_ADC                 0x02000000
#define ADC_SINGLE_ENDED_INPUT          0x00000000
#define ADC_SINGLE_ENDED                (ADC_SINGLE_ENDED_INPUT)         // for compatibility
#define ADC_DIFFERENTIAL_INPUT          0x04000000
#define ADC_SINGLE_SHOT_MODE            0x00000000
#define ADC_LOOP_MODE                   0x08000000
#define ADC_SELECT_INPUTS_A             0x00000000
#define ADC_SELECT_INPUTS_B             0x10000000
#define ADC_FULL_BUFFER_DMA             0x20000000
#define ADC_HALF_BUFFER_DMA             0x40000000
#define ADC_DIFFERENTIAL_B              0x80000000

#define PGA_GAIN_OFF                    0
#define PGA_GAIN_1                      ((ADC_PGA_PGAG_1  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_2                      ((ADC_PGA_PGAG_2  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_4                      ((ADC_PGA_PGAG_4  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_8                      ((ADC_PGA_PGAG_8  | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_16                     ((ADC_PGA_PGAG_16 | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_32                     ((ADC_PGA_PGAG_32 | ADC_PGA_PGAEN) >> 16)
#define PGA_GAIN_64                     ((ADC_PGA_PGAG_64 | ADC_PGA_PGAEN) >> 16)
#define PGA_RUNS_IN_LP_MODE             (ADC_PGA_PGALPb >> 16)
 

#define ADC_RESULT_NOT_READY            0x00
#define ADC_RESULT_VALID                0x01
#define ADC_INT_ZERO_CROSSING           0x02
#define ADC_INT_HIGH_LEVEL              0x04
#define ADC_INT_LOW_LEVEL               0x08

#define ADC_SAMPLING_SPEED(sample_rate) (((BUS_CLOCK/2)/sample_rate/2) - 1)

typedef struct stDAC_SETUP
{
    void (*int_handler)(void);                                           // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set
    unsigned long    dac_mode;                                           // the mode of operation
    unsigned short  *ptrDAC_Buffer;                                      // if DMA is specified this is a pointer to the buffer which supplies DAC output values
    unsigned long    ulDAC_buffer_length;                                // buffer length
    unsigned short   usOutputValue;                                      // value to be output on the DAC output
    unsigned char    int_dac_controller;                                 // the controller to be used
    unsigned char    ucDmaChannel;                                       // DMA channel to be used
    unsigned short   usDmaTriggerSource;                                 // DMA trigger source to be used - 8 bits used for register configuration and higher bits for additional information
} DAC_SETUP;

// dac_mode
//
#define DAC_CONFIGURE                   0x00000001
#define DAC_REF_VREF                    0x00000000
#define DAC_REF_VDDA                    0x00000002                       // K parts
#define DAC_REF_VREF2                   0x00000002                       // KL parts
#define DAC_NON_BUFFERED_MODE           0x00000000                       // write to data[0] trigger conversion
#define DAC_BUFFERED_MODE               0x00000004
#define DAC_OUTPUT_VALUE                0x00000008
#define DAC_ENABLE                      0x00000040
#define DAC_DISABLE                     0x00000080
#define DAC_HALF_BUFFER_DMA             0x00000100
#define DAC_FULL_BUFFER_DMA             0x00000200
#define DAC_FULL_BUFFER_DMA_AUTO_REPEAT 0x00000400                       // automatically repeat transfers (not one-shot buffer - used by KL parts)
#define DAC_DMA_LINKING                 0x00000800                       // use two linked DMA channels to ensure no sample loss at high speeds (used by KL parts)
#define DAC_HW_TRIGGER_MODE             0x00001000
#define DAC_BUFFER_DMA_START            0x00002000


typedef struct stCOMPARATOR_SETUP
{
    void (*int_handler)(int iCMP_reference, int iEvent);                 // interrupt handler to be configured
    unsigned char    int_type;                                           // identifier for when configuring
    unsigned char    int_priority;                                       // priority the user wants to set
    unsigned long    comparator_mode;                                    // the mode of operation
    unsigned char    comparator;                                         // comparator to be used
    unsigned char    positive_input;                                     // positive input connection
    unsigned char    negative_input;                                     // negative input connection
    unsigned char    hysterisis_level;                                   // levels 0 to 3
    unsigned char    filter;                                             // filter sample count (1..7) in external sampling mode or 0..255 in bus clock mode
    unsigned char    DAC_level;                                          // 0..63
} COMPARATOR_SETUP;

// Comparator modes
//
#define COMPARATOR_DISABLED                       0x00000000             // not powered and consuming no current
#define COMPARATOR_BUS_CLOCK                      (CMP_CR0_FILTER_1_SAMPLE) // powered and active - continuous operation with neither windows nor filter control
#define COMPARATOR_SAMPLE_FILTER_OFF              COMPARATOR_BUS_CLOCK
#define COMPARATOR_SAMPLE_FILTER_2                (CMP_CR0_FILTER_2_SAMPLE | (CMP_CR1_SE << 8))
#define COMPARATOR_SAMPLE_FILTER_3                (CMP_CR0_FILTER_3_SAMPLE | (CMP_CR1_SE << 8))
#define COMPARATOR_SAMPLE_FILTER_4                (CMP_CR0_FILTER_4_SAMPLE | (CMP_CR1_SE << 8))
#define COMPARATOR_SAMPLE_FILTER_5                (CMP_CR0_FILTER_5_SAMPLE | (CMP_CR1_SE << 8))
#define COMPARATOR_SAMPLE_FILTER_6                (CMP_CR0_FILTER_6_SAMPLE | (CMP_CR1_SE << 8))
#define COMPARATOR_SAMPLE_FILTER_7                (CMP_CR0_FILTER_7_SAMPLE | (CMP_CR1_SE << 8))
#define COMPARATOR_HYSTERISIS_LEVEL_0             (CMP_CR0_HYSTCTR_LEVEL_0)
#define COMPARATOR_HYSTERISIS_LEVEL_1             (CMP_CR0_HYSTCTR_LEVEL_1)
#define COMPARATOR_HYSTERISIS_LEVEL_2             (CMP_CR0_HYSTCTR_LEVEL_2)
#define COMPARATOR_HYSTERISIS_LEVEL_3             (CMP_CR0_HYSTCTR_LEVEL_3)           
#define COMPARATOR_WINDOWED_MODE                  (CMP_CR1_WE << 8)      // powered and active - continuous operation with window but no filter control
#define COMPARATOR_HIGH_SPEED_MODE                (CMP_CR1_PMODE_HS << 8)
#define COMPARATOR_LOW_SPEED_MODE                 0x00000000
#define COMPARATOR_OUTPUT_ENABLE                  (CMP_CR1_OPE << 8)
#define COMPARATOR_OUTPUT_INVERT                  (CMP_CR1_INV << 8)
#define COMPARATOR_OUTPUT_FILTERED                0x00000000
#define COMPARATOR_OUTPUT_UNFILTERED              (CMP_CR1_COS_UNFILTERED << 8)
#define COMPARATOR_ENABLE                         (CMP_CR1_EN << 8)
#define COMPARATOR_INTERRUPT_RISING               (CMP_SCR_IER << 16)
#define COMPARATOR_INTERRUPT_FALLING              (CMP_SCR_IEF << 16)
#define COMPARATOR_INTERRUPT_RISING_AND_FALLING   (COMPARATOR_INTERRUPT_RISING | COMPARATOR_INTERRUPT_FALLING)
#define COMPARATOR_DMA_FALLING                    ((CMP_SCR_DMA << 16) | COMPARATOR_INTERRUPT_FALLING)
#define COMPARATOR_DMA_RISING                     ((CMP_SCR_DMA << 16) | COMPARATOR_INTERRUPT_RISING)
#define COMPARATOR_DMA_RISING_AND_FALLING         ((CMP_SCR_DMA << 16) | COMPARATOR_INTERRUPT_RISING_AND_FALLING)
#define COMPARATOR_DAC_ENABLE                     (CMP_DACCR_DACEN << 24)
#define COMPARATOR_DAC_VOLTAGE_VREF_OUT           (CMP_DACCR_VRSEL_VREF_OUT << 24)
#define COMPARATOR_DAC_VOLTAGE_VDD                (CMP_DACCR_VRSEL_VDD << 24)

#define COMPARATOR_IN0                            (CMP_MUXCR_MSEL_IN0)
#define COMPARATOR_IN1                            (CMP_MUXCR_MSEL_IN1)
#define COMPARATOR_IN2                            (CMP_MUXCR_MSEL_IN2)
#define COMPARATOR_IN3                            (CMP_MUXCR_MSEL_IN3)
#define COMPARATOR_IN4                            (CMP_MUXCR_MSEL_IN4)
#define COMPARATOR_IN5                            (CMP_MUXCR_MSEL_IN5)
#define COMPARATOR_IN6                            (CMP_MUXCR_MSEL_IN6)
#define COMPARATOR_IN7                            (CMP_MUXCR_MSEL_IN7)
#define COMPARATOR_IN_DAC_OUT                     (COMPARATOR_IN7)

#define COMPARATOR_INTERRUPT_EVENT_FALLING        0x00                   // interrupt due to falling threshold detection
#define COMPARATOR_INTERRUPT_EVENT_RISING         0x01                   // interrupt due to rising threshold detection
#define COMPARATOR_INTERRUPT_EVENT_RISING_AND_FALLING 0x02               // interrupt due to falling and falling thresholds detection - both rising and fallin have been seen since last interrupt



// i.MX DCDC
//
#define DCDC_REG0            *(volatile unsigned long *)(DCDC_BLOCK + 0x0) // DCDC register 0
    #define DCDC_REG0_SEL_CLK                     0x00000004             // select 24 MHz crystal clock for DCDC when dcdc_disable_auto_clk_switch is set
    #define DCDC_REG0_PWD_OSC_INT                 0x00000008             // power down internal DCDC oscillator (only set when 24MHz crystal is available)
    #define DCDC_REG0_STS_DC_OK                   0x80000000             // DCDC as settled (read-only)
#define DCDC_REG1            *(unsigned long *)(DCDC_BLOCK + 0x4)        // DCDC register 1
#define DCDC_REG2            *(unsigned long *)(DCDC_BLOCK + 0x8)        // DCDC register 2
#define DCDC_REG3            *(unsigned long *)(DCDC_BLOCK + 0xc)        // DCDC register 3
    #define DCDC_REG3_TRG_MASK                    0x0000001f             // target value of VDD_SOC mask
    #define DCDC_REG3_TRG_0_800V                  0x00000000
    #define DCDC_REG3_TRG_0_825V                  0x00000001
    #define DCDC_REG3_TRG_0_850V                  0x00000002
    #define DCDC_REG3_TRG_0_875V                  0x00000003
    #define DCDC_REG3_TRG_0_900V                  0x00000004
    #define DCDC_REG3_TRG_0_925V                  0x00000005
    #define DCDC_REG3_TRG_0_950V                  0x00000006
    #define DCDC_REG3_TRG_0_975V                  0x00000007
    #define DCDC_REG3_TRG_1_000V                  0x00000008
    #define DCDC_REG3_TRG_1_025V                  0x00000009
    #define DCDC_REG3_TRG_1_050V                  0x0000000a
    #define DCDC_REG3_TRG_1_075V                  0x0000000b
    #define DCDC_REG3_TRG_1_100V                  0x0000000c
    #define DCDC_REG3_TRG_1_125V                  0x0000000d
    #define DCDC_REG3_TRG_1_150V                  0x0000000e             // default
    #define DCDC_REG3_TRG_1_175V                  0x0000000f
    #define DCDC_REG3_TRG_1_200V                  0x00000010
    #define DCDC_REG3_TRG_1_225V                  0x00000011
    #define DCDC_REG3_TRG_1_250V                  0x00000012
    #define DCDC_REG3_TRG_1_275V                  0x00000013
    #define DCDC_REG3_TRG_1_300V                  0x00000014
    #define DCDC_REG3_TRG_1_325V                  0x00000015
    #define DCDC_REG3_TRG_1_350V                  0x00000016
    #define DCDC_REG3_TRG_1_375V                  0x00000017
    #define DCDC_REG3_TRG_1_400V                  0x00000018
    #define DCDC_REG3_TRG_1_425V                  0x00000019
    #define DCDC_REG3_TRG_1_450V                  0x0000001a
    #define DCDC_REG3_TRG_1_475V                  0x0000001b
    #define DCDC_REG3_TRG_1_500V                  0x0000001c
    #define DCDC_REG3_TRG_1_525V                  0x0000001d
    #define DCDC_REG3_TRG_1_550V                  0x0000001e
    #define DCDC_REG3_TRG_1_575V                  0x0000001f


#if defined iMX_RT1011
    // OTFAD
    //
    #define OTFAD_CR_ADD        (unsigned long *)(OTFAD_BLOCK + 0x000)
    #define OTFAD_CR            *(unsigned long *)(OTFAD_BLOCK + 0x000)  // OTFAD control register
        #define OTFAD_CR_IRQE   0x00000001                               // interrupt enable
        #define OTFAD_CR_FERR   0x00000002                               // force error
        #define OTFAD_CR_FSVM   0x00000004                               // force security violation mode
        #define OTFAD_CR_FLDM   0x00000008                               // force logically disabled mode
        #define OTFAD_CR_KBSE   0x00000010                               // key blob scramble enable
        #define OTFAD_CR_KBPE   0x00000020                               // key blob processing enable
        #define OTFAD_CR_KBCE   0x00000040                               // key blob CRC enable
        #define OTFAD_CR_RRAE   0x00000080                               // restricted register access enable (register access is restricted and only the CR, SR and optional MDPC registers can be accessed)
        #define OTFAD_CR_SKBP   0x40000000                               // start key blob processing
        #define OTFAD_CR_GE     0x80000000                               // global OTFAD enable
    #define OTFAD_SR            *(volatile unsigned long *)(OTFAD_BLOCK + 0x004) // OTFAD status register
        #define OTFAD_SR_KBERR  0x00000001                               // key blob error detected
        #define OTFAD_SR_MDPCP  0x00000002                               // MDPC present
        #define OTFAD_SR_MODE_NORMAL             0x00000000              // NRM
        #define OTFAD_SR_MODE_SECURITY_VIOLATION 0x00000008              // SVM
        #define OTFAD_SR_MODE_LOGICALLY_DISABLED 0x0000000c              // LDM
        #define OTFAD_SR_MODE_MASK               0x0000000c
        #define OTFAD_SR_NCTX_MASK               0x000000f0              // number of contexts mask
        #define OTFAD_SR_CTXER0 0x00000100                               // context 0 error
        #define OTFAD_SR_CTXER1 0x00000200                               // context 1 error
        #define OTFAD_SR_CTXER2 0x00000400                               // context 2 error
        #define OTFAD_SR_CTXER3 0x00000800                               // context 3 error
        #define OTFAD_SR_CTXIE0 0x00010000                               // integrity 0 error
        #define OTFAD_SR_CTXIE1 0x00020000                               // integrity 1 error
        #define OTFAD_SR_CTXIE2 0x00040000                               // integrity 2 error
        #define OTFAD_SR_CTXIE3 0x00080000                               // integrity 3 error
        #define OTFAD_SR_HRL_MASK               0x0f000000               // hardware revision level mask
        #define OTFAD_SR_RRAM   0x10000000                               // restricted register access mode
        #define OTFAD_SR_GEM    0x20000000                               // global enable mode
        #define OTFAD_SR_KBPE   0x40000000                               // key blob processing enabled
        #define OTFAD_SR_KBD    0x80000000                               // key blob processing done
    #define OTFAD_CTX0_KEY0_ADD  (unsigned long *)(OTFAD_BLOCK + 0x100)
    #define OTFAD_CTX0_KEY0     *(unsigned long *)(OTFAD_BLOCK + 0x100)  // OTFAD AES 0 key word 0
    #define OTFAD_CTX0_KEY1     *(unsigned long *)(OTFAD_BLOCK + 0x104)  // OTFAD AES 0 key word 1
    #define OTFAD_CTX0_KEY2     *(unsigned long *)(OTFAD_BLOCK + 0x108)  // OTFAD AES 0 key word 2
    #define OTFAD_CTX0_KEY3     *(unsigned long *)(OTFAD_BLOCK + 0x10c)  // OTFAD AES 0 key word 3
    #define OTFAD_CTX0_CTR0_ADD  (unsigned long *)(OTFAD_BLOCK + 0x110)
    #define OTFAD_CTX0_CTR0     *(unsigned long *)(OTFAD_BLOCK + 0x110)  // OTFAD AES 0 counter word 0
    #define OTFAD_CTX0_CTR1     *(unsigned long *)(OTFAD_BLOCK + 0x114)  // OTFAD AES 0 counter word 1
    #define OTFAD_CTX0_RGD_W0   *(unsigned long *)(OTFAD_BLOCK + 0x118)  // OTFAD AES 0 region description word 0
        #define OTFAD_RGD_W0_SRTADDR_MASK   0xfffffc00                   // start address mask
    #define OTFAD_CTX0_RGD_W1   *(unsigned long *)(OTFAD_BLOCK + 0x11c)  // OTFAD AES 0 region description word 1
        #define OTFAD_RGD_W1_VLD            0x00000001                   // context is invalid.
        #define OTFAD_RGD_W1_ADE            0x00000002                   // perform the CTR-AES128 mode decryption on the fetched data
        #define OTFAD_RGD_W1_RO             0x00000004                   // context registers are read-only and accesses may be further restricted based on SR[RRAM]
        #define OTFAD_RGD_W1_ENDADDR_MASK   0xfffffc00                   // end address

    #define OTFAD_CTX1_KEY0_ADD (unsigned long *)(OTFAD_BLOCK + 0x140)
    #define OTFAD_CTX1_KEY0     *(unsigned long *)(OTFAD_BLOCK + 0x140)  // OTFAD AES 1 key word 0
    #define OTFAD_CTX1_KEY1     *(unsigned long *)(OTFAD_BLOCK + 0x144)  // OTFAD AES 1 key word 1
    #define OTFAD_CTX1_KEY2     *(unsigned long *)(OTFAD_BLOCK + 0x148)  // OTFAD AES 1 key word 2
    #define OTFAD_CTX1_KEY3     *(unsigned long *)(OTFAD_BLOCK + 0x14c)  // OTFAD AES 1 key word 3
    #define OTFAD_CTX1_CTR0_ADD (unsigned long *)(OTFAD_BLOCK + 0x150)
    #define OTFAD_CTX1_CTR0     *(unsigned long *)(OTFAD_BLOCK + 0x150)  // OTFAD AES 1 counter word 0
    #define OTFAD_CTX1_CTR1     *(unsigned long *)(OTFAD_BLOCK + 0x154)  // OTFAD AES 1 counter word 1
    #define OTFAD_CTX1_RGD_W0   *(unsigned long *)(OTFAD_BLOCK + 0x158)  // OTFAD AES 1 region description word 0
    #define OTFAD_CTX1_RGD_W1   *(unsigned long *)(OTFAD_BLOCK + 0x15c)  // OTFAD AES 1 region description word 1

    #define OTFAD_CTX2_KEY0     *(unsigned long *)(OTFAD_BLOCK + 0x180)  // OTFAD AES 2 key word 0
    #define OTFAD_CTX2_KEY1     *(unsigned long *)(OTFAD_BLOCK + 0x184)  // OTFAD AES 2 key word 1
    #define OTFAD_CTX2_KEY2     *(unsigned long *)(OTFAD_BLOCK + 0x188)  // OTFAD AES 2 key word 2
    #define OTFAD_CTX2_KEY3     *(unsigned long *)(OTFAD_BLOCK + 0x18c)  // OTFAD AES 2 key word 3
    #define OTFAD_CTX2_CTR0     *(unsigned long *)(OTFAD_BLOCK + 0x190)  // OTFAD AES 2 counter word 0
    #define OTFAD_CTX2_CTR1     *(unsigned long *)(OTFAD_BLOCK + 0x194)  // OTFAD AES 2 counter word 1
    #define OTFAD_CTX2_RGD_W0   *(unsigned long *)(OTFAD_BLOCK + 0x198)  // OTFAD AES 2 region description word 0
    #define OTFAD_CTX2_RGD_W1   *(unsigned long *)(OTFAD_BLOCK + 0x19c)  // OTFAD AES 2 region description word 1

    #define OTFAD_CTX3_KEY0     *(unsigned long *)(OTFAD_BLOCK + 0x1c0)  // OTFAD AES 3 key word 0
    #define OTFAD_CTX3_KEY1     *(unsigned long *)(OTFAD_BLOCK + 0x1c4)  // OTFAD AES 3 key word 1
    #define OTFAD_CTX3_KEY2     *(unsigned long *)(OTFAD_BLOCK + 0x1c8)  // OTFAD AES 3 key word 2
    #define OTFAD_CTX3_KEY3     *(unsigned long *)(OTFAD_BLOCK + 0x1cc)  // OTFAD AES 3 key word 3
    #define OTFAD_CTX3_CTR0     *(unsigned long *)(OTFAD_BLOCK + 0x1d0)  // OTFAD AES 3 counter word 0
    #define OTFAD_CTX3_CTR1     *(unsigned long *)(OTFAD_BLOCK + 0x1d4)  // OTFAD AES 3 counter word 1
    #define OTFAD_CTX3_RGD_W0   *(unsigned long *)(OTFAD_BLOCK + 0x1d8)  // OTFAD AES 3 region description word 0
    #define OTFAD_CTX3_RGD_W1   *(unsigned long *)(OTFAD_BLOCK + 0x1dc)  // OTFAD AES 3 region description word 1
#else
    #define BEE_CTRL_ADD                (volatile unsigned long *)(BEE_BLOCK + 0x00)
    #define BEE_CTRL                   *(volatile unsigned long *)(BEE_BLOCK + 0x00) // control register
        #define BEE_CTRL_BEE_ENABLE             0x00000001
        #define BEE_CTRL_CTRL_CLK_EN            0x00000002
        #define BEE_CTRL_CTRL_SFTRST_N          0x00000004
        #define BEE_CTRL_KEY_VALID              0x00000010
        #define BEE_CTRL_KEY_REGION_SEL         0x00000020
        #define BEE_CTRL_AC_PROT_EN             0x00000040
        #define BEE_CTRL_LITTLE_ENDIAN          0x00000080
        #define BEE_CTRL_SECURITY_LEVEL_R0      0x00000300
        #define BEE_CTRL_CTRL_AES_MODE_R0       0x00000400
        #define BEE_CTRL_SECURITY_LEVEL_R1      0x00003000
        #define BEE_CTRL_CTRL_AES_MODE_R1       0x00004000
        #define BEE_CTRL_BEE_ENABLE_LOCK        0x00010000
        #define BEE_CTRL_CTRL_CLK_EN_LOCK       0x00020000
        #define BEE_CTRL_CTRL_SFTRST_N_LOCK     0x00040000
        #define BEE_CTRL_REGION1_ADDR_LOCK      0x00080000
        #define BEE_CTRL_KEY_VALID_LOCK         0x00100000
        #define BEE_CTRL_KEY_REGION_SEL_LOCK    0x00200000
        #define BEE_CTRL_AC_PROT_EN_LOCK        0x00400000
        #define BEE_CTRL_LITTLE_ENDIAN_LOCK     0x00800000
        #define BEE_CTRL_SECURITY_LEVEL_R0_LOCK 0x03000000
        #define BEE_CTRL_CTRL_AES_MODE_R0_LOCK  0x04000000
        #define BEE_CTRL_REGION0_KEY_LOCK       0x08000000
        #define BEE_CTRL_SECURITY_LEVEL_R1_LOCK 0x30000000
        #define BEE_CTRL_CTRL_AES_MODE_R1_LOCK  0x40000000
        #define BEE_CTRL_REGION1_KEY_LOCK       0x80000000
    #define BEE_ADDR_OFFSET0           *(unsigned long *)(BEE_BLOCK + 0x04) // offset region 0 register
    #define BEE_ADDR_OFFSET1           *(unsigned long *)(BEE_BLOCK + 0x08) // offset region 1 register
    #define BEE_AES_KEY0_W0_ADD         (unsigned long *)(BEE_BLOCK + 0x0c) // AES key 0 register address
    #define BEE_AES_KEY0_W0            *(volatile unsigned long *)(BEE_BLOCK + 0x0c) // AES key 0 register
    #define BEE_AES_KEY0_W1            *(volatile unsigned long *)(BEE_BLOCK + 0x10) // AES key 1 register
    #define BEE_AES_KEY0_W2            *(volatile unsigned long *)(BEE_BLOCK + 0x14) // AES key 2 register
    #define BEE_AES_KEY0_W3            *(volatile unsigned long *)(BEE_BLOCK + 0x18) // AES key 3 register
    #define BEE_STATUS_ADD              (volatile unsigned long *)(BEE_BLOCK + 0x1c)
    #define BEE_STATUS                 *(volatile unsigned long *)(BEE_BLOCK + 0x1c) // status register
        #define BEE_STATUS_DISABLE_ABORT            0x00000001
        #define BEE_STATUS_REG0_READ_SEC_VIOLATION  0x00000002
        #define BEE_STATUS_READ_ILLEGAL_ACCESS      0x00000004
        #define BEE_STATUS_REG1_READ_SEC_VIOLATION  0x00000008
        #define BEE_STATUS_REG0_ACCESS_VIOLATION    0x00000010
        #define BEE_STATUS_REG1_ACCESS_VIOLATION    0x00000020
        #define BEE_STATUS_IDLE                     0x00000100
    #define BEE_CTR_NONCE0_ADD          (unsigned long *)(BEE_BLOCK + 0x20)
    #define BEE_CTR_NONCE0_W0          *(volatile unsigned long *)(BEE_BLOCK + 0x20) // NONCE00 register
    #define BEE_CTR_NONCE0_W1          *(volatile unsigned long *)(BEE_BLOCK + 0x24) // NONCE01 register
    #define BEE_CTR_NONCE0_W2          *(volatile unsigned long *)(BEE_BLOCK + 0x28) // NONCE02 register
    #define BEE_CTR_NONCE0_W3          *(volatile unsigned long *)(BEE_BLOCK + 0x2c) // NONCE03 register
    #define BEE_CTR_NONCE1_ADD          (unsigned long *)(BEE_BLOCK + 0x30)
    #define BEE_CTR_NONCE1_W0          *(volatile unsigned long *)(BEE_BLOCK + 0x30) // NONCE10 register
    #define BEE_CTR_NONCE1_W1          *(volatile unsigned long *)(BEE_BLOCK + 0x34) // NONCE11 register
    #define BEE_CTR_NONCE1_W2          *(volatile unsigned long *)(BEE_BLOCK + 0x38) // NONCE12 register
    #define BEE_CTR_NONCE1_W3          *(volatile unsigned long *)(BEE_BLOCK + 0x3c) // NONCE13 register
    #define BEE_REGION1_TOP            *(unsigned long *)(BEE_BLOCK + 0x40) // region 1 top address register
    #define BEE_REGION1_BOT            *(unsigned long *)(BEE_BLOCK + 0x44) // region 1 bottom address register
#endif

// XBARA
//
#define XBARA1_SEL0_ADD            (unsigned short *)(XBARA1_BLOCK + 0x00)
#define XBARA1_SEL0                *(unsigned short *)(XBARA1_BLOCK + 0x00) // crossbar A select register 0
    #define XBAR_IN00              0x00
    #define XBAR_IN01              0x01
    #define XBAR_IN02              0x02
    #define XBAR_IN03              0x03
    #define XBAR_IN04              0x04
    #define XBAR_IN05              0x05
    #define XBAR_IN06              0x06
    #define XBAR_IN07              0x07
    #define XBAR_IN08              0x08
    #define XBAR_IN09              0x09
    #define XBAR_IN10              0x0a
    #define XBAR_IN11              0x0b
    #define XBAR_IN12              0x0c
    #define XBAR_IN13              0x0d
    #define XBAR_IN14              0x0e
    #define XBAR_IN15              0x0f
    #define XBAR_IN16              0x10
    #define XBAR_IN17              0x11
    #define XBAR_IN18              0x12
    #define XBAR_IN19              0x13
    #define XBAR_IN20              0x14
    #define XBAR_IN21              0x15
    #define XBAR_IN22              0x16
    #define XBAR_IN23              0x17
    #define XBAR_IN24              0x18
    #define XBAR_IN25              0x19
    #define XBAR_IN26              0x1a
    #define XBAR_IN27              0x1b
    #define XBAR_IN28              0x1c
    #define XBAR_IN29              0x1d
    #define XBAR_IN30              0x1e
    #define XBAR_IN31              0x1f
    #define XBAR_IN32              0x20
    #define XBAR_IN33              0x21
    #define XBAR_IN34              0x22
    #define XBAR_IN35              0x23
    #define XBAR_IN36              0x24
    #define XBAR_IN37              0x25
    #define XBAR_IN38              0x26
    #define XBAR_IN39              0x27
    #define XBAR_IN40              0x28
    #define XBAR_IN41              0x29
    #define XBAR_IN42              0x2a
    #define XBAR_IN43              0x2b
    #define XBAR_IN44              0x2c
    #define XBAR_IN45              0x2d
    #define XBAR_IN46              0x2e
    #define XBAR_IN47              0x2f
    #define XBAR_IN48              0x30
    #define XBAR_IN49              0x31
    #define XBAR_IN50              0x32
    #define XBAR_IN51              0x33
    #define XBAR_IN52              0x34
    #define XBAR_IN53              0x35
    #define XBAR_IN54              0x36
    #define XBAR_IN55              0x37
    #define XBAR_IN56              0x38
    #define XBAR_IN57              0x39
    #define XBAR_IN58              0x3a
    #define XBAR_IN59              0x3b
    #define XBAR_IN60              0x3c
    #define XBAR_IN61              0x3d
    #define XBAR_IN62              0x3e
    #define XBAR_IN63              0x3f
    #define XBAR_IN64              0x40
    #define XBAR_IN65              0x41
    #define XBAR_IN66              0x42
    #define XBAR_IN67              0x43
    #define XBAR_IN68              0x44
    #define XBAR_IN69              0x45
    #define XBAR_IN70              0x46
    #define XBAR_IN71              0x47
    #define XBAR_IN72              0x48
    #define XBAR_IN73              0x49
    #define XBAR_IN74              0x4a
    #define XBAR_IN75              0x4b
    #define XBAR_IN76              0x4c
    #define XBAR_IN77              0x4d
    #define XBAR_IN78              0x4e
    #define XBAR_IN79              0x4f
    #define XBAR_IN80              0x50
    #define XBAR_IN81              0x51
    #define XBAR_IN82              0x52
    #define XBAR_IN83              0x53
    #define XBAR_IN84              0x54
    #define XBAR_IN85              0x55
    #define XBAR_IN86              0x56
    #define XBAR_IN87              0x57

#define XBARA1_SEL1                *(unsigned short *)(XBARA1_BLOCK + 0x02) // crossbar A select register 1
#define XBARA1_SEL2                *(unsigned short *)(XBARA1_BLOCK + 0x04) // crossbar A select register 2
#define XBARA1_SEL3                *(unsigned short *)(XBARA1_BLOCK + 0x06) // crossbar A select register 3
#define XBARA1_SEL4                *(unsigned short *)(XBARA1_BLOCK + 0x08) // crossbar A select register 4
#define XBARA1_SEL5                *(unsigned short *)(XBARA1_BLOCK + 0x0a) // crossbar A select register 5
#define XBARA1_SEL6                *(unsigned short *)(XBARA1_BLOCK + 0x0c) // crossbar A select register 6
#define XBARA1_SEL7                *(unsigned short *)(XBARA1_BLOCK + 0x0e) // crossbar A select register 7
#define XBARA1_SEL8                *(unsigned short *)(XBARA1_BLOCK + 0x10) // crossbar A select register 8
#define XBARA1_SEL9                *(unsigned short *)(XBARA1_BLOCK + 0x12) // crossbar A select register 9
#define XBARA1_SEL10               *(unsigned short *)(XBARA1_BLOCK + 0x14) // crossbar A select register 10
#define XBARA1_SEL11               *(unsigned short *)(XBARA1_BLOCK + 0x16) // crossbar A select register 11
#define XBARA1_SEL12               *(unsigned short *)(XBARA1_BLOCK + 0x18) // crossbar A select register 12
#define XBARA1_SEL13               *(unsigned short *)(XBARA1_BLOCK + 0x1a) // crossbar A select register 13
#define XBARA1_SEL14               *(unsigned short *)(XBARA1_BLOCK + 0x1c) // crossbar A select register 14
#define XBARA1_SEL15               *(unsigned short *)(XBARA1_BLOCK + 0x1e) // crossbar A select register 15
#define XBARA1_SEL16               *(unsigned short *)(XBARA1_BLOCK + 0x20) // crossbar A select register 16
#define XBARA1_SEL17               *(unsigned short *)(XBARA1_BLOCK + 0x22) // crossbar A select register 17
#define XBARA1_SEL18               *(unsigned short *)(XBARA1_BLOCK + 0x24) // crossbar A select register 18
#define XBARA1_SEL19               *(unsigned short *)(XBARA1_BLOCK + 0x26) // crossbar A select register 19
#define XBARA1_SEL20               *(unsigned short *)(XBARA1_BLOCK + 0x28) // crossbar A select register 20
#define XBARA1_SEL21               *(unsigned short *)(XBARA1_BLOCK + 0x2a) // crossbar A select register 21
#define XBARA1_SEL22               *(unsigned short *)(XBARA1_BLOCK + 0x2c) // crossbar A select register 22
#define XBARA1_SEL23               *(unsigned short *)(XBARA1_BLOCK + 0x2e) // crossbar A select register 23
#define XBARA1_SEL24               *(unsigned short *)(XBARA1_BLOCK + 0x30) // crossbar A select register 24
#define XBARA1_SEL25               *(unsigned short *)(XBARA1_BLOCK + 0x32) // crossbar A select register 25
#define XBARA1_SEL26               *(unsigned short *)(XBARA1_BLOCK + 0x34) // crossbar A select register 26
#define XBARA1_SEL27               *(unsigned short *)(XBARA1_BLOCK + 0x36) // crossbar A select register 27
#define XBARA1_SEL28               *(unsigned short *)(XBARA1_BLOCK + 0x38) // crossbar A select register 28
#define XBARA1_SEL29               *(unsigned short *)(XBARA1_BLOCK + 0x3a) // crossbar A select register 29
#define XBARA1_SEL30               *(unsigned short *)(XBARA1_BLOCK + 0x3c) // crossbar A select register 30
#define XBARA1_SEL31               *(unsigned short *)(XBARA1_BLOCK + 0x3e) // crossbar A select register 31
#define XBARA1_SEL32               *(unsigned short *)(XBARA1_BLOCK + 0x40) // crossbar A select register 32
#define XBARA1_SEL33               *(unsigned short *)(XBARA1_BLOCK + 0x42) // crossbar A select register 33
#define XBARA1_SEL34               *(unsigned short *)(XBARA1_BLOCK + 0x44) // crossbar A select register 34
#define XBARA1_SEL35               *(unsigned short *)(XBARA1_BLOCK + 0x46) // crossbar A select register 35
#define XBARA1_SEL36               *(unsigned short *)(XBARA1_BLOCK + 0x48) // crossbar A select register 36
#define XBARA1_SEL37               *(unsigned short *)(XBARA1_BLOCK + 0x4a) // crossbar A select register 37
#define XBARA1_SEL38               *(unsigned short *)(XBARA1_BLOCK + 0x4c) // crossbar A select register 38
#define XBARA1_SEL39               *(unsigned short *)(XBARA1_BLOCK + 0x4e) // crossbar A select register 39
#define XBARA1_SEL40               *(unsigned short *)(XBARA1_BLOCK + 0x50) // crossbar A select register 40
#define XBARA1_SEL41               *(unsigned short *)(XBARA1_BLOCK + 0x52) // crossbar A select register 41
#define XBARA1_SEL42               *(unsigned short *)(XBARA1_BLOCK + 0x54) // crossbar A select register 42
#define XBARA1_SEL43               *(unsigned short *)(XBARA1_BLOCK + 0x56) // crossbar A select register 43
#define XBARA1_SEL44               *(unsigned short *)(XBARA1_BLOCK + 0x58) // crossbar A select register 44
#define XBARA1_SEL45               *(unsigned short *)(XBARA1_BLOCK + 0x5a) // crossbar A select register 45
#define XBARA1_SEL46               *(unsigned short *)(XBARA1_BLOCK + 0x5c) // crossbar A select register 46
#define XBARA1_SEL47               *(unsigned short *)(XBARA1_BLOCK + 0x5e) // crossbar A select register 47
#define XBARA1_SEL48               *(unsigned short *)(XBARA1_BLOCK + 0x60) // crossbar A select register 48
#define XBARA1_SEL49               *(unsigned short *)(XBARA1_BLOCK + 0x62) // crossbar A select register 49
#define XBARA1_SEL50               *(unsigned short *)(XBARA1_BLOCK + 0x64) // crossbar A select register 50
#define XBARA1_SEL51               *(unsigned short *)(XBARA1_BLOCK + 0x66) // crossbar A select register 51
#define XBARA1_SEL52               *(unsigned short *)(XBARA1_BLOCK + 0x68) // crossbar A select register 52
#define XBARA1_SEL53               *(unsigned short *)(XBARA1_BLOCK + 0x6a) // crossbar A select register 53
#define XBARA1_SEL54               *(unsigned short *)(XBARA1_BLOCK + 0x6c) // crossbar A select register 54
#define XBARA1_SEL55               *(unsigned short *)(XBARA1_BLOCK + 0x6e) // crossbar A select register 55
#define XBARA1_SEL56               *(unsigned short *)(XBARA1_BLOCK + 0x70) // crossbar A select register 56
#define XBARA1_SEL57               *(unsigned short *)(XBARA1_BLOCK + 0x72) // crossbar A select register 57
#define XBARA1_SEL58               *(unsigned short *)(XBARA1_BLOCK + 0x74) // crossbar A select register 58
#define XBARA1_SEL59               *(unsigned short *)(XBARA1_BLOCK + 0x76) // crossbar A select register 59
#define XBARA1_SEL60               *(unsigned short *)(XBARA1_BLOCK + 0x78) // crossbar A select register 60
#define XBARA1_SEL61               *(unsigned short *)(XBARA1_BLOCK + 0x7a) // crossbar A select register 61
#define XBARA1_SEL62               *(unsigned short *)(XBARA1_BLOCK + 0x7c) // crossbar A select register 62
#define XBARA1_SEL63               *(unsigned short *)(XBARA1_BLOCK + 0x7e) // crossbar A select register 63
#define XBARA1_SEL64               *(unsigned short *)(XBARA1_BLOCK + 0x80) // crossbar A select register 64
#define XBARA1_SEL65               *(unsigned short *)(XBARA1_BLOCK + 0x82) // crossbar A select register 65
#define XBARA1_CTRL0_ADD           (volatile unsigned short *)(XBARA1_BLOCK + 0x84)
#define XBARA1_CTRL0               *(volatile unsigned short *)(XBARA1_BLOCK + 0x84) // crossbar A control register 0
    #define XBARA_CTRL0_DEN0       0x0001                                // DMA enabled on XBAR_OUT0
    #define XBARA_CTRL0_IEN0       0x0002                                // interrupt enabled on XBAR_OUT0
    #define XBARA_CTRL0_EDGE0_OFF  0x0000                                // STS0 never asserts
    #define XBARA_CTRL0_EDGE0_RISE 0x0004                                // STS0 asserts on rising edges
    #define XBARA_CTRL0_EDGE0_FALL 0x0008                                // STS0 asserts on falling edges
    #define XBARA_CTRL0_EDGE0_BOTH 0x000c                                // STS0 asserts on rising and falling edges
    #define XBARA_CTRL0_EDGE0_MASK 0x000c                                // active edge for edge detection on XBAR_OUT0 (causing STS0 to be asserted)
    #define XBARA_CTRL0_STS0       0x0010                                // edge detection status for XBAR_OUT0 (write '1' to clear or cleared by DMA ack 0)
    #define XBARA_CTRL0_DEN1       0x0100                                // DMA enabled on XBAR_OUT1
    #define XBARA_CTRL0_IEN1       0x0200                                // interrupt enabled on XBAR_OUT1
    #define XBARA_CTRL0_EDGE1_OFF  0x0000                                // STS1 never asserts
    #define XBARA_CTRL0_EDGE1_RISE 0x0400                                // STS1 asserts on rising edges
    #define XBARA_CTRL0_EDGE1_FALL 0x0800                                // STS1 asserts on falling edges
    #define XBARA_CTRL0_EDGE1_BOTH 0x0c00                                // STS1 asserts on rising and falling edges
    #define XBARA_CTRL0_EDGE1_MASK 0x0c00                                // active edge for edge detection on XBAR_OUT1 (causing STS1 to be asserted)
    #define XBARA_CTRL0_STS1       0x1000                                // edge detection status for XBAR_OUT1 (write '1' to clear or cleared by DMA ack 1)
#define XBARA1_CTRL1_ADD           (volatile unsigned short *)(XBARA1_BLOCK + 0x86)
#define XBARA1_CTRL1               *(volatile unsigned short *)(XBARA1_BLOCK + 0x86) // crossbar A control register 1
    #define XBARA_CTRL1_DEN2       0x0001                                // DMA enabled on XBAR_OUT2
    #define XBARA_CTRL1_IEN2       0x0002                                // interrupt enabled on XBAR_OUT2
    #define XBARA_CTRL1_EDGE2_OFF  0x0000                                // STS2 never asserts
    #define XBARA_CTRL1_EDGE2_RISE 0x0004                                // STS2 asserts on rising edges
    #define XBARA_CTRL1_EDGE2_FALL 0x0008                                // STS2 asserts on falling edges
    #define XBARA_CTRL1_EDGE2_BOTH 0x000c                                // STS2 asserts on rising and falling edges
    #define XBARA_CTRL1_EDGE2_MASK 0x000c                                // active edge for edge detection on XBAR_OUT2 (causing STS2 to be asserted)
    #define XBARA_CTRL1_STS2       0x0010                                // edge detection status for XBAR_OUT2 (write '1' to clear or cleared by DMA ack 2)
    #define XBARA_CTRL1_DEN3       0x0100                                // DMA enabled on XBAR_OUT3
    #define XBARA_CTRL1_IEN3       0x0200                                // interrupt enabled on XBAR_OUT3
    #define XBARA_CTRL1_EDGE3_OFF  0x0000                                // STS3 never asserts
    #define XBARA_CTRL1_EDGE3_RISE 0x0400                                // STS3 asserts on rising edges
    #define XBARA_CTRL1_EDGE3_FALL 0x0800                                // STS3 asserts on falling edges
    #define XBARA_CTRL1_EDGE3_BOTH 0x0c00                                // STS3 asserts on rising and falling edges
    #define XBARA_CTRL1_EDGE3_MASK 0x0c00                                // active edge for edge detection on XBAR_OUT3 (causing STS3 to be asserted)
    #define XBARA_CTRL1_STS3       0x1000                                // edge detection status for XBAR_OUT3 (write '1' to clear or cleared by DMA ack 3)

#if XBARA_AVAILABLE > 1
    // XBARB2
    //
    #define XBARB2_SEL0_ADD            (unsigned short *)(XBARB2_BLOCK + 0x00)
    #define XBARB2_SEL0                *(unsigned short *)(XBARB2_BLOCK + 0x00) // crossbar B2 select register 0
    #define XBARB2_SEL1                *(unsigned short *)(XBARB2_BLOCK + 0x02) // crossbar B2 select register 1
    #define XBARB2_SEL2                *(unsigned short *)(XBARB2_BLOCK + 0x04) // crossbar B2 select register 2
    #define XBARB2_SEL3                *(unsigned short *)(XBARB2_BLOCK + 0x06) // crossbar B2 select register 3
    #define XBARB2_SEL4                *(unsigned short *)(XBARB2_BLOCK + 0x08) // crossbar B2 select register 4
    #define XBARB2_SEL5                *(unsigned short *)(XBARB2_BLOCK + 0x0a) // crossbar B2 select register 5
    #define XBARB2_SEL6                *(unsigned short *)(XBARB2_BLOCK + 0x0c) // crossbar B2 select register 6
    #define XBARB2_SEL7                *(unsigned short *)(XBARB2_BLOCK + 0x0e) // crossbar B2 select register 7
#endif

#if XBARA_AVAILABLE > 2
    // XBARB3
    //
    #define XBARB3_SEL0_ADD            (unsigned short *)(XBARB3_BLOCK + 0x00)
    #define XBARB3_SEL0                *(unsigned short *)(XBARB3_BLOCK + 0x00) // crossbar B3 select register 0
    #define XBARB3_SEL1                *(unsigned short *)(XBARB3_BLOCK + 0x02) // crossbar B3 select register 1
    #define XBARB3_SEL2                *(unsigned short *)(XBARB3_BLOCK + 0x04) // crossbar B3 select register 2
    #define XBARB3_SEL3                *(unsigned short *)(XBARB3_BLOCK + 0x06) // crossbar B3 select register 3
    #define XBARB3_SEL4                *(unsigned short *)(XBARB3_BLOCK + 0x08) // crossbar B3 select register 4
    #define XBARB3_SEL5                *(unsigned short *)(XBARB3_BLOCK + 0x0a) // crossbar B3 select register 5
    #define XBARB3_SEL6                *(unsigned short *)(XBARB3_BLOCK + 0x0c) // crossbar B3 select register 6
    #define XBARB3_SEL7                *(unsigned short *)(XBARB3_BLOCK + 0x0e) // crossbar B3 select register 7
#endif

#if defined iMX_RT1011
    // XBAR1 input assignments
    //
    // XBAR1_IN00 reserved
    #define XBAR1_LOGIC_HIGH                XBAR_IN01
    #define XBAR1_IOMUX_XBAR_INOUT02_IN     XBAR_IN02
    #define XBAR1_IOMUX_XBAR_INOUT03_IN     XBAR_IN03
    #define XBAR1_FLEXPWM1_PWM1_OUT_TRIG0   XBAR_IN04
    #define XBAR1_FLEXPWM1_PWM1_OUT_TRIG1   XBAR_FLEXPWM1_PWM1_OUT_TRIG0
    #define XBAR1_FLEXPWM1_PWM2_OUT_TRIG0   XBAR_IN05
    #define XBAR1_FLEXPWM1_PWM2_OUT_TRIG1   XBAR_FLEXPWM1_PWM2_OUT_TRIG0
    #define XBAR1_FLEXPWM1_PWM3_OUT_TRIG0   XBAR_IN06
    #define XBAR1_FLEXPWM1_PWM3_OUT_TRIG1   XBAR_FLEXPWM1_PWM3_OUT_TRIG0
    #define XBAR1_FLEXPWM1_PWM4_OUT_TRIG0   XBAR_IN07
    #define XBAR1_FLEXPWM1_PWM4_OUT_TRIG1   XBAR_FLEXPWM1_PWM4_OUT_TRIG0
    #define XBAR1_PIT_TRIGGER0              XBAR_IN08
    #define XBAR1_PIT_TRIGGER1              XBAR_IN09
    #define XBAR1_PIT_TRIGGER2              XBAR_IN10
    #define XBAR1_PIT_TRIGGER3              XBAR_IN11
    #define XBAR1_DMA_DONE0                 XBAR_IN12
    #define XBAR1_DMA_DONE1                 XBAR_IN13
    #define XBAR1_DMA_DONE2                 XBAR_IN14
    #define XBAR1_DMA_DONE3                 XBAR_IN15
    #define XBAR1_DMA_DONE4                 XBAR_IN16
    #define XBAR1_DMA_DONE5                 XBAR_IN17
    #define XBAR1_DMA_DONE6                 XBAR_IN18
    #define XBAR1_DMA_DONE7                 XBAR_IN19
    #define XBAR1_AIO1_OUT0                 XBAR_IN20
    #define XBAR1_AIO1_OUT1                 XBAR_IN21
    #define XBAR1_AIO1_OUT2                 XBAR_IN22
    #define XBAR1_AIO1_OUT3                 XBAR_IN23
    #define XBAR1_ADC_ETC0_COCO0            XBAR_IN24
    #define XBAR1_ADC_ETC0_COCO1            XBAR_IN25
    #define XBAR1_ADC_ETC0_COCO2            XBAR_IN26
    #define XBAR1_ADC_ETC0_COCO3            XBAR_IN27
#else
    // XBAR1 input assignments
    //
    #define XBAR1_LOGIC_LOW                 XBAR_IN00
    #define XBAR1_LOGIC_HIGH                XBAR_IN01
    #if defined iMX_RT105X || defined iMX_RT106X
        #define XBAR1_IOMUX_XBAR_IN02       XBAR_IN02
        #define XBAR1_IOMUX_XBAR_IN03       XBAR_IN03
    #endif
    #define XBAR1_IOMUX_XBAR_INOUT04_IN     XBAR_IN04
    #define XBAR1_IOMUX_XBAR_INOUT05_IN     XBAR_IN05
    #define XBAR1_IOMUX_XBAR_INOUT06_IN     XBAR_IN06
    #define XBAR1_IOMUX_XBAR_INOUT07_IN     XBAR_IN07
    #define XBAR1_IOMUX_XBAR_INOUT08_IN     XBAR_IN08
    #define XBAR1_IOMUX_XBAR_INOUT09_IN     XBAR_IN09
    #define XBAR1_IOMUX_XBAR_INOUT10_IN     XBAR_IN10
    #if !defined iMX_RT1015
        #define XBAR1_IOMUX_XBAR_INOUT11_IN XBAR_IN11
        #define XBAR1_IOMUX_XBAR_INOUT12_IN XBAR_IN12
        #define XBAR1_IOMUX_XBAR_INOUT13_IN XBAR_IN13
        #define XBAR1_IOMUX_XBAR_INOUT14_IN XBAR_IN14
        #define XBAR1_IOMUX_XBAR_INOUT15_IN XBAR_IN15
    #endif
    #define XBAR1_IOMUX_XBAR_INOUT16_IN     XBAR_IN16
    #define XBAR1_IOMUX_XBAR_INOUT17_IN     XBAR_IN17
    #if !defined iMX_RT1015
        #define XBAR1_IOMUX_XBAR_INOUT18_IN XBAR_IN18
        #define XBAR1_IOMUX_XBAR_INOUT19_IN XBAR_IN19
    #endif
    #if defined iMX_RT105X || defined iMX_RT106X
        #define XBAR1_IOMUX_XBAR_IN20       XBAR_IN20
        #define XBAR1_IOMUX_XBAR_IN21       XBAR_IN21
        #define XBAR1_IOMUX_XBAR_IN22       XBAR_IN22
        #define XBAR1_IOMUX_XBAR_IN23       XBAR_IN23
        #define XBAR1_IOMUX_XBAR_IN24       XBAR_IN24
        #define XBAR1_IOMUX_XBAR_IN25       XBAR_IN25
    #endif
    #if !defined iMX_RT1015
        #define XBAR1_ACMP1_OUT             XBAR_IN26
        #define XBAR1_ACMP2_OUT             XBAR_IN27
        #define XBAR1_ACMP3_OUT             XBAR_IN28
        #define XBAR1_ACMP4_OUT             XBAR_IN29
    #endif
    // XBAR1_IN30 reserved
    // XBAR1_IN31 reserved
    #if defined iMX_RT105X || defined iMX_RT106X
        #define XBAR1_QTIMER3_TIMER0            XBAR_IN32
        #define XBAR1_QTIMER3_TIMER1            XBAR_IN33
        #define XBAR1_QTIMER3_TIMER2            XBAR_IN34
        #define XBAR1_QTIMER3_TIMER3            XBAR_IN35
        #define XBAR1_QTIMER4_TIMER0            XBAR_IN36
        #define XBAR1_QTIMER4_TIMER1            XBAR_IN37
        #define XBAR1_QTIMER4_TIMER2            XBAR_IN38
        #define XBAR1_QTIMER4_TIMER3            XBAR_IN39
    #else
        #define XBAR1_QTIMER1_TIMER0_IN         XBAR_IN32
        #define XBAR1_QTIMER1_TIMER1_IN         XBAR_IN33
        #define XBAR1_QTIMER1_TIMER2_IN         XBAR_IN34
        #define XBAR1_QTIMER1_TIMER3_IN         XBAR_IN35
        #if !defined iMX_RT1015
            #define XBAR1_QTIMER2_TIMER0_IN     XBAR_IN36
            #define XBAR1_QTIMER2_TIMER1_IN     XBAR_IN37
            #define XBAR1_QTIMER2_TIMER2_IN     XBAR_IN38
            #define XBAR1_QTIMER2_TIMER3_IN     XBAR_IN39
        #endif
    #endif
    #define XBAR1_FLEXPWM1_PWM1_OUT_TRIG0   XBAR_IN40
    #define XBAR1_FLEXPWM1_PWM1_OUT_TRIG1   XBAR1_FLEXPWM1_PWM1_OUT_TRIG0
    #define XBAR1_FLEXPWM1_PWM2_OUT_TRIG0   XBAR_IN41
    #define XBAR1_FLEXPWM1_PWM2_OUT_TRIG1   XBAR1_FLEXPWM1_PWM2_OUT_TRIG0
    #define XBAR1_FLEXPWM1_PWM3_OUT_TRIG0   XBAR_IN42
    #define XBAR1_FLEXPWM1_PWM3_OUT_TRIG1   XBAR1_FLEXPWM1_PWM3_OUT_TRIG0
    #define XBAR1_FLEXPWM1_PWM4_OUT_TRIG0   XBAR_IN43
    #if !defined iMX_RT1015
        #define XBAR1_FLEXPWM1_PWM4_OUT_TRIG1   XBAR1_FLEXPWM1_PWM4_OUT_TRIG0
        #define XBAR1_FLEXPWM2_PWM1_OUT_TRIG0   XBAR_IN44
        #define XBAR1_FLEXPWM2_PWM1_OUT_TRIG1   XBAR1_FLEXPWM2_PWM1_OUT_TRIG0
        #define XBAR1_FLEXPWM2_PWM2_OUT_TRIG0   XBAR_IN45
        #define XBAR1_FLEXPWM2_PWM2_OUT_TRIG1   XBAR1_FLEXPWM2_PWM2_OUT_TRIG0
        #define XBAR1_FLEXPWM2_PWM3_OUT_TRIG0   XBAR_IN46
        #define XBAR1_FLEXPWM2_PWM3_OUT_TRIG1   XBAR1_FLEXPWM2_PWM3_OUT_TRIG0
        #define XBAR1_FLEXPWM2_PWM4_OUT_TRIG0   XBAR_IN47
        #define XBAR1_FLEXPWM2_PWM4_OUT_TRIG1   XBAR1_FLEXPWM2_PWM4_OUT_TRIG0
    #endif
    #if defined iMX_RT105X || defined iMX_RT106X
        #define XBAR1_FLEXPWM3_PWM1_OUT_TRIG0   XBAR_IN48
        #define XBAR1_FLEXPWM3_PWM1_OUT_TRIG1   XBAR1_FLEXPWM1_PWM1_OUT_TRIG0
        #define XBAR1_FLEXPWM3_PWM2_OUT_TRIG0   XBAR_IN49
        #define XBAR1_FLEXPWM3_PWM2_OUT_TRIG1   XBAR1_FLEXPWM1_PWM2_OUT_TRIG0
        #define XBAR1_FLEXPWM3_PWM3_OUT_TRIG0   XBAR_IN50
        #define XBAR1_FLEXPWM3_PWM3_OUT_TRIG1   XBAR1_FLEXPWM1_PWM3_OUT_TRIG0
        #define XBAR1_FLEXPWM3_PWM4_OUT_TRIG0   XBAR_IN51
        #define XBAR1_FLEXPWM3_PWM4_OUT_TRIG1   XBAR1_FLEXPWM1_PWM4_OUT_TRIG0
        #define XBAR1_FLEXPWM4_PWM1_OUT_TRIG0   XBAR_IN52
        #define XBAR1_FLEXPWM4_PWM1_OUT_TRIG1   XBAR1_FLEXPWM2_PWM1_OUT_TRIG0
        #define XBAR1_FLEXPWM4_PWM2_OUT_TRIG0   XBAR_IN53
        #define XBAR1_FLEXPWM4_PWM2_OUT_TRIG1   XBAR1_FLEXPWM2_PWM2_OUT_TRIG0
        #define XBAR1_FLEXPWM4_PWM3_OUT_TRIG0   XBAR_IN54
        #define XBAR1_FLEXPWM4_PWM3_OUT_TRIG1   XBAR1_FLEXPWM2_PWM3_OUT_TRIG0
        #define XBAR1_FLEXPWM4_PWM4_OUT_TRIG0   XBAR_IN55
        #define XBAR1_FLEXPWM4_PWM4_OUT_TRIG1   XBAR1_FLEXPWM2_PWM4_OUT_TRIG0
    #endif
    #define XBAR1_PIT_TRIGGER0              XBAR_IN56
    #define XBAR1_PIT_TRIGGER1              XBAR_IN57
    #define XBAR1_PIT_TRIGGER2              XBAR_IN58
    #define XBAR1_PIT_TRIGGER3              XBAR_IN59
    #define XBAR1_ENC1_POS_MATCH            XBAR_IN60
    #if !defined iMX_RT1015
        #define XBAR1_ENC2_POS_MATCH        XBAR_IN61
    #endif
    #if defined iMX_RT105X || defined iMX_RT106X
        #define XBAR1_ENC3_POS_MATCH        XBAR_IN62
        #define XBAR1_ENC4_POS_MATCH        XBAR_IN63
    #endif
    #define XBAR1_DMA_DONE0                 XBAR_IN64
    #define XBAR1_DMA_DONE1                 XBAR_IN65
    #define XBAR1_DMA_DONE2                 XBAR_IN66
    #define XBAR1_DMA_DONE3                 XBAR_IN67
    #define XBAR1_DMA_DONE4                 XBAR_IN68
    #define XBAR1_DMA_DONE5                 XBAR_IN69
    #define XBAR1_DMA_DONE6                 XBAR_IN70
    #define XBAR1_DMA_DONE7                 XBAR_IN71
    #define XBAR1_AOI1_OUT0                 XBAR_IN72
    #define XBAR1_AOI1_OUT1                 XBAR_IN73
    #define XBAR1_AOI1_OUT2                 XBAR_IN74
    #define XBAR1_AOI1_OUT3                 XBAR_IN75
    #if defined iMX_RT105X || defined iMX_RT106X
        #define XBAR1_AOI2_OUT0             XBAR_IN76
        #define XBAR1_AOI2_OUT1             XBAR_IN77
        #define XBAR1_AOI2_OUT2             XBAR_IN78
        #define XBAR1_AOI2_OUT3             XBAR_IN79
    #endif
    #define XBAR1_ADC_ETC0_COCO0            XBAR_IN80
    #define XBAR1_ADC_ETC0_COCO1            XBAR_IN81
    #define XBAR1_ADC_ETC0_COCO2            XBAR_IN82
    #define XBAR1_ADC_ETC0_COCO3            XBAR_IN83
    #define XBAR1_ADC_ETC1_COCO0            XBAR_IN84
    #define XBAR1_ADC_ETC1_COCO1            XBAR_IN85
    #define XBAR1_ADC_ETC1_COCO2            XBAR_IN86
    #define XBAR1_ADC_ETC1_COCO3            XBAR_IN87

    // XBAR2 input assignments
    //
    #define XBAR2_LOGIC_LOW                 XBAR_IN00
    #define XBAR2_LOGIC_HIGH                XBAR_IN01
    // XBAR2_IN02 reserved
    // XBAR2_IN03 reserved
    // XBAR2_IN04 reserved
    // XBAR2_IN05 reserved
    #if !defined iMX_RT1015
        #define XBAR2_ACMP1_OUT             XBAR_IN06
        #define XBAR2_ACMP2_OUT             XBAR_IN07
        #define XBAR2_ACMP3_OUT             XBAR_IN08
        #define XBAR2_ACMP4_OUT             XBAR_IN09
    #endif
    // XBAR2_IN10 reserved
    // XBAR2_IN11 reserved
    #if defined iMX_RT1015
        #define XBAR2_QTIMER1_TIMER0        XBAR_IN12
        #define XBAR2_QTIMER1_TIMER1        XBAR_IN13
        #define XBAR2_QTIMER1_TIMER2        XBAR_IN14
        #define XBAR2_QTIMER1_TIMER3        XBAR_IN15
    #else
        #define XBAR2_QTIMER3_TIMER0        XBAR_IN12
        #define XBAR2_QTIMER3_TIMER1        XBAR_IN13
        #define XBAR2_QTIMER3_TIMER2        XBAR_IN14
        #define XBAR2_QTIMER3_TIMER3        XBAR_IN15
        #define XBAR2_QTIMER4_TIMER0        XBAR_IN16
        #define XBAR2_QTIMER4_TIMER1        XBAR_IN17
        #define XBAR2_QTIMER4_TIMER2        XBAR_IN18
        #define XBAR2_QTIMER4_TIMER3        XBAR_IN19
    #endif
    #define XBAR2_FLEXPWM1_PWM1_OUT_TRIG0   XBAR_IN20
    #define XBAR2_FLEXPWM1_PWM1_OUT_TRIG1   XBAR2_FLEXPWM1_PWM1_OUT_TRIG0
    #define XBAR2_FLEXPWM1_PWM2_OUT_TRIG0   XBAR_IN21
    #define XBAR2_FLEXPWM1_PWM2_OUT_TRIG1   XBAR2_FLEXPWM1_PWM2_OUT_TRIG0
    #define XBAR2_FLEXPWM1_PWM3_OUT_TRIG0   XBAR_IN22
    #define XBAR2_FLEXPWM1_PWM3_OUT_TRIG1   XBAR2_FLEXPWM1_PWM3_OUT_TRIG0
    #define XBAR2_FLEXPWM1_PWM4_OUT_TRIG0   XBAR_IN23
    #define XBAR2_FLEXPWM1_PWM4_OUT_TRIG1   XBAR2_FLEXPWM1_PWM4_OUT_TRIG0
    #if !defined iMX_RT1015
        #define XBAR2_FLEXPWM2_PWM1_OUT_TRIG0   XBAR_IN24
        #define XBAR2_FLEXPWM2_PWM1_OUT_TRIG1   XBAR2_FLEXPWM2_PWM1_OUT_TRIG0
        #define XBAR2_FLEXPWM2_PWM2_OUT_TRIG0   XBAR_IN25
        #define XBAR2_FLEXPWM2_PWM2_OUT_TRIG1   XBAR2_FLEXPWM2_PWM2_OUT_TRIG0
        #define XBAR2_FLEXPWM2_PWM3_OUT_TRIG0   XBAR_IN26
        #define XBAR2_FLEXPWM2_PWM3_OUT_TRIG1   XBAR2_FLEXPWM2_PWM3_OUT_TRIG0
        #define XBAR2_FLEXPWM2_PWM4_OUT_TRIG0   XBAR_IN27
        #define XBAR2_FLEXPWM2_PWM4_OUT_TRIG1   XBAR2_FLEXPWM2_PWM4_OUT_TRIG0
        #define XBAR2_FLEXPWM3_PWM1_OUT_TRIG0   XBAR_IN28
        #define XBAR2_FLEXPWM3_PWM1_OUT_TRIG1   XBAR2_FLEXPWM3_PWM1_OUT_TRIG0
        #define XBAR2_FLEXPWM3_PWM2_OUT_TRIG0   XBAR_IN29
        #define XBAR2_FLEXPWM3_PWM2_OUT_TRIG1   XBAR2_FLEXPWM3_PWM2_OUT_TRIG0
        #define XBAR2_FLEXPWM3_PWM3_OUT_TRIG0   XBAR_IN30
        #define XBAR2_FLEXPWM3_PWM3_OUT_TRIG1   XBAR2_FLEXPWM3_PWM3_OUT_TRIG0
        #define XBAR2_FLEXPWM3_PWM4_OUT_TRIG0   XBAR_IN31
        #define XBAR2_FLEXPWM3_PWM4_OUT_TRIG1   XBAR2_FLEXPWM3_PWM4_OUT_TRIG0
        #define XBAR2_FLEXPWM4_PWM1_OUT_TRIG0   XBAR_IN32
        #define XBAR2_FLEXPWM4_PWM1_OUT_TRIG1   XBAR2_FLEXPWM4_PWM1_OUT_TRIG0
        #define XBAR2_FLEXPWM4_PWM2_OUT_TRIG0   XBAR_IN33
        #define XBAR2_FLEXPWM4_PWM2_OUT_TRIG1   XBAR2_FLEXPWM4_PWM2_OUT_TRIG0
        #define XBAR2_FLEXPWM4_PWM3_OUT_TRIG0   XBAR_IN34
        #define XBAR2_FLEXPWM4_PWM3_OUT_TRIG1   XBAR2_FLEXPWM4_PWM3_OUT_TRIG0
        #define XBAR2_FLEXPWM4_PWM4_OUT_TRIG0   XBAR_IN35
        #define XBAR2_FLEXPWM4_PWM4_OUT_TRIG1   XBAR2_FLEXPWM4_PWM4_OUT_TRIG0
    #endif
    #define XBAR2_PIT_TRIGGER0              XBAR_IN36
    #define XBAR2_PIT_TRIGGER1              XBAR_IN37
    #define XBAR2_ADC_ETC0_COCO0            XBAR_IN38
    #define XBAR2_ADC_ETC0_COCO1            XBAR_IN39
    #define XBAR2_ADC_ETC0_COCO2            XBAR_IN40
    #define XBAR2_ADC_ETC0_COCO3            XBAR_IN41
    #define XBAR2_ADC_ETC1_COCO0            XBAR_IN42
    #define XBAR2_ADC_ETC1_COCO1            XBAR_IN43
    #define XBAR2_ADC_ETC1_COCO2            XBAR_IN44
    #define XBAR2_ADC_ETC1_COCO3            XBAR_IN45
    #define XBAR2_ENC1_POS_MATCH            XBAR_IN46
    #if !defined iMX_RT1015
        #define XBAR2_ENC2_POS_MATCH        XBAR_IN47
        #define XBAR2_ENC3_POS_MATCH        XBAR_IN48
        #define XBAR2_ENC4_POS_MATCH        XBAR_IN49
    #endif
    #define XBAR2_DMA_DONE0                 XBAR_IN50
    #define XBAR2_DMA_DONE1                 XBAR_IN51
    #define XBAR2_DMA_DONE2                 XBAR_IN52
    #define XBAR2_DMA_DONE3                 XBAR_IN53
    #define XBAR2_DMA_DONE4                 XBAR_IN54
    #define XBAR2_DMA_DONE5                 XBAR_IN55
    #define XBAR2_DMA_DONE6                 XBAR_IN56
    #define XBAR2_DMA_DONE7                 XBAR_IN57

    #if !defined iMX_RT1015
        // XBAR3 input assignments
        //
        #define XBAR3_LOGIC_LOW                 XBAR_IN00
        #define XBAR3_LOGIC_HIGH                XBAR_IN01
        // XBAR3_IN02 reserved
        // XBAR3_IN03 reserved
        // XBAR3_IN04 reserved
        // XBAR3_IN05 reserved
        #define XBAR3_ACMP1_OUT                 XBAR_IN06
        #define XBAR3_ACMP2_OUT                 XBAR_IN07
        #define XBAR3_ACMP3_OUT                 XBAR_IN08
        #define XBAR3_ACMP4_OUT                 XBAR_IN09
        // XBAR3_IN10 reserved
        // XBAR3_IN11 reserved
        #define XBAR3_QTIMER3_TIMER0            XBAR_IN12
        #define XBAR3_QTIMER3_TIMER1            XBAR_IN13
        #define XBAR3_QTIMER3_TIMER2            XBAR_IN14
        #define XBAR3_QTIMER3_TIMER3            XBAR_IN15
        #define XBAR3_QTIMER4_TIMER0            XBAR_IN16
        #define XBAR3_QTIMER4_TIMER1            XBAR_IN17
        #define XBAR3_QTIMER4_TIMER2            XBAR_IN18
        #define XBAR3_QTIMER4_TIMER3            XBAR_IN19
        #define XBAR3_FLEXPWM1_PWM1_OUT_TRIG0   XBAR_IN20
        #define XBAR3_FLEXPWM1_PWM1_OUT_TRIG1   XBAR3_FLEXPWM1_PWM1_OUT_TRIG0
        #define XBAR3_FLEXPWM1_PWM2_OUT_TRIG0   XBAR_IN21
        #define XBAR3_FLEXPWM1_PWM2_OUT_TRIG1   XBAR3_FLEXPWM1_PWM2_OUT_TRIG0
        #define XBAR3_FLEXPWM1_PWM3_OUT_TRIG0   XBAR_IN22
        #define XBAR3_FLEXPWM1_PWM3_OUT_TRIG1   XBAR3_FLEXPWM1_PWM3_OUT_TRIG0
        #define XBAR3_FLEXPWM1_PWM4_OUT_TRIG0   XBAR_IN23
        #define XBAR3_FLEXPWM1_PWM4_OUT_TRIG1   XBAR3_FLEXPWM1_PWM4_OUT_TRIG0
        #define XBAR3_FLEXPWM2_PWM1_OUT_TRIG0   XBAR_IN24
        #define XBAR3_FLEXPWM2_PWM1_OUT_TRIG1   XBAR3_FLEXPWM2_PWM1_OUT_TRIG0
        #define XBAR3_FLEXPWM2_PWM2_OUT_TRIG0   XBAR_IN25
        #define XBAR3_FLEXPWM2_PWM2_OUT_TRIG1   XBAR3_FLEXPWM2_PWM2_OUT_TRIG0
        #define XBAR3_FLEXPWM2_PWM3_OUT_TRIG0   XBAR_IN26
        #define XBAR3_FLEXPWM2_PWM3_OUT_TRIG1   XBAR3_FLEXPWM2_PWM3_OUT_TRIG0
        #define XBAR3_FLEXPWM2_PWM4_OUT_TRIG0   XBAR_IN27
        #define XBAR3_FLEXPWM2_PWM4_OUT_TRIG1   XBAR3_FLEXPWM2_PWM4_OUT_TRIG0
        #define XBAR3_FLEXPWM3_PWM1_OUT_TRIG0   XBAR_IN28
        #define XBAR3_FLEXPWM3_PWM1_OUT_TRIG1   XBAR3_FLEXPWM3_PWM1_OUT_TRIG0
        #define XBAR3_FLEXPWM3_PWM2_OUT_TRIG0   XBAR_IN29
        #define XBAR3_FLEXPWM3_PWM2_OUT_TRIG1   XBAR3_FLEXPWM3_PWM2_OUT_TRIG0
        #define XBAR3_FLEXPWM3_PWM3_OUT_TRIG0   XBAR_IN30
        #define XBAR3_FLEXPWM3_PWM3_OUT_TRIG1   XBAR3_FLEXPWM3_PWM3_OUT_TRIG0
        #define XBAR3_FLEXPWM3_PWM4_OUT_TRIG0   XBAR_IN31
        #define XBAR3_FLEXPWM3_PWM4_OUT_TRIG1   XBAR3_FLEXPWM3_PWM4_OUT_TRIG0
        #define XBAR3_FLEXPWM4_PWM1_OUT_TRIG0   XBAR_IN32
        #define XBAR3_FLEXPWM4_PWM1_OUT_TRIG1   XBAR3_FLEXPWM4_PWM1_OUT_TRIG0
        #define XBAR3_FLEXPWM4_PWM2_OUT_TRIG0   XBAR_IN33
        #define XBAR3_FLEXPWM4_PWM2_OUT_TRIG1   XBAR3_FLEXPWM4_PWM2_OUT_TRIG0
        #define XBAR3_FLEXPWM4_PWM3_OUT_TRIG0   XBAR_IN34
        #define XBAR3_FLEXPWM4_PWM3_OUT_TRIG1   XBAR3_FLEXPWM4_PWM3_OUT_TRIG0
        #define XBAR3_FLEXPWM4_PWM4_OUT_TRIG0   XBAR_IN35
        #define XBAR3_FLEXPWM4_PWM4_OUT_TRIG1   XBAR3_FLEXPWM4_PWM4_OUT_TRIG0
        #define XBAR3_PIT_TRIGGER0              XBAR_IN36
        #define XBAR3_PIT_TRIGGER1              XBAR_IN37
        #define XBAR3_ADC_ETC0_COCO0            XBAR_IN38
        #define XBAR3_ADC_ETC0_COCO1            XBAR_IN39
        #define XBAR3_ADC_ETC0_COCO2            XBAR_IN40
        #define XBAR3_ADC_ETC0_COCO3            XBAR_IN41
        #define XBAR3_ADC_ETC1_COCO0            XBAR_IN42
        #define XBAR3_ADC_ETC1_COCO1            XBAR_IN43
        #define XBAR3_ADC_ETC1_COCO2            XBAR_IN44
        #define XBAR3_ADC_ETC1_COCO3            XBAR_IN45
        #define XBAR3_ENC1_POS_MATCH            XBAR_IN46
        #define XBAR3_ENC2_POS_MATCH            XBAR_IN47
        #define XBAR3_ENC3_POS_MATCH            XBAR_IN48
        #define XBAR3_ENC4_POS_MATCH            XBAR_IN49
        #define XBAR3_DMA_DONE0                 XBAR_IN50
        #define XBAR3_DMA_DONE1                 XBAR_IN51
        #define XBAR3_DMA_DONE2                 XBAR_IN52
        #define XBAR3_DMA_DONE3                 XBAR_IN53
        #define XBAR3_DMA_DONE4                 XBAR_IN54
        #define XBAR3_DMA_DONE5                 XBAR_IN55
        #define XBAR3_DMA_DONE6                 XBAR_IN56
        #define XBAR3_DMA_DONE7                 XBAR_IN57
    #endif
#endif


#if defined iMX_RT1011
    // XBAR1 fixed output assignments 
    //
    #define XBAR1_FLEXIO1_TRIGGER_IN0       0
    #define XBAR1_FLEXIO1_TRIGGER_IN1       1
    // XBAR1_OUT02 reserved
    // XBAR1_OUT03 reserved
    #define XBAR1_FLEXPWM1_PWM0_EXTA        4
    #define XBAR1_FLEXPWM1_PWM1_EXTA        5
    #define XBAR1_FLEXPWM1_PWM2_EXTA        6
    #define XBAR1_FLEXPWM1_PWM3_EXTA        7
    #define XBAR1_FLEXPWM1_PWM0_EXT_SYNC    8
    #define XBAR1_FLEXPWM1_PWM1_EXT_SYNC    9
    #define XBAR1_FLEXPWM1_PWM2_EXT_SYNC    10
    #define XBAR1_FLEXPWM1_PWM3_EXT_SYNC    11
    #define XBAR1_FLEXPWM1_EXT_CLK          12
    #define XBAR1_FLEXPWM1_FAULT0           13
    #define XBAR1_FLEXPWM1_FAULT1           14
    #define XBAR1_FLEXPWM1_FAULT2           15
    #define XBAR1_FLEXPWM1_FAULT3           16
    #define XBAR1_FLEXPWM1_EXT_FORCE        17
    #define XBAR1_EWM_EWM_IN                18
    #define XBAR1_ADC_ETC_TRIG00            19
    #define XBAR1_ADC_ETC_TRIG01            20
    #define XBAR1_ADC_ETC_TRIG02            21
    #define XBAR1_ADC_ETC_TRIG03            22
    #define XBAR1_LPI2C1_TRG_INPUT          23
    #define XBAR1_LPI2C2_TRG_INPUT          24
    #define XBAR1_LPSPI1_TRG_INPUT          25
    #define XBAR1_LPSPI2_TRG_INPUT          26
    #define XBAR1_LPUART1_TRG_INPUT         27
    #define XBAR1_LPUART2_TRG_INPUT         28
    #define XBAR1_LPUART3_TRG_INPUT         29
    #define XBAR1_LPUART4_TRG_INPUT         30
#elif defined iMX_RT1015 || defined iMX_RT102X || defined iMX_RT105X || defined iMX_RT106X
    // XBAR1 fixed output assignments 
    //
    #if !defined iMX_RT1015
        #define XBAR1_DMA_CH_MUX_REQ30       0
        #define XBAR1_DMA_CH_MUX_REQ31       1
        #define XBAR1_DMA_CH_MUX_REQ94       2
        #define XBAR1_DMA_CH_MUX_REQ95       3
        #define XBAR1_IOMUX_XBAR_INOUT04_OUT 4
        #define XBAR1_IOMUX_XBAR_INOUT05_OUT 5
        #define XBAR1_IOMUX_XBAR_INOUT06_OUT 6
        #define XBAR1_IOMUX_XBAR_INOUT07_OUT 7
        #define XBAR1_IOMUX_XBAR_INOUT08_OUT 8
        #define XBAR1_IOMUX_XBAR_INOUT09_OUT 9
        #define XBAR1_IOMUX_XBAR_INOUT10_OUT 10
        #define XBAR1_IOMUX_XBAR_INOUT11_OUT 11
        #define XBAR1_IOMUX_XBAR_INOUT12_OUT 12
        #define XBAR1_IOMUX_XBAR_INOUT13_OUT 13
        #define XBAR1_IOMUX_XBAR_INOUT14_OUT 14
        #define XBAR1_IOMUX_XBAR_INOUT15_OUT 15
        #define XBAR1_IOMUX_XBAR_INOUT16_OUT 16
        #define XBAR1_IOMUX_XBAR_INOUT17_OUT 17
        #define XBAR1_IOMUX_XBAR_INOUT18_OUT 18
        #define XBAR1_IOMUX_XBAR_INOUT19_OUT 19
        #define XBAR1_ACMP1_SAMPLE           20
        #define XBAR1_ACMP2_SAMPLE           21
        #define XBAR1_ACMP3_SAMPLE           22
        #define XBAR1_ACMP4_SAMPLE           23
    #endif
    // XBAR1_OUT24 reserved
    // XBAR1_OUT25 reserved
    #define XBAR1_FLEXPWM1_PWM0_EXTA        26
    #define XBAR1_FLEXPWM1_PWM1_EXTA        27
    #define XBAR1_FLEXPWM1_PWM2_EXTA        28
    #define XBAR1_FLEXPWM1_PWM3_EXTA        29
    #define XBAR1_FLEXPWM1_PWM0_EXT_SYNC    30
    #define XBAR1_FLEXPWM1_PWM1_EXT_SYNC    31
    #define XBAR1_FLEXPWM1_PWM2_EXT_SYNC    32
    #define XBAR1_FLEXPWM1_PWM3_EXT_SYNC    33
    #define XBAR1_FLEXPWM1_EXT_CLK          34
    #define XBAR1_FLEXPWM1_FAULT0           35
    #define XBAR1_FLEXPWM1_FAULT1           36
    #define XBAR1_FLEXPWM1_FAULT2           37
    #if !defined iMX_RT1015
        #define XBAR1_FLEXPWM2_FAULT2       XBAR1_FLEXPWM1_FAULT2
        #define XBAR1_FLEXPWM3_FAULT2       XBAR1_FLEXPWM1_FAULT2
        #define XBAR1_FLEXPWM4_FAULT2       XBAR1_FLEXPWM1_FAULT2
    #endif
    #define XBAR1_FLEXPWM1_FAULT3           38
    #if !defined iMX_RT1015
        #define XBAR1_FLEXPWM2_FAULT3       XBAR1_FLEXPWM1_FAULT3
        #define XBAR1_FLEXPWM3_FAULT3       XBAR1_FLEXPWM1_FAULT3
        #define XBAR1_FLEXPWM4_FAULT3       XBAR1_FLEXPWM1_FAULT3
    #endif
    #define XBAR1_FLEXPWM1_EXT_FORCE        39
    #if !defined iMX_RT1015
        #define XBAR1_FLEXPWM2_PWM0_EXTA        40
        #define XBAR1_FLEXPWM3_PWM0_EXTA        XBAR1_FLEXPWM2_PWM0_EXTA
        #define XBAR1_FLEXPWM4_PWM0_EXTA        XBAR1_FLEXPWM2_PWM0_EXTA
        #define XBAR1_FLEXPWM2_PWM1_EXTA        41
        #define XBAR1_FLEXPWM3_PWM1_EXTA        XBAR1_FLEXPWM2_PWM1_EXTA
        #define XBAR1_FLEXPWM4_PWM1_EXTA        XBAR1_FLEXPWM2_PWM1_EXTA
        #define XBAR1_FLEXPWM2_PWM2_EXTA        42
        #define XBAR1_FLEXPWM3_PWM2_EXTA        XBAR1_FLEXPWM2_PWM2_EXTA
        #define XBAR1_FLEXPWM4_PWM2_EXTA        XBAR1_FLEXPWM2_PWM2_EXTA
        #define XBAR1_FLEXPWM2_PWM3_EXTA        43
        #define XBAR1_FLEXPWM3_PWM3_EXTA        XBAR1_FLEXPWM2_PWM3_EXTA
        #define XBAR1_FLEXPWM4_PWM3_EXTA        XBAR1_FLEXPWM2_PWM3_EXTA
        #define XBAR1_FLEXPWM2_PWM0_EXT_SYNC    44
        #define XBAR1_FLEXPWM2_PWM1_EXT_SYNC    45
        #define XBAR1_FLEXPWM2_PWM2_EXT_SYNC    46
        #define XBAR1_FLEXPWM2_PWM3_EXT_SYNC    47
        #define XBAR1_FLEXPWM2_EXT_CLK          48
        #define XBAR1_FLEXPWM3_EXT_CLK          XBAR1_FLEXPWM2_EXT_CLK
        #define XBAR1_FLEXPWM4_EXT_CLK          XBAR1_FLEXPWM2_EXT_CLK
        #define XBAR1_FLEXPWM2_FAULT0           49
        #define XBAR1_FLEXPWM2_FAULT1           50
        #define XBAR1_FLEXPWM2_EXT_FORCE        51
        #define XBAR1_FLEXPWM3_PWM0_EXT_SYNC0   52
        #define XBAR1_FLEXPWM3_PWM1_EXT_SYNC1   53
        #define XBAR1_FLEXPWM3_PWM2_EXT_SYNC2   54
        #define XBAR1_FLEXPWM3_PWM3_EXT_SYNC3   55
        #define XBAR1_FLEXPWM3_FAULT0           56
        #define XBAR1_FLEXPWM3_FAULT1           57
        #define XBAR1_FLEXPWM3_EXT_FORCE        58
        #define XBAR1_FLEXPWM4_PWM0_EXT_SYNC0   59
        #define XBAR1_FLEXPWM4_PWM1_EXT_SYNC1   60
        #define XBAR1_FLEXPWM4_PWM2_EXT_SYNC2   61
        #define XBAR1_FLEXPWM4_PWM3_EXT_SYNC3   62
        #define XBAR1_FLEXPWM4_FAULT0           63
        #define XBAR1_FLEXPWM4_FAULT1           64
        #define XBAR1_FLEXPWM4_EXT_FORCE        65
    #endif
    #define XBAR1_ENC1_PHASEA_INPUT         66
    #define XBAR1_ENC1_PHASEB_INPUT         67
    #define XBAR1_ENC1_INDEX_INPUT          68
    #define XBAR1_ENC1_HOME_INPUT           69
    #define XBAR1_ENC1_TRIGGER              70
    #if !defined iMX_RT1015
        #define XBAR1_ENC2_PHASEA_INPUT     71
        #define XBAR1_ENC2_PHASEB_INPUT     72
        #define XBAR1_ENC2_INDEX_INPUT      73
        #define XBAR1_ENC2_HOME_INPUT       74
        #define XBAR1_ENC2_TRIGGER          75
        #define XBAR1_ENC3_PHASEA_INPUT     76
        #define XBAR1_ENC3_PHASEB_INPUT     77
        #define XBAR1_ENC3_INDEX_INPUT      78
        #define XBAR1_ENC3_HOME_INPUT       79
        #define XBAR1_ENC3_TRIGGER          80
        #define XBAR1_ENC4_PHASEA_INPUT     81
        #define XBAR1_ENC4_PHASEB_INPUT     82
        #define XBAR1_ENC4_INDEX_INPUT      83
        #define XBAR1_ENC4_HOME_INPUT       84
        #define XBAR1_ENC4_TRIGGER          85
    #endif
    #define XBAR1_QTIMER1_TIMER0_OUT        86
    #define XBAR1_QTIMER1_TIMER1_OUT        87
    #define XBAR1_QTIMER1_TIMER2_OUT        88
    #define XBAR1_QTIMER1_TIMER3_OUT        89
    #if !defined iMX_RT1015
        #define XBAR1_QTIMER2_TIMER0_OUT    90
        #define XBAR1_QTIMER2_TIMER1_OUT    91
        #define XBAR1_QTIMER2_TIMER2_OUT    92
        #define XBAR1_QTIMER2_TIMER3_OUT    93
        #define XBAR1_QTIMER3_TIMER0_OUT    94
        #define XBAR1_QTIMER3_TIMER1_OUT    95
        #define XBAR1_QTIMER3_TIMER2_OUT    96
        #define XBAR1_QTIMER3_TIMER3_OUT    97
        #define XBAR1_QTIMER4_TIMER0_OUT    98
        #define XBAR1_QTIMER4_TIMER1_OUT    99
        #define XBAR1_QTIMER4_TIMER2_OUT    100
        #define XBAR1_QTIMER4_TIMER3_OUT    101
    #endif
    #define XBAR1_EWM_EWM_IN                102
    #define XBAR1_ADC_ETC_TRIG00            103
    #define XBAR1_ADC_ETC_TRIG01            104
    #define XBAR1_ADC_ETC_TRIG02            105
    #define XBAR1_ADC_ETC_TRIG03            106
    #define XBAR1_ADC_ETC_TRIG10            107
    #define XBAR1_ADC_ETC_TRIG11            108
    #define XBAR1_ADC_ETC_TRIG12            109
    #define XBAR1_ADC_ETC_TRIG13            110
    #define XBAR1_LPI2C1_TRG_INPUT          111
    #define XBAR1_LPI2C2_TRG_INPUT          112
    #if LPI2C_AVAILABLE > 2
        #define XBAR1_LPI2C3_TRG_INPUT      113
        #define XBAR1_LPI2C4_TRG_INPUT      114
    #endif
    #define XBAR1_LPSPI1_TRG_INPUT          115
    #define XBAR1_LPSPI2_TRG_INPUT          116
    #if LPSPI_AVAILABLE > 2
        #define XBAR1_LPSPI3_TRG_INPUT      117
        #define XBAR1_LPSPI4_TRG_INPUT      118
    #endif
    #define XBAR1_LPUART1_TRG_INPUT         119
    #define XBAR1_LPUART2_TRG_INPUT         120
    #define XBAR1_LPUART3_TRG_INPUT         121
    #define XBAR1_LPUART4_TRG_INPUT         122
    #if LPUARTS_AVAILABLE > 4
        #define XBAR1_LPUART5_TRG_INPUT     123
        #define XBAR1_LPUART6_TRG_INPUT     124
        #define XBAR1_LPUART7_TRG_INPUT     125
        #define XBAR1_LPUART8_TRG_INPUT     126
    #endif
    #define XBAR1_FLEXIO1_TRIGGER_IN0       127
    #define XBAR1_FLEXIO1_TRIGGER_IN1       128
    #if !defined iMX_RT1015
        #define XBAR1_FLEXIO2_TRIGGER_IN0   129
        #define XBAR1_FLEXIO2_TRIGGER_IN1   130
    #endif
    // XBAR1_OUT131 reserved

    // XBAR2 fixed output assignments 
    //
    #define XBAR2_AOI1_IN00                 0
    #define XBAR2_AOI1_IN01                 1
    #define XBAR2_AOI1_IN02                 2
    #define XBAR2_AOI1_IN03                 3
    #define XBAR2_AOI1_IN04                 4
    #define XBAR2_AOI1_IN05                 5
    #define XBAR2_AOI1_IN06                 6
    #define XBAR2_AOI1_IN07                 7
    #define XBAR2_AOI1_IN08                 8
    #define XBAR2_AOI1_IN09                 9
    #define XBAR2_AOI1_IN10                 10
    #define XBAR2_AOI1_IN11                 11
    #define XBAR2_AOI1_IN12                 12
    #define XBAR2_AOI1_IN13                 13
    #define XBAR2_AOI1_IN14                 14
    #define XBAR2_AOI1_IN15                 15

    #if !defined iMX_RT1015
        // XBAR3 fixed output assignments 
        //
        #define XBAR3_AOI1_IN00             0
        #define XBAR3_AOI1_IN01             1
        #define XBAR3_AOI1_IN02             2
        #define XBAR3_AOI1_IN03             3
        #define XBAR3_AOI1_IN04             4
        #define XBAR3_AOI1_IN05             5
        #define XBAR3_AOI1_IN06             6
        #define XBAR3_AOI1_IN07             7
        #define XBAR3_AOI1_IN08             8
        #define XBAR3_AOI1_IN09             9
        #define XBAR3_AOI1_IN10             10
        #define XBAR3_AOI1_IN11             11
        #define XBAR3_AOI1_IN12             12
        #define XBAR3_AOI1_IN13             13
        #define XBAR3_AOI1_IN14             14
        #define XBAR3_AOI1_IN15             15
    #endif
#endif

#define XBAR1_OUT00(x)                  XBARA1_SEL0 = ((XBARA1_SEL0 & ~(0x00ff)) | (x))
#define XBAR1_OUT01(x)                  XBARA1_SEL0 = ((XBARA1_SEL0 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT02(x)                  XBARA1_SEL1 = ((XBARA1_SEL1 & ~(0x00ff)) | (x))
#define XBAR1_OUT03(x)                  XBARA1_SEL1 = ((XBARA1_SEL1 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT04(x)                  XBARA1_SEL2 = ((XBARA1_SEL2 & ~(0x00ff)) | (x))
#define XBAR1_OUT05(x)                  XBARA1_SEL2 = ((XBARA1_SEL2 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT06(x)                  XBARA1_SEL3 = ((XBARA1_SEL3 & ~(0x00ff)) | (x))
#define XBAR1_OUT07(x)                  XBARA1_SEL3 = ((XBARA1_SEL3 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT08(x)                  XBARA1_SEL4 = ((XBARA1_SEL4 & ~(0x00ff)) | (x))
#define XBAR1_OUT09(x)                  XBARA1_SEL4 = ((XBARA1_SEL4 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT10(x)                  XBARA1_SEL5 = ((XBARA1_SEL5 & ~(0x00ff)) | (x))
#define XBAR1_OUT11(x)                  XBARA1_SEL5 = ((XBARA1_SEL5 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT12(x)                  XBARA1_SEL6 = ((XBARA1_SEL6 & ~(0x00ff)) | (x))
#define XBAR1_OUT13(x)                  XBARA1_SEL6 = ((XBARA1_SEL6 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT14(x)                  XBARA1_SEL7 = ((XBARA1_SEL7 & ~(0x00ff)) | (x))
#define XBAR1_OUT15(x)                  XBARA1_SEL7 = ((XBARA1_SEL7 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT16(x)                  XBARA1_SEL8 = ((XBARA1_SEL8 & ~(0x00ff)) | (x))
#define XBAR1_OUT17(x)                  XBARA1_SEL8 = ((XBARA1_SEL8 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT18(x)                  XBARA1_SEL9 = ((XBARA1_SEL9 & ~(0x00ff)) | (x))
#define XBAR1_OUT19(x)                  XBARA1_SEL9 = ((XBARA1_SEL9 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT20(x)                  XBARA1_SEL10 = ((XBARA1_SEL10 & ~(0x00ff)) | (x))
#define XBAR1_OUT21(x)                  XBARA1_SEL10 = ((XBARA1_SEL10 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT22(x)                  XBARA1_SEL11 = ((XBARA1_SEL11 & ~(0x00ff)) | (x))
#define XBAR1_OUT23(x)                  XBARA1_SEL11 = ((XBARA1_SEL11 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT24(x)                  XBARA1_SEL12 = ((XBARA1_SEL12 & ~(0x00ff)) | (x))
#define XBAR1_OUT25(x)                  XBARA1_SEL12 = ((XBARA1_SEL12 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT26(x)                  XBARA1_SEL13 = ((XBARA1_SEL13 & ~(0x00ff)) | (x))
#define XBAR1_OUT27(x)                  XBARA1_SEL13 = ((XBARA1_SEL13 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT28(x)                  XBARA1_SEL14 = ((XBARA1_SEL14 & ~(0x00ff)) | (x))
#define XBAR1_OUT29(x)                  XBARA1_SEL14 = ((XBARA1_SEL14 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT30(x)                  XBARA1_SEL15 = ((XBARA1_SEL15 & ~(0x00ff)) | (x))
#define XBAR1_OUT31(x)                  XBARA1_SEL15 = ((XBARA1_SEL15 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT32(x)                  XBARA1_SEL16 = ((XBARA1_SEL16 & ~(0x00ff)) | (x))
#define XBAR1_OUT33(x)                  XBARA1_SEL16 = ((XBARA1_SEL16 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT34(x)                  XBARA1_SEL17 = ((XBARA1_SEL17 & ~(0x00ff)) | (x))
#define XBAR1_OUT35(x)                  XBARA1_SEL17 = ((XBARA1_SEL17 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT36(x)                  XBARA1_SEL18 = ((XBARA1_SEL18 & ~(0x00ff)) | (x))
#define XBAR1_OUT37(x)                  XBARA1_SEL18 = ((XBARA1_SEL18 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT38(x)                  XBARA1_SEL19 = ((XBARA1_SEL19 & ~(0x00ff)) | (x))
#define XBAR1_OUT39(x)                  XBARA1_SEL19 = ((XBARA1_SEL19 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT40(x)                  XBARA1_SEL20 = ((XBARA1_SEL20 & ~(0x00ff)) | (x))
#define XBAR1_OUT41(x)                  XBARA1_SEL20 = ((XBARA1_SEL20 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT42(x)                  XBARA1_SEL21 = ((XBARA1_SEL21 & ~(0x00ff)) | (x))
#define XBAR1_OUT43(x)                  XBARA1_SEL21 = ((XBARA1_SEL21 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT44(x)                  XBARA1_SEL22 = ((XBARA1_SEL22 & ~(0x00ff)) | (x))
#define XBAR1_OUT45(x)                  XBARA1_SEL22 = ((XBARA1_SEL22 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT46(x)                  XBARA1_SEL23 = ((XBARA1_SEL23 & ~(0x00ff)) | (x))
#define XBAR1_OUT47(x)                  XBARA1_SEL23 = ((XBARA1_SEL23 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT48(x)                  XBARA1_SEL24 = ((XBARA1_SEL24 & ~(0x00ff)) | (x))
#define XBAR1_OUT49(x)                  XBARA1_SEL24 = ((XBARA1_SEL24 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT50(x)                  XBARA1_SEL25 = ((XBARA1_SEL25 & ~(0x00ff)) | (x))
#define XBAR1_OUT51(x)                  XBARA1_SEL25 = ((XBARA1_SEL25 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT52(x)                  XBARA1_SEL26 = ((XBARA1_SEL26 & ~(0x00ff)) | (x))
#define XBAR1_OUT53(x)                  XBARA1_SEL26 = ((XBARA1_SEL26 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT54(x)                  XBARA1_SEL27 = ((XBARA1_SEL27 & ~(0x00ff)) | (x))
#define XBAR1_OUT55(x)                  XBARA1_SEL27 = ((XBARA1_SEL27 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT56(x)                  XBARA1_SEL28 = ((XBARA1_SEL28 & ~(0x00ff)) | (x))
#define XBAR1_OUT57(x)                  XBARA1_SEL28 = ((XBARA1_SEL28 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT58(x)                  XBARA1_SEL29 = ((XBARA1_SEL29 & ~(0x00ff)) | (x))
#define XBAR1_OUT59(x)                  XBARA1_SEL29 = ((XBARA1_SEL29 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT60(x)                  XBARA1_SEL30 = ((XBARA1_SEL30 & ~(0x00ff)) | (x))
#define XBAR1_OUT61(x)                  XBARA1_SEL30 = ((XBARA1_SEL30 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT62(x)                  XBARA1_SEL31 = ((XBARA1_SEL31 & ~(0x00ff)) | (x))
#define XBAR1_OUT63(x)                  XBARA1_SEL31 = ((XBARA1_SEL31 & ~(0xff00)) | (x << 8))
#define XBAR1_OUT64(x)                  XBARA1_SEL32 = ((XBARA1_SEL32 & ~(0x00ff)) | (x))

#define XBAR1_IOMUX_XBAR_OUT04(x)       XBAR1_OUT04(x)
#define XBAR1_IOMUX_XBAR_OUT05(x)       XBAR1_OUT05(x)
#define XBAR1_IOMUX_XBAR_OUT06(x)       XBAR1_OUT06(x)
#define XBAR1_IOMUX_XBAR_OUT07(x)       XBAR1_OUT07(x)
#define XBAR1_IOMUX_XBAR_OUT08(x)       XBAR1_OUT08(x)
#define XBAR1_IOMUX_XBAR_OUT09(x)       XBAR1_OUT09(x)
#define XBAR1_IOMUX_XBAR_OUT10(x)       XBAR1_OUT10(x)
#define XBAR1_IOMUX_XBAR_OUT11(x)       XBAR1_OUT11(x)
#define XBAR1_IOMUX_XBAR_OUT12(x)       XBAR1_OUT12(x)
#define XBAR1_IOMUX_XBAR_OUT13(x)       XBAR1_OUT13(x)
#define XBAR1_IOMUX_XBAR_OUT14(x)       XBAR1_OUT14(x)
#define XBAR1_IOMUX_XBAR_OUT15(x)       XBAR1_OUT15(x)
#define XBAR1_IOMUX_XBAR_OUT16(x)       XBAR1_OUT16(x)
#define XBAR1_IOMUX_XBAR_OUT17(x)       XBAR1_OUT17(x)
#define XBAR1_IOMUX_XBAR_OUT18(x)       XBAR1_OUT18(x)
#define XBAR1_IOMUX_XBAR_OUT19(x)       XBAR1_OUT19(x)

#define XBAR1_OUT_FLEXPWM1_FAULT0(x)    XBAR1_OUT35(x)
#define XBAR1_OUT_FLEXPWM1_FAULT1(x)    XBAR1_OUT36(x)
#define XBAR1_OUT_FLEXPWM1_FAULT2(x)    XBAR1_OUT37(x)                   // shared with FLEXPWM1,2,3,4 fault 2
#define XBAR1_OUT_FLEXPWM1_FAULT3(x)    XBAR1_OUT38(x)                   // shared with FLEXPWM1,2,3,4 fault 3
#define XBAR1_OUT_FLEXPWM2_FAULT0(x)    XBAR1_OUT49(x)
#define XBAR1_OUT_FLEXPWM2_FAULT1(x)    XBAR1_OUT50(x)
#define XBAR1_OUT_FLEXPWM2_FAULT2(x)    XBAR1_OUT37(x)
#define XBAR1_OUT_FLEXPWM2_FAULT3(x)    XBAR1_OUT38(x)
#define XBAR1_OUT_FLEXPWM3_FAULT0(x)    XBAR1_OUT56(x)
#define XBAR1_OUT_FLEXPWM3_FAULT1(x)    XBAR1_OUT57(x)
#define XBAR1_OUT_FLEXPWM3_FAULT2(x)    XBAR1_OUT37(x)
#define XBAR1_OUT_FLEXPWM3_FAULT3(x)    XBAR1_OUT38(x)
#define XBAR1_OUT_FLEXPWM4_FAULT0(x)    XBAR1_OUT63(x)
#define XBAR1_OUT_FLEXPWM4_FAULT1(x)    XBAR1_OUT64(x)
#define XBAR1_OUT_FLEXPWM4_FAULT2(x)    XBAR1_OUT37(x)
#define XBAR1_OUT_FLEXPWM4_FAULT3(x)    XBAR1_OUT38(x)

#define XBAR2_OUT00(x)                  XBARB2_SEL0 = ((XBARB2_SEL0 & ~(0x00ff)) | (x))
#define XBAR2_OUT01(x)                  XBARB2_SEL0 = ((XBARB2_SEL0 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT02(x)                  XBARB2_SEL1 = ((XBARB2_SEL1 & ~(0x00ff)) | (x))
#define XBAR2_OUT03(x)                  XBARB2_SEL1 = ((XBARB2_SEL1 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT04(x)                  XBARB2_SEL2 = ((XBARB2_SEL2 & ~(0x00ff)) | (x))
#define XBAR2_OUT05(x)                  XBARB2_SEL2 = ((XBARB2_SEL2 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT06(x)                  XBARB2_SEL3 = ((XBARB2_SEL3 & ~(0x00ff)) | (x))
#define XBAR2_OUT07(x)                  XBARB2_SEL3 = ((XBARB2_SEL3 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT08(x)                  XBARB2_SEL4 = ((XBARB2_SEL4 & ~(0x00ff)) | (x))
#define XBAR2_OUT09(x)                  XBARB2_SEL4 = ((XBARB2_SEL4 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT10(x)                  XBARB2_SEL5 = ((XBARB2_SEL5 & ~(0x00ff)) | (x))
#define XBAR2_OUT11(x)                  XBARB2_SEL5 = ((XBARB2_SEL5 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT12(x)                  XBARB2_SEL6 = ((XBARB2_SEL6 & ~(0x00ff)) | (x))
#define XBAR2_OUT13(x)                  XBARB2_SEL6 = ((XBARB2_SEL6 & ~(0xff00)) | (x << 8))
#define XBAR2_OUT14(x)                  XBARB2_SEL7 = ((XBARB2_SEL7 & ~(0x00ff)) | (x))
#define XBAR2_OUT15(x)                  XBARB2_SEL7 = ((XBARB2_SEL7 & ~(0xff00)) | (x << 8))

#define XBAR2_OUT_AOI1_IN00(x)          XBAR2_OUT00(x)
#define XBAR2_OUT_AOI1_IN01(x)          XBAR2_OUT01(x)
#define XBAR2_OUT_AOI1_IN02(x)          XBAR2_OUT02(x)
#define XBAR2_OUT_AOI1_IN03(x)          XBAR2_OUT03(x)
#define XBAR2_OUT_AOI1_IN04(x)          XBAR2_OUT04(x)
#define XBAR2_OUT_AOI1_IN05(x)          XBAR2_OUT05(x)
#define XBAR2_OUT_AOI1_IN06(x)          XBAR2_OUT06(x)
#define XBAR2_OUT_AOI1_IN07(x)          XBAR2_OUT07(x)
#define XBAR2_OUT_AOI1_IN08(x)          XBAR2_OUT08(x)
#define XBAR2_OUT_AOI1_IN09(x)          XBAR2_OUT09(x)
#define XBAR2_OUT_AOI1_IN10(x)          XBAR2_OUT10(x)
#define XBAR2_OUT_AOI1_IN11(x)          XBAR2_OUT11(x)
#define XBAR2_OUT_AOI1_IN12(x)          XBAR2_OUT12(x)
#define XBAR2_OUT_AOI1_IN13(x)          XBAR2_OUT13(x)
#define XBAR2_OUT_AOI1_IN14(x)          XBAR2_OUT14(x)
#define XBAR2_OUT_AOI1_IN15(x)          XBAR2_OUT15(x)

#define XBAR3_OUT00(x)                  XBARA3_SEL0 = ((XBARA3_SEL0 & ~(0x00ff)) | (x))
#define XBAR3_OUT01(x)                  XBARA3_SEL0 = ((XBARA3_SEL0 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT02(x)                  XBARA3_SEL1 = ((XBARA3_SEL1 & ~(0x00ff)) | (x))
#define XBAR3_OUT03(x)                  XBARA3_SEL1 = ((XBARA3_SEL1 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT04(x)                  XBARA3_SEL2 = ((XBARA3_SEL2 & ~(0x00ff)) | (x))
#define XBAR3_OUT05(x)                  XBARA3_SEL2 = ((XBARA3_SEL2 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT06(x)                  XBARA3_SEL3 = ((XBARA3_SEL3 & ~(0x00ff)) | (x))
#define XBAR3_OUT07(x)                  XBARA3_SEL3 = ((XBARA3_SEL3 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT08(x)                  XBARA3_SEL4 = ((XBARA3_SEL4 & ~(0x00ff)) | (x))
#define XBAR3_OUT09(x)                  XBARA3_SEL4 = ((XBARA3_SEL4 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT10(x)                  XBARA3_SEL5 = ((XBARA3_SEL5 & ~(0x00ff)) | (x))
#define XBAR3_OUT11(x)                  XBARA3_SEL5 = ((XBARA3_SEL5 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT12(x)                  XBARA3_SEL6 = ((XBARA3_SEL6 & ~(0x00ff)) | (x))
#define XBAR3_OUT13(x)                  XBARA3_SEL6 = ((XBARA3_SEL6 & ~(0xff00)) | (x << 8))
#define XBAR3_OUT14(x)                  XBARA3_SEL7 = ((XBARA3_SEL7 & ~(0x00ff)) | (x))
#define XBAR3_OUT15(x)                  XBARA3_SEL7 = ((XBARA3_SEL7 & ~(0xff00)) | (x << 8))

// AOI
//
#define AOI1_BFCRT010                *(unsigned short *)(AOI1_BLOCK + 0x0) // boolean function term 0 and 1 configuration register for EVENT0
    #define AOI_BFCRT_PT1_DC_0       0x0000                              // product term 1, D input configuration forces input to logical '0'
    #define AOI_BFCRT_PT1_DC_D       0x0001                              // product term 1, D input configuration passes input D
    #define AOI_BFCRT_PT1_DC_DI      0x0002                              // product term 1, D input configuration passes inverted input D
    #define AOI_BFCRT_PT1_DC_1       0x0003                              // product term 1, D input configuration forces input to logical '1'
    #define AOI_BFCRT_PT1_CC_0       0x0000                              // product term 1, C input configuration forces input to logical '0'
    #define AOI_BFCRT_PT1_CC_C       0x0004                              // product term 1, C input configuration passes input C
    #define AOI_BFCRT_PT1_CC_CI      0x0008                              // product term 1, C input configuration passes inverted input C
    #define AOI_BFCRT_PT1_CC_1       0x000c                              // product term 1, C input configuration forces input to logical '1'
    #define AOI_BFCRT_PT1_BC_0       0x0000                              // product term 1, B input configuration forces input to logical '0'
    #define AOI_BFCRT_PT1_BC_B       0x0010                              // product term 1, B input configuration passes input B
    #define AOI_BFCRT_PT1_BC_BI      0x0020                              // product term 1, B input configuration passes inverted input B
    #define AOI_BFCRT_PT1_BC_1       0x0030                              // product term 1, B input configuration forces input to logical '1'
    #define AOI_BFCRT_PT1_AC_0       0x0000                              // product term 1, A input configuration forces input to logical '0'
    #define AOI_BFCRT_PT1_AC_A       0x0040                              // product term 1, A input configuration passes input A
    #define AOI_BFCRT_PT1_AC_AI      0x0080                              // product term 1, A input configuration passes inverted input A
    #define AOI_BFCRT_PT1_AC_1       0x00c0                              // product term 1, A input configuration forces input to logical '1'
    #define AOI_BFCRT_PT0_DC_0       0x0000                              // product term 0, D input configuration forces input to logical '0'
    #define AOI_BFCRT_PT0_DC_D       0x0100                              // product term 0, D input configuration passes input D
    #define AOI_BFCRT_PT0_DC_DI      0x0200                              // product term 0, D input configuration passes inverted input D
    #define AOI_BFCRT_PT0_DC_1       0x0300                              // product term 0, D input configuration forces input to logical '1'
    #define AOI_BFCRT_PT0_CC_0       0x0000                              // product term 0, C input configuration forces input to logical '0'
    #define AOI_BFCRT_PT0_CC_C       0x0400                              // product term 0, C input configuration passes input C
    #define AOI_BFCRT_PT0_CC_CI      0x0800                              // product term 0, C input configuration passes inverted input C
    #define AOI_BFCRT_PT0_CC_1       0x0c00                              // product term 0, C input configuration forces input to logical '1'
    #define AOI_BFCRT_PT0_BC_0       0x0000                              // product term 0, B input configuration forces input to logical '0'
    #define AOI_BFCRT_PT0_BC_B       0x1000                              // product term 0, B input configuration passes input B
    #define AOI_BFCRT_PT0_BC_BI      0x2000                              // product term 0, B input configuration passes inverted input B
    #define AOI_BFCRT_PT0_BC_1       0x3000                              // product term 0, B input configuration forces input to logical '1'
    #define AOI_BFCRT_PT0_AC_0       0x0000                              // product term 0, A input configuration forces input to logical '0'
    #define AOI_BFCRT_PT0_AC_A       0x4000                              // product term 0, A input configuration passes input A
    #define AOI_BFCRT_PT0_AC_AI      0x8000                              // product term 0, A input configuration passes inverted input A
    #define AOI_BFCRT_PT0_AC_1       0xc000                              // product term 0, A input configuration forces input to logical '1'
#define AOI1_BFCRT230                 *(unsigned short *)(AOI1_BLOCK + 0x2) // boolean function term 2 and 3 configuration register for EVENT0
    #define AOI_BFCRT_PT3_DC_0       0x0000                              // product term 3, D input configuration forces input to logical '0'
    #define AOI_BFCRT_PT3_DC_D       0x0001                              // product term 3, D input configuration passes input D
    #define AOI_BFCRT_PT3_DC_DI      0x0002                              // product term 3, D input configuration passes inverted input D
    #define AOI_BFCRT_PT3_DC_1       0x0003                              // product term 3, D input configuration forces input to logical '1'
    #define AOI_BFCRT_PT3_CC_0       0x0000                              // product term 3, C input configuration forces input to logical '0'
    #define AOI_BFCRT_PT3_CC_C       0x0004                              // product term 3, C input configuration passes input C
    #define AOI_BFCRT_PT3_CC_CI      0x0008                              // product term 3, C input configuration passes inverted input C
    #define AOI_BFCRT_PT3_CC_1       0x000c                              // product term 3, C input configuration forces input to logical '1'
    #define AOI_BFCRT_PT3_BC_0       0x0000                              // product term 3, B input configuration forces input to logical '0'
    #define AOI_BFCRT_PT3_BC_B       0x0010                              // product term 3, B input configuration passes input B
    #define AOI_BFCRT_PT3_BC_BI      0x0020                              // product term 3, B input configuration passes inverted input B
    #define AOI_BFCRT_PT3_BC_1       0x0030                              // product term 3, B input configuration forces input to logical '1'
    #define AOI_BFCRT_PT3_AC_0       0x0000                              // product term 3, A input configuration forces input to logical '0'
    #define AOI_BFCRT_PT3_AC_A       0x0040                              // product term 3, A input configuration passes input A
    #define AOI_BFCRT_PT3_AC_AI      0x0080                              // product term 3, A input configuration passes inverted input A
    #define AOI_BFCRT_PT3_AC_1       0x00c0                              // product term 3, A input configuration forces input to logical '1'
    #define AOI_BFCRT_PT2_DC_0       0x0000                              // product term 2, D input configuration forces input to logical '0'
    #define AOI_BFCRT_PT2_DC_D       0x0100                              // product term 2, D input configuration passes input D
    #define AOI_BFCRT_PT2_DC_DI      0x0200                              // product term 2, D input configuration passes inverted input D
    #define AOI_BFCRT_PT2_DC_1       0x0300                              // product term 2, D input configuration forces input to logical '1'
    #define AOI_BFCRT_PT2_CC_0       0x0000                              // product term 2, C input configuration forces input to logical '0'
    #define AOI_BFCRT_PT2_CC_C       0x0400                              // product term 2, C input configuration passes input C
    #define AOI_BFCRT_PT2_CC_CI      0x0800                              // product term 2, C input configuration passes inverted input C
    #define AOI_BFCRT_PT2_CC_1       0x0c00                              // product term 2, C input configuration forces input to logical '1'
    #define AOI_BFCRT_PT2_BC_0       0x0000                              // product term 2, B input configuration forces input to logical '0'
    #define AOI_BFCRT_PT2_BC_B       0x1000                              // product term 2, B input configuration passes input B
    #define AOI_BFCRT_PT2_BC_BI      0x2000                              // product term 2, B input configuration passes inverted input B
    #define AOI_BFCRT_PT2_BC_1       0x3000                              // product term 2, B input configuration forces input to logical '1'
    #define AOI_BFCRT_PT2_AC_0       0x0000                              // product term 2, A input configuration forces input to logical '0'
    #define AOI_BFCRT_PT2_AC_A       0x4000                              // product term 2, A input configuration passes input A
    #define AOI_BFCRT_PT2_AC_AI      0x8000                              // product term 2, A input configuration passes inverted input A
    #define AOI_BFCRT_PT2_AC_1       0xc000                              // product term 2, A input configuration forces input to logical '1'
#define AOI1_BFCRT011                *(unsigned short *)(AOI1_BLOCK + 0x4) // boolean function term 0 and 1 configuration register for EVENT1
#define AOI1_BFCRT231                *(unsigned short *)(AOI1_BLOCK + 0x6) // boolean function term 2 and 3 configuration register for EVENT1
#define AOI1_BFCRT012                *(unsigned short *)(AOI1_BLOCK + 0x8) // boolean function term 0 and 1 configuration register for EVENT2
#define AOI1_BFCRT232                *(unsigned short *)(AOI1_BLOCK + 0xa) // boolean function term 2 and 3 configuration register for EVENT2
#define AOI1_BFCRT013                *(unsigned short *)(AOI1_BLOCK + 0xc) // boolean function term 0 and 1 configuration register for EVENT3
#define AOI1_BFCRT233                *(unsigned short *)(AOI1_BLOCK + 0xe) // boolean function term 2 and 3 configuration register for EVENT3

#define AOI_A_LOW                    AOI_BFCRT_PT0_AC_0
#define AOI_A_HIGH                   AOI_BFCRT_PT0_AC_1
#define AOI_A_CONNECTED              AOI_BFCRT_PT0_AC_A
#define AOI_A_INVERTED               AOI_BFCRT_PT0_AC_AI
#define AOI_B_LOW                    AOI_BFCRT_PT0_BC_0
#define AOI_B_HIGH                   AOI_BFCRT_PT0_BC_1
#define AOI_B_CONNECTED              AOI_BFCRT_PT0_BC_B
#define AOI_B_INVERTED               AOI_BFCRT_PT0_BC_BI
#define AOI_C_LOW                    AOI_BFCRT_PT0_CC_0
#define AOI_C_HIGH                   AOI_BFCRT_PT0_CC_1
#define AOI_C_CONNECTED              AOI_BFCRT_PT0_CC_C
#define AOI_C_INVERTED               AOI_BFCRT_PT0_CC_CI
#define AOI_D_LOW                    AOI_BFCRT_PT0_DC_0
#define AOI_D_HIGH                   AOI_BFCRT_PT0_DC_1
#define AOI_D_CONNECTED              AOI_BFCRT_PT0_DC_D
#define AOI_D_INVERTED               AOI_BFCRT_PT0_DC_DI

// Macro for defining an event logic
// - evt is the event number (0, 1, 2, 3)
// eg. for event 0 on AOI1
// CONFIGURE_LOGIC_AOI_EVENT(0, (AOI_A_LOW + AOI_B_HIGH + AOI_C_CONNECTED + AOI_D_INVERTED), (AOI_A_HIGH + AOI_B_LOW + AOI_C_INVERTED + AOI_D_CONNECTED)), (AOI_A_CONNECTED + AOI_B_INVERTED + AOI_C_LOW + AOI_D_HIGH), (AOI_A_INVERTED + AOI_B_CONNECTED + AOI_C_HIGH + AOI_D_LOW));
//
#define CONFIGURE_LOGIC_AOI1_EVENT(evt, a, b, c, d)   POWER_UP_ATOMIC(3, AOI1_CLOCK); AOI1_BFCRT01##evt = (unsigned short)((a) | ((b) >> 8)); AOI1_BFCRT23##evt = (unsigned short)((c) | ((d) >> 8))
#define CONFIGURE_LOGIC_AOI2_EVENT(evt, a, b, c, d)   POWER_UP_ATOMIC(1, AOI2_CLOCK); AOI2_BFCRT01##evt = (unsigned short)((a) | ((b) >> 8)); AOI2_BFCRT23##evt = (unsigned short)((c) | ((d) >> 8))

#define AOI_A_LOW                    AOI_BFCRT_PT0_AC_0
#define AOI_A_HIGH                   AOI_BFCRT_PT0_AC_1
#define AOI_A_CONNECTED              AOI_BFCRT_PT0_AC_A
#define AOI_A_INVERTED               AOI_BFCRT_PT0_AC_AI
#define AOI_B_LOW                    AOI_BFCRT_PT0_BC_0
#define AOI_B_HIGH                   AOI_BFCRT_PT0_BC_1
#define AOI_B_CONNECTED              AOI_BFCRT_PT0_BC_B
#define AOI_B_INVERTED               AOI_BFCRT_PT0_BC_BI
#define AOI_C_LOW                    AOI_BFCRT_PT0_CC_0
#define AOI_C_HIGH                   AOI_BFCRT_PT0_CC_1
#define AOI_C_CONNECTED              AOI_BFCRT_PT0_CC_C
#define AOI_C_INVERTED               AOI_BFCRT_PT0_CC_CI
#define AOI_D_LOW                    AOI_BFCRT_PT0_DC_0
#define AOI_D_HIGH                   AOI_BFCRT_PT0_DC_1
#define AOI_D_CONNECTED              AOI_BFCRT_PT0_DC_D
#define AOI_D_INVERTED               AOI_BFCRT_PT0_DC_DI


    #define PORT_PSEUDO_FLAG_SET_ONLY_PULLS       0x80000000             // not used by the port but passed when only characteristics are to be modified

    #define IOMUXC_SW_PAD_CTL_PAD_HYS             0x00010000             // hysterisis enable field
    #define IOMUXC_SW_PAD_CTL_PAD_PUS_MASK        0x0000c000             // pull-up/down configuration field
    #define IOMUXC_SW_PAD_CTL_PAD_PUS_100k_DOWN   0x00000000             // pull-up/down configuration field - 100k pull-down
    #define IOMUXC_SW_PAD_CTL_PAD_PUS_47k_UP      0x00004000             // pull-up/down configuration field - 47k pull-up
    #define IOMUXC_SW_PAD_CTL_PAD_PUS_100k_UP     0x00008000             // pull-up/down configuration field - 100k pull-up
    #define IOMUXC_SW_PAD_CTL_PAD_PUS_22k_UP      0x0000c000             // pull-up/down configuration field - 22k pull-up
    #define IOMUXC_SW_PAD_CTL_PAD_PUE             0x00002000             // pull/keep select field
    #define IOMUXC_SW_PAD_CTL_PAD_PKE             0x00001000             // pull/keep enable field
    #define IOMUXC_SW_PAD_CTL_PAD_ODE             0x00000800             // open drain enable field
    #define IOMUXC_SW_PAD_CTL_PAD_SPEED_MASK      0x000000c0             // speed field
    #define IOMUXC_SW_PAD_CTL_PAD_SPEED_LOW       0x00000000             // speed field (50MHz)
    #define IOMUXC_SW_PAD_CTL_PAD_SPEED_MEDIUM    0x00000080             // speed field (100MHz)
    #define IOMUXC_SW_PAD_CTL_PAD_SPEED_MAX       0x000000c0             // speed field (200MHz)
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_MASK        0x00000038             // drive strength field
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_DISABLED    0x00000000             // drive strength field - output driver disabled
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_1           0x00000008             // drive strength field - R0 = 260 Ohm at 3V3, 150 Ohm at 1V8, 240 Ohm for DDR
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_2           0x00000010             // drive strength field - R0/2
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_3           0x00000018             // drive strength field - R0/3
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_4           0x00000020             // drive strength field - R0/4
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_5           0x00000028             // drive strength field - R0/5
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_6           0x00000030             // drive strength field - R0/6
    #define IOMUXC_SW_PAD_CTL_PAD_DSE_7           0x00000038             // drive strength field - R0/7
    #define IOMUXC_SW_PAD_CTL_PAD_SRE             0x00000001             // slew rate field

    #define IOMUXC_SW_MUX_CTL_PAD_SION            0x00000010             // software input on field (force input path to pad)
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0   0x00000000             // MUX mode select field - ALT0
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1   0x00000001             // MUX mode select field - ALT1
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2   0x00000002             // MUX mode select field - ALT2
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3   0x00000003             // MUX mode select field - ALT3
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4   0x00000004             // MUX mode select field - ALT4
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5   0x00000005             // MUX mode select field - ALT5
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_GPIO   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6   0x00000006             // MUX mode select field - ALT6
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7   0x00000007             // MUX mode select field - ALT7
  #if defined iMX_RT106X
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8   0x00000008             // MUX mode select field - ALT8
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9   0x00000009             // MUX mode select field - ALT9
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_MASK   0x0000000f             // MUX mode select field
  #else
    #define IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_MASK   0x00000007             // MUX mode select field
  #endif
// i.MX IOMUXC SNVS GPR (only long word accesses possible)
//
#define IOMUXC_SNVS_GPR_GPR0           *(volatile unsigned long *)(IOMUXC_SNVS_GPR_BLOCK + 0x0000) // GPR0 general purpose register (reserved)
#define IOMUXC_SNVS_GPR_GPR1           *(volatile unsigned long *)(IOMUXC_SNVS_GPR_BLOCK + 0x0004) // GPR1 general purpose register (reserved)
#define IOMUXC_SNVS_GPR_GPR2           *(volatile unsigned long *)(IOMUXC_SNVS_GPR_BLOCK + 0x0008) // GPR2 general purpose register (reserved)
#define IOMUXC_SNVS_GPR_GPR3           *(volatile unsigned long *)(IOMUXC_SNVS_GPR_BLOCK + 0x000c) // GPR3 general purpose register
    #define IOMUXC_SNVS_GPR_GPR3_LPSR_MODE_ENABLE       0x00000001       // low power state retention mode enable
    #define IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR   0x00000002       // DCDC captured status clear (write '1' to clear DCDC error flags)
    #define IOMUXC_SNVS_GPR_GPR3_POR_PULL_TYPE          0x0000000c       // POR_B pad control
    #define IOMUXC_SNVS_GPR_GPR3_DCDC_IN_LOW_VOL        0x00010000       // DCDC_IN low voltage detect (read-only - cleared with IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR)
    #define IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_CUR          0x00020000       // DCDC output over current alert (read-only - cleared with IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR)
    #define IOMUXC_SNVS_GPR_GPR3_DCDC_OVER_VOL          0x00040000       // DCDC output over voltage alert (read-only - cleared with IOMUXC_SNVS_GPR_GPR3_DCDC_STATUS_CAPT_CLR)
    #define IOMUXC_SNVS_GPR_GPR3_DCDC_STS_DC_OK         0x00080000       // DCDC status OK (read-only)

// i.MX IOMUXC SNVS
//
#if defined iMX_RT1011
    #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_ADD (unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0000) // SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX control register address
    #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ    *(unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0000) // SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX control register
        #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION (IOMUXC_SW_MUX_CTL_PAD_SION)
        #define PAD_PMIC_ON_REQ_SNVS_LP_PMIC_ON_REQ    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define PAD_PMIC_ON_REQ_GPIO5_IO00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE      *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0004) // SW_PAD_CTL_PAD_TEST_MODE SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B          *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x008) // SW_PAD_CTL_PAD_POR_B SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF          *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x000c) // SW_PAD_CTL_PAD_ONOFF SW PAD control register 
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ_ADD (volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0010) // SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD control register address
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ    *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0010) // SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD control register
#else
    #define IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_ADD     (unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0000)
    #define IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP         *(unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0000) // SW_MUX_CTL_PAD_WAKEUP SW MUX control register
        #define IOMUXC_SNVS_SW_MUX_CTL_PAD_WAKEUP_SION (IOMUXC_SW_MUX_CTL_PAD_SION)
        #define PAD_WAKEUP_GPIO5_IO00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define PAD_WAKEUP_NMI_GLUE_NMI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ    *(unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0004) // SW_MUX_CTL_PAD_PMIC_ON_REQ SW MUX control register
        #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_ON_REQ_SION (IOMUXC_SW_MUX_CTL_PAD_SION)
        #define PAD_PMIC_ON_REQ_SNVS_LP_PMIC_ON_REQ   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define PAD_PMIC_ON_REQ_GPIO5_IO01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ  *(unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0008) // SW_MUX_CTL_PAD_PMIC_STBY_REQ SW MUX control register
        #define IOMUXC_SNVS_SW_MUX_CTL_PAD_PMIC_STBY_REQ_SION (IOMUXC_SW_MUX_CTL_PAD_SION)
        #define PAD_PMIC_STBY_REQ_CCM_PMIC_VSTBY_REQ  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define PAD_PMIC_STBY_REQ_GPIO5_IO02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_TEST_MODE      *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x000c) // SW_PAD_CTL_PAD_TEST_MODE SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_POR_B          *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0010) // SW_PAD_CTL_PAD_POR_B SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_ONOFF          *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0014) // SW_PAD_CTL_PAD_ONOFF SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP_ADD     (unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0018)
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_WAKEUP         *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0018) // SW_PAD_CTL_PAD_WAKEUP SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_ON_REQ    *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x001c) // SW_PAD_CTL_PAD_PMIC_ON_REQ SW PAD control register
    #define IOMUXC_SNVS_SW_PAD_CTL_PAD_PMIC_STBY_REQ  *(volatile unsigned long *)(IOMUXC_SNVS_BLOCK + 0x0020) // SW_PAD_CTL_PAD_PMIC_STBY_REQ SW PAD control register
#endif

// i.MX IOMUXC
//
#define IOMUXC_GPR_GPR0                 *(unsigned long *)(IOMUXC_BLOCK + 0x0000) // GPR0 general purpose register
#define IOMUXC_GPR_GPR1                 *(unsigned long *)(IOMUXC_BLOCK + 0x0004) // GPR1 general purpose register
    #define IOMUXC_GPR_GPR1_CM7_FORCE_HCLK_EN      0x80000000            // ARM CM7 platform clock enable (AHB clock enabled)
    #define IOMUXC_GPR_GPR1_ENET_IPG_CLK_S_EN      0x00800000            // ENET ipg_clk_s clock gating enable
    #define IOMUXC_GPR_GPR1_EXC_MON                0x00400000            // exclusive monitor response select of illegal command
    #define IOMUXC_GPR_GPR1_SAI3_MCLK_DIR          0x00200000            // sai3.MCLK signal direction control
    #define IOMUXC_GPR_GPR1_SAI2_MCLK_DIR          0x00100000            // sai2.MCLK signal direction control
    #define IOMUXC_GPR_GPR1_SAI1_MCLK_DIR          0x00080000            // sai1.MCLK signal direction control
    #define IOMUXC_GPR_GPR1_ENET1_TX_CLK_DIR       0x00020000            // ENET1_TX_CLK data direction control
    #define IOMUXC_GPR_GPR1_USB_EXP_MODE           0x00008000            // USB exposure mode
    #define IOMUXC_GPR_GPR1_ENET1_CLK_SEL          0x00002000            // ENET1 reference clock mode select
    #define IOMUXC_GPR_GPR1_GINT                   0x00001000            // global interrupt bit (connected to ARM M7 IRQ#41)
    #define IOMUXC_GPR_GPR1_SAI3_MCLK3_SEL         0x00000c00            // SAI3 MCLK3 source select
    #define IOMUXC_GPR_GPR1_SAI2_MCLK3_SEL         0x00000300            // SAI2 MCLK3 source select
    #define IOMUXC_GPR_GPR1_SAI1_MCLK3_SEL         0x000000c0            // SAI1 MCLK3 source select
    #define IOMUXC_GPR_GPR1_SAI1_MCLK2_SEL         0x00000038            // SAI1 MCLK2 source select
    #define IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL         0x00000007            // SAI1 MCLK1 source select
#define IOMUXC_GPR_GPR2                 *(unsigned long *)(IOMUXC_BLOCK + 0x0008) // GPR2 general purpose register
    #define IOMUXC_GPR_GPR2_QTIMER2_TMR_CNTS_FREEZE  0x20000000          // QTIMER2 timer counter freeze
    #define IOMUXC_GPR_GPR2_QTIMER1_TMR_CNTS_FREEZE  0x10000000          // QTIMER1 timer counter freeze
    #define IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_32      0x0000000             // PWM x32 oversampling rate compared with mclk
    #define IOMUXC_GPR_GPR2_MQS_OVERSAMPLE_64      0x0400000             // PWM x64 oversampling rate compared with mclk
    #define IOMUXC_GPR_GPR2_MQS_EN                 0x02000000            // enable MQS
    #define IOMUXC_GPR_GPR2_MQS_SW_RST             0x01000000            // MQS software reset
    #define IOMUXC_GPR_GPR2_MQS_CLK_DIV            0x00ff0000            // divider ratio control for mclk from hmclk. mclk frequency = 1/(n+1) * hmclk frequency
    #define IOMUXC_GPR_GPR2_L2_MEM_DEEPSLEEP       0x00004000            // force memory into deep sleep mode
    #define IOMUXC_GPR_GPR2_RAM_AUTO_CLK_GATING_EN   0x00002000          // enable automatically gate off RAM clock
    #define IOMUXC_GPR_GPR2_L2_MEM_EN_POWERSAVING    0x00001000          // memory power saving features enabled [SHUTDOWN/DEEPSLEEP/LIGHTSLEEP]
#define IOMUXC_GPR_GPR3                 *(volatile unsigned long *)(IOMUXC_BLOCK + 0x000c) // GPR3 general purpose register
    #define IOMUXC_GPR_GPR3_OCRAM_STATUS           0x000f0000            // OCRAM pipeline settings status (read-only)
    #define IOMUXC_GPR_GPR3_DCP_KEY_SEL_LO         0x00000000            // select [127:0] from snvs/ocotp key as dcp key
    #define IOMUXC_GPR_GPR3_DCP_KEY_SEL_HI         0x00000010            // select [255:128] from snvs/ocotp key as dcp key
    #define IOMUXC_GPR_GPR3_OCRAM_CTL_WAPL         0x00000008            // write address pipeline is enabled
    #define IOMUXC_GPR_GPR3_OCRAM_CTL_WDPL         0x00000004            // write data pipeline is enabled
    #define IOMUXC_GPR_GPR3_OCRAM_CTL_RAPL         0x00000002            // read address pipeline is enabled
    #define IOMUXC_GPR_GPR3_OCRAM_CTL_RDPL         0x00000001            // read data pipeline is enabled
#define IOMUXC_GPR_GPR4                 *(volatile unsigned long *)(IOMUXC_BLOCK + 0x0010) // GPR4 general purpose register
    #define IOMUXC_GPR_GPR4_FLEXIO1_STOP_ACK       0x10000000            // FLEXIO1 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_FLEXSPI_STOP_ACK       0x08000000            // FLEXSPI stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_PIT_STOP_ACK           0x04000000            // PIT stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_SEMC_STOP_ACK          0x02000000            // SEMC stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_SAI3_STOP_ACK          0x00800000            // SAI3 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_SAI2_STOP_ACK          0x00400000            // SAI2 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_SAI1_STOP_ACK          0x00200000            // SAI1 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_ENET_STOP_ACK          0x00100000            // ENET stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_TRNG_STOP_ACK          0x00080000            // TRNG stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_CAN2_STOP_ACK          0x00040000            // CAN2 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_CAN1_STOP_ACK          0x00020000            // CAN1 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR4_EDMA_STOP_ACK          0x00010000            // EDMA stop acknowledge is asserted [eDMA is in STOP mode] (read-only)
    #define IOMUXC_GPR_GPR4_FLEXIO1_STOP_REQ       0x00001000            // FLEXIO1 stop request on
    #define IOMUXC_GPR_GPR4_FLEXSPI_STOP_REQ       0x00000800            // FLEXSPI stop request on
    #define IOMUXC_GPR_GPR4_PIT_STOP_REQ           0x00000400            // PIT stop request on 
    #define IOMUXC_GPR_GPR4_SEMC_STOP_REQ          0x00000200            // SEMC stop request on 
    #define IOMUXC_GPR_GPR4_SAI3_STOP_REQ          0x00000080            // SAI3 stop request on 
    #define IOMUXC_GPR_GPR4_SAI2_STOP_REQ          0x00000040            // SAI2 stop request on 
    #define IOMUXC_GPR_GPR4_SAI1_STOP_REQ          0x00000020            // SAI1 stop request on 
    #define IOMUXC_GPR_GPR4_ENET_STOP_REQ          0x00000010            // ENET stop request on 
    #define IOMUXC_GPR_GPR4_TRNG_STOP_REQ          0x00000008            // TRNG stop request on 
    #define IOMUXC_GPR_GPR4_CAN2_STOP_REQ          0x00000004            // CAN2 stop request on 
    #define IOMUXC_GPR_GPR4_CAN1_STOP_REQ          0x00000002            // CAN1 stop request on 
    #define IOMUXC_GPR_GPR4_EDMA_STOP_REQ          0x00000001            // EDMA stop request on
#define IOMUXC_GPR_GPR5                 *(unsigned long *)(IOMUXC_BLOCK + 0x0014) // GPR5 general purpose register
    #define IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT2       0x20000000            // GPT2 ipg_clk_highfreq driven by anatop 1 MHz clock (rather than by IPG_PERCLK)
    #define IOMUXC_GPR_GPR5_VREF_1M_CLK_GPT1       0x10000000            // GPT1 ipg_clk_highfreq driven by anatop 1 MHz clock (rather than by IPG_PERCLK)
    #define IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL_ENET 0x0o000000            // ENET input timer event3 source input from ENET_1588_EVENT3_IN
    #define IOMUXC_GPR_GPR5_ENET_EVENT3IN_SEL_GPT2 0x02000000            // ENET input timer event3 source input from GPT2.GPT_COMPARE1
    #define IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL_GPT2   0x00000000            // GPT2 input capture channel 1 source from GPT2_CAPTURE1
    #define IOMUXC_GPR_GPR5_GPT2_CAPIN1_SEL_ENET   0x00800000            // GPT2 input capture channel 1 source from ENET_1588_EVENT3_OUT (channel 3 of IEEE 1588 timer)
    #define IOMUXC_GPR_GPR5_WDOG2_MASK             0x00000080            // WDOG2 timeout is masked
    #define IOMUXC_GPR_GPR5_WDOG1_MASK             0x00000040            // WDOG1 timeout is masked
#define IOMUXC_GPR_GPR6                 *(unsigned long *)(IOMUXC_BLOCK + 0x0018) // GPR6 general purpose register
    #if defined iMX_RT1011
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_3  0x00020000        // IOMUXC XBAR_INOUT3 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_2  0x00010000        // IOMUXC XBAR_INOUT2 select as output (rather than as input)
    #else
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_19 0x80000000        // IOMUXC XBAR_INOUT19 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_18 0x40000000        // IOMUXC XBAR_INOUT18 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_17 0x20000000        // IOMUXC XBAR_INOUT17 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_16 0x10000000        // IOMUXC XBAR_INOUT16 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_15 0x08000000        // IOMUXC XBAR_INOUT15 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_14 0x04000000        // IOMUXC XBAR_INOUT14 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_13 0x02000000        // IOMUXC XBAR_INOUT13 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_12 0x01000000        // IOMUXC XBAR_INOUT12 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_11 0x00800000        // IOMUXC XBAR_INOUT11 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_10 0x00400000        // IOMUXC XBAR_INOUT10 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_9  0x00200000        // IOMUXC XBAR_INOUT9 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_8  0x00100000        // IOMUXC XBAR_INOUT8 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_7  0x00080000        // IOMUXC XBAR_INOUT7 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_6  0x00040000        // IOMUXC XBAR_INOUT6 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_5  0x00020000        // IOMUXC XBAR_INOUT5 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_IOMUXC_XBAR_DIR_SEL_4  0x00010000        // IOMUXC XBAR_INOUT4 select as output (rather than as input)
        #define IOMUXC_GPR_GPR6_QTIMER2_TRM3_INPUT_SEL 0x00000080        // QTIMER2 TMR3 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER2_TRM2_INPUT_SEL 0x00000040        // QTIMER2 TMR2 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER2_TRM1_INPUT_SEL 0x00000020        // QTIMER2 TMR1 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER2_TRM0_INPUT_SEL 0x00000010        // QTIMER2 TMR0 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER1_TRM3_INPUT_SEL 0x00000008        // QTIMER1 TMR3 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER1_TRM2_INPUT_SEL 0x00000004        // QTIMER1 TMR2 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER1_TRM1_INPUT_SEL 0x00000002        // QTIMER1 TMR1 input from XBAR (rather than from IOMUX)
        #define IOMUXC_GPR_GPR6_QTIMER1_TRM0_INPUT_SEL 0x00000001        // QTIMER1 TMR0 input from XBAR (rather than from IOMUX)
    #endif
#define IOMUXC_GPR_GPR7                 *(volatile unsigned long *)(IOMUXC_BLOCK + 0x001c) // GPR7 general purpose register
    #define IOMUXC_GPR_GPR7_LPUART8_STOP_ACK       0x80000000            // LPUART8 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART7_STOP_ACK       0x40000000            // LPUART7 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART6_STOP_ACK       0x20000000            // LPUART6 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART5_STOP_ACK       0x10000000            // LPUART5 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART4_STOP_ACK       0x08000000            // LPUART4 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART3_STOP_ACK       0x04000000            // LPUART3 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART2_STOP_ACK       0x02000000            // LPUART2 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART1_STOP_ACK       0x01000000            // LPUART1 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPSPI4_STOP_ACK        0x00800000            // LPSPI4 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPSPI3_STOP_ACK        0x00400000            // LPSPI3 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPSPI2_STOP_ACK        0x00200000            // LPSPI2 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPSPI1_STOP_ACK        0x00100000            // LPSPI1 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPI2C4_STOP_ACK        0x00080000            // LPI2C4 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPI2C3_STOP_ACK        0x00040000            // LPI2C3 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPI2C2_STOP_ACK        0x00020000            // LPI2C2 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPI2C1_STOP_ACK        0x00010000            // LPI2C1 stop acknowledge is asserted (read-only)
    #define IOMUXC_GPR_GPR7_LPUART8_STOP_REQ       0x00008000            // LPUART8 stop request on
    #define IOMUXC_GPR_GPR7_LPUART7_STOP_REQ       0x00004000            // LPUART7 stop request on
    #define IOMUXC_GPR_GPR7_LPUART6_STOP_REQ       0x00002000            // LPUART6 stop request on
    #define IOMUXC_GPR_GPR7_LPUART5_STOP_REQ       0x00001000            // LPUART5 stop request on
    #define IOMUXC_GPR_GPR7_LPUART4_STOP_REQ       0x00000800            // LPUART4 stop request on
    #define IOMUXC_GPR_GPR7_LPUART3_STOP_REQ       0x00000400            // LPUART3 stop request on 
    #define IOMUXC_GPR_GPR7_LPUART2_STOP_REQ       0x00000200            // LPUART2 stop request on 
    #define IOMUXC_GPR_GPR7_LPUART1_STOP_REQ       0x00000100            // LPUART1 stop request on
    #define IOMUXC_GPR_GPR7_LPSPI4_STOP_REQ        0x00000080            // LPSPI4 stop request on 
    #define IOMUXC_GPR_GPR7_LPSPI3_STOP_REQ        0x00000040            // LPSPI3 stop request on 
    #define IOMUXC_GPR_GPR7_LPSPI2_STOP_REQ        0x00000020            // LPSPI2 stop request on 
    #define IOMUXC_GPR_GPR7_LPSPI1_STOP_REQ        0x00000010            // LPSPI1 stop request on 
    #define IOMUXC_GPR_GPR7_LPI2C4_STOP_REQ        0x00000008            // LPI2C4 stop request on 
    #define IOMUXC_GPR_GPR7_LPI2C3_STOP_REQ        0x00000004            // LPI2C3 stop request on 
    #define IOMUXC_GPR_GPR7_LPI2C2_STOP_REQ        0x00000002            // LPI2C2 stop request on 
    #define IOMUXC_GPR_GPR7_LPI2C1_STOP_REQ        0x00000001            // LPI2C1 stop request on
#define IOMUXC_GPR_GPR8                 *(unsigned long *)(IOMUXC_BLOCK + 0x0020) // GPR8 general purpose register
    #define IOMUXC_GPR_GPR8_LPUART8_IPG_DOZE       0x80000000            // LPUART8 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART8_IPG_STOP_MODE  0x40000000            // LPUART8 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART7_IPG_DOZE       0x20000000            // LPUART7 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART7_IPG_STOP_MODE  0x10000000            // LPUART7 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART6_IPG_DOZE       0x08000000            // LPUART6 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART6_IPG_STOP_MODE  0x04000000            // LPUART6 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART5_IPG_DOZE       0x02000000            // LPUART5 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART5_IPG_STOP_MODE  0x01000000            // LPUART5 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART4_IPG_DOZE       0x00800000            // LPUART4 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART4_IPG_STOP_MODE  0x00400000            // LPUART4 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART3_IPG_DOZE       0x00200000            // LPUART3 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART3_IPG_STOP_MODE  0x00100000            // LPUART3 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART2_IPG_DOZE       0x00080000            // LPUART2 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART2_IPG_STOP_MODE  0x00040000            // LPUART2 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPUART1_IPG_DOZE       0x00020000            // LPUART1 in doze mode
    #define IOMUXC_GPR_GPR8_LPUART1_IPG_STOP_MODE  0x00010000            // LPUART1 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPSPI4_IPG_DOZE        0x00008000            // LPSPI4 in doze mode
    #define IOMUXC_GPR_GPR8_LPSPI4_IPG_STOP_MODE   0x00004000            // LPSPI4 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPSPI3_IPG_DOZE        0x00002000            // LPSPI3 in doze mode
    #define IOMUXC_GPR_GPR8_LPSPI3_IPG_STOP_MODE   0x00001000            // LPSPI3 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPSPI2_IPG_DOZE        0x00000800            // LPSPI2 in doze mode
    #define IOMUXC_GPR_GPR8_LPSPI2_IPG_STOP_MODE   0x00000400            // LPSPI2 not functional in stop mode 
    #define IOMUXC_GPR_GPR8_LPSPI1_IPG_DOZE        0x00000200            // LPSPI1 in doze mode 
    #define IOMUXC_GPR_GPR8_LPSPI1_IPG_STOP_MODE   0x00000100            // LPSPI1 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPI2C4_IPG_DOZE        0x00000080            // LPI2C4 in doze mode
    #define IOMUXC_GPR_GPR8_LPI2C4_IPG_STOP_MODE   0x00000040            // LPI2C4 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPI2C3_IPG_DOZE        0x00000020            // LPI2C3 in doze mode
    #define IOMUXC_GPR_GPR8_LPI2C3_IPG_STOP_MODE   0x00000010            // LPI2C3 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPI2C2_IPG_DOZE        0x00000008            // LPI2C2 in doze mode
    #define IOMUXC_GPR_GPR8_LPI2C2_IPG_STOP_MODE   0x00000004            // LPI2C2 not functional in stop mode
    #define IOMUXC_GPR_GPR8_LPI2C1_IPG_DOZE        0x00000002            // LPI2C1 in doze mode
    #define IOMUXC_GPR_GPR8_LPI2C1_IPG_STOP_MODE   0x00000001            // LPI2C1 not functional in stop mode
#define IOMUXC_GPR_GPR9                 *(unsigned long *)(IOMUXC_BLOCK + 0x0024) // GPR9 general purpose register (reserved)
#define IOMUXC_GPR_GPR10                *(unsigned long *)(IOMUXC_BLOCK + 0x0028) // GPR10 general purpose register
    #define IOMUXC_GPR_GPR10_NIDEN                 0x00000001            // ARM non-secure (non-invasive) debug enable
    #define IOMUXC_GPR_GPR10_DBG_EN                0x00000002            // ARM invasive debug enable 
    #define IOMUXC_GPR_GPR10_SEC_ERR_RESP          0x00000004            // security error response enable for all security gaskets
    #define IOMUXC_GPR_GPR10_DCPKEY_KEYMUX         0x00000000            // DCD key selection from key MUX (SNVS/OTPMK)
    #define IOMUXC_GPR_GPR10_DCPKEY_OCOTP          0x00000010            // DCD key selection from OCOTP (SW_GP2)
    #define IOMUXC_GPR_GPR10_LOCK_DCPKEY           0x00100000            // lock IOMUXC_GPR_GPR10_DCPKEY_OCOTP field (sticky - cleared only by reset)
#define IOMUXC_GPR_GPR11_ADD            (volatile unsigned long *)(IOMUXC_BLOCK + 0x002c)
#define IOMUXC_GPR_GPR11                *(volatile unsigned long *)(IOMUXC_BLOCK + 0x002c) // GPR11 general purpose register
    #define IOMUXC_GPR_GPR11_M7_APC_AC_R0_CTRL     0x00000001            // access of control of memory region-0 - M7 debug protection enabled
    #define IOMUXC_GPR_GPR11_M7_APC_AC_R1_CTRL     0x00000004            // access of control of memory region-1 - M7 debug protection enabled
    #define IOMUXC_GPR_GPR11_M7_APC_AC_R2_CTRL     0x00000010            // access of control of memory region-2 - M7 debug protection enabled
    #define IOMUXC_GPR_GPR11_M7_APC_AC_R3_CTRL     0x00000040            // access of control of memory region-3 - M7 debug protection enabled
#if !defined iMX_RT1011
        #define IOMUXC_GPR_GPR11_BEE_DE_RX_EN_0    0x00000100            // flexSPI data decryption enabled in memory region-0
        #define IOMUXC_GPR_GPR11_BEE_DE_RX_EN_1    0x00000200            // flexSPI data decryption enabled in memory region-1
        #define IOMUXC_GPR_GPR11_BEE_DE_RX_EN_2    0x00000400            // flexSPI data decryption enabled in memory region-2
        #define IOMUXC_GPR_GPR11_BEE_DE_RX_EN_3    0x00000800            // flexSPI data decryption enabled in memory region-3
#endif
    #define IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R0_CTRL 0x00010000           // lock M7_APC_AC_R0_CTRL for changes (sticky - only cleared by reset)
    #define IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R1_CTRL 0x00040000           // lock M7_APC_AC_R1_CTRL for changes (sticky - only cleared by reset)
    #define IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R2_CTRL 0x00100000           // lock M7_APC_AC_R2_CTRL for changes (sticky - only cleared by reset)
    #define IOMUXC_GPR_GPR11_LOCK_M7_APC_AC_R3_CTRL 0x00400000           // lock M7_APC_AC_R3_CTRL for changes (sticky - only cleared by reset)
#if !defined iMX_RT1011
        #define IOMUXC_GPR_GPR11_LOCK_BEE_DE_RX_EN_0 0x01000000          // lock BEE_DE_RX_EN_0 for changes (sticky - only cleared by reset)
        #define IOMUXC_GPR_GPR11_LOCK_BEE_DE_RX_EN_1 0x02000000          // lock BEE_DE_RX_EN_1 for changes (sticky - only cleared by reset)
        #define IOMUXC_GPR_GPR11_LOCK_BEE_DE_RX_EN_2 0x04000000          // lock BEE_DE_RX_EN_2 for changes (sticky - only cleared by reset)
        #define IOMUXC_GPR_GPR11_LOCK_BEE_DE_RX_EN_3 0x08000000          // lock BEE_DE_RX_EN_3 for changes (sticky - only cleared by reset)
#endif
#define IOMUXC_GPR_GPR12                *(unsigned long *)(IOMUXC_BLOCK + 0x0030) // GPR12 general purpose register
#define IOMUXC_GPR_GPR13                *(unsigned long *)(IOMUXC_BLOCK + 0x0034) // GPR13 general purpose register
#define IOMUXC_GPR_GPR14                *(unsigned long *)(IOMUXC_BLOCK + 0x0038) // GPR14 general purpose register
    #define IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_DN 0x00000001           // reduce ACMP1 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_DN 0x00000002           // reduce ACMP2 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_DN 0x00000004           // reduce ACMP3 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_DN 0x00000008           // reduce ACMP4 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP1_CMP_IGEN_TRIM_UP 0x00000010           // increase ACMP1 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP2_CMP_IGEN_TRIM_UP 0x00000020           // increase ACMP2 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP3_CMP_IGEN_TRIM_UP 0x00000040           // increase ACMP3 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP4_CMP_IGEN_TRIM_UP 0x00000080           // increase ACMP4 internal bias current by 30%
    #define IOMUXC_GPR_GPR14_ACMP1_SAMPLE_SYNC_EN   0x00000100           // ACMP1 sample select synced sample_lv instead of XBAR output
    #define IOMUXC_GPR_GPR14_ACMP2_SAMPLE_SYNC_EN   0x00000200           // ACMP2 sample select synced sample_lv instead of XBAR output
    #define IOMUXC_GPR_GPR14_ACMP3_SAMPLE_SYNC_EN   0x00000400           // ACMP3 sample select synced sample_lv instead of XBAR output
    #define IOMUXC_GPR_GPR14_ACMP4_SAMPLE_SYNC_EN   0x00000800           // ACMP4 sample select synced sample_lv instead of XBAR output
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_0        0x00000000           // no ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_4K       0x00030000           // 4k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_8K       0x00040000           // 8k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_16K      0x00050000           // 16k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_32K      0x00060000           // 32k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_64K      0x00070000           // 64k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_128K     0x00080000           // 128k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_256K     0x00090000           // 256k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_512K     0x000a0000           // 512k ITCM
    #define IOMUXC_GPR_GPR14_CM7_CFGITCMSZ_MASK     0x000f0000           // ITC memory size mask
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_0        0x00000000           // no DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_4K       0x00300000           // 4k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_8K       0x00400000           // 8k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_16K      0x00500000           // 16k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_32K      0x00600000           // 32k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_64K      0x00700000           // 64k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_128K     0x00800000           // 128k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_256K     0x00900000           // 256k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_512K     0x00a00000           // 512k DTCM
    #define IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ_MASK     0x00f00000           // DTC memory size mask
#define IOMUXC_GPR_GPR15                *(unsigned long *)(IOMUXC_BLOCK + 0x003c) // GPR15 general purpose register (reserved)
#define IOMUXC_GPR_GPR16_ADD            (unsigned long *)(IOMUXC_BLOCK + 0x0040)
#define IOMUXC_GPR_GPR16                *(volatile unsigned long *)(IOMUXC_BLOCK + 0x0040) // GPR16 general purpose register
    #define IOMUXC_GPR_GPR16_INIT_ITCM_EN           0x00000001           // ITCM enabled (IOMUXC_GPR_GPR14_CM7_CFGITCMSZ may not be 0 when enabled)
    #define IOMUXC_GPR_GPR16_INIT_DTCM_EN           0x00000002           // DTCM enabled (IOMUXC_GPR_GPR14_CM7_CFGDTCMSZ may not be 0 when enabled)
    #define IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_FUSE  0x00000000       // use fuse value to select configuration
    #define IOMUXC_GPR_GPR16_FLEXRAM_BANK_CFG_SEL_CFG   0x00000004       // use FLEXRAM_BANK_CFG to select configuration
    #define IOMUXC_GPR_GPR16_RESERVED               0x00200000
#define IOMUXC_GPR_GPR17                *(volatile unsigned long *)(IOMUXC_BLOCK + 0x0044) // GPR17 general purpose register
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_MASK           0x0000ffff
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK0_NOT_USED 0x00000000  // bank 0 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK0_OCRAM    0x00000001  // bank 0 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK0_DTCM     0x00000002  // bank 0 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK0_ITCM     0x00000003  // bank 0 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK1_NOT_USED 0x00000000  // bank 1 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK1_OCRAM    0x00000004  // bank 1 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK1_DTCM     0x00000008  // bank 1 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK1_ITCM     0x0000000c  // bank 1 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK2_NOT_USED 0x00000000  // bank 2 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK2_OCRAM    0x00000010  // bank 2 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK2_DTCM     0x00000020  // bank 2 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK2_ITCM     0x00000030  // bank 2 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK3_NOT_USED 0x00000000  // bank 3 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK3_OCRAM    0x00000040  // bank 3 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK3_DTCM     0x00000080  // bank 3 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK3_ITCM     0x000000c0  // bank 3 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK4_NOT_USED 0x00000000  // bank 4 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK4_OCRAM    0x00000100  // bank 4 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK4_DTCM     0x00000200  // bank 4 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK4_ITCM     0x00000300  // bank 4 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK5_NOT_USED 0x00000000  // bank 5 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK5_OCRAM    0x00000400  // bank 5 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK5_DTCM     0x00000800  // bank 5 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK5_ITCM     0x00000c00  // bank 5 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK6_NOT_USED 0x00000000  // bank 6 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK6_OCRAM    0x00001000  // bank 6 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK6_DTCM     0x00002000  // bank 6 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK6_ITCM     0x00003000  // bank 6 configured as ITCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK7_NOT_USED 0x00000000  // bank 7 not used
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK7_OCRAM    0x00004000  // bank 7 configured as OCRAM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK7_DTCM     0x00008000  // bank 7 configured as DTCM
    #define IOMUXC_GPR_GPR17_FLEXRAM_BANK_CFG_BANK7_ITCM     0x0000c000  // bank 7 configured as ITCM
#define IOMUXC_GPR_GPR18_ADD            (volatile unsigned long *)(IOMUXC_BLOCK + 0x0048)
#define IOMUXC_GPR_GPR18                *(volatile unsigned long *)(IOMUXC_BLOCK + 0x0048) // GPR18 general purpose register
    #define IOMUXC_GPR_GPR18_LOCK_M7_APC_AC_R0_BOT           0x00000001 // lock M7_APC_AC_R0_BOT field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR18_M7_APC_AC_R0_BOT_MASK           0xfffffff8 // APC end address of memory region-0
#define IOMUXC_GPR_GPR19                *(volatile unsigned long *)(IOMUXC_BLOCK + 0x004c) // GPR19 general purpose register
    #define IOMUXC_GPR_GPR19_LOCK_M7_APC_AC_R0_TOP           0x00000001 // lock M7_APC_AC_R0_TOP field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR19_M7_APC_AC_R0_TOP_MASK           0xfffffff8 // APC start address of memory region-0
#define IOMUXC_GPR_GPR20                *(unsigned long *)(IOMUXC_BLOCK + 0x0050) // GPR20 general purpose register
    #define IOMUXC_GPR_GPR20_LOCK_M7_APC_AC_R1_BOT           0x00000001 // lock M7_APC_AC_R1_BOT field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR20_M7_APC_AC_R1_BOT_MASK           0xfffffff8 // APC end address of memory region-1
#define IOMUXC_GPR_GPR21                *(unsigned long *)(IOMUXC_BLOCK + 0x0054) // GPR21 general purpose register
    #define IOMUXC_GPR_GPR21_LOCK_M7_APC_AC_R0_TOP           0x00000001 // lock M7_APC_AC_R1_TOP field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR21_M7_APC_AC_R0_TOP_MASK           0xfffffff8 // APC start address of memory region-1
#define IOMUXC_GPR_GPR22                *(unsigned long *)(IOMUXC_BLOCK + 0x0058) // GPR22 general purpose register
    #define IOMUXC_GPR_GPR22_LOCK_M7_APC_AC_R2_BOT           0x00000001 // lock M7_APC_AC_R2_BOT field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR22_M7_APC_AC_R2_BOT_MASK           0xfffffff8 // APC end address of memory region-2
#define IOMUXC_GPR_GPR23                *(unsigned long *)(IOMUXC_BLOCK + 0x005c) // GPR24 general purpose register
    #define IOMUXC_GPR_GPR23_LOCK_M7_APC_AC_R2_TOP           0x00000001 // lock M7_APC_AC_R2_TOP field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR23_M7_APC_AC_R2_TOP_MASK           0xfffffff8 // APC start address of memory region-2
#define IOMUXC_GPR_GPR24                *(unsigned long *)(IOMUXC_BLOCK + 0x0060) // GPR25 general purpose register
    #define IOMUXC_GPR_GPR24_LOCK_M7_APC_AC_R3_BOT           0x00000001 // lock M7_APC_AC_R3_BOT field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR24_M7_APC_AC_R3_BOT_MASK           0xfffffff8 // APC end address of memory region-3
#define IOMUXC_GPR_GPR25                *(unsigned long *)(IOMUXC_BLOCK + 0x0064) // GPR25 general purpose register
    #define IOMUXC_GPR_GPR25_LOCK_M7_APC_AC_R3_TOP           0x00000001 // lock M7_APC_AC_R3_TOP field from changes (sticky - once set it remains set until next reset)
    #define IOMUXC_GPR_GPR25_M7_APC_AC_R3_TOP_MASK           0xfffffff8 // APC start address of memory region-3
#if defined iMX_RT106X
    #define IOMUXC_GPR_GPR26_ADD        (unsigned long *)(IOMUXC_BLOCK + 0x0068) // GPR26 general purpose register address
    #define IOMUXC_GPR_GPR26            *(unsigned long *)(IOMUXC_BLOCK + 0x0068) // GPR26 general purpose register
    #define IOMUXC_GPR_GPR27_ADD        (unsigned long *)(IOMUXC_BLOCK + 0x006c) // GPR27 general purpose register address
    #define IOMUXC_GPR_GPR27            *(unsigned long *)(IOMUXC_BLOCK + 0x006c) // GPR27 general purpose register
    #define IOMUXC_GPR_GPR28_ADD        (unsigned long *)(IOMUXC_BLOCK + 0x0070) // GPR28 general purpose register address
    #define IOMUXC_GPR_GPR28            *(unsigned long *)(IOMUXC_BLOCK + 0x0070) // GPR28 general purpose register
    #define IOMUXC_GPR_GPR29_ADD        (unsigned long *)(IOMUXC_BLOCK + 0x0074) // GPR29 general purpose register address
    #define IOMUXC_GPR_GPR29            *(unsigned long *)(IOMUXC_BLOCK + 0x0074) // GPR29 general purpose register
    #define IOMUXC_GPR_GPR30            *(unsigned long *)(IOMUXC_BLOCK + 0x0078) // GPR30 general purpose register
    #define IOMUXC_GPR_GPR31            *(unsigned long *)(IOMUXC_BLOCK + 0x007c) // GPR31 general purpose register
    #define IOMUXC_GPR_GPR32            *(unsigned long *)(IOMUXC_BLOCK + 0x0080) // GPR32 general purpose register
    #define IOMUXC_GPR_GPR33            *(unsigned long *)(IOMUXC_BLOCK + 0x0084) // GPR33 general purpose register
    #define IOMUXC_GPR_GPR34            *(unsigned long *)(IOMUXC_BLOCK + 0x0088) // GPR34 general purpose register
#endif

// SEMC
//
#if defined SEMC_AVAILABLE
    #define SEMC_MCR_ADD                (unsigned long *)(SEMC_BLOCK + 0x00)
    #define SEMC_MCR                    *(unsigned long *)(SEMC_BLOCK + 0x00) // SEMC module control register
        #define SEMC_MCR_SWRST          0x00000001                       // software reset
        #define SEMC_MCR_MDIS           0x00000002                       // module disabled
        #define SEMC_MCR_DQSMD          0x00000004                       // DQS (read strobe) mode - dummy read strobe loopbacked from DQS pad (rather than internally)
        #define SEMC_MCR_BTO_MASK       0x1f000000                       // bus timeout mask (AXI bus timeout cycle 255x2^BTO)
        #define SEMC_MCR_BTO_DEFAULT    0x10000000                       // 16711680
    #define SEMC_IOCR_ADD               (unsigned long *)(SEMC_BLOCK + 0x04)
    #define SEMC_IOCR                   *(unsigned long *)(SEMC_BLOCK + 0x04) // SEMC IO mux control register
        #define SEMC_IOCR_MUX_A8_SDRAM_A8        0x00000000              // SEMC_A8 output selection - SDRAM address bit (A8)
        #define SEMC_IOCR_MUX_A8_NAND_CE         0x00000001              // SEMC_A8 output selection - NAND CE#
        #define SEMC_IOCR_MUX_A8_NOR_CE          0x00000002              // SEMC_A8 output selection - NOR CE#
        #define SEMC_IOCR_MUX_A8_PSRAM_CE        0x00000003              // SEMC_A8 output selection - PSRAM CE#
        #define SEMC_IOCR_MUX_A8_DBI_CSX         0x00000004              // SEMC_A8 output selection - DBI CSX
        #define SEMC_IOCR_MUX_CSX0_NOR_PSRAM_A24 0x00000000              // SEMC_CSX0 output selection - NOR/PSRAM address bit (A24)
        #define SEMC_IOCR_MUX_CSX0_SDRAM_CS1     0x00000008              // SEMC_CSX0 output selection - SDRAM CS1
        #define SEMC_IOCR_MUX_CSX0_SDRAM_CS2     0x00000010              // SEMC_CSX0 output selection - SDRAM CS2
        #define SEMC_IOCR_MUX_CSX0_SDRAM_CS3     0x00000018              // SEMC_CSX0 output selection - SDRAM CS3
        #define SEMC_IOCR_MUX_CSX0_NAND_CE       0x00000020              // SEMC_CSX0 output selection - NAND CE#
        #define SEMC_IOCR_MUX_CSX0_NOR_CE        0x00000028              // SEMC_CSX0 output selection - NOR CE#
        #define SEMC_IOCR_MUX_CSX0_PSRAM_CE      0x00000030              // SEMC_CSX0 output selection - PSRAM CE#
        #define SEMC_IOCR_MUX_CSX0_DBI_CSX       0x00000038              // SEMC_CSX0 output selection - DBI CSX
        #define SEMC_IOCR_MUX_CSX1_NOR_PSRAM_A25 0x00000000              // SEMC_CSX1 output selection - NOR/PSRAM address bit (A25)
        #define SEMC_IOCR_MUX_CSX1_SDRAM_CS1     0x00000040              // SEMC_CSX1 output selection - SDRAM CS1
        #define SEMC_IOCR_MUX_CSX1_SDRAM_CS2     0x00000080              // SEMC_CSX1 output selection - SDRAM CS2
        #define SEMC_IOCR_MUX_CSX1_SDRAM_CS3     0x000000c0              // SEMC_CSX1 output selection - SDRAM CS3
        #define SEMC_IOCR_MUX_CSX1_NAND_CE       0x00000100              // SEMC_CSX1 output selection - NAND CE#
        #define SEMC_IOCR_MUX_CSX1_NOR_CE        0x00000140              // SEMC_CSX1 output selection - NOR CE#
        #define SEMC_IOCR_MUX_CSX1_PSRAM_CE      0x00000180              // SEMC_CSX1 output selection - PSRAM CE#
        #define SEMC_IOCR_MUX_CSX1_DBI_CSX       0x000001c0              // SEMC_CSX1 output selection - DBI CSX
        #define SEMC_IOCR_MUX_CSX2_NOR_PSRAM_A26 0x00000000              // SEMC_CSX2 output selection - NOR/PSRAM address bit (A26)
        #define SEMC_IOCR_MUX_CSX2_SDRAM_CS1     0x00000200              // SEMC_CSX2 output selection - SDRAM CS1
        #define SEMC_IOCR_MUX_CSX2_SDRAM_CS2     0x00000400              // SEMC_CSX2 output selection - SDRAM CS2
        #define SEMC_IOCR_MUX_CSX2_SDRAM_CS3     0x00000600              // SEMC_CSX2 output selection - SDRAM CS3
        #define SEMC_IOCR_MUX_CSX2_NAND_CE       0x00000800              // SEMC_CSX2 output selection - NAND CE#
        #define SEMC_IOCR_MUX_CSX2_NOR_CE        0x00000a00              // SEMC_CSX2 output selection - NOR CE#
        #define SEMC_IOCR_MUX_CSX2_PSRAM_CE      0x00000c00              // SEMC_CSX2 output selection - PSRAM CE#
        #define SEMC_IOCR_MUX_CSX2_DBI_CSX       0x00000e00              // SEMC_CSX2 output selection - DBI CSX
        #define SEMC_IOCR_MUX_CSX3_NOR_PSRAM_A27 0x00000000              // SEMC_CSX3 output selection - NOR/PSRAM address bit (A27)
        #define SEMC_IOCR_MUX_CSX3_SDRAM_CS1     0x00001000              // SEMC_CSX3 output selection - SDRAM CS1
        #define SEMC_IOCR_MUX_CSX3_SDRAM_CS2     0x00002000              // SEMC_CSX3 output selection - SDRAM CS2
        #define SEMC_IOCR_MUX_CSX3_SDRAM_CS3     0x00003000              // SEMC_CSX3 output selection - SDRAM CS3
        #define SEMC_IOCR_MUX_CSX3_NAND_CE       0x00004000              // SEMC_CSX3 output selection - NAND CE#
        #define SEMC_IOCR_MUX_CSX3_NOR_CE        0x00005000              // SEMC_CSX3 output selection - NOR CE#
        #define SEMC_IOCR_MUX_CSX3_PSRAM_CE      0x00006000              // SEMC_CSX3 output selection - PSRAM CE#
        #define SEMC_IOCR_MUX_CSX3_DBI_CSX       0x00007000              // SEMC_CSX3 output selection - DBI CSX
        #define SEMC_IOCR_MUX_RDY_NAND_RDY_WAIT  0x00000000              // SEMC_RDY selection - NAND Ready/Wait# input
        #define SEMC_IOCR_MUX_RDY_SDRAM_CS1      0x00008000              // SEMC_RDY selection - SDRAM CS1 output
        #define SEMC_IOCR_MUX_RDY_SDRAM_CS2      0x00010000              // SEMC_RDY selection - SDRAM CS2 output
        #define SEMC_IOCR_MUX_RDY_SDRAM_CS3      0x00018000              // SEMC_RDY selection - SDRAM CS3 output
        #define SEMC_IOCR_MUX_RDY_NOR_CE         0x00020000              // SEMC_RDY selection - NOR CE#
        #define SEMC_IOCR_MUX_RDY_PSRAM_CE       0x00028000              // SEMC_RDY selection - PSRAM CE#
        #define SEMC_IOCR_MUX_RDY_DBI_CSX        0x00030000              // SEMC_RDY selection - DBI CSX
        #define SEMC_IOCR_MUX_RDY_NOR_PSRAM_A27  0x00038000              // SEMC_RDY selection - NOR/PSRAM address bit (A27)
    #define SEMC_BMCR0_ADD              (unsigned long *)(SEMC_BLOCK + 0x08)
    #define SEMC_BMCR0                  *(unsigned long *)(SEMC_BLOCK + 0x08) // SEMC bus (AXI) master control register 0 (queue A weight setting)
        #define SEMC_BMCR0_WQOS_MASK    0x0000000f                       // weight of QoS
        #define SEMC_BMCR0_WAGE_MASK    0x000000f0                       // weight of aging
        #define SEMC_BMCR0_WSH_MASK     0x0000ff00                       // weight of slave hit (no read/write switch)
        #define SEMC_BMCR0_WRWS_MASK    0x00ff0000                       // weight of slave hit (read/write switch)
    #define SEMC_BMCR1_ADD              (unsigned long *)(SEMC_BLOCK + 0x0c)
    #define SEMC_BMCR1                  *(unsigned long *)(SEMC_BLOCK + 0x0c) // SEMC bus (AXI) master control register 1 (queue B weight setting)
        #define SEMC_BMCR1_WQOS_MASK    0x0000000f                       // weight of QoS
        #define SEMC_BMCR1_WAGE_MASK    0x000000f0                       // weight of aging
        #define SEMC_BMCR1_WPH_MASK     0x0000ff00                       // weight of page hit
        #define SEMC_BMCR1_WRWS_MASK    0x00ff0000                       // weight of no read/write switch
        #define SEMC_BMCR1_WRB_MASK     0x00ff0000                       // weight of bank rotation
    #define SEMC_BR0_ADD                (unsigned long *)(SEMC_BLOCK + 0x10)
    #define SEMC_BR0                    *(unsigned long *)(SEMC_BLOCK + 0x10) // SEMC base register 0 (for SDRAM CS0 device)
        #define SEMC_BR_VLD             0x00000001                       // valid
        #define SEMC_BR_MS_4KB          0x00000000                       // memory size 4kBytes
        #define SEMC_BR_MS_8KB          0x00000002                       // memory size 8kBytes
        #define SEMC_BR_MS_16KB         0x00000004                       // memory size 16kBytes
        #define SEMC_BR_MS_32KB         0x00000006                       // memory size 32kBytes
        #define SEMC_BR_MS_64KB         0x00000008                       // memory size 64kBytes
        #define SEMC_BR_MS_128KB        0x0000000a                       // memory size 128kBytes
        #define SEMC_BR_MS_256KB        0x0000000c                       // memory size 256kBytes
        #define SEMC_BR_MS_512KB        0x0000000e                       // memory size 512kBytes
        #define SEMC_BR_MS_1MB          0x00000010                       // memory size 1MBytes
        #define SEMC_BR_MS_2MB          0x00000012                       // memory size 2MBytes
        #define SEMC_BR_MS_4MB          0x00000014                       // memory size 4MBytes
        #define SEMC_BR_MS_8MB          0x00000016                       // memory size 8MBytes
        #define SEMC_BR_MS_16MB         0x00000018                       // memory size 16MBytes
        #define SEMC_BR_MS_32MB         0x0000001a                       // memory size 32MBytes
        #define SEMC_BR_MS_64MB         0x0000001c                       // memory size 64MBytes
        #define SEMC_BR_MS_128MB        0x0000001e                       // memory size 128MBytes
        #define SEMC_BR_MS_256MB        0x00000020                       // memory size 256MBytes
        #define SEMC_BR_MS_512MB        0x00000022                       // memory size 512MBytes
        #define SEMC_BR_MS_1GB          0x00000024                       // memory size 1GBytes
        #define SEMC_BR_MS_2GB          0x00000026                       // memory size 2GBytes
        #define SEMC_BR_MS_4GB          0x00000028                       // memory size 4GBytes
    #define SEMC_BR1_ADD                (unsigned long *)(SEMC_BLOCK + 0x14)
    #define SEMC_BR1                    *(unsigned long *)(SEMC_BLOCK + 0x14) // SEMC base register 1 (for SDRAM CS1 device)
    #define SEMC_BR2_ADD                (unsigned long *)(SEMC_BLOCK + 0x18)
    #define SEMC_BR2                    *(unsigned long *)(SEMC_BLOCK + 0x18) // SEMC base register 2 (for SDRAM CS2 device)
    #define SEMC_BR3_ADD                (unsigned long *)(SEMC_BLOCK + 0x1c)
    #define SEMC_BR3                    *(unsigned long *)(SEMC_BLOCK + 0x1c) // SEMC base register 3 (for SDRAM CS3 device)
    #define SEMC_BR4_ADD                (unsigned long *)(SEMC_BLOCK + 0x20)
    #define SEMC_BR4                    *(unsigned long *)(SEMC_BLOCK + 0x20) // SEMC base register 4 (for NAND device)
    #define SEMC_BR5_ADD                (unsigned long *)(SEMC_BLOCK + 0x24)
    #define SEMC_BR5                    *(unsigned long *)(SEMC_BLOCK + 0x24) // SEMC base register 5 (for NOR device)
    #define SEMC_BR6_ADD                (unsigned long *)(SEMC_BLOCK + 0x28)
    #define SEMC_BR6                    *(unsigned long *)(SEMC_BLOCK + 0x28) // SEMC base register 6 (for PSRAM device)
    #define SEMC_BR7_ADD                (unsigned long *)(SEMC_BLOCK + 0x2c)
    #define SEMC_BR7                    *(unsigned long *)(SEMC_BLOCK + 0x2c) // SEMC base register 7 (for DBI-B - MIPI display bus interface type B - device)
    #define SEMC_BR8_ADD                (unsigned long *)(SEMC_BLOCK + 0x30)
    #define SEMC_BR8                    *(unsigned long *)(SEMC_BLOCK + 0x30) // SEMC base register 8 (for NAND device)
    #define SEMC_INTEN                  *(unsigned long *)(SEMC_BLOCK + 0x38) // SEMC interrupt enable register
    #define SEMC_INTR_ADD               (unsigned long *)(SEMC_BLOCK + 0x3c)
    #define SEMC_INTR                   *(volatile unsigned long *)(SEMC_BLOCK + 0x3c) // SEMC interrupt register (read-only/write-one to clear)
        #define SEMC_INTR_IPCMDDONE     0x00000001
        #define SEMC_INTR_IPCMDERR      0x00000002
        #define SEMC_INTR_AXICMDERR     0x00000004
        #define SEMC_INTR_AXIBUSERR     0x00000008
        #define SEMC_INTR_NDPAGEEND     0x00000010
        #define SEMC_INTR_NDNOPEND      0x00000020
    #define SEMC_SDRAMCR0_ADD           (unsigned long *)(SEMC_BLOCK + 0x40)
    #define SEMC_SDRAMCR0               *(unsigned long *)(SEMC_BLOCK + 0x40) // SEMC SDRAM control register 0
    #define SEMC_SDRAMCR1_ADD           (unsigned long *)(SEMC_BLOCK + 0x44)
    #define SEMC_SDRAMCR1               *(unsigned long *)(SEMC_BLOCK + 0x44) // SEMC SDRAM control register 1
    #define SEMC_SDRAMCR2_ADD           (unsigned long *)(SEMC_BLOCK + 0x48)
    #define SEMC_SDRAMCR2               *(unsigned long *)(SEMC_BLOCK + 0x48) // SEMC SDRAM control register 2
    #define SEMC_SDRAMCR3_ADD           (unsigned long *)(SEMC_BLOCK + 0x4c)
    #define SEMC_SDRAMCR3               *(unsigned long *)(SEMC_BLOCK + 0x4c) // SEMC SDRAM control register 3
        #define SEMC_SDRAMCR3_REN       0x00000001                       // refresh enable
    #define SEMC_NANDCR0                *(unsigned long *)(SEMC_BLOCK + 0x50) // SEMC NAND control register 0
    #define SEMC_NANDCR1                *(unsigned long *)(SEMC_BLOCK + 0x54) // SEMC NAND control register 1
    #define SEMC_NANDCR2                *(unsigned long *)(SEMC_BLOCK + 0x58) // SEMC NAND control register 2
    #define SEMC_NANDCR3                *(unsigned long *)(SEMC_BLOCK + 0x5c) // SEMC NAND control register 3
    #define SEMC_NORCR0                 *(unsigned long *)(SEMC_BLOCK + 0x60) // SEMC NOR control register 0
    #define SEMC_NORCR1                 *(unsigned long *)(SEMC_BLOCK + 0x64) // SEMC NOR control register 1
    #define SEMC_NORCR2                 *(unsigned long *)(SEMC_BLOCK + 0x68) // SEMC NOR control register 2
    #define SEMC_NORCR3                 *(unsigned long *)(SEMC_BLOCK + 0x6c) // SEMC NOR control register 3
    #define SEMC_SRAMCR0                *(unsigned long *)(SEMC_BLOCK + 0x70) // SEMC SRAM control register 0
    #define SEMC_SRAMCR1                *(unsigned long *)(SEMC_BLOCK + 0x74) // SEMC SRAM control register 1
    #define SEMC_SRAMCR2                *(unsigned long *)(SEMC_BLOCK + 0x78) // SEMC SRAM control register 2
    #define SEMC_SRAMCR3                *(unsigned long *)(SEMC_BLOCK + 0x7c) // SEMC SRAM control register 3
    #define SEMC_DBICR0_ADD             (unsigned long *)(SEMC_BLOCK + 0x80)
    #define SEMC_DBICR0                 *(unsigned long *)(SEMC_BLOCK + 0x80) // SEMC DBI-B control register 0
    #define SEMC_DBICR1_ADD             (unsigned long *)(SEMC_BLOCK + 0x84)
    #define SEMC_DBICR1                 *(unsigned long *)(SEMC_BLOCK + 0x84) // SEMC DBI-B control register 1
    #define SEMC_IPCR0_ADD              (unsigned long *)(SEMC_BLOCK + 0x90)
    #define SEMC_IPCR0                  *(unsigned long *)(SEMC_BLOCK + 0x90) // SEMC IP command control register 0
    #define SEMC_IPCR1_ADD              (unsigned long *)(SEMC_BLOCK + 0x94)
    #define SEMC_IPCR1                  *(unsigned long *)(SEMC_BLOCK + 0x94) // SEMC IP command control register 1
    #define SEMC_IPCR2_ADD              (unsigned long *)(SEMC_BLOCK + 0x98)
    #define SEMC_IPCR2                  *(unsigned long *)(SEMC_BLOCK + 0x98) // SEMC IP command control register 2
    #define SEMC_IPCMD_ADD              (unsigned long *)(SEMC_BLOCK + 0x9c)
    #define SEMC_IPCMD                  *(volatile unsigned long *)(SEMC_BLOCK + 0x9c) // SEMC IP command register
        #define SEMC_IPCMD_SDRAM_READ           0x00000008
        #define SEMC_IPCMD_SDRAM_WRITE          0x00000009
        #define SEMC_IPCMD_SDRAM_MODESET        0x0000000a
        #define SEMC_IPCMD_SDRAM_ACTIVE         0x0000000b
        #define SEMC_IPCMD_SDRAM_AUTO_REFRESH   0x0000000c
        #define SEMC_IPCMD_SDRAM_SELF_REFRESH   0x0000000d
        #define SEMC_IPCMD_SDRAM_PRECHARGE      0x0000000e
        #define SEMC_IPCMD_SDRAM_PRECHARGE_ALL  0x0000000f
        #define SEMC_IPCMD_KEY                  0xa55a0000               // key that must be set when triggering an IP command
    #define SEMC_IPTXDAT_ADD            (unsigned long *)(SEMC_BLOCK + 0xa0)
    #define SEMC_IPTXDAT                *(unsigned long *)(SEMC_BLOCK + 0xa0) // SEMC TX DATA register
    #define SEMC_IPRXDAT                *(volatile unsigned long *)(SEMC_BLOCK + 0xb0) // SEMC RX DATA register (read-only)
    #define SEMC_STS0                   *(volatile unsigned long *)(SEMC_BLOCK + 0xc0) // SEMC status register 0 (read-only)
    #define SEMC_STS1                   *(volatile unsigned long *)(SEMC_BLOCK + 0xc4) // SEMC status register 1 (read-only)
    #define SEMC_STS2                   *(volatile unsigned long *)(SEMC_BLOCK + 0xc8) // SEMC status register 2 (read-only)
    #define SEMC_STS3                   *(volatile unsigned long *)(SEMC_BLOCK + 0xcc) // SEMC status register 3 (read-only)
    #define SEMC_STS4                   *(volatile unsigned long *)(SEMC_BLOCK + 0xd0) // SEMC status register 4 (read-only)
    #define SEMC_STS5                   *(volatile unsigned long *)(SEMC_BLOCK + 0xd4) // SEMC status register 5 (read-only)
    #define SEMC_STS6                   *(volatile unsigned long *)(SEMC_BLOCK + 0xd8) // SEMC status register 6 (read-only)
    #define SEMC_STS7                   *(volatile unsigned long *)(SEMC_BLOCK + 0xdc) // SEMC status register 7 (read-only)
    #define SEMC_STS8                   *(volatile unsigned long *)(SEMC_BLOCK + 0xe0) // SEMC status register 8 (read-only)
    #define SEMC_STS9                   *(volatile unsigned long *)(SEMC_BLOCK + 0xe4) // SEMC status register 9 (read-only)
    #define SEMC_STS10                  *(volatile unsigned long *)(SEMC_BLOCK + 0xe8) // SEMC status register 10 (read-only)
    #define SEMC_STS11                  *(volatile unsigned long *)(SEMC_BLOCK + 0xec) // SEMC status register 11 (read-only)
    #define SEMC_STS12                  *(volatile unsigned long *)(SEMC_BLOCK + 0xf0) // SEMC status register 12 (read-only)
    #define SEMC_STS13                  *(volatile unsigned long *)(SEMC_BLOCK + 0xf4) // SEMC status register 13 (read-only)
    #define SEMC_STS14                  *(volatile unsigned long *)(SEMC_BLOCK + 0xf8) // SEMC status register 14 (read-only)
    #define SEMC_STS15                  *(volatile unsigned long *)(SEMC_BLOCK + 0xfc) // SEMC status register 15 (read-only)
#endif

// i.MX IOMUXC SW
//
#if defined iMX_RT1011
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_14       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0010) // SW_MUX_CTL_PAD_GPIO_AD_14 SW MUX control register [GPIO1-28]
        #define GPIO_AD_14_LPI2C1_SCL              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_14_LPUART3_CTS_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_14_KPP_COL00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_14_LPUART4_CTS_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_14_FLEXIO1_IO26            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_14_GPIOMUX_IO28            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_14_REF_CLK_24M             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_14_XBAR1_INOUT02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_13       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0014) // SW_MUX_CTL_PAD_GPIO_AD_13 SW MUX control register [GPIO1-27]
        #define GPIO_AD_13_LPI2C1_SDA              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_13_LPUART3_RTS_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_13_KPP_ROW00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_13_LPUART4_RTS_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_13_FLEXIO1_IO25            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_13_GPIO1_IO27              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_13_NMI_GLUE_NMI            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_13_JTAG_TMS                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_12       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0018) // SW_MUX_CTL_PAD_GPIO_AD_12 SW MUX control register [GPIO1-26]
        #define GPIO_AD_12_LPSPI2_SCK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_12_FLEXPWM1_PWM0_X         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_12_KPP_COL01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_12_PIT_TRIGGER01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_12_FLEXIO1_IO24            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_12_GPIOMUX_IO26            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_12_USB_OTG1_PWR            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_12_JTAG_TCK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_11       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x001c) // SW_MUX_CTL_PAD_GPIO_AD_11 SW MUX control register [GPIO1-25]
        #define GPIO_AD_11_LPSPI2_PCS0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_11_FLEXPWM1_PWM1_X         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_11_KPP_ROW01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_11_PIT_TRIGGER02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_11_FLEXIO1_IO23            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_11_GPIOMUX_IO25            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_11_WDOG1_B                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_11_JTAG_MOD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_10       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0020) // SW_MUX_CTL_PAD_GPIO_AD_10 SW MUX control register [GPIO1-24]
        #define GPIO_AD_10_LPSPI2_SDO              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_10_FLEXPWM1_PWM2_X         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_10_KPP_COL02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_10_PIT_TRIGGER03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_10_FLEXIO1_IO22            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_10_GPIOMUX_IO24            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_10_OTG1_ID                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_10_JTAG_TDI                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_09       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0024) // SW_MUX_CTL_PAD_GPIO_AD_09 SW MUX control register [GPIO1-23]
        #define GPIO_AD_09_LPSPI2_SDI              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_09_FLEXPWM1_PWM3_X         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_09_KPP_ROW02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_09_ARM_TRACE_SWO           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_09_FLEXIO1_IO21            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_09_GPIOMUX_IO23            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_09_REF_32K_OUT             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_09_JTAG_TDO                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_08       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0028) // SW_MUX_CTL_PAD_GPIO_AD_08 SW MUX control register [GPIO1-22]
        #define GPIO_AD_08_LPI2C2_SCL              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_08_LPUART3_TXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_08_ARM_CM7_TXEV            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_08_LPUART2_CTS_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_08_GPT2_COMPARE3           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_08_GPIOMUX_IO22            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_08_EWM_OUT_B               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_08_JTAG_TRSTB              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_07       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x002c) // SW_MUX_CTL_PAD_GPIO_AD_07 SW MUX control register [GPIO1-21]
        #define GPIO_AD_07_LPI2C2_SDA              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_07_LPUART3_RXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_07_ARM_CM7_RXEV            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_07_LPUART2_RTS_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_07_GPT2_CAPTURE2           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_07_GPIOMUX_IO21            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_07_OCOTP_FUSE_LATCHED      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_07_XBAR1_INOUT03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_06       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0030) // SW_MUX_CTL_PAD_GPIO_AD_06 SW MUX control register [GPIO1-20]
        #define GPIO_AD_06_LPSPI1_SCK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_06_PIT_TRIGGER00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_06_FLEXPWM1_PWM3           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_06_KPP_COL01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_06_GPT2_COMPARE2           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_06_GPIOMUX_IO20            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_06_LPI2C1_HREQ             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_05       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0034) // SW_MUX_CTL_PAD_GPIO_AD_05 SW MUX control register [GPIO1-19]
        #define GPIO_AD_05_LPSPI1_PCS0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_05_PIT_TRIGGER01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_05_FLEXPWM1_PWM3_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_05_KPP_ROW01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_05_GPT2_CAPTURE1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_05_GPIOMUX_IO19            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_04       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0038) // SW_MUX_CTL_PAD_GPIO_AD_04 SW MUX control register [GPIO1-18]
        #define GPIO_AD_04_LPSPI1_SDO              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_04_PIT_TRIGGER02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_04_FLEXPWM1_PWM2_A         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_04_KPP_COL02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_04_GPT2_COMPARE1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_04_GPIOMUX_IO18            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_04_SNVS_HP_VIO_5_CTL       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_03       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x003c) // SW_MUX_CTL_PAD_GPIO_AD_03 SW MUX control register [GPIO1-17]
        #define GPIO_AD_03_LPSPI1_SDI              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_03_PIT_TRIGGER03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_03_FLEXPWM1_PWM2_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_03_KPP_ROW02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_03_GPT2_CLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_03_GPIOMUX_IO17            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_03_SNVS_HP_VIO_5_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_03_JTAG_DE_B               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_02       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0040) // SW_MUX_CTL_PAD_GPIO_AD_02 SW MUX control register [GPIO1-16]
        #define GPIO_AD_02_LPUART4_TXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_02_LPSPI1_PCS1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_02_WDOG2_B                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_02_LPI2C2_SCL              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_02_MQS_RIGHT               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_02_GPIOMUX_IO16            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_02_ARM_CM7_TRACE_CLK       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_01       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0044) // SW_MUX_CTL_PAD_GPIO_AD_01 SW MUX control register [GPIO1-15]
        #define GPIO_AD_01_LPUART4_RXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_01_LPSPI2_PCS1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_01_WDOG1_ANY               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_01_LPI2C2_SDA              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_01_MQS_LEFT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_01_GPIOMUX_IO15            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_01_USB_OTG1_OC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_01_ARM_CM7_TRACE_SWO       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00_ADD   (unsigned long *)(IOMUXC_SW_BLOCK + 0x0048) // SW_MUX_CTL_PAD_GPIO_AD_00 SW MUX control register address
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_00       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0048) // SW_MUX_CTL_PAD_GPIO_AD_00 SW MUX control register [GPIO1-14]
        #define GPIO_AD_00_LPUART2_TXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_00_LPSPI1_PCS2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_00_KPP_COL03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_00_USB_OTG1_PWR            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_00_FLEXIO1_IO20            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_00_GPIOMUX_IO14            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_00_NMI_GLUE_NMI            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_00_ARM_CM7_TRACE00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_14       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x004c) // SW_MUX_CTL_PAD_GPIO_SD_14 SW MUX control register [no GPIO]
        #define GPIO_SD_14_FLEXSPI_A_DQS           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_14_FLEXSPI_B_DQS           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_13       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0050) // SW_MUX_CTL_PAD_GPIO_SD_13 SW MUX control register [GPIO2-13]
        #define GPIO_SD_13_FLEXSPI_B_SCLK          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_13_SAI3_RX_BCLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_13_ARM_CM7_TXEV            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_13_CCM_PMIC_RDY            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_13_FLEXIO1_IO19            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_13_GPIO2_IO13              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_13_SRC_BT_CFG03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_12       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0054) // SW_MUX_CTL_PAD_GPIO_SD_12 SW MUX control register [GPIO2-12]
        #define GPIO_SD_12_FLEXSPI_A_DQS           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_12_LPSPI2_PCS0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_12_LPUART1_TXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_12_FLEXIO1_IO18            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_12_GPIO2_IO12              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_12_WDOG2_RST_B_DEB         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_11       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0058) // SW_MUX_CTL_PAD_GPIO_SD_11 SW MUX control register [GPIO2-11]
        #define GPIO_SD_11_FLEXSPI_A_DATA03        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_11_LPSPI2_SCK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_11_LPUART1_RXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_11_FLEXIO1_IO17            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_11_GPIO2_IO11              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_11_WDOG1_RST_B_DEB         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_10       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x005c) // SW_MUX_CTL_PAD_GPIO_SD_10 SW MUX control register [GPIO2-10]
        #define GPIO_SD_10_FLEXSPI_A_SCLK          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_10_LPSPI2_SDO              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_10_LPUART2_TXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_10_FLEXIO1_IO16            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_10_GPIO2_IO10              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_09       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0060) // SW_MUX_CTL_PAD_GPIO_SD_09 SW MUX control register [GPIO2-09]
        #define GPIO_SD_09_FLEXSPI_A_DATA00        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_09_LPSPI2_SDI              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_09_LPUART2_RXD             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_09_FLEXIO1_IO15            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_09_GPIO2_IO09              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_08       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0064) // SW_MUX_CTL_PAD_GPIO_SD_08 SW MUX control register [GPIO2-08]
        #define GPIO_SD_08_FLEXSPI_A_DATA02        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_08_LPI2C2_SCL              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_08_LPSPI1_SCK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_08_FLEXIO1_IO14            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_08_GPIO2_IO08              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_07       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0068) // SW_MUX_CTL_PAD_GPIO_SD_07 SW MUX control register [GPIO2-07]
        #define GPIO_SD_07_FLEXSPI_A_DATA01        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_07_LPI2C2_SDA              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_07_LPSPI1_PCS0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_07_FLEXIO1_IO13            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_07_GPIO2_IO07              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_06       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x006c) // SW_MUX_CTL_PAD_GPIO_SD_06 SW MUX control register [GPIO2-06]
        #define GPIO_SD_06_FLEXSPI_A_SS0_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_06_LPI2C1_SCL              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_06_LPSPI1_SDO              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_06_FLEXIO1_IO12            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_06_GPIO2_IO06              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_05       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0070) // SW_MUX_CTL_PAD_GPIO_SD_05 SW MUX control register [GPIO2-05]
        #define GPIO_SD_05_FLEXSPI_A_SS1_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_05_LPI2C1_SDA              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_05_LPSPI1_SDI              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_05_FLEXIO1_IO11            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_05_GPIO2_IO05              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_04       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0074) // SW_MUX_CTL_PAD_GPIO_SD_04 SW MUX control register [GPIO2-04]
        #define GPIO_SD_04_FLEXSPI_B_DATA03        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_04_SAI3_RX_SYNC            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_04_FLEXPWM1_PWM1_A         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_04_CCM_WAIT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_04_FLEXIO1_IO10            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_04_GPIO2_IO04              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_04_SRC_BOOT_MODE00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_03       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0078) // SW_MUX_CTL_PAD_GPIO_SD_03 SW MUX control register [GPIO2-03]
        #define GPIO_SD_03_FLEXSPI_B_DATA00        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_03_SAI3_RX_DATA            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_03_FLEXPWM1_PWM1_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_03_CCM_REF_EN_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_03_FLEXIO1_IO09            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_03_GPIO2_IO03              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_03_SRC_BOOT_MODE01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_02       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x007c) // SW_MUX_CTL_PAD_GPIO_SD_02 SW MUX control register [GPIO2-02]
        #define GPIO_SD_02_FLEXSPI_B_DATA02        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_02_SAI3_TX_DATA            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_02_FLEXPWM1_PWM0_A         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_02_CCM_CLKO1               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_02_FLEXIO1_IO08            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_02_GPIO2_IO02              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_02_SRC_BT_CFG00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_01       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0080) // SW_MUX_CTL_PAD_GPIO_SD_01 SW MUX control register [GPIO2-01]
        #define GPIO_SD_01_FLEXSPI_B_DATA01        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_01_SAI3_TX_BCLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_01_FLEXPWM1_PWM0_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_01_CCM_CLKO2               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_01_FLEXIO1_IO07            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_01_GPIO2_IO01              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_01_SRC_BT_CFG01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00_ADD   (unsigned long *)(IOMUXC_SW_BLOCK + 0x0084) // SW_MUX_CTL_PAD_GPIO_SD_00 SW MUX control register address
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_00       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0084) // SW_MUX_CTL_PAD_GPIO_SD_00 SW MUX control register [GPIO2-00]
        #define GPIO_SD_00_FLEXSPI_B_SS0_B         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_00_SAI3_TX_SYNC            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_00_ARM_CM7_RXEV            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_00_CCM_STOP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_00_FLEXIO1_IO06            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_00_GPIO2_IO00              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_00_SRC_BT_CFG02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_13          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0088) // SW_MUX_CTL_PAD_GPIO_13 SW MUX control register [GPIO1-13]
        #define GPIO_13_LPUART2_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_13_LPSPI2_PCS2                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_13_KPP_ROW03                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_13_OTG1_ID                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_13_FLEXIO1_IO05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_13_GPIOMUX_IO13               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_13_SPDIF_LOCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_13_ARM_CM7_TRACE01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_12          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x008c) // SW_MUX_CTL_PAD_GPIO_12 SW MUX control register [GPIO1-12]
        #define GPIO_12_LPUART3_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_12_LPI2C1_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_12_KPP_COL00                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_12_USB_OTG1_OC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_12_FLEXIO1_IO04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_12_GPIOMUX_IO12               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_12_SPDIF_EXT_CLK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_12_ARM_CM7_TRACE02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_11          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0090) // SW_MUX_CTL_PAD_GPIO_11 SW MUX control register [GPIO1-11]
        #define GPIO_11_LPUART3_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_11_LPI2C1_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_11_KPP_ROW00                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_11_FLEXSPI_B_SS1_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_11_FLEXIO1_IO03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_11_GPIOMUX_IO11               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_11_SPDIF_OUT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_11_ARM_CM7_TRACE03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_10          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0094) // SW_MUX_CTL_PAD_GPIO_10 SW MUX control register [GPIO1-10]
        #define GPIO_10_LPUART1_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_10_LPI2C1_HREQ                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_10_EWM_OUT_B                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_10_LPI2C2_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_10_FLEXIO1_IO02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_10_GPIO1_IO10                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_10_SPDIF_IN                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_09          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0098) // SW_MUX_CTL_PAD_GPIO_09 SW MUX control register [GPIO1-09]
        #define GPIO_09_LPUART1_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_09_WDOG1_B                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_09_FLEXSPI_A_SS1_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_09_LPI2C2_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_09_FLEXIO1_IO01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_09_GPIO1_IO09                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_09_SPDIF_SR_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_08          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x009c) // SW_MUX_CTL_PAD_GPIO_08 SW MUX control register [GPIO1-08]
        #define GPIO_08_SAI1_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_08_GPT1_CLK                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_08_FLEXPWM1_PWM3_A            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_08_LPUART3_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_08_FLEXIO1_IO00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_08_GPIO1_IO08                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_08_LPUART1_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_07          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00a0) // SW_MUX_CTL_PAD_GPIO_07 SW MUX control register [GPIO1-07]
        #define GPIO_07_SAI1_TX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_07_GPT1_COMPARE1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_07_FLEXPWM1_PWM3_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_07_LPUART3_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_07_SPDIF_LOCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_07_GPIO1_IO07                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_07_LPUART1_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_06          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00a4) // SW_MUX_CTL_PAD_GPIO_06 SW MUX control register [GPIO1-06]
        #define GPIO_06_SAI1_TX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_06_GPT1_CAPTURE1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_06_FLEXPWM1_PWM2_A            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_06_LPUART4_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_06_SPDIF_EXT_CLK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_06_GPIOMUX_IO06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_05          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00a8) // SW_MUX_CTL_PAD_GPIO_05 SW MUX control register [GPIO1-05]
        #define GPIO_05_SAI1_TX_DATA01             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_05_GPT1_COMPARE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_05_FLEXPWM1_PWM2_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_05_LPUART4_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_05_SPDIF_OUT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_05_GPIOMUX_IO05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_04          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00ac) // SW_MUX_CTL_PAD_GPIO_04 SW MUX control register [GPIO1-04]
        #define GPIO_04_SAI1_TX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_04_GPT1_CAPTURE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_04_FLEXPWM1_PWM1_A            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_04_SPDIF_IN                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_04_GPIOMUX_IO04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_03          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00b0) // SW_MUX_CTL_PAD_GPIO_03 SW MUX control register [GPIO1-03]
        #define GPIO_03_SAI1_RX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_03_GPT1_COMPARE3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_03_FLEXPWM1_PWM1_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_03_SPDIF_SR_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_03_GPIOMUX_IO03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_02          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00b4) // SW_MUX_CTL_PAD_GPIO_02 SW MUX control register [GPIO1-02]
        #define GPIO_02_SAI1_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_02_WDOG2_B                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_02_FLEXPWM1_PWM0_A            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_02_LPI2C1_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_02_KPP_COL03                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_02_GPIOMUX_IO02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_01          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00b8) // SW_MUX_CTL_PAD_GPIO_01 SW MUX control register [GPIO1-01]
        #define GPIO_01_SAI1_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_01_WDOG1_ANY                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_01_FLEXPWM1_PWM0_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_01_LPI2C1_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_01_KPP_ROW03                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_01_GPIOMUX_IO01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_00_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00bc) // SW_MUX_CTL_PAD_GPIO_00 SW MUX control register [GPIO1-00] address
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_00          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00bc) // SW_MUX_CTL_PAD_GPIO_00 SW MUX control register [GPIO1-00]
        #define GPIO_00_FLEXSPI_B_DQS              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_00_SAI3_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_00_LPSPI2_PCS3                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_00_LPSPI1_PCS3                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_00_PIT_TRIGGER00              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_00_GPIOMUX_IO00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_14       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00c0) // SW_PAD_CTL_PAD_GPIO_AD_14 SW PAD control register [GPIO1-28]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_13       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00c4) // SW_PAD_CTL_PAD_GPIO_AD_13 SW PAD control register [GPIO1-27]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_12       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00c8) // SW_PAD_CTL_PAD_GPIO_AD_12 SW PAD control register [GPIO1-26]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_11       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00cc) // SW_PAD_CTL_PAD_GPIO_AD_11 SW PAD control register [GPIO1-25]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_10       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00d0) // SW_PAD_CTL_PAD_GPIO_AD_10 SW PAD control register [GPIO1-24]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_09       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00d4) // SW_PAD_CTL_PAD_GPIO_AD_09 SW PAD control register [GPIO1-23]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_08       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00d8) // SW_PAD_CTL_PAD_GPIO_AD_08 SW PAD control register [GPIO1-22]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_07       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00dc) // SW_PAD_CTL_PAD_GPIO_AD_07 SW PAD control register [GPIO1-21]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_06       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00e0) // SW_PAD_CTL_PAD_GPIO_AD_06 SW PAD control register [GPIO1-20]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_05       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00e4) // SW_PAD_CTL_PAD_GPIO_AD_05 SW PAD control register [GPIO1-19]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_04       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00e8) // SW_PAD_CTL_PAD_GPIO_AD_04 SW PAD control register [GPIO1-18]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_03       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00ec) // SW_PAD_CTL_PAD_GPIO_AD_03 SW PAD control register [GPIO1-17]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_02       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00f0) // SW_PAD_CTL_PAD_GPIO_AD_02 SW PAD control register [GPIO1-16]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_01       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00f4) // SW_PAD_CTL_PAD_GPIO_AD_01 SW PAD control register [GPIO1-15]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00_ADD   (unsigned long *)(IOMUXC_SW_BLOCK + 0x00f8) // SW_PAD_CTL_PAD_GPIO_AD_00 SW PAD control register address
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_00       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00f8) // SW_PAD_CTL_PAD_GPIO_AD_00 SW PAD control register [GPIO1-14]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_14       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00fc) // SW_PAD_CTL_PAD_GPIO_SD_14 SW PAD control register [no GPIO]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_13       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0100) // SW_PAD_CTL_PAD_GPIO_SD_13 SW PAD control register [GPIO2-13]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_12       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0104) // SW_PAD_CTL_PAD_GPIO_SD_12 SW PAD control register [GPIO2-12]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_11       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0108) // SW_PAD_CTL_PAD_GPIO_SD_11 SW PAD control register [GPIO2-11]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_10       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x010c) // SW_PAD_CTL_PAD_GPIO_SD_10 SW PAD control register [GPIO2-10]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_09       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0110) // SW_PAD_CTL_PAD_GPIO_SD_09 SW PAD control register [GPIO2-09]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_08       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0114) // SW_PAD_CTL_PAD_GPIO_SD_08 SW PAD control register [GPIO2-08]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_07       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0118) // SW_PAD_CTL_PAD_GPIO_SD_07 SW PAD control register [GPIO2-07]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_06       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x011c) // SW_PAD_CTL_PAD_GPIO_SD_06 SW PAD control register [GPIO2-06]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_05       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0120) // SW_PAD_CTL_PAD_GPIO_SD_05 SW PAD control register [GPIO2-05]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_04       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0124) // SW_PAD_CTL_PAD_GPIO_SD_04 SW PAD control register [GPIO2-04]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_03       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0128) // SW_PAD_CTL_PAD_GPIO_SD_03 SW PAD control register [GPIO2-03]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_02       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x012c) // SW_PAD_CTL_PAD_GPIO_SD_02 SW PAD control register [GPIO2-02]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_01       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0130) // SW_PAD_CTL_PAD_GPIO_SD_01 SW PAD control register [GPIO2-01]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00_ADD   (unsigned long *)(IOMUXC_SW_BLOCK + 0x0134) // SW_PAD_CTL_PAD_GPIO_SD_00 SW PAD control register address
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_00       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0134) // SW_PAD_CTL_PAD_GPIO_SD_00 SW PAD control register [GPIO2-00]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_13          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0138) // SW_PAD_CTL_PAD_GPIO_13 SW PAD control register [GPIO1-13]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_12          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x013c) // SW_PAD_CTL_PAD_GPIO_12 SW PAD control register [GPIO1-12]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_11          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0140) // SW_PAD_CTL_PAD_GPIO_11 SW PAD control register [GPIO1-11]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_10          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0144) // SW_PAD_CTL_PAD_GPIO_10 SW PAD control register [GPIO1-10]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_09          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0148) // SW_PAD_CTL_PAD_GPIO_09 SW PAD control register [GPIO1-09]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_08          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x014c) // SW_PAD_CTL_PAD_GPIO_08 SW PAD control register [GPIO1-08]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_07          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0150) // SW_PAD_CTL_PAD_GPIO_07 SW PAD control register [GPIO1-07]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_06          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0154) // SW_PAD_CTL_PAD_GPIO_06 SW PAD control register [GPIO1-06]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_05          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0158) // SW_PAD_CTL_PAD_GPIO_05 SW PAD control register [GPIO1-05]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_04          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x015c) // SW_PAD_CTL_PAD_GPIO_04 SW PAD control register [GPIO1-04]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_03          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0160) // SW_PAD_CTL_PAD_GPIO_03 SW PAD control register [GPIO1-03]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_02          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0164) // SW_PAD_CTL_PAD_GPIO_02 SW PAD control register [GPIO1-02]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_01          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0168) // SW_PAD_CTL_PAD_GPIO_01 SW PAD control register [GPIO1-01]
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_00_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x016c) // SW_PAD_CTL_PAD_GPIO_00 SW PAD control register address
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_00          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x016c) // SW_PAD_CTL_PAD_GPIO_00 SW PAD control register [GPIO1-00]
    #define IOMUXC_USB_OTG_ID_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0170) // USB_OTG_ID_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_0    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0174) // FLEXPWM1_PWMA_SELECT_INPUT_0 DAISY register
    #define IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_1    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0178) // FLEXPWM1_PWMA_SELECT_INPUT_1 DAISY register
    #define IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_2    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x017c) // FLEXPWM1_PWMA_SELECT_INPUT_2 DAISY register
    #define IOMUXC_FLEXPWM1_PWMA_SELECT_INPUT_3    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0180) // FLEXPWM1_PWMA_SELECT_INPUT_3 DAISY register
    #define IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_0    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0184) // FLEXPWM1_PWMB_SELECT_INPUT_0 DAISY register
    #define IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_1    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0188) // FLEXPWM1_PWMB_SELECT_INPUT_1 DAISY register
    #define IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_2    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x018c) // FLEXPWM1_PWMB_SELECT_INPUT_2 DAISY register
    #define IOMUXC_FLEXPWM1_PWMB_SELECT_INPUT_3    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0190) // FLEXPWM1_PWMB_SELECT_INPUT_3 DAISY register
    #define IOMUXC_FLEXSPI_DQS_FA_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0194) // FLEXSPI_DQS_FA_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXSPI_DQS_FB_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0198) // FLEXSPI_DQS_FB_SELECT_INPUT DAISY register
    #define IOMUXC_KPP_COL_SELECT_INPUT_0          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x019c) // KPP_COL_SELECT_INPUT_0 DAISY register
    #define IOMUXC_KPP_COL_SELECT_INPUT_1          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a0) // KPP_COL_SELECT_INPUT_1 DAISY register
    #define IOMUXC_KPP_COL_SELECT_INPUT_2          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a4) // KPP_COL_SELECT_INPUT_2 DAISY register
    #define IOMUXC_KPP_COL_SELECT_INPUT_3          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a8) // KPP_COL_SELECT_INPUT_3 DAISY register
    #define IOMUXC_KPP_ROW_SELECT_INPUT_0          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01ac) // KPP_ROW_SELECT_INPUT_0 DAISY register
    #define IOMUXC_KPP_ROW_SELECT_INPUT_1          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b0) // KPP_ROW_SELECT_INPUT_1 DAISY register
    #define IOMUXC_KPP_ROW_SELECT_INPUT_2          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b4) // KPP_ROW_SELECT_INPUT_2 DAISY register
    #define IOMUXC_KPP_ROW_SELECT_INPUT_3          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b8) // KPP_ROW_SELECT_INPUT_3 DAISY register
    #define IOMUXC_LPI2C1_HREQ_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01bc) // LPI2C1_HREQ_SELECT_INPUT DAISY register
    #define IOMUXC_LPI2C1_SCL_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c0) // LPI2C1_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_AD_14_ALT0    0x00000000 // selecting pad: GPIO_AD_14 for mode: ALT0
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_SD_06_ALT1    0x00000001 // selecting pad: GPIO_SD_06 for mode: ALT1
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_12_ALT1       0x00000002 // selecting pad: GPIO_12 for mode: ALT1
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_02_ALT3       0x00000003 // selecting pad: GPIO_02 for mode: ALT3
    #define IOMUXC_LPI2C1_SDA_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c4) // LPI2C1_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_AD_13_ALT0    0x00000000 // selecting pad: GPIO_AD_13 for mode: ALT0
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_SD_05_ALT1    0x00000001 // selecting pad: GPIO_SD_05 for mode: ALT1
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_11_ALT1       0x00000002 // selecting pad: GPIO_11 for mode: ALT1
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_01_ALT3       0x00000003 // selecting pad: GPIO_01 for mode: ALT3
    #define IOMUXC_LPI2C2_SCL_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c8) // LPI2C2_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_AD_08_ALT0    0x00000000 // selecting pad: GPIO_AD_08 for mode: ALT0
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_AD_02_ALT3    0x00000001 // selecting pad: GPIO_AD_02 for mode: ALT3
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_SD_08_ALT1    0x00000002 // selecting pad: GPIO_SD_08 for mode: ALT1
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_10_ALT3       0x00000003 // selecting pad: GPIO_10 for mode: ALT3
    #define IOMUXC_LPI2C2_SDA_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01cc) // LPI2C2_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_AD_07_ALT0    0x00000000 // selecting pad: GPIO_AD_07 for mode: ALT0
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_AD_01_ALT3    0x00000001 // selecting pad: GPIO_AD_01 for mode: ALT3
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_SD_07_ALT1    0x00000002 // selecting pad: GPIO_SD_07 for mode: ALT1
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_09_ALT3       0x00000003 // selecting pad: GPIO_09 for mode: ALT3
    #define IOMUXC_LPSPI1_PCS_SELECT_INPUT_0       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d0) // LPSPI1_PCS_SELECT_INPUT_0 DAISY register
    #define IOMUXC_LPSPI1_SCK_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d4) // LPSPI1_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI1_SDI_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d8) // LPSPI1_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI1_SDO_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01dc) // LPSPI1_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_PCS_SELECT_INPUT_0       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e0) // LPSPI2_PCS_SELECT_INPUT_0 DAISY register
    #define IOMUXC_LPSPI2_SCK_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e4) // LPSPI2_SCK_SELECT_INPUT DAISY register
        #define IOMUXC_LPSPI2_SCK_SELECT_INPUT_GPIO_AD_12_ALT0  0x00000000 // selecting pad: GPIO_AD_12 for mode: ALT0
        #define IOMUXC_LPSPI2_SCK_SELECT_INPUT_GPIO_SD_11_ALT1  0x00000001 // selecting pad: GPIO_SD_11 for mode: ALT1
    #define IOMUXC_LPSPI2_SDI_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e8) // LPSPI2_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SDO_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01ec) // LPSPI2_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPUART1_RXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f0) // LPUART1_RXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART1_RXD_SELECT_INPUT_GPIO_SD_11_ALT2  0x00000000 // selecting pad: GPIO_SD_11 for mode: ALT2
        #define IOMUXC_LPUART1_RXD_SELECT_INPUT_GPIO_09_ALT0     0x00000001 // selecting pad: GPIO_09 for mode: ALT0
    #define IOMUXC_LPUART1_TXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f4) // LPUART1_TXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART1_TXD_SELECT_INPUT_GPIO_SD_12_ALT2  0x00000000 // selecting pad: GPIO_SD_12 for mode: ALT2
        #define IOMUXC_LPUART1_TXD_SELECT_INPUT_GPIO_10_ALT0     0x00000001 // selecting pad: GPIO_10 for mode: ALT0
    #define IOMUXC_LPUART2_RXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f8) // LPUART2_RXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART2_RXD_SELECT_INPUT_GPIO_SD_09_ALT2  0x00000000 // selecting pad: GPIO_SD_09 for mode: ALT2
        #define IOMUXC_LPUART2_RXD_SELECT_INPUT_GPIO_13_ALT0     0x00000001 // selecting pad: GPIO_13 for mode: ALT0
    #define IOMUXC_LPUART2_TXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01fc) // LPUART2_TXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART2_TXD_SELECT_INPUT_GPIO_AD_00_ALT0  0x00000000 // selecting pad: GPIO_AD_00 for mode: ALT0
        #define IOMUXC_LPUART2_TXD_SELECT_INPUT_GPIO_SD_10_ALT2  0x00000001 // selecting pad: GPIO_SD_10 for mode: ALT2
    #define IOMUXC_LPUART3_RXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0200) // LPUART3_RXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_RXD_SELECT_INPUT_GPIO_AD_07_ALT1  0x00000000 // selecting pad: GPIO_AD_07 for mode: ALT1
        #define IOMUXC_LPUART3_RXD_SELECT_INPUT_GPIO_11_ALT0     0x00000001 // selecting pad: GPIO_11 for mode: ALT0
        #define IOMUXC_LPUART3_RXD_SELECT_INPUT_GPIO_07_ALT3     0x00000002 // selecting pad: GPIO_07 for mode: ALT3
    #define IOMUXC_LPUART3_TXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0204) // LPUART3_TXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_TXD_SELECT_INPUT_GPIO_AD_08_ALT1  0x00000000 // selecting pad: GPIO_AD_08 for mode: ALT1
        #define IOMUXC_LPUART3_TXD_SELECT_INPUT_GPIO_12_ALT0     0x00000001 // selecting pad: GPIO_12 for mode: ALT0
        #define IOMUXC_LPUART3_TXD_SELECT_INPUT_GPIO_08_ALT3     0x00000002 // selecting pad: GPIO_08 for mode: ALT3
    #define IOMUXC_LPUART4_RXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0208) // LPUART4_RXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART4_RXD_SELECT_INPUT_GPIO_AD_01_ALT0  0x00000000 // selecting pad: GPIO_AD_01 for mode: ALT0
        #define IOMUXC_LPUART4_RXD_SELECT_INPUT_GPIO_05_ALT3     0x00000001 // selecting pad: GPIO_05 for mode: ALT3
    #define IOMUXC_LPUART4_TXD_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x020c) // LPUART4_TXD_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART4_TXD_SELECT_INPUT_GPIO_AD_02_ALT0  0x00000000 // selecting pad: GPIO_AD_02 for mode: ALT0
        #define IOMUXC_LPUART4_TXD_SELECT_INPUT_GPIO_06_ALT3     0x00000001 // selecting pad: GPIO_06 for mode: ALT3
    #define IOMUXC_NMI_GLUE_NMI_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0210) // NMI_GLUE_NMI_SELECT_INPUT DAISY register
    #define IOMUXC_SPDIF_IN1_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0214) // SPDIF_IN1_SELECT_INPUT DAISY register
    #define IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT      *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0218) // SPDIF_TX_CLK2_SELECT_INPUT DAISY register
    #define IOMUXC_USB_OTG_OC_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x021c) // USB_OTG_OC_SELECT_INPUT DAISY register
    #define IOMUXC_XEV_GLUE_RXEV_SELECT_INPUT      *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0220) // XEV_GLUE_RXEV_SELECT_INPUT DAISY register
#else
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0014)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_00          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0014) // SW_MUX_CTL_PAD_GPIO_EMC_00 SW MUX control register [GPIO2-0]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_00_SEMC_DATA00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_00_FLEXPWM4_PWMA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_00_LPSPI2_SCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_00_XBAR1_XBAR_IN02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_00_FLEXIO1_FLEXIO00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_00_GPIO4_IO00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_00_USB_PHY1_TSTI_TX_LS_MODE (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_00_SEMC_DATA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_00_QTIMER2_TIMER0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_00_LPUART4_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_00_SPDIF_SR_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_00_LPSPI2_SCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_00_GPIO2_IO00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_00_FLEXCAN1_TX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_00_PIT_TRIGGER02              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0018)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_01          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0018) // SW_MUX_CTL_PAD_GPIO_EMC_01 SW MUX control register [GPIO2-1]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_01_SEMC_DATA01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_01_FLEXPWM4_PWMB00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_01_LPSPI2_PCS0                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_01_XBAR1_IN03                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_01_FLEXIO1_FLEXIO01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_01_GPIO4_IO01                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_01_USB_PHY1_TSTI_TX_HS_MODE (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_01_JTAG_DE_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_01_SEMC_DATA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_01_QTIMER2_TIMER1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_01_LPUART4_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_01_SPDIF_OUT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_01_LPSPI2_PCS0                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_01_GPIO2_IO01                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_01_FLEXCAN1_RX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_01_PIT_TRIGGER03              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x001c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_02          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x001c) // SW_MUX_CTL_PAD_GPIO_EMC_02 SW MUX control register [GPIO2-2]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_02_SEMC_DATA02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_02_FLEXPWM4_PWMA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_02_LPSPI2_SDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_02_XBAR1_INOUT04              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_02_FLEXIO1_FLEXIO02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_02_GPIO4_IO02                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_02_USB_PHY1_TSTI_TX_DN    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_02_SEMC_DATA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_02_QTIMER2_TIMER2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_02_LPUART4_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_02_SPDIF_LOCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_02_LPSPI2_SDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_02_GPIO2_IO02                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_02_LPI2C1_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0020)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_03          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0020) // SW_MUX_CTL_PAD_GPIO_EMC_03 SW MUX control register [GPIO2-3]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_03_SEMC_DATA03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_03_FLEXPWM4_PWMB01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_03_LPSPI2_SDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_03_XBAR1_INOUT05              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_03_FLEXIO1_FLEXIO03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_03_GPIO4_IO03                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_03_USB_PHY1_TSTO_RX_SQUELCH (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_03_SEMC_DATA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_03_QTIMER2_TIMER3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_03_LPUART4_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_03_SPDIF_EXT_CLK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_03_LPSPI2_SDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_03_GPIO2_IO03                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_03_LPI2C1_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0024)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0024) // SW_MUX_CTL_PAD_GPIO_EMC_04 SW MUX control register [GPIO2-4]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_04_SEMC_DATA04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_04_FLEXPWM4_PWMA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_04_SAI2_TX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_04_XBAR1_INOUT06              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_04_FLEXIO1_FLEXIO04           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_04_GPIO4_IO04                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_04_USB_PHY1_TSTO_RX_DISCON_DET (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_04_SEMC_DATA04            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_04_XBAR1_INOUT04              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_04_SPDIF_OUT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_04_SAI2_TX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_04_FLEXIO1_FLEXIO16           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_04_GPIO2_IO04                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0028)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0028) // SW_MUX_CTL_PAD_GPIO_EMC_05 SW MUX control register [GPIO2-5]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_05_SEMC_DATA05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_05_FLEXPWM4_PWMB02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_05_SAI2_TX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_05_XBAR1_INOUT07              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_05_FLEXIO1_FLEXIO05           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_05_GPIO4_IO05                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_05_USB_PHY1_TSTO_RX_HS_RXD (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_05_SEMC_DATA05            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_05_XBAR1_INOUT05              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_05_SPDIF_IN                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_05_SAI2_TX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_05_FLEXIO1_FLEXIO17           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_05_GPIO2_IO05                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x002c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x002c) // SW_MUX_CTL_PAD_GPIO_EMC_06 SW MUX control register [GPIO2-6]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_06_SEMC_DATA06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_06_FLEXPWM2_PWMA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_06_SAI2_TX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_06_XBAR1_INOUT08              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_06_FLEXIO1_FLEXIO06           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_06_GPIO4_IO06                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_06_USB_PHY2_TSTO_RX_FS_RXD (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_06_SEMC_DATA06            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_06_XBAR1_INOUT06              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_06_LPUART3_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_06_SAI2_TX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_06_FLEXIO1_FLEXIO18           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_06_GPIO2_IO06                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0030)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0030) // SW_MUX_CTL_PAD_GPIO_EMC_07 SW MUX control register [GPIO2-7]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_07_SEMC_DATA07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_07_FLEXPWM2_PWMB00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_07_SAI2_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_07_XBAR1_INOUT09              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_07_FLEXIO1_FLEXIO07           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_07_GPIO4_IO07                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_07_USB_PHY1_TSTO_RX_FS_RXD (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_07_SEMC_DATA07            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_07_XBAR1_INOUT07              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_07_LPUART3_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_07_SAI2_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_07_FLEXIO1_FLEXIO19           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_07_GPIO2_IO07                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0034)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0034) // SW_MUX_CTL_PAD_GPIO_EMC_08 SW MUX control register [GPIO2-8]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_08_SEMC_DM00                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_08_FLEXPWM2_PWMA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_08_SAI2_RX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_08_XBAR1_INOUT17              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_08_FLEXIO1_FLEXIO08           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_08_GPIO4_IO08                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_08_USB_PHY1_TSTI_TX_DP    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_08_SEMC_DM00              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_08_XBAR1_INOUT08              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_08_FLEXCAN2_TX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_08_SAI2_RX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_08_FLEXIO1_FLEXIO20           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_08_GPIO2_IO08                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0038)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_09          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0038) // SW_MUX_CTL_PAD_GPIO_EMC_09 SW MUX control register [GPIO2-9]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_09_SEMC_ADDR00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_09_FLEXPWM2_PWMB01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_09_SAI2_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_09_FLEXCAN2_TX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_09_FLEXIO1_FLEXIO09           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_09_GPIO4_IO09                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_09_USB_PHY1_TSTI_TX_EN    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_09_FLEXSPI2_B_SS1_B       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_09_SEMC_WE                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_09_XBAR1_INOUT09              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_09_FLEXCAN2_RX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_09_SAI2_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_09_FLEXIO1_FLEXIO21           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_09_GPIO2_IO09                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x003c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_10          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x003c) // SW_MUX_CTL_PAD_GPIO_EMC_10 SW MUX control register [GPIO2-10]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_10_SEMC_ADDR01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_10_FLEXPWM2_PWMA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_10_SAI2_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_10_FLEXCAN2_RX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_10_FLEXIO1_FLEXIO10           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_10_GPIO4_IO10                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_10_USB_PHY1_TSTI_TX_HIZ   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_10_FLEXSPI2_B_SS0_B       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_10_SEMC_CAS               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_10_XBAR1_INOUT10              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_10_LPI2C4_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_10_SAI1_TX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_10_LPSPI2_SCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_10_GPIO2_IO10                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_10_FLEXPWM2_PWMX00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0040)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_11          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0040) // SW_MUX_CTL_PAD_GPIO_EMC_11 SW MUX control register [GPIO2-11]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_11_SEMC_ADDR02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_11_FLEXPWM2_PWMB02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_11_LPI2C4_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_11_USDHC2_RESET_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_11_FLEXIO1_FLEXIO11           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_11_GPIO4_IO11                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_11_USB_PHY2_TSTO_RX_HS_RXD (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_11_FLEXSPI2_B_DQS         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_11_SEMC_RAS               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_11_XBAR1_INOUT11              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_11_LPI2C4_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_11_SAI1_TX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_11_LPSPI2_PCS0                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_11_GPIO2_IO11                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_11_FLEXPWM2_PWMX01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0044)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_12          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0044) // SW_MUX_CTL_PAD_GPIO_EMC_12 SW MUX control register [GPIO2-12]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_12_SEMC_ADDR03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_12_XBAR1_IN24                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_12_LPI2C4_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_12_USDHC1_WP                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_12_FLEXPWM1_PWMA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_12_GPIO4_IO12                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_12_USB_PHY1_TSTO_PLL_CLK20DIV (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_12_FLEXSPI2_B_SCLK        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #if defined SEMC_AVAILABLE
        #define GPIO_EMC_12_SEMC_CS0               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #endif
    #define GPIO_EMC_12_XBAR1_INOUT12              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_12_LPUART6_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_12_SAI1_TX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_12_LPSPI2_SDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_12_GPIO2_IO12                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_12_FLEXPWM2_PWMX02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0048)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_13          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0048) // SW_MUX_CTL_PAD_GPIO_EMC_13 SW MUX control register [GPIO2-13]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_13_SEMC_ADDR04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_13_XBAR1_IN25                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_13_LPUART3_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_13_MQS_RIGHT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_13_FLEXPWM1_PWMB03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_13_GPIO4_IO13                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_13_USB_PHY2_TSTO_PLL_CLK20DIV (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_13_FLEXSPI2_B_DATA0       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_13_SEMC_BA0                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_13_XBAR1_INOUT13              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_13_LPUART6_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_13_SAI1_RX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_13_LPSPI2_SDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_13_GPIO2_IO13                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_13_FLEXPWM2_PWMX03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_13_CCM_PMIC_RDY               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x004c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_14          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x004c) // SW_MUX_CTL_PAD_GPIO_EMC_14 SW MUX control register [GPIO2-14]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_14_SEMC_ADDR05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_14_XBAR1_INOUT19              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_14_LPUART3_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_14_MQS_LEFT                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_14_LPSPI2_PCS1                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_14_GPIO4_IO14                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_14_USB_PHY2_TSTO_RX_SQUELCH (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_14_FLEXSPI2_B_DATA1       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_14_SEMC_BA1                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_14_XBAR1_INOUT14              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_14_LPUART6_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_14_SAI1_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_14_LPSPI2_PCS1                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_14_GPIO2_IO14                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_14_FLEXCAN1_TX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0050)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_15          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0050) // SW_MUX_CTL_PAD_GPIO_EMC_15 SW MUX control register [GPIO2-15]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_15_SEMC_ADDR06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_15_XBAR1_IN20                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_15_LPUART3_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_15_SPDIF_OUT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_15_QTIMER3_TIMER0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_15_GPIO4_IO15                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_15_USB_PHY2_TSTO_RX_DISCON_DET (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_15_FLEXSPI2_B_DATA2       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_15_SEMC_ADDR10                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_15_XBAR1_INOUT15              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_15_LPUART6_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_15_SAI1_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_15_WDOG1_B                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_15_GPIO2_IO15                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_15_FLEXCAN1_RX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0054)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_16          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0054) // SW_MUX_CTL_PAD_GPIO_EMC_16 SW MUX control register [GPIO2-16]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_16_SEMC_ADDR07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_16_XBAR1_IN21                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_16_LPUART3_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_16_SPDIF_IN                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_16_QTIMER3_TIMER1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_16_GPIO4_IO16                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_16_FLEXSPI2_B_DATA3       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_16_SEMC_ADDR00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_16_MQS_RIGHT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_16_SAI2_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_16_GPIO2_IO16                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_16_SRC_BOOT_MODE00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0058)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_17          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0058) // SW_MUX_CTL_PAD_GPIO_EMC_17 SW MUX control register [GPIO2-17]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_17_SEMC_ADDR08                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_17_FLEXPWM4_PWMA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_17_LPUART4_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_17_FLEXCAN1_TX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_17_QTIMER3_TIMER2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_17_GPIO4_IO17                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #else
    #define GPIO_EMC_17_SEMC_ADDR01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_17_MQS_LEFT                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_17_SAI3_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_17_GPIO2_IO17                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_17_SRC_BOOT_MODE01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x005c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_18          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x005c) // SW_MUX_CTL_PAD_GPIO_EMC_18 SW MUX control register [GPIO2-18]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_18_SEMC_ADDR09                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_18_FLEXPWM4_PWMB03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_18_LPUART4_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_18_FLEXCAN1_RX                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_18_QTIMER3_TIMER3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_18_GPIO4_IO18                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_18_SNVS_VIO_5_CTL             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #else
    #define GPIO_EMC_18_SEMC_ADDR02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_18_XBAR1_INOUT16              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_18_LPI2C2_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_18_SAI1_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_18_FLEXIO1_FLEXIO22           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_18_GPIO2_IO18                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_18_SRC_BT_CFG00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0060)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_19          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0060) // SW_MUX_CTL_PAD_GPIO_EMC_19 SW MUX control register [GPIO2-19]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_19_SEMC_ADDR11                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_19_FLEXPWM2_PWMA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_19_LPUART4_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_19_ENET_RDATA01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_19_QTIMER2_TIMER0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_19_GPIO4_IO19                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_19_SNVS_VIO_5                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #else
    #define GPIO_EMC_19_SEMC_ADDR03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_19_XBAR1_INOUT17              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_19_LPI2C2_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_19_SAI1_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_19_FLEXIO1_FLEXIO23           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_19_GPIO2_IO19                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_19_SRC_BT_CFG01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0064)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_20          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0064) // SW_MUX_CTL_PAD_GPIO_EMC_20 SW MUX control register [GPIO2-20]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_20_SEMC_ADDR12                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_20_FLEXPWM2_PWMB03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_20_LPUART4_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_20_ENET_RDATA00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_20_QTIMER2_TIMER1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_20_GPIO4_IO20                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #else
    #define GPIO_EMC_20_SEMC_ADDR04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_20_FLEXPWM1_PWMA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_20_LPUART2_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_20_SAI1_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_20_FLEXIO1_FLEXIO24           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_20_GPIO2_IO20                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_20_SRC_BT_CFG02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0068)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_21          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0068) // SW_MUX_CTL_PAD_GPIO_EMC_21 SW MUX control register [GPIO2-21]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_21_SEMC_BA0                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_21_FLEXPWM3_PWMA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_21_LPI2C3_SDA                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_21_ENET_TDATA01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_21_QTIMER2_TIMER2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_21_GPIO4_IO21                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #else
    #define GPIO_EMC_21_SEMC_ADDR05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_21_FLEXPWM1_PWMB03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_21_LPUART2_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_21_SAI1_RX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_21_FLEXIO1_FLEXIO25           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_21_GPIO2_IO21                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_21_SRC_BT_CFG03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x006c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x006c) // SW_MUX_CTL_PAD_GPIO_EMC_22 SW MUX control register [GPIO2-22]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_22_SEMC_BA1                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_22_FLEXPWM3_PWMB03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_22_LPI2C3_SCL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_22_ENET_TDATA00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_22_QTIMER2_TIMER3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_22_GPIO4_IO22                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_22_FLEXSPI2_A_SS1_B       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_22_SEMC_ADDR06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_22_FLEXPWM1_PWMA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_22_LPUART2_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_22_SAI1_TX_DATA03             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_22_FLEXIO1_FLEXIO26           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_22_GPIO2_IO22                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_22_SRC_BT_CFG04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0070)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0070) // SW_MUX_CTL_PAD_GPIO_EMC_23 SW MUX control register [GPIO2-23]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_23_SEMC_ADDR10                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_23_FLEXPWM1_PWMA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_23_LPUART5_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_23_ENET_RX_EN                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_23_GPT1_CAPTURE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_23_GPIO4_IO23                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_23_FLEXSPI2_A_DQS         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_23_SEMC_ADDR07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_23_FLEXPWM1_PWMB02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_23_LPUART2_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_23_SAI1_TX_DATA02             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_23_FLEXIO1_FLEXIO27           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_23_GPIO2_IO23                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_23_SRC_BT_CFG05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0074)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0074) // SW_MUX_CTL_PAD_GPIO_EMC_24 SW MUX control register [GPIO2-24]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_24_SEMC_CAS                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_24_FLEXPWM1_PWMB00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_24_LPUART5_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_24_ENET_TX_EN                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_24_GPT1_CAPTURE1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_24_GPIO4_IO24                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_24_FLEXSPI2_A_SS0_B       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_24_SEMC_ADDR08                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_24_FLEXPWM1_PWMA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_24_LPUART8_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_24_SAI1_TX_DATA01             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_24_FLEXIO1_FLEXIO28           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_24_GPIO2_IO24                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_24_SRC_BT_CFG06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0078)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0078) // SW_MUX_CTL_PAD_GPIO_EMC_25 SW MUX control register [GPIO2-25]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_25_SEMC_RAS                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_25_FLEXPWM1_PWMA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_25_LPUART6_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_25_ENET_TX_CLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_25_ENET_REF_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_25_GPIO4_IO25                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_25_FLEXSPI2_A_SCLK        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_25_SEMC_ADDR09                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_25_FLEXPWM1_PWMB01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_25_LPUART8_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_25_SAI1_TX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_25_FLEXIO1_FLEXIO29           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_25_GPIO2_IO25                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_25_SRC_BT_CFG07               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x007c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x007c) // SW_MUX_CTL_PAD_GPIO_EMC_26 SW MUX control register [GPIO2-26]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_26_SEMC_CLK                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_26_FLEXPWM1_PWMB01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_26_LPUART6_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_26_ENET_RX_ER                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_26_FLEXIO1_FLEXIO12           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_26_GPIO4_IO26                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_26_FLEXSPI2_A_DATA0       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_26_SEMC_ADDR11                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_26_FLEXPWM1_PWMA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_26_LPUART8_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_26_SAI1_TX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_26_FLEXIO1_FLEXIO30           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_26_GPIO2_IO26                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_26_SRC_BT_CFG08               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0080)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0080) // SW_MUX_CTL_PAD_GPIO_EMC_27 SW MUX control register [GPIO2-27]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_27_SEMC_CKE                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_27_FLEXPWM1_PWMA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_27_LPUART5_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_27_LPSPI1_SCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_27_FLEXIO1_FLEXIO13           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_27_GPIO4_IO27                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_27_FLEXSPI2_A_DATA1       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_27_SEMC_ADDR12                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_27_FLEXPWM1_PWMB00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_27_LPUART8_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_27_SAI1_TX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_27_FLEXIO1_FLEXIO31           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_27_GPIO2_IO27                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_27_SRC_BT_CFG09               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0084)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0084) // SW_MUX_CTL_PAD_GPIO_EMC_28 SW MUX control register [GPIO2-28]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_28_SEMC_WE                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_28_FLEXPWM1_PWMB02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_28_LPUART5_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_28_LPSPI1_SDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_28_FLEXIO1_FLEXIO14           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_28_GPIO4_IO28                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_28_FLEXSPI2_A_DATA2       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_28_SEMC_DQS                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_28_FLEXPWM2_PWMA03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_28_XBAR1_INOUT18              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_28_SAI3_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_28_EWM_OUT_B                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_28_GPIO2_IO28                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_28_GPT2_CAPTURE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_28_FLEXPWM1_PWMX00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0088)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0088) // SW_MUX_CTL_PAD_GPIO_EMC_29 SW MUX control register [GPIO2-29]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_29_SEMC_CS0                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_29_FLEXPWM3_PWMA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_29_LPUART6_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_29_LPSPI1_SDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_29_FLEXIO1_FLEXIO15           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_29_GPIO4_IO29                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_29_FLEXSPI2_A_DATA3       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_29_SEMC_CKE                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_29_FLEXPWM2_PWMB03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_29_XBAR1_INOUT19              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_29_SAI3_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_29_WDOG2_RST_B_DEB            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_29_GPIO2_IO29                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_29_GPT2_COMPARE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_29_FLEXPWM1_PWMX01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x008c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_30          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x008c) // SW_MUX_CTL_PAD_GPIO_EMC_30 SW MUX control register [GPIO2-30]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_30_SEMC_DATA08                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_30_FLEXPWM3_PWMB00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_30_LPUART6_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_30_LPSPI1_PCS0                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_30_CSI_DATA23                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_30_GPIO4_IO30                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_30_ENET2_TDATA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_EMC_30_SEMC_CLK                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_30_FLEXPWM2_PWMA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_30_LPUART4_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_30_SAI3_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_30_WDOG1_RST_B_DEB            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_30_GPIO2_IO30                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_30_GPT2_COMPARE3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_30_FLEXPWM1_PWMX02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0090)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_31          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0090) // SW_MUX_CTL_PAD_GPIO_EMC_31 SW MUX control register [GPIO2-31]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_31_SEMC_DATA09                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_31_FLEXPWM3_PWMA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_31_LPUART7_TXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_31_LPSPI1_PCS1                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_31_CSI_DATA22                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_31_GPIO4_IO31                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_31_ENET2_TDATA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_31_SEMC_DM01                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_31_FLEXPWM2_PWMB02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_31_LPUART4_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_31_SAI3_RX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_31_WDOG2_B                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_31_GPIO2_IO31                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_31_GPT2_CLK                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_31_FLEXPWM1_PWMX03            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0094)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_32          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0094) // SW_MUX_CTL_PAD_GPIO_EMC_32 SW MUX control register [GPIO3-00]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_32_SEMC_DATA10                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_32_FLEXPWM3_PWMB01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_32_LPUART7_RXD                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_32_CCM_PMIC_RDY               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_32_CSI_DATA21                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_32_GPIO3_IO18                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_32_ENET2_TX_EN            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_32_SEMC_DATA08                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_32_QTIMER1_TIMER0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_32_LPUART4_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_32_SAI3_TX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_32_LPSPI4_SCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_32_GPIO3_IO00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_32_REF_24M_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0098)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_33          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0098) // SW_MUX_CTL_PAD_GPIO_EMC_33 SW MUX control register [GPIO3-01]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_33_SEMC_DATA11                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_33_FLEXPWM3_PWMA02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_33_USDHC1_RESET_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_33_SAI3_RX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_33_CSI_DATA20                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_33_GPIO3_IO19                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_33_ENET2_TX_CLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_33_SEMC_DATA09                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_33_QTIMER1_TIMER1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_33_LPUART4_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_33_SAI3_TX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_33_LPSPI4_PCS0                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_33_GPIO3_IO01                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x009c)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_34          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x009c) // SW_MUX_CTL_PAD_GPIO_EMC_34 SW MUX control register [GPIO3-02]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_34_SEMC_DATA12                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_34_FLEXPWM3_PWMB02            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_34_USDHC1_VSELECT             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_34_SAI3_RX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_34_CSI_DATA19                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_34_GPIO3_IO20                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #if defined iMX_RT106X
        #define GPIO_EMC_34_ENET2_RX_ER            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_34_SEMC_DATA10                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_34_QTIMER1_TIMER2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_34_LPUART7_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_34_SAI3_TX_SYNC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_34_LPSPI4_SDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_34_GPIO3_IO02                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_34_ENET0_CRS                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00a0)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_35          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00a0) // SW_MUX_CTL_PAD_GPIO_EMC_35 SW MUX control register [GPIO3-03]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_35_SEMC_DATA13                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_35_XBAR1_INOUT18              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_35_GPT1_COMPARE1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_35_SAI3_RX_BCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_35_CSI_DATA18                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_35_GPIO3_IO21                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_35_USDHC1_CD_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #if defined iMX_RT106X
        #define GPIO_EMC_35_ENET2_RDATA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_35_SEMC_DATA11                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_35_QTIMER1_TIMER3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_35_LPUART7_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_35_USDHC2_WP                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_35_LPSPI4_SDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_35_GPIO3_IO03                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_35_ENET0_COL                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00a4)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_36          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00a4) // SW_MUX_CTL_PAD_GPIO_EMC_36 SW MUX control register [GPIO3-04]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_36_SEMC_DATA14                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_36_XBAR1_IN22                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_36_GPT1_COMPARE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_36_SAI3_TX_DATA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_36_CSI_DATA17                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_36_GPIO3_IO22                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_36_USDHC1_WP                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #if defined iMX_RT106X
        #define GPIO_EMC_36_ENET2_RDATA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_36_SEMC_DATA12                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_36_FLEXPWM2_PWMA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_36_LPUART5_CTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_36_CCM_PMIC_RDY               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_36_LPSPI4_PCS1                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_36_GPIO3_IO04                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_36_ENET0_RX_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_36_USDHC1_WP                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00a8)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_37          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00a8) // SW_MUX_CTL_PAD_GPIO_EMC_37 SW MUX control register [GPIO3-05]
#if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_37_SEMC_DATA15                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_37_XBAR1_IN23                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_37_GPT1_COMPARE3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_37_SAI3_MCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_37_CSI_DATA16                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_37_GPIO3_IO23                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_37_USDHC2_WP                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #if defined iMX_RT106X
        #define GPIO_EMC_37_ENET2_RX_EN            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
#else
    #define GPIO_EMC_37_SEMC_DATA13                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_37_FLEXPWM2_PWMB01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_37_LPUART5_RTS_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_37_MQS_RIGHT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_37_LPSPI4_PCS2                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_37_GPIO3_IO05                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_37_ENET0_RDATA03              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_37_USDHC1_VSELECT             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00ac)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_38          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00ac) // SW_MUX_CTL_PAD_GPIO_EMC_38 SW MUX control register [GPIO3-06]
    #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_EMC_38_SEMC_DM01              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_EMC_38_FLEXPWM1_PWM3_A        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_EMC_38_LPUART8_TXD            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_EMC_38_SAI3_TX_BCLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_EMC_38_CSI_FIELD              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_EMC_38_GPIO3_IO24             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_EMC_38_USDHC2_VSELECT         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_EMC_38_ENET2_MDC          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #else
        #define GPIO_EMC_38_SEMC_DATA14            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_EMC_38_FLEXPWM2_PWMA00        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_EMC_38_LPUART5_TX             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_EMC_38_MQS_LEFT               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_EMC_38_LPSPI4_PCS3            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_EMC_38_GPIO3_IO06             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_EMC_38_ENET0_RDATA02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_38_USDHC1_CD_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00b0)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_39          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00b0) // SW_MUX_CTL_PAD_GPIO_EMC_39 SW MUX control register [GPIO3-07]
    #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_EMC_39_SEMC_DQS               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_EMC_39_FLEXPWM1_PWM3_B        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_EMC_39_LPUART8_RXD            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_EMC_39_SAI3_TX_SYNC           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_EMC_39_WDOG1_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_EMC_39_GPIO3_IO25             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_EMC_39_USDHC2_CD_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_EMC_39_ENET2_MDIO         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_EMC_39_SEMC_DQS4          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #else
        #define GPIO_EMC_39_SEMC_DATA15            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_EMC_39_FLEXPWM2_PWMB00        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_EMC_39_LPUART5_RX             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_EMC_39_USB_OTG1_OC            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_EMC_39_WDOG1_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_EMC_39_GPIO3_IO07             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_EMC_39_ENET_TX_ER             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_EMC_39_GPT1_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00b4)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_40          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00b4) // SW_MUX_CTL_PAD_GPIO_EMC_40 SW MUX control register
  #if defined iMX_RT105X || defined iMX_RT106X                           // [GPIO3-26]
    #define GPIO_EMC_40_SEMC_RDY                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_40_GPT2_CAPTURE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_40_LPSPI1_PCS2                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_40_USB_OTG2_OC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_40_ENET0_MDC                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_40_GPIO3_IO26                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_40_USDHC2_RESET_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #else                                                                  // [GPIO3-08]
    #define GPIO_EMC_40_SEMC_CSX00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_40_XBAR1_INOUT18              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_40_SPDIF_OUT                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_40_USB_OTG1_ID                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_40_ENET0_MDIO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_40_GPIO3_IO08                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_40_ENET0_TDATA03              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_40_GPT1_COMPARE3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x00b8)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_41          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00b8) // SW_MUX_CTL_PAD_GPIO_EMC_41 SW MUX control register [GPIO3-09]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_EMC_41_SEMC_CSX0                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_41_GPT2_CAPTURE1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_41_LPSPI1_PCS3                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_41_USB_OTG2_PWR               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_41_ENET0_MDIO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_41_GPIO3_IO27                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_41_USDHC1_VSELECT             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #else
    #define GPIO_EMC_41_SEMC_READY                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_EMC_41_XBAR1_INOUT19              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_EMC_41_SPDIF_IN                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_EMC_41_USB_OTG1_PWR               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_EMC_41_ENET0_MDC                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_EMC_41_GPIO3_IO09                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_EMC_41_ENET0_TDATA02              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_EMC_41_GPT1_COMPARE2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x00bc)
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00bc) // SW_MUX_CTL_PAD_GPIO_AD_B0_00 SW MUX control register [GPIO1-00]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_00_FLEXPWM2_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_00_XBAR1_INOUT14            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_00_REF_CLK_32K              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_00_USB_OTG2_ID              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_00_LPI2C1_SCLS              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_00_GPIO1_IO00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_00_USDHC1_RESET_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_00_LPSPI3_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_00_JTAG_TMS                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_00_GPIO1_IO00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_00_GPT1_COMPARE1            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00c0) // SW_MUX_CTL_PAD_GPIO_AD_B0_01 SW MUX control register [GPIO1-01]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_01_FLEXPWM2_PWMB03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_01_XBAR1_INOUT15            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_01_REF_CLK_24M              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_01_USB_OTG1_ID              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_01_LPI2C1_SDAS              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_01_GPIO1_IO01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_01_EWM_OUT_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_01_LPSPI3_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_01_JTAG_TCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_01_GPIO1_IO01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_01_GPT1_CAPTURE2            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00c4) // SW_MUX_CTL_PAD_GPIO_AD_B0_02 SW MUX control register [GPIO1-02]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_02_FLEXCAN2_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_02_XBAR1_INOUT16            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_02_LPUART6_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_02_USB_OTG1_PWR             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_02_FLEXPWM1_PWMX00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_02_GPIO1_IO02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_02_LPI2C1_HREQ              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_02_LPSPI3_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_02_JTAG_MOD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_02_GPIO1_IO02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_02_GPT1_CAPTURE1            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00c8) // SW_MUX_CTL_PAD_GPIO_AD_B0_03 SW MUX control register [GPIO1-03]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_03_FLEXCAN2_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_03_XBAR1_INOUT17            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_03_LPUART6_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_03_USB_OTG1_OC              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_03_FLEXPWM1_PWMX01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_03_GPIO1_IO03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_03_REF_CLK_24M              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_03_LPSPI3_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_03_JTAG_TDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_03_USDHC2_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_03_WDOG1_B                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_03_SAI1_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_03_USDHC1_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_03_GPIO1_IO03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_03_USB_OTG1_OC              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_03_CCM_PMIC_RDY             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00cc) // SW_MUX_CTL_PAD_GPIO_AD_B0_04 SW MUX control register [GPIO1-04]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_04_SRC_BOOT_MODE00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_04_MQS_RIGHT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_04_ENET_TX_DATA03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_04_SAI2_TX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_04_CSI_DATA09               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_04_GPIO1_IO04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_04_PIT_TRIGGER00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_04_LPSPI3_PCS1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_04_JTAG_TDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_04_FLEXCAN1_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_04_USDHC1_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_04_QTIMER2_TIMER0           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_04_ENET0_MDIO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_04_GPIO1_IO04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_04_USB_OTG1_PWR             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_04_EWM_OUT_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00d0) // SW_MUX_CTL_PAD_GPIO_AD_B0_05 SW MUX control register [GPIO1-05]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_05_SRC_BOOT_MODE01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_05_MQS_LEFT                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_05_ENET_TX_DATA02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_05_SAI2_TX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_05_CSI_DATA08               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_05_GPIO1_IO05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_05_XBAR1_INOUT17            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_05_LPSPI3_PCS2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_05_JTAG_TRSTB               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_05_FLEXCAN1_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_05_USDHC1_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_05_QTIMER2_TIMER1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_05_ENET0_MDC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_05_GPIO1_IO05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_05_USB_OTG1_ID              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_05_NMI_GLUE_NMI             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00d4) // SW_MUX_CTL_PAD_GPIO_AD_B0_06 SW MUX control register [GPIO1-06]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_06_JTAG_TMS                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_06_GPT2_COMPARE1            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_06_ENET_RX_CLK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_06_SAI2_RX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_06_CSI_DATA07               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_06_GPIO1_IO06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_06_XBAR1_INOUT18            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_06_LPSPI3_PCS3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_06_PIT_TRIGGER00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_06_MQS_RIGHT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_06_LPUART1_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_06_QTIMER2_TIMER2           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_06_FLEXPWM2_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_06_GPIO1_IO06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_06_REF_32K_OUT              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00d8) // SW_MUX_CTL_PAD_GPIO_AD_B0_07 SW MUX control register [GPIO1-07]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_07_JTAG_TCK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_07_GPT2_COMPARE2            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_07_ENET_TX_ER               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_07_SAI2_RX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_07_CSI_DATA06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_07_GPIO1_IO07               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_07_XBAR1_INOUT19            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_07_ENET_1588_EVENT3_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_07_PIT_TRIGGER01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_07_MQS_LEFT                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_07_LPUART1_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_07_QTIMER2_TIMER3           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_07_FLEXPWM2_PWMB03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_07_GPIO1_IO07               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_07_REF_24M_OUT              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00dc) // SW_MUX_CTL_PAD_GPIO_AD_B0_08 SW MUX control register [GPIO1-08]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_08_JTAG_MOD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_08_GPT2_COMPARE3            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_08_ENET_RX_DATA03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_08_SAI2_RX_DATA             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_08_CSI_DATA05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_08_GPIO1_IO08               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_08_XBAR1_IN20               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_08_ENET_1588_EVENT3_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_08_ENET0_TX_CLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_08_LPI2C3_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_08_LPUART1_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_08_KPP_COL00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_08_ENET0_REF_CLK1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4 | IOMUXC_SW_MUX_CTL_PAD_SION)
    #define GPIO_AD_B0_08_GPIO1_IO08               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_08_ARM_CM7_TXEV             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00e0) // SW_MUX_CTL_PAD_GPIO_AD_B0_09 SW MUX control register [GPIO1-09]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_09_JTAG_TDI                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_09_FLEXPWM2_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_09_ENET_RX_DATA02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_09_SAI2_TX_DATA             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_09_CSI_DATA04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_09_GPIO1_IO09               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_09_XBAR1_IN21               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_09_GPT2_CLK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define GPIO_AD_B0_09_SEMC_DQS4                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
  #else
    #define GPIO_AD_B0_09_ENET0_RDATA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_09_LPI2C3_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_09_LPUART1_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_09_KPP_ROW00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_09_GPIO1_IO09               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_09_ARM_CM7_RXEV             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00e4) // SW_MUX_CTL_PAD_GPIO_AD_B0_10 SW MUX control register [GPIO1-10]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_10_JTAG_TDO                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_10_FLEXPWM1_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_10_ENET_CRS                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_10_SAI2_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_10_CSI_DATA03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_10_GPIO1_IO10               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_10_XBAR1_IN22               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_10_ENET_1588_EVENT0_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B0_10_FLEXCAN3_TX          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B0_10_ARM_TRACE_SWO        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B0_10_ENET0_RDATA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_10_LPSPI1_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_10_LPUART5_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_10_KPP_COL01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_10_FLEXPWM2_PWMA02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_10_GPIO1_IO10               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_10_ARM_CM7_TRACE_CLK        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00e8) // SW_MUX_CTL_PAD_GPIO_AD_B0_11 SW MUX control register [GPIO1-11]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_11_JTAG_TRSTB               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_11_FLEXPWM1_PWMB03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_11_ENET_COL                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_11_WDOG1_WDOG_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_11_CSI_DATA02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_11_GPIO1_IO11               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_11_XBAR1_IN23               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_11_ENET_1588_EVENT0_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B0_11_FLEXCAN3_RX          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B0_11_SEMC_CLK6            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B0_11_ENET0_RX_EN              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0) // ENET_CRS_DV
    #define GPIO_AD_B0_11_LPSPI1_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_11_LPUART5_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_11_KPP_ROW01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_11_FLEXPWM2_PWMB02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_11_GPIO1_IO11               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_11_ARM_CM7_TRACE_SWO        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_12        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00ec) // SW_MUX_CTL_PAD_GPIO_AD_B0_12 SW MUX control register [GPIO1-12]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_12_LPI2C4_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_12_CCM_PMIC_READY           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_12_LPUART1_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_12_WDOG2_WDOG_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_12_FLEXPWM1_PWMX02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_12_GPIO1_IO12               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_12_ENET_1588_EVENT1_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_12_NMI_GLUE_NMI             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_12_ENET0_RX_ER              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_12_LPSPI1_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_12_LPUART3_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_12_KPP_COL02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_12_FLEXPWM2_PWMA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_12_GPIO1_IO12               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_12_ARM_CM7_TRACE00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_12_SNVS_HP_VIO_5_CTL        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_13        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00f0) // SW_MUX_CTL_PAD_GPIO_AD_B0_13 SW MUX control register [GPIO1-13]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_13_LPI2C4_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_13_GPT1_CLK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_13_LPUART1_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_13_EWM_OUT_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_13_FLEXPWM1_PWMX03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_13_GPIO1_IO13               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_13_ENET_1588_EVENT1_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_13_REF_CLK_24M              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #else
    #define GPIO_AD_B0_13_ENET0_TX_EN              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_13_LPSPI1_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_13_LPUART3_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_13_KPP_ROW02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_13_FLEXPWM2_PWMB01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_13_GPIO1_IO13               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_13_ARM_CM7_TRACE01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_13_SNVS_HP_VIO_5_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_14        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00f4) // SW_MUX_CTL_PAD_GPIO_AD_B0_14 SW MUX control register [GPIO1-14]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_14_USB_OTG2_OC              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_14_XBAR1_IN24               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_14_LPUART1_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_14_ENET_1588_EVENT0_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_14_CSI_VSYNC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_14_GPIO1_IO14               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_14_FLEXCAN2_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #if defined iMX_RT106X
        #define GPIO_AD_B0_14_FLEXCAN3_TX          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_AD_B0_14_ENET0_TDATA00            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_14_FLEXCAN2_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_14_LPUART3_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_14_KPP_COL03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_14_FLEXPWM2_PWMA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_14_GPIO1_IO14               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_14_ARM_CM7_TRACE02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_14_WDOG1_ANY                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B0_15        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00f8) // SW_MUX_CTL_PAD_GPIO_AD_B0_15 SW MUX control register [GPIO1-15]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B0_15_USB_OTG2_PWR             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_15_XBAR1_IN25               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_15_LPUART1_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_15_ENET_1588_EVENT0_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_15_CSI_HSYNC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_15_GPIO1_IO15               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_15_FLEXCAN2_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B0_15_WDOG1_WDOG_RST_B_DEB     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B0_15_FLEXCAN3_RX          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
    #endif
  #else
    #define GPIO_AD_B0_15_ENET0_TDATA01            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B0_15_FLEXCAN2_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B0_15_LPUART3_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B0_15_KPP_ROW03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B0_15_FLEXPWM2_PWMB00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B0_15_GPIO1_IO15               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B0_15_ARM_CM7_TRACE03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#if !defined iMX_RT1015
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x00fc) // SW_MUX_CTL_PAD_GPIO_AD_B1_00 SW MUX control register [GPIO1-16]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_00_USB_OTG2_ID              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_00_QTIMER3_TIMER0           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_00_LPUART2_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_00_LPI2C1_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_00_WDOG1_B                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_00_GPIO1_IO16               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_00_USDHC1_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_00_KPP_ROW07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_00_ENET2_1588_EVENT0_OUT  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_00_FLEXIO3_FLEXIO00     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_00_SEMC_READY               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_00_FLEXSPI_A_DATA03         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_00_FLEXCAN2_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_00_SAI1_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_00_FLEXIO1_FLEXIO15         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_00_GPIO1_IO16               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_00_ENET_1588_EVENT2_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_00_KPP_COL04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0100) // SW_MUX_CTL_PAD_GPIO_AD_B1_01 SW MUX control register [GPIO1-17]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_01_USB_OTG1_PWR             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_01_QTIMER3_TIMER1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_01_LPUART2_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_01_LPI2C1_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_01_CCM_PMIC_READY           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_01_GPIO1_IO17               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_01_USDHC1_VSELECT           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_01_KPP_COL07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_01_ENET2_1588_EVENT0_IN (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_01_FLEXIO3_FLEXIO01     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_01_SEMC_CSX00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_01_FLEXSPI_A_SCLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_01_FLEXCAN2_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_01_SAI1_TX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_01_FLEXIO1_FLEXIO14         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_01_GPIO1_IO17               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_01_ENET_1588_EVENT2_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_01_KPP_ROW04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0104) // SW_MUX_CTL_PAD_GPIO_AD_B1_02 SW MUX control register [GPIO1-18]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_02_USB_OTG1_ID              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_02_QTIMER3_TIMER2           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_02_LPUART2_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_02_SPDIF_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_02_ENET_1588_EVENT2_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_02_GPIO1_IO18               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_02_USDHC1_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_02_KPP_ROW06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_02_GPT2_CLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_02_FLEXIO3_FLEXIO02     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_02_SEMC_CSX01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_02_FLEXSPI_A_DATA00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_02_LPSPI4_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_02_SAI1_TX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_02_FLEXIO1_FLEXIO13         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_02_GPIO1_IO18               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_02_ENET_1588_EVENT3_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_02_KPP_COL05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0108) // SW_MUX_CTL_PAD_GPIO_AD_B1_03 SW MUX control register [GPIO1-19]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_03_USB_OTG1_OC              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_03_QTIMER3_TIMER3           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_03_LPUART2_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_03_SPDIF_IN                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_03_ENET_1588_EVENT2_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_03_GPIO1_IO19               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_03_USDHC2_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_03_KPP_COL06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_03_GPT2_CAPTURE1        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_03_FLEXIO3_FLEXIO03     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_03_SEMC_CSX02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_03_FLEXSPI_A_DATA02         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_03_LPSPI4_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_03_SAI1_TX_DATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_03_FLEXIO1_FLEXIO12         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_03_GPIO1_IO19               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_03_ENET_1588_EVENT3_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_03_KPP_ROW05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x010c) // SW_MUX_CTL_PAD_GPIO_AD_B1_04 SW MUX control register [GPIO1-20]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_04_FLEXSPIB_DATA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_04_ENET_MDC                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_04_LPUART3_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_04_SPDIF_SR_CLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_04_CSI_PIXCLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_04_GPIO1_IO20               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_04_USDHC2_DATA0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_04_KPP_ROW05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_04_GPT2_CAPTURE2        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_04_FLEXIO3_FLEXIO04     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_04_SEMC_CSX03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_04_FLEXSPI_A_DATA01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_04_LPSPI4_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_04_SAI1_RX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_04_FLEXIO1_FLEXIO11         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_04_GPIO1_IO20               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_04_LPSPI1_PCS1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_04_KPP_COL06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0110) // SW_MUX_CTL_PAD_GPIO_AD_B1_05 SW MUX control register [GPIO1-21]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_05_FLEXSPIB_DATA02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_05_ENET_MDIO                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_05_LPUART3_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_05_SPDIF_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_05_CSI_MCLK                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_05_GPIO1_IO21               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_05_USDHC2_DATA1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_05_KPP_COL05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_05_GPT2_COMPARE1        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_05_FLEXIO3_FLEXIO05     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_05_USDHC1_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_05_FLEXSPI_A_SS0_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_05_LPSPI4_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_05_SAI1_RX_DATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_05_FLEXIO1_FLEXIO10         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_05_GPIO1_IO21               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_05_LPSPI1_PCS2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_05_KPP_ROW06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0114) // SW_MUX_CTL_PAD_GPIO_AD_B1_06 SW MUX control register [GPIO1-22]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_06_FLEXSPIB_DATA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_06_LPI2C3_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_06_LPUART3_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_06_SPDIF_LOCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_06_CSI_VSYNC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_06_GPIO1_IO22               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_06_USDHC2_DATA2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_06_KPP_ROW04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_06_GPT2_COMPARE2        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_06_FLEXIO3_FLEXIO06     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_06_USDHC1_RESET_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_06_FLEXPWM1_PWMA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_06_LPUART2_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_06_SAI1_RX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_06_FLEXIO1_FLEXIO09         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_06_GPIO1_IO22               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_06_LPSPI1_PCS3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_06_KPP_COL07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0118) // SW_MUX_CTL_PAD_GPIO_AD_B1_07 SW MUX control register [GPIO1-23]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_07_FLEXSPIB_DATA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_07_LPI2C3_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_07_LPUART3_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_07_SPDIF_EXT_CLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_07_CSI_HSYNC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_07_GPIO1_IO23               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_07_USDHC2_DATA3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_07_KPP_COL04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #if defined iMX_RT106X
            #define GPIO_AD_B1_07_GPT2_COMPARE3        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_AD_B1_07_FLEXIO3_FLEXIO07     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
      #else
        #define GPIO_AD_B1_07_USDHC1_VSELECT           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_07_FLEXPWM1_PWMB00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_07_LPUART2_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_07_SAI1_TX_DATA01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_07_FLEXIO1_FLEXIO08         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_07_GPIO1_IO23               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_07_LPSPI3_PCS3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_07_KPP_ROW07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x011c) // SW_MUX_CTL_PAD_GPIO_AD_B1_08 SW MUX control register [GPIO1-24]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_08_FLEXSPIA_SS1_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_08_FLEXPWM4_PWMA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_08_FLEXCAN1_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_08_CCM_PMIC_READY           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_08_CSI_DATA09               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_08_GPIO1_IO24               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_08_USDHC2_CMD               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_08_KPP_ROW03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #define GPIO_AD_B1_08_FLEXIO3_FLEXIO08         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
      #else
        #define GPIO_AD_B1_08_LPI2C2_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_08_FLEXPWM1_PWMA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_08_LPUART2_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_08_SAI1_TX_DATA02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_08_FLEXIO1_FLEXIO07         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_08_GPIO1_IO24               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_08_LPSPI3_PCS2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_08_XBAR1_INOUT12            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0120) // SW_MUX_CTL_PAD_GPIO_AD_B1_09 SW MUX control register [GPIO1-25]
      #if defined iMX_RT105X || defined iMX_RT106X
        #define GPIO_AD_B1_09_FLEXSPIA_DQS             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_09_FLEXPWM4_PWMA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_09_FLEXCAN1_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_09_SAI1_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_09_CSI_DATA08               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_09_GPIO1_IO25               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_09_USDHC2_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_09_KPP_COL03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
        #define GPIO_AD_B1_09_FLEXIO3_FLEXIO09         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
      #else
        #define GPIO_AD_B1_09_LPI2C2_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_AD_B1_09_FLEXPWM1_PWMB01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_AD_B1_09_LPUART2_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_AD_B1_09_SAI1_TX_DATA03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_AD_B1_09_FLEXIO1_FLEXIO06         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_AD_B1_09_GPIO1_IO25               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_AD_B1_09_LPSPI3_PCS1              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_AD_B1_09_XBAR1_INOUT13            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
      #endif
#endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0124) // SW_MUX_CTL_PAD_GPIO_AD_B1_10 SW MUX control register [GPIO1-26]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B1_10_FLEXSPIA_DATA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_10_WDOG1_B                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_10_LPUART8_TXD              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_10_SAI1_RX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_10_CSI_DATA07               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_10_GPIO1_IO26               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_10_USDHC2_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B1_10_KPP_ROW02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B1_10_ENET2_1588_EVENT1_OUT  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B1_10_FLEXIO3_FLEXIO10     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B1_10_USB_OTG1_PWR             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_10_FLEXPWM1_PWMA02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_10_LPUART4_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_10_USDHC1_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_10_FLEXIO1_FLEXIO05         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_10_GPIO1_IO26               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_10_GPT2_CAPTURE1            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0128) // SW_MUX_CTL_PAD_GPIO_AD_B1_11 SW MUX control register [GPIO1-27]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B1_11_FLEXSPIA_DATA02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_11_EWM_OUT_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_11_LPUART8_RXD              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_11_SAI1_RX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_11_CSI_DATA06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_11_GPIO1_IO27               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_11_USDHC2_RESET_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B1_11_KPP_COL02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B1_11_ENET2_1588_EVENT1_IN (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B1_11_FLEXIO3_FLEXIO11     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B1_11_USB_OTG1_ID              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_11_FLEXPWM1_PWMB02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_11_LPUART4_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_11_USDHC1_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_11_FLEXIO1_FLEXIO04         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_11_GPIO1_IO27               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_11_GPT2_COMPARE1            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x012c) // SW_MUX_CTL_PAD_GPIO_AD_B1_12 SW MUX control register [GPIO1-28]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B1_12_FLEXSPIA_DATA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_12_ACMP_OUT00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_12_LPSPI3_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_12_SAI1_RX_DATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_12_CSI_DATA05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_12_GPIO1_IO28               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_12_USDHC2_DATA4             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B1_12_KPP_ROW01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B1_12_ENET2_1588_EVENT2_OUT  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B1_12_FLEXIO3_FLEXIO12     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B1_12_USB_OTG1_OC              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_12_ACMP1_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_12_LPSPI3_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_12_USDHC2_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_12_FLEXIO1_FLEXIO03         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_12_GPIO1_IO28               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_12_FLEXPWM1_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0130) // SW_MUX_CTL_PAD_GPIO_AD_B1_13 SW MUX control register [GPIO1-29]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B1_13_FLEXSPIA_DATA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_13_ACMP_OUT01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_13_LPSPI3_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_13_SAI1_TX_DATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_13_CSI_DATA04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_13_GPIO1_IO29               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_13_USDHC2_DATA5             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B1_13_KPP_COL01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B1_13_ENET2_1588_EVENT2_IN (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B1_13_FLEXIO3_FLEXIO13     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B1_13_LPI2C1_HREQ              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_13_ACMP2_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_13_LPSPI3_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_13_USDHC2_WP                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_13_FLEXIO1_FLEXIO02         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_13_GPIO1_IO29               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_13_FLEXPWM1_PWMB03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_14        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0134) // SW_MUX_CTL_PAD_GPIO_AD_B1_14 SW MUX control register [GPIO1-30]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B1_14_FLEXSPIA_SCLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_14_ACMP_OUT02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_14_LPSPI3_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_14_SAI1_TX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_14_CSI_DATA03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_14_GPIO1_IO30               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_14_USDHC2_DATA6             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B1_14_KPP_ROW00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B1_14_ENET2_1588_EVENT3_OUT  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B1_14_FLEXIO3_FLEXIO14     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B1_14_LPI2C1_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_14_ACMP3_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_14_LPSPI3_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_14_ENET_1588_EVENT0_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_14_FLEXIO1_FLEXIO01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_14_GPIO1_IO30               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#define IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_15        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0138) // SW_MUX_CTL_PAD_GPIO_AD_B1_15 SW MUX control register [GPIO1-31]
  #if defined iMX_RT105X || defined iMX_RT106X
    #define GPIO_AD_B1_15_FLEXSPIA_SS0_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_15_ACMP_OUT03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_15_LPSPI3_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_15_SAI1_TX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_15_CSI_DATA02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_15_GPIO1_IO31               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define GPIO_AD_B1_15_USDHC2_DATA7             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define GPIO_AD_B1_15_KPP_COL00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #if defined iMX_RT106X
        #define GPIO_AD_B1_15_ENET2_1588_EVENT3_IN (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #define GPIO_AD_B1_15_FLEXIO3_FLEXIO15     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
    #endif
  #else
    #define GPIO_AD_B1_15_LPI2C1_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
    #define GPIO_AD_B1_15_ACMP4_OUT                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
    #define GPIO_AD_B1_15_LPSPI3_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
    #define GPIO_AD_B1_15_ENET_1588_EVENT0_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
    #define GPIO_AD_B1_15_FLEXIO1_FLEXIO00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
    #define GPIO_AD_B1_15_GPIO1_IO31               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
  #endif
#if defined iMX_RT105X || defined iMX_RT106X
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00_ADD       (unsigned long *)(IOMUXC_SW_BLOCK + 0x013c)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x013c) // SW_MUX_CTL_PAD_GPIO_B0_00 SW MUX control register [GPIO2-0]
        #define GPIO_B0_00_LCD_CLK                     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_00_QTIMER1_TIMER0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_00_MQS_RIGHT                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_00_LPSPI4_PCS0                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_00_FLEXIO2_D00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_00_GPIO2_IO00                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
            #define GPIO_B0_00_SEMC_CSX01              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_00_ENET2_MDC               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0140) // SW_MUX_CTL_PAD_GPIO_B0_01 SW MUX control register [GPIO2-1]
        #define GPIO_B0_01_LCD_ENABLE                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_01_TMR1_TIMER1                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_01_MQS_LEFT                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_01_LPSPI4_SDI                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_01_FLEXIO2_D01                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_01_GPIO2_IO01                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_01_SEMC_CSX02                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_01_ENET2_MDIO              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0144) // SW_MUX_CTL_PAD_GPIO_B0_02 SW MUX control register [GPIO2-2]
        #define GPIO_B0_02_LCD_HSYNC                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_02_TMR1_TIMER2                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_02_FLEXCAN1_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_02_LPSPI4_SDO                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_02_FLEXIO2_D02                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_02_GPIO2_IO02                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_02_SEMC_CSX03                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_02_ENET2_1588_EVENT0_OUT   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0148) // SW_MUX_CTL_PAD_GPIO_B0_03 SW MUX control register [GPIO2-3]
        #define GPIO_B0_03_LCD_VSYNC                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_03_TMR2_TIMER0                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_03_FLEXCAN1_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_03_LPSPI4_SCK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_03_FLEXIO2_D03                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_03_GPIO2_IO03                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_03_WDOG2_RESET_B_DEB           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_03_ENET2_1588_EVENT0_IN    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_04           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x014c) // SW_MUX_CTL_PAD_GPIO_B0_04 SW MUX control register [GPIO2-4]
        #define GPIO_B0_04_LCD_DATA00                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_04_TMR2_TIMER1                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_04_LPI2C2_SCL                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_04_ARM_TRACE00                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_04_FLEXIO2_D04                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_04_GPIO2_IO04                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_04_SRC_BT_CFG00                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_04_ENET2_TDATA03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_05           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0150) // SW_MUX_CTL_PAD_GPIO_B0_05 SW MUX control register [GPIO2-5]
        #define GPIO_B0_05_LCD_DATA01                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_05_TMR2_TIMER2                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_05_LPI2C2_SDA                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_05_ARM_TRACE01                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_05_FLEXIO2_D05                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_05_GPIO2_IO05                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_05_SRC_BT_CFG01                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_05_ENET2_TDATA02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_06           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0154) // SW_MUX_CTL_PAD_GPIO_B0_06 SW MUX control register [GPIO2-6]
        #define GPIO_B0_06_LCD_DATA02                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_06_TMR3_TIMER0                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_06_FLEXPWM2_PWM0_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_06_ARM_TRACE02                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_06_FLEXIO2_D06                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_06_GPIO2_IO06                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_06_SRC_BT_CFG02                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_06_ENET2_RX_CLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_07           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0158) // SW_MUX_CTL_PAD_GPIO_B0_08 SW MUX control register [GPIO2-7]
        #define GPIO_B0_07_LCD_DATA03                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_07_TMR3_TIMER1                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_07_FLEXPWM2_PWM0_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_07_ARM_TRACE03                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_07_FLEXIO2_D07                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_07_GPIO2_IO07                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_07_SRC_BT_CFG03                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_07_ENET2_TX_ER             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_08           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x015c) // SW_MUX_CTL_PAD_GPIO_B0_09 SW MUX control register [GPIO2-8]
        #define GPIO_B0_08_LCD_DATA04                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_08_TMR3_TIMER2                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_08_FLEXPWM2_PWM1_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_08_LPUART3_TXD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_08_FLEXIO2_D08                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_08_GPIO2_IO08                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_08_SRC_BT_CFG04                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_08_ENET2_RDATA03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_09           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0160) // SW_MUX_CTL_PAD_GPIO_B0_09 SW MUX control register [GPIO2-9]
        #define GPIO_B0_09_LCD_DATA05                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_09_TMR4_TIMER0                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_09_FLEXPWM2_PWM1_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_09_LPUART3_RXD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_09_FLEXIO2_D09                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_09_GPIO2_IO09                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_09_SRC_BT_CFG05                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_09_ENET2_RDATA02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0164) // SW_MUX_CTL_PAD_GPIO_B0_10 SW MUX control register [GPIO2-10]
        #define GPIO_B0_10_LCD_DATA06                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_10_TMR4_TIMER1                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_10_FLEXPWM2_PWM2_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_10_SAI1_TX_DATA03D             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_10_FLEXIO2_D10                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_10_GPIO2_IO10                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_10_SRC_BT_CFG06                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_10_ENET2_CRS               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0168) // SW_MUX_CTL_PAD_GPIO_B0_11 SW MUX control register [GPIO2-11]
        #define GPIO_B0_11_LCD_DATA07                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_11_TMR4_TIMER2                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_11_FLEXPWM2_PWM2_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_11_SAI1_TX_DATA02              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_11_FLEXIO2_D11                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_11_GPIO2_IO11                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_11_SRC_BT_CFG07                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_11_ENET2_COL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x016c) // SW_MUX_CTL_PAD_GPIO_B0_12 SW MUX control register [GPIO2-12]
        #define GPIO_B0_12_LCD_DATA08                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_12_XBAR1_INOUT10               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_12_ARM_TRACE_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_12_SAI1_TX_DATA01              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_12_FLEXIO2_D12                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_12_GPIO2_IO12                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_12_SRC_BT_CFG08                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_12_ENET2_TDATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_13           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0170) // SW_MUX_CTL_PAD_GPIO_B0_13 SW MUX control register [GPIO2-13]
        #define GPIO_B0_13_LCD_DATA09                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_13_XBAR1_INOUT11               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_13_ARM_TRACE_SWO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_13_SAI1_MCLK                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_13_FLEXIO2_D13                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_13_GPIO2_IO13                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_13_SRC_BT_CFG09                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_13_ENET2_TDATA01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_14           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0174) // SW_MUX_CTL_PAD_GPIO_B0_14 SW MUX control register [GPIO2-14]
        #define GPIO_B0_14_LCD_DATA10                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_14_XBAR1_INOUT12               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_14_ARM_CM7_TXEV                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_14_SAI1_RX_SYNC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_14_FLEXIO2_D14                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_14_GPIO2_IO14                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_14_SRC_BT_CFG10                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_14_ENET2_TX_EN             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_15           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0178) // SW_MUX_CTL_PAD_GPIO_B0_15 SW MUX control register [GPIO2-15]
        #define GPIO_B0_15_LCD_DATA11                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B0_15_XBAR1_INOUT13               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B0_15_ARM_CM7_RXEV                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B0_15_SAI1_RX_BCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B0_15_FLEXIO2_D15                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B0_15_GPIO2_IO15                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B0_15_SRC_BT_CFG11                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B0_15_ENET2_TX_CLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B0_15_ENET2_REF_CLK2          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_00           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x017c) // SW_MUX_CTL_PAD_GPIO_B1_00 SW MUX control register [GPIO2-16]
        #define GPIO_B1_00_LCD_DATA12                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_00_XBAR1_INOUT14               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_00_LPUART4_TXD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_00_SAI1_RX_DATA00              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_00_FLEXIO2_D16                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_00_GPIO2_IO16                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_00_FLEXPWM1_PWM3_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_00_ENET2_RX_ER             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_00_FLEXIO3_FLEXIO16        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_01           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0180) // SW_MUX_CTL_PAD_GPIO_B1_01 SW MUX control register [GPIO2-17]
        #define GPIO_B1_01_LCD_DATA13                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_01_XBAR1_INOUT15               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_01_LPUART4_RXD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_01_SAI1_TX_DATA00              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_01_FLEXIO2_D17                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_01_GPIO2_IO17                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_01_FLEXPWM1_PWM3_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_01_ENET2_RDATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_01_FLEXIO3_FLEXIO17        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0184) // SW_MUX_CTL_PAD_GPIO_B1_02 SW MUX control register [GPIO2-18]
        #define GPIO_B1_02_LCD_DATA14                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_02_XBAR1_INOUT16               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_02_LPSPI4_PCS2                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_02_SAI1_TX_BCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_02_FLEXIO2_D18                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_02_GPIO2_IO18                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_02_FLEXPWM2_PWM3_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_02_ENET2_RDATA01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_02_FLEXIO3_FLEXIO18        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0188) // SW_MUX_CTL_PAD_GPIO_B1_03 SW MUX control register [GPIO2-19]
        #define GPIO_B1_03_LCD_DATA15                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_03_XBAR1_INOUT17               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_03_LPSPI4_PCS1                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_03_SAI1_TX_SYNC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_03_FLEXIO2_D19                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_03_GPIO2_IO19                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_03_FLEXPWM2_PWM3_B             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_03_ENET2_RX_EN             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_03_FLEXIO3_FLEXIO19        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_04           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x018c) // SW_MUX_CTL_PAD_GPIO_B1_04 SW MUX control register [GPIO2-20]
        #define GPIO_B1_04_LCD_DATA16                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_04_LPSPI4_PCS0                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_04_CSI_DATA15                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_04_ENET0_RX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_04_FLEXIO2_D20                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_04_GPIO2_IO20                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_B1_04_GPT1_CLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_04_FLEXIO3_FLEXIO20        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_05           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0190) // SW_MUX_CTL_PAD_GPIO_B1_05 SW MUX control register [GPIO2-21]
        #define GPIO_B1_05_LCD_DATA17                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_05_LPSPI4_SDI                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_05_CSI_DATA14                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_05_ENET0_RX_DATA01             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_05_FLEXIO2_D21                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_05_GPIO2_IO21                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_B1_05_GPT1_CAPTURE1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_05_FLEXIO3_FLEXIO21        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_06           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0194) // SW_MUX_CTL_PAD_GPIO_B1_06 SW MUX control register [GPIO2-22]
        #define GPIO_B1_06_LCD_DATA18                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_06_LPSPI4_SDO                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_06_CSI_DATA13                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_06_ENET0_RX_EN                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_06_FLEXIO2_D22                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_06_GPIO2_IO22                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_B1_06_GPT1_CAPTURE2           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_06_FLEXIO3_FLEXIO22        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_07           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0198) // SW_MUX_CTL_PAD_GPIO_B1_07 SW MUX control register [GPIO2-23]
        #define GPIO_B1_07_LCD_DATA19                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_07_LPSPI4_SCK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_07_CSI_DATA12                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_07_ENET0_TX_DATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_07_FLEXIO2_D23                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_07_GPIO2_IO23                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_B1_07_GPT1_COMPARE1	       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_07_FLEXIO3_FLEXIO23        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_08           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x019c) // SW_MUX_CTL_PAD_GPIO_B1_08 SW MUX control register [GPIO2-24]
        #define GPIO_B1_08_LCD_DATA20                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_08_TMR1_TIMER3                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_08_CSI_DATA11                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_08_ENET0_TX_DATA01             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_08_FLEXIO2_D24                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_08_GPIO2_IO24                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_08_FLEXCAN2_TX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_08_GPT1_COMPARE2	       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_08_FLEXIO3_FLEXIO24        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_09           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a0) // SW_MUX_CTL_PAD_GPIO_B1_09 SW MUX control register [GPIO2-25]
        #define GPIO_B1_09_LCD_DATA21                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_09_TMR2_TIMER3                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_09_CSI_DATA10                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_09_ENET0_TX_EN                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_09_FLEXIO2_D25                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_09_GPIO2_IO25                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_09_FLEXCAN2_RX                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_09_GPT1_COMPARE3	       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_09_FLEXIO3_FLEXIO25        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_10           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a4) // SW_MUX_CTL_PAD_GPIO_B1_10 SW MUX control register [GPIO2-26]
        #define GPIO_B1_10_LCD_DATA22                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_10_TMR3_TIMER3                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_10_CSI_DATA00                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_10_ENET0_TX_CLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_10_FLEXIO2_D26                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_10_GPIO2_IO26                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_10_ENET0_REF_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_10_FLEXIO3_FLEXIO26        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_11           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a8) // SW_MUX_CTL_PAD_GPIO_B1_11 SW MUX control register [GPIO2-27]
        #define GPIO_B1_11_LCD_DATA23                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_11_TMR4_TIMER3                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_11_CSI_DATA01                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_11_ENET0_RX_ER                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_11_FLEXIO2_D27                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_11_GPIO2_IO27                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_11_LPSPI4_PCS3                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_11_FLEXIO3_FLEXIO27        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01ac) // SW_MUX_CTL_PAD_GPIO_B1_12 SW MUX control register [GPIO2-28]
        #define GPIO_B1_12_LPUART5_TXD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_12_CSI_PIXCLK                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_12_ENET_1588_EVENT0_IN         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_12_FLEXIO2_D28                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_12_GPIO2_IO28                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_12_USDHC1_CD_B                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_12_FLEXIO3_FLEXIO28        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b0) // SW_MUX_CTL_PAD_GPIO_B1_13 SW MUX control register [GPIO2-29]
        #define GPIO_B1_13_WDOG1_B                     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_13_LPUART5_RXD                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_13_CSI_VSYNC                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_13_ENET_1588_EVENT0_OUT        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_13_FLEXIO2_D29                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_13_GPIO2_IO29                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_13_USDHC1_WP                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_13_GSEMC_DQS4	           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_13_FLEXIO3_FLEXIO29        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_14           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b4) // SW_MUX_CTL_PAD_GPIO_B1_14 SW MUX control register [GPIO2-30]
        #define GPIO_B1_14_ENET_MDC                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_14_FLEXPWM4_PWM2_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_14_CSI_HSYNC                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_14_XBAR1_INOUT02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_14_FLEXIO2_D30                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_14_GPIO2_IO30                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_14_USDHC1_VSELECT              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_14_ENET2_TDATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_14_FLEXIO3_FLEXIO30        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_15           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b8) // SW_MUX_CTL_PAD_GPIO_B1_15 SW MUX control register [GPIO2-31]
        #define GPIO_B1_15_ENET_MDIO                   (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_B1_15_FLEXPWM4_PWM3_A             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_B1_15_CSI_MCLK                    (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_B1_15_XBAR1_INOUT03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_B1_15_FLEXIO2_D31                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_B1_15_GPIO2_IO31                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_B1_15_USDHC1_RESET_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_B1_15_ENET2_TDATA01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_B1_15_FLEXIO3_FLEXIO31        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT9)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x01bc)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01bc) // SW_MUX_CTL_PAD_GPIO_SD_B0_00 SW MUX control register [GPIO3-12]
        #define GPIO_SD_B0_00_USDHC1_CMD               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_00_FLEXPWM1_PWMA00          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_00_LPI2C3_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_00_XBAR1_INOUT04            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_00_LPSPI1_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_00_GPIO3_IO12               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_00_FLEXSPIA_SS1_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B0_00_ENET2_TX_EN          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_SD_B0_00_SEMC_DQS4           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c0) // SW_MUX_CTL_PAD_GPIO_SD_B0_01 SW MUX control register [GPIO3-13]
        #define GPIO_SD_B0_01_USDHC1_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_01_FLEXPWM1_PWM0_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_01_LPI2C3_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_01_XBAR1_INOUT05            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_01_LPSPI1_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_01_GPIO3_IO13               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_01_FLEXSPI_B_SS1_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B0_01_ENET2_TX_CLK         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_SD_B0_01_ENET2_REF_CLK2       (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c4) // SW_MUX_CTL_PAD_GPIO_SD_B0_02 SW MUX control register [GPIO3-14]
        #define GPIO_SD_B0_02_USDHC1_DATA0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_02_FLEXPWM1_PWMA01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_02_LPUART8_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_02_XBAR1_INOUT06            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_02_LPSPI1_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_02_GPIO3_IO14               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_SD_B0_02_ENET2_RX_ER          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_SD_B0_02_SEMC_CLK5            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c8) // SW_MUX_CTL_PAD_GPIO_SD_B0_04 SW MUX control register [GPIO3-15]
        #define GPIO_SD_B0_03_USDHC1_DATA1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_03_FLEXPWM1_PWMB01          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_03_LPUART8_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_03_XBAR1_INOUT07            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_03_LPSPI1_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_03_GPIO3_IO15               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_SD_B0_03_ENET2_RDATA00        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
            #define GPIO_SD_B0_03_SEMC_CLK6            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01cc) // SW_MUX_CTL_PAD_GPIO_SD_B0_04 SW MUX control register [GPIO3-16]
        #define GPIO_SD_B0_04_USDHC1_DATA2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_04_FLEXPWM1_PWMA02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_04_LPUART8_TXD              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_04_XBAR1_INOUT08            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_04_FLEXSPIB_SS0_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_04_GPIO3_IO16               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_04_CCM_CLKO1                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B0_04_ENET2_RDATA01        (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d0) // SW_MUX_CTL_PAD_GPIO_SD_B0_05 SW MUX control register [GPIO3-17]
        #define GPIO_SD_B0_05_USDHC1_DATA3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_05_FLEXPWM1_PWMB02          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_05_LPUART8_RXD              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_05_XBAR1_INOUT09            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_05_FLEXSPIB_DQS             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_05_GPIO3_IO17               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_05_CCM_CLKO2                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B0_05_ENET2_RX_EN          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x01d4)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d4) // SW_MUX_CTL_PAD_GPIO_SD_B1_00 SW MUX control register [GPIO3-0]
        #define GPIO_SD_B1_00_USDHC2_DATA3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_00_FLEXSPI_B_DATA03         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_00_FLEXPWM1_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_00_SAI1_TX_DATA03           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_00_LPUART4_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_00_GPIO3_IO00               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_00_SAI3_RX_DATA         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d8) // SW_MUX_CTL_PAD_GPIO_SD_B1_01 SW MUX control register [GPIO3-1]
        #define GPIO_SD_B1_01_USDHC2_DATA2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_01_FLEXSPI_B_DATA02         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_01_FLEXPWM1_PWMB03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_01_SAI1_TX_DATA02           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_01_LPUART4_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_01_GPIO3_IO01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_01_SAI3_TX_DATA         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01dc) // SW_MUX_CTL_PAD_GPIO_SD_B1_02 SW MUX control register [GPIO3-2]
        #define GPIO_SD_B1_02_USDHC2_DATA1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_02_FLEXSPI_B_DATA01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_02_FLEXPWM2_PWMA03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_02_SAI1_TX_DATA01           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_02_FLEXCAN1_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_02_GPIO3_IO02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_02_CCM_WAIT                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_02_SAI3_TX_SYNC         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e0) // SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW MUX control register [GPIO3-3]
        #define GPIO_SD_B1_03_USDHC2_DATA0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_03_FLEXSPI_B_DATA00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_03_FLEXPWM2_PWMB03          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_03_SAI1_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_03_FLEXCAN1_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_03_GPIO3_IO03               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_03_CCM_PMIC_READY           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_03_SAI3_TX_BCLK         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e4) // SW_MUX_CTL_PAD_GPIO_SD_B1_04 SW MUX control register [GPIO3-4]
        #define GPIO_SD_B1_04_USDHC2_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_04_FLEXSPI_B_SCLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_04_LPI2C1_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_04_SAI1_RX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_04_FLEXSPIA_SS1_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_04_GPIO3_IO04               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_04_CCM_STOP                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_04_SAI3_MCLK            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e8) // SW_MUX_CTL_PAD_GPIO_SD_B1_05 SW MUX control register [GPIO3-5]
        #define GPIO_SD_B1_05_USDHC2_CMD               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_05_FLEXSPI_A_DQS            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_05_LPI2C1_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_05_SAI1_RX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_05_FLEXSPIB_SS0_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_05_GPIO3_IO05               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_05_SAI3_RX_SYNC         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01ec) // SW_MUX_CTL_PAD_GPIO_SD_B1_06 SW MUX control register [GPIO3-6]
        #define GPIO_SD_B1_06_USDHC2_RESET_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_06_FLEXSPI_A_SS0_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_06_LPUART7_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_06_SAI1_RX_DATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_06_LPSPI2_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_06_GPIO3_IO06               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #if defined iMX_RT106X
            #define GPIO_SD_B1_06_SAI3_RX_BCLK         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT8)
        #endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f0) // SW_MUX_CTL_PAD_GPIO_SD_B1_07 SW MUX control register [GPIO3-7]
        #define GPIO_SD_B1_07_SEMC_CSX01               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_07_FLEXSPI_A_SCLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_07_LPUART7_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_07_SAI1_TX_DATA00           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_07_LPSPI2_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_07_GPIO3_IO07               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f4) // SW_MUX_CTL_PAD_GPIO_SD_B1_08 SW MUX control register [GPIO3-8]
        #define GPIO_SD_B1_08_USDHC2_DATA4             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_08_FLEXSPI_A_DATA00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_08_LPUART7_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_08_SAI1_TX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_08_LPSPI2_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_08_GPIO3_IO08               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_08_SEMC_CSX02               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f8) // SW_MUX_CTL_PAD_GPIO_SD_B1_09 SW MUX control register [GPIO3-9]
        #define GPIO_SD_B1_09_USDHC2_DATA5             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_09_FLEXSPI_A_DATA01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_09_LPUART7_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_09_SAI1_TX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_09_LPSPI2_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_09_GPIO3_IO09               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01fc) // SW_MUX_CTL_PAD_GPIO_SD_B1_10 SW MUX control register [GPIO3-10]
        #define GPIO_SD_B1_10_USDHC2_DATA6             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_10_FLEXSPI_A_DATA02         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_10_LPUART2_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_10_LPI2C2_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_10_LPSPI2_PCS2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_10_GPIO3_IO10               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0200) // SW_MUX_CTL_PAD_GPIO_SD_B1_11 SW MUX control register [GPIO3-11]
        #define GPIO_SD_B1_11_USDHC2_DATA7             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_11_FLEXSPI_A_DATA03         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_11_LPUART2_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_11_LPI2C2_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_11_LPSPI2_PCS3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_11_GPIO3_IO11               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0204)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0204) // SW_PAD_CTL_PAD_GPIO_EMC_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0208)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0208) // SW_PAD_CTL_PAD_GPIO_EMC_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x020c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x020c) // SW_PAD_CTL_PAD_GPIO_EMC_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0210)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0210) // SW_PAD_CTL_PAD_GPIO_EMC_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0214)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0214) // SW_PAD_CTL_PAD_GPIO_EMC_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0218)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0218) // SW_PAD_CTL_PAD_GPIO_EMC_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x021c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x021c) // SW_PAD_CTL_PAD_GPIO_EMC_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0220)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0220) // SW_PAD_CTL_PAD_GPIO_EMC_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0224)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0224) // SW_PAD_CTL_PAD_GPIO_EMC_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0228)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0228) // SW_PAD_CTL_PAD_GPIO_EMC_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x022c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x022c) // SW_PAD_CTL_PAD_GPIO_EMC_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0230)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0230) // SW_PAD_CTL_PAD_GPIO_EMC_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0234)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0234) // SW_PAD_CTL_PAD_GPIO_EMC_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0238)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0238) // SW_PAD_CTL_PAD_GPIO_EMC_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x023c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x023c) // SW_PAD_CTL_PAD_GPIO_EMC_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0240)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0240) // SW_PAD_CTL_PAD_GPIO_EMC_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0244)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0244) // SW_PAD_CTL_PAD_GPIO_EMC_16 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0248)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0248) // SW_PAD_CTL_PAD_GPIO_EMC_17 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x024c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x024c) // SW_PAD_CTL_PAD_GPIO_EMC_18 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0250)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0250) // SW_PAD_CTL_PAD_GPIO_EMC_19 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0254)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0254) // SW_PAD_CTL_PAD_GPIO_EMC_20 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0258)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0258) // SW_PAD_CTL_PAD_GPIO_EMC_21 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x025c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x025c) // SW_PAD_CTL_PAD_GPIO_EMC_22 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0260)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0260) // SW_PAD_CTL_PAD_GPIO_EMC_23 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0264)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0264) // SW_PAD_CTL_PAD_GPIO_EMC_24 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0268)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0268) // SW_PAD_CTL_PAD_GPIO_EMC_25 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x026c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x026c) // SW_PAD_CTL_PAD_GPIO_EMC_26 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0270)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0270) // SW_PAD_CTL_PAD_GPIO_EMC_27 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0274)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0274) // SW_PAD_CTL_PAD_GPIO_EMC_28 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0278)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0278) // SW_PAD_CTL_PAD_GPIO_EMC_29 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x027c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x027c) // SW_PAD_CTL_PAD_GPIO_EMC_30 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0280)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0280) // SW_PAD_CTL_PAD_GPIO_EMC_32 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0284) // SW_PAD_CTL_PAD_GPIO_EMC_32 SW PAD control register address
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0284) // SW_PAD_CTL_PAD_GPIO_EMC_32 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0288)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0288) // SW_PAD_CTL_PAD_GPIO_EMC_33 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x028c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x028c) // SW_PAD_CTL_PAD_GPIO_EMC_34 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0290)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0290) // SW_PAD_CTL_PAD_GPIO_EMC_35 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0294)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0294) // SW_PAD_CTL_PAD_GPIO_EMC_36 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0298)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0298) // SW_PAD_CTL_PAD_GPIO_EMC_37 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x029c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x029c) // SW_PAD_CTL_PAD_GPIO_EMC_38 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x02a0)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02a0) // SW_PAD_CTL_PAD_GPIO_EMC_39 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x02a4)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02a4) // SW_PAD_CTL_PAD_GPIO_EMC_40 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x02a8)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02a8) // SW_PAD_CTL_PAD_GPIO_EMC_41 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x02ac)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02ac) // SW_PAD_CTL_PAD_GPIO_AD_B0_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02b0) // SW_PAD_CTL_PAD_GPIO_AD_B0_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02b4) // SW_PAD_CTL_PAD_GPIO_AD_B0_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02b8) // SW_PAD_CTL_PAD_GPIO_AD_B0_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02bc) // SW_PAD_CTL_PAD_GPIO_AD_B0_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02c0) // SW_PAD_CTL_PAD_GPIO_AD_B0_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02c4) // SW_PAD_CTL_PAD_GPIO_AD_B0_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02c8) // SW_PAD_CTL_PAD_GPIO_AD_B0_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02cc) // SW_PAD_CTL_PAD_GPIO_AD_B0_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02d0) // SW_PAD_CTL_PAD_GPIO_AD_B0_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02d4) // SW_PAD_CTL_PAD_GPIO_AD_B0_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02d8) // SW_PAD_CTL_PAD_GPIO_AD_B0_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02dc) // SW_PAD_CTL_PAD_GPIO_AD_B0_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02e0) // SW_PAD_CTL_PAD_GPIO_AD_B0_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02e4) // SW_PAD_CTL_PAD_GPIO_AD_B0_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02e8) // SW_PAD_CTL_PAD_GPIO_AD_B0_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02ec) // SW_PAD_CTL_PAD_GPIO_AD_B1_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02f0) // SW_PAD_CTL_PAD_GPIO_AD_B1_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02f4) // SW_PAD_CTL_PAD_GPIO_AD_B1_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02f8) // SW_PAD_CTL_PAD_GPIO_AD_B1_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02fc) // SW_PAD_CTL_PAD_GPIO_AD_B1_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0300) // SW_PAD_CTL_PAD_GPIO_AD_B1_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0304) // SW_PAD_CTL_PAD_GPIO_AD_B1_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0308) // SW_PAD_CTL_PAD_GPIO_AD_B1_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x030c) // SW_PAD_CTL_PAD_GPIO_AD_B1_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0310) // SW_PAD_CTL_PAD_GPIO_AD_B1_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0314) // SW_PAD_CTL_PAD_GPIO_AD_B1_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0318) // SW_PAD_CTL_PAD_GPIO_AD_B1_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x031c) // SW_PAD_CTL_PAD_GPIO_AD_B1_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0320) // SW_PAD_CTL_PAD_GPIO_AD_B1_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0324) // SW_PAD_CTL_PAD_GPIO_AD_B1_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0328) // SW_PAD_CTL_PAD_GPIO_AD_B1_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00_ADD       (unsigned long *)(IOMUXC_SW_BLOCK + 0x032c)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_00           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x032c) // SW_PAD_CTL_PAD_GPIO_B0_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0330) // SW_PAD_CTL_PAD_GPIO_B0_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0334) // SW_PAD_CTL_PAD_GPIO_B0_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0338) // SW_PAD_CTL_PAD_GPIO_B0_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_04           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x033c) // SW_PAD_CTL_PAD_GPIO_B0_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_05           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0340) // SW_PAD_CTL_PAD_GPIO_B0_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_06           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0344) // SW_PAD_CTL_PAD_GPIO_B0_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_07           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0348) // SW_PAD_CTL_PAD_GPIO_B0_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_08           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x034c) // SW_PAD_CTL_PAD_GPIO_B0_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_09           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0350) // SW_PAD_CTL_PAD_GPIO_B0_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_10           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0354) // SW_PAD_CTL_PAD_GPIO_B0_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_11           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0358) // SW_PAD_CTL_PAD_GPIO_B0_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_12           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x035c) // SW_PAD_CTL_PAD_GPIO_B0_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_13           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0360) // SW_PAD_CTL_PAD_GPIO_B0_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_14           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0364) // SW_PAD_CTL_PAD_GPIO_B0_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_15           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0368) // SW_PAD_CTL_PAD_GPIO_B0_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_00           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x036c) // SW_PAD_CTL_PAD_GPIO_B1_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_01           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0370) // SW_PAD_CTL_PAD_GPIO_B1_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_02           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0374) // SW_PAD_CTL_PAD_GPIO_B1_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_03           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0378) // SW_PAD_CTL_PAD_GPIO_B1_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_04           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x037c) // SW_PAD_CTL_PAD_GPIO_B1_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_05           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0380) // SW_PAD_CTL_PAD_GPIO_B1_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_06           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0384) // SW_PAD_CTL_PAD_GPIO_B1_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_07           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0388) // SW_PAD_CTL_PAD_GPIO_B1_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_08           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x038c) // SW_PAD_CTL_PAD_GPIO_B1_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_09           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0390) // SW_PAD_CTL_PAD_GPIO_B1_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_10           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0394) // SW_PAD_CTL_PAD_GPIO_B1_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_11           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0398) // SW_PAD_CTL_PAD_GPIO_B1_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_12           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x039c) // SW_PAD_CTL_PAD_GPIO_B1_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_13           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03a0) // SW_PAD_CTL_PAD_GPIO_B1_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_14           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03a4) // SW_PAD_CTL_PAD_GPIO_B1_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_B1_15           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03a8) // SW_PAD_CTL_PAD_GPIO_B1_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x03ac)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03ac) // SW_PAD_CTL_PAD_GPIO_SD_B0_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03b0) // SW_PAD_CTL_PAD_GPIO_SD_B0_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03b4) // SW_PAD_CTL_PAD_GPIO_SD_B0_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03b8) // SW_PAD_CTL_PAD_GPIO_SD_B0_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03bc) // SW_PAD_CTL_PAD_GPIO_SD_B0_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03c0) // SW_PAD_CTL_PAD_GPIO_SD_B0_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x03c4) // SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD control register address
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03c4) // SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03c8) // SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03cc) // SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03d0) // SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03d4) // SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03d8) // SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03dc) // SW_PAD_CTL_PAD_GPIO_SD_B1_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03e0) // SW_PAD_CTL_PAD_GPIO_SD_B1_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03e4) // SW_PAD_CTL_PAD_GPIO_SD_B1_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03e8) // SW_PAD_CTL_PAD_GPIO_SD_B1_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03ec) // SW_PAD_CTL_PAD_GPIO_SD_B1_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03f0) // SW_PAD_CTL_PAD_GPIO_SD_B1_11 SW PAD control register
    #define IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03f4) // ANATOP_USB_OTG1_ID_SELECT_INPUT DAISYANATOP_USB_OTG1_ID_SELECT_INPUT DAISY register
        #define IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_GPIO_AD_B0_01_ALT3  0x00000000 // select GPIO_AD_B0_01 for mode: ALT3
        #define IOMUXC_ANATOP_USB_OTG1_ID_SELECT_INPUT_GPIO_AD_B1_02_ALT0  0x00000001 // select GPIO_AD_B1_02 for mode: ALT0
    #define IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03f8) // ANATOP_USB_OTG2_ID_SELECT_INPUT DAISY register
        #define IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_GPIO_AD_B0_00_ALT3  0x00000000 // select GPIO_AD_B0_00 for mode: ALT3
        #define IOMUXC_ANATOP_USB_OTG2_ID_SELECT_INPUT_GPIO_AD_B1_00_ALT0  0x00000001 // select GPIO_AD_B1_00 for mode: ALT0
    #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03fc) // CCM_PMIC_READY_SELECT_INPUT DAISY register
        #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT_GPIO_SD_B1_03_ALT6  0x00000000 // select GPIO_SD_B1_03 for mode: ALT6
        #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT_GPIO_AD_B0_12_ALT1  0x00000001 // select GPIO_AD_B0_12 for mode: ALT1
        #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT_GPIO_AD_B1_01_ALT4  0x00000002 // select GPIO_AD_B1_01 for mode: ALT4
        #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT_GPIO_AD_B1_08_ALT3  0x00000003 // select GPIO_AD_B1_08 for mode: ALT3
        #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT_GPIO_EMC_32_ALT3    0x00000004 // select GPIO_EMC_32 for mode: ALT3
    #define IOMUXC_CSI_DATA02_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0400) // CSI_DATA02_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA02_SELECT_INPUT_GPIO_AD_B1_15_ALT4  0x00000000 // select GPIO_AD_B1_15 for mode: ALT4
        #define IOMUXC_CSI_DATA02_SELECT_INPUT_GPIO_AD_B0_11_ALT4  0x00000001 // select GPIO_AD_B0_11 for mode: ALT4
    #define IOMUXC_CSI_DATA03_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0404) // CSI_DATA03_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA03_SELECT_INPUT_GPIO_AD_B1_14_ALT4  0x00000000 // select GPIO_AD_B1_14 for mode: ALT4
        #define IOMUXC_CSI_DATA03_SELECT_INPUT_GPIO_AD_B0_10_ALT4  0x00000001 // select GPIO_AD_B0_10 for mode: ALT4
    #define IOMUXC_CSI_DATA04_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0408) // CSI_DATA04_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA04_SELECT_INPUT_GPIO_AD_B1_13_ALT4  0x00000000 // select GPIO_AD_B1_13 for mode: ALT4
        #define IOMUXC_CSI_DATA04_SELECT_INPUT_GPIO_AD_B0_09_ALT4  0x00000001 // select GPIO_AD_B0_09 for mode: ALT4
    #define IOMUXC_CSI_DATA05_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x040c) // CSI_DATA05_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA05_SELECT_INPUT_GPIO_AD_B1_12_ALT4  0x00000000 // select GPIO_AD_B1_12 for mode: ALT4
        #define IOMUXC_CSI_DATA05_SELECT_INPUT_GPIO_AD_B0_08_ALT4  0x00000001 // select GPIO_AD_B0_08 for mode: ALT4
    #define IOMUXC_CSI_DATA06_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0410) // CSI_DATA06_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA06_SELECT_INPUT_GPIO_AD_B1_11_ALT4  0x00000000 // select GPIO_AD_B1_11 for mode: ALT4
        #define IOMUXC_CSI_DATA06_SELECT_INPUT_GPIO_AD_B0_07_ALT4  0x00000001 // select GPIO_AD_B0_07 for mode: ALT4
    #define IOMUXC_CSI_DATA07_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0414) // CSI_DATA07_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA07_SELECT_INPUT_GPIO_AD_B1_10_ALT4  0x00000000 // select GPIO_AD_B1_10 for mode: ALT4
        #define IOMUXC_CSI_DATA07_SELECT_INPUT_GPIO_AD_B0_06_ALT4  0x00000001 // select GPIO_AD_B0_06 for mode: ALT4
    #define IOMUXC_CSI_DATA08_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0418) // IOMUXC_CSI_DATA08_SELECT_INPUT register
        #define IOMUXC_CSI_DATA08_SELECT_INPUT_GPIO_AD_B1_09_ALT4  0x00000000 // select GPIO_AD_B1_09 for mode: ALT4
        #define IOMUXC_CSI_DATA08_SELECT_INPUT_GPIO_AD_B0_05_ALT4  0x00000001 // select GPIO_AD_B0_05 for mode: ALT4
    #define IOMUXC_CSI_DATA09_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x041c) // CSI_DATA09_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_DATA09_SELECT_INPUT_GPIO_AD_B1_08_ALT4  0x00000000 // select GPIO_AD_B1_08 for mode: ALT4
        #define IOMUXC_CSI_DATA09_SELECT_INPUT_GPIO_AD_B0_04_ALT4  0x00000001 // select GPIO_AD_B0_04 for mode: ALT4
    #define IOMUXC_CSI_HSYNC_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0420) // CSI_HSYNC_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_HSYNC_SELECT_INPUT_GPIO_AD_B0_15_ALT4  0x00000000 // select GPIO_AD_B0_15 for mode: ALT4
        #define IOMUXC_CSI_HSYNC_SELECT_INPUT_GPIO_AD_B1_07_ALT4  0x00000001 // select GPIO_AD_B1_07 for mode: ALT4
        #define IOMUXC_CSI_HSYNC_SELECT_INPUT_GPIO_B1_14_ALT2     0x00000002 // select GPIO_B1_14 for mode: ALT2
    #define IOMUXC_CSI_PIXCLK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0424) // CSI_PIXCLK_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_PIXCLK_SELECT_INPUT_GPIO_AD_B1_04_ALT4  0x00000000 // select GPIO_AD_B1_04 for mode: ALT4
        #define IOMUXC_CSI_PIXCLK_SELECT_INPUT_GPIO_B1_12_ALT2     0x00000001 // select GPIO_B1_12 for mode: ALT2
    #define IOMUXC_CSI_VSYNC_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0428) // CSI_VSYNC_SELECT_INPUT DAISY register
        #define IOMUXC_CSI_VSYNC_SELECT_INPUT_GPIO_AD_B0_14_ALT4  0x00000000 // select GPIO_AD_B0_14 for mode: ALT4
        #define IOMUXC_CSI_VSYNC_SELECT_INPUT_GPIO_AD_B1_06_ALT4  0x00000001 // select GPIO_AD_B1_06 for mode: ALT4
        #define IOMUXC_CSI_VSYNC_SELECT_INPUT_GPIO_B1_13_ALT2     0x00000002 // select GPIO_B1_13 for mode: ALT2
    #define IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT      *(unsigned long *)(IOMUXC_SW_BLOCK + 0x042c) // ENET_IPG_CLK_RMII_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_GPIO_EMC_25_ALT4    0x00000000 // select GPIO_EMC_25 for mode: ALT4
        #define IOMUXC_ENET_IPG_CLK_RMII_SELECT_INPUT_GPIO_B1_10_ALT6     0x00000001 // select GPIO_B1_10 for mode: ALT6
    #define IOMUXC_ENET_MDIO_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0430) // ENET_MDIO_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_MDIO_SELECT_INPUT_GPIO_AD_B1_05_ALT1  0x00000000 // select GPIO_AD_B1_05 for mode: ALT1
        #define IOMUXC_ENET_MDIO_SELECT_INPUT_GPIO_EMC_41_ALT4    0x00000001 // select GPIO_EMC_41 for mode: ALT4
        #define IOMUXC_ENET_MDIO_SELECT_INPUT_GPIO_B1_15_ALT0     0x00000002 // select GPIO_B1_15 for mode: ALT0
    #define IOMUXC_ENET0_RXDATA_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0434) // ENET0_RXDATA_SELECT_INPUT DAISY register
        #define IOMUXC_ENET0_RXDATA_SELECT_INPUT_GPIO_EMC_20_ALT3 0x00000000 // select GPIO_EMC_20 for mode: ALT3
        #define IOMUXC_ENET0_RXDATA_SELECT_INPUT_GPIO_B1_04_ALT3  0x00000001 // select GPIO_B1_04 for mode: ALT3
    #define IOMUXC_ENET1_RXDATA_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0438) // ENET1_RXDATA_SELECT_INPUT DAISY register
        #define IOMUXC_ENET1_RXDATA_SELECT_INPUT_GPIO_EMC_19_ALT3 0x00000000 // select GPIO_EMC_19 for mode: ALT3
        #define IOMUXC_ENET1_RXDATA_SELECT_INPUT_GPIO_B1_05_ALT3  0x00000001 // select GPIO_B1_05 for mode: ALT3
    #define IOMUXC_ENET_RXEN_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x043c) // ENET_RXEN_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RXEN_SELECT_INPUT_GPIO_EMC_23_ALT3    0x00000000 // select GPIO_EMC_23 for mode: ALT3
        #define IOMUXC_ENET_RXEN_SELECT_INPUT_GPIO_B1_06_ALT3     0x00000001 // select GPIO_B1_06 for mode: ALT3
    #define IOMUXC_ENET_RXERR_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0440) // ENET_RXERR_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RXEN_SELECT_INPUT_GPIO_EMC_26_ALT3    0x00000000 // select GPIO_EMC_26 for mode: ALT3
        #define IOMUXC_ENET_RXEN_SELECT_INPUT_GPIO_B1_11_ALT3     0x00000001 // select GPIO_B1_11 for mode: ALT3
    #define IOMUXC_ENET0_TIMER_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0444) // ENET0_TIMER_SELECT_INPUT DAISY register
        #define IOMUXC_ENET0_TIMER_SELECT_INPUT_GPIO_AD_B0_15_ALT3 0x00000000 // select GPIO_AD_B0_15 for mode: ALT3
        #define IOMUXC_ENET0_TIMER_SELECT_INPUT_GPIO_AD_B0_11_ALT7 0x00000001 // select GPIO_AD_B0_11 for mode: ALT7
        #define IOMUXC_ENET0_TIMER_SELECT_INPUT_GPIO_B1_12_ALT3    0x00000002 // select GPIO_B1_12 for mode: ALT3
    #define IOMUXC_ENET_TXCLK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0448) // ENET_TXCLK_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RXEN_SELECT_INPUT_GPIO_EMC_25_ALT3    0x00000000 // select GPIO_EMC_25 for mode: ALT3
        #define IOMUXC_ENET_RXEN_SELECT_INPUT_GPIO_B1_10_ALT3     0x00000001 // select GPIO_B1_10 for mode: ALT3
    #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x044c) // FLEXCAN1_RX_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_SD_B1_03_ALT4 0x00000000 // select GPIO_SD_B1_03 for mode: ALT4
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_EMC_18_ALT3   0x00000001 // select GPIO_EMC_18 for mode: ALT3
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_AD_B1_09_ALT2 0x00000002 // select GPIO_AD_B1_09 for mode: ALT2
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_B0_03_ALT2    0x00000003 // select GPIO_B0_03 for mode: ALT2
    #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0450) // FLEXCAN2_RX_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_EMC_10_ALT3   0x00000000 // select GPIO_EMC_10 for mode: ALT3
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_AD_B0_03_ALT0 0x00000001 // select GPIO_AD_B0_03 for mode: ALT0
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_AD_B0_15_ALT6 0x00000002 // select GPIO_AD_B0_15 for mode: ALT6
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_B1_09_ALT6    0x00000003 // select GPIO_B1_09 for mode: ALT6
    #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0454) // FLEXPWM1_PWMA3_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_GPIO_SD_B1_00_ALT2 0x00000000 // select GPIO_SD_B1_00 for mode: ALT2
        #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_GPIO_EMC_12_ALT4   0x00000001 // select GPIO_EMC_12 for mode: ALT4
        #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_PIO_EMC_38_ALT1    0x00000002 // select PIO_EMC_38 for mode: ALT1
        #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_GPIO_AD_B0_10_ALT1 0x00000003 // select GPIO_AD_B0_10 for mode: ALT1
        #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT_GPIO_B1_00_ALT6    0x00000003 // select GPIO_B1_00 for mode: ALT6
    #define IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0458) // FLEXPWM1_PWMA0_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_GPIO_EMC_23_ALT1   0x00000000 // select GPIO_EMC_23 for mode: ALT1
        #define IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT_GPIO_SD_B0_00_ALT1 0x00000001 // select GPIO_SD_B0_00 for mode: ALT1
    #define IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x045c) // FLEXPWM1_PWMA1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0460) // FLEXPWM1_PWMA2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0464) // FLEXPWM1_PWMB3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0468) // FLEXPWM1_PWMB0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x046c) // FLEXPWM1_PWMB1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0470) // FLEXPWM1_PWMB2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0474) // FLEXPWM2_PWMA3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0478) // FLEXPWM2_PWMA0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x047c) // FLEXPWM2_PWMA1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0480) // FLEXPWM2_PWMA2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0484) // FLEXPWM2_PWMB3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0488) // FLEXPWM2_PWMB0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x048c) // FLEXPWM2_PWMB1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0490) // FLEXPWM2_PWMB2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM4_PWMA0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0494) // FLEXPWM4_PWMA0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM4_PWMA1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0498) // FLEXPWM4_PWMA1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x049c) // FLEXPWM4_PWMA2_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_GPIO_EMC_04_ALT1  0x00000000 // GPIO_EMC_04 for mode: ALT1
        #define IOMUXC_FLEXPWM4_PWMA2_SELECT_INPUT_GPIO_B1_14_ALT1   0x00000001 // GPIO_B1_14 for mode: ALT1
    #define IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04a0) // FLEXPWM4_PWMA3_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_GPIO_EMC_17_ALT1  0x00000000 // GPIO_EMC_17 for mode: ALT1
        #define IOMUXC_FLEXPWM4_PWMA3_SELECT_INPUT_GPIO_B1_15_ALT1   0x00000001 // GPIO_B1_15 for mode: ALT1
    #define IOMUXC_FLEXSPI_A_DQS_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04a4) // FLEXSPI_A_DQS_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_A_DQS_SELECT_INPUT_GPIO_SD_B1_05_ALT1 0x00000000 // select GPIO_SD_B1_05 for mode: ALT1
        #define IOMUXC_FLEXSPI_A_DQS_SELECT_INPUT_GPIO_AD_B1_09_ALT0 0x00000001 // select GPIO_AD_B1_09 for mode: ALT0
    #define IOMUXC_FLEXSPI_A_DATA0_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04a8) // FLEXSPI_A_DATA0_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_A_DATA0_SELECT_INPUT_GPIO_SD_B1_08_ALT1 0x00000000 // select GPIO_SD_B1_08 for mode: ALT1
        #define IOMUXC_FLEXSPI_A_DATA0_SELECT_INPUT_GPIO_AD_B1_13_ALT0 0x00000001 // select GPIO_AD_B1_13 for mode: ALT0
    #define IOMUXC_FLEXSPI_A_DATA1_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04ac) // FLEXSPI_A_DATA1_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_A_DATA1_SELECT_INPUT_GPIO_SD_B1_09_ALT1 0x00000000 // select GPIO_SD_B1_09 for mode: ALT1
        #define IOMUXC_FLEXSPI_A_DATA1_SELECT_INPUT_GPIO_AD_B1_12_ALT0 0x00000001 // select GPIO_AD_B1_12 for mode: ALT0
    #define IOMUXC_FLEXSPI_A_DATA2_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04b0) // FLEXSPI_A_DATA2_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_A_DATA2_SELECT_INPUT_GPIO_SD_B1_10_ALT1 0x00000000 // select GPIO_SD_B1_10 for mode: ALT1
        #define IOMUXC_FLEXSPI_A_DATA2_SELECT_INPUT_GPIO_AD_B1_11_ALT0 0x00000001 // select GPIO_AD_B1_11 for mode: ALT0
    #define IOMUXC_FLEXSPI_A_DATA3_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04b4) // FLEXSPI_A_DATA3_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_A_DATA3_SELECT_INPUT_GPIO_SD_B1_11_ALT1 0x00000000 // select GPIO_SD_B1_11 for mode: ALT1
        #define IOMUXC_FLEXSPI_A_DATA3_SELECT_INPUT_GPIO_AD_B1_10_ALT0 0x00000001 // select GPIO_AD_B1_10 for mode: ALT0
    #define IOMUXC_FLEXSPI_B_DATA0_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04b8) // FLEXSPI_B_DATA0_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_B_DATA0_SELECT_INPUT_GPIO_SD_B1_03_ALT1 0x00000000 // select GPIO_SD_B1_03 for mode: ALT1
        #define IOMUXC_FLEXSPI_B_DATA0_SELECT_INPUT_GPIO_AD_B1_07_ALT0 0x00000001 // select GPIO_AD_B1_07 for mode: ALT0
    #define IOMUXC_FLEXSPI_B_DATA1_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04bc) // FLEXSPI_B_DATA1_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_B_DATA1_SELECT_INPUT_GPIO_SD_B1_02_ALT1 0x00000000 // select GPIO_SD_B1_02 for mode: ALT1
        #define IOMUXC_FLEXSPI_B_DATA1_SELECT_INPUT_GPIO_AD_B1_06_ALT0 0x00000001 // select GPIO_AD_B1_06 for mode: ALT0
    #define IOMUXC_FLEXSPI_B_DATA2_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04c0) // FLEXSPI_B_DATA2_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_B_DATA2_SELECT_INPUT_GPIO_SD_B1_01_ALT1 0x00000000 // select GPIO_SD_B1_01 for mode: ALT1
        #define IOMUXC_FLEXSPI_B_DATA2_SELECT_INPUT_GPIO_AD_B1_05_ALT0 0x00000001 // select GPIO_AD_B1_05 for mode: ALT0
    #define IOMUXC_FLEXSPI_B_DATA3_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04c4) // FLEXSPI_B_DATA3_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_B_DATA3_SELECT_INPUT_GPIO_SD_B1_00_ALT1 0x00000000 // select GPIO_SD_B1_00 for mode: ALT1
        #define IOMUXC_FLEXSPI_B_DATA3_SELECT_INPUT_GPIO_AD_B1_14_ALT0 0x00000001 // select GPIO_AD_B1_14 for mode: ALT0
    #define IOMUXC_FLEXSPI_A_SCK_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04c8) // FLEXSPI_A_SCK_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXSPI_A_SCK_SELECT_INPUT_GPIO_SD_B1_07_ALT1 0x00000000 // select GPIO_SD_B1_07 for mode: ALT1
        #define IOMUXC_FLEXSPI_A_SCK_SELECT_INPUT_GPIO_AD_B1_04_ALT0 0x00000001 // select GPIO_AD_B1_04 for mode: ALT0
    #define IOMUXC_LPI2C1_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04cc) // LPI2C1_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_SD_B1_04_ALT2 0x00000000 // select GPIO_SD_B1_04 for mode: ALT2
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_AD_B1_00_ALT3 0x00000001 // select GPIO_AD_B1_00 for mode: ALT3
    #define IOMUXC_LPI2C1_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04d0) // LPI2C1_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_SD_B1_05_ALT2 0x00000000 // select GPIO_SD_B1_05 for mode: ALT2
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_AD_B1_01_ALT3 0x00000001 // select GPIO_AD_B1_01 for mode: ALT3
    #define IOMUXC_LPI2C2_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04d4) // LPI2C2_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_SD_B1_11_ALT3 0x00000000 // select GPIO_SD_B1_11 for mode: ALT3
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_B0_04_ALT2    0x00000001 // select GPIO_B0_04 for mode: ALT2
    #define IOMUXC_LPI2C2_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04d8) // LPI2C2_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_SD_B1_10_ALT3 0x00000000 // select GPIO_SD_B1_10 for mode: ALT3
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_B0_05_ALT2    0x00000001 // select GPIO_B0_05 for mode: ALT2
    #define IOMUXC_LPI2C3_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04dc) // LPI2C3_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C3_SCL_SELECT_INPUT_GPIO_EMC_22_ALT2   0x00000000 // select GPIO_EMC_22 for mode: ALT2
        #define IOMUXC_LPI2C3_SCL_SELECT_INPUT_GPIO_SD_B0_00_ALT2 0x00000001 // select GPIO_SD_B0_00 for mode: ALT2
        #define IOMUXC_LPI2C3_SCL_SELECT_INPUT_GPIO_AD_B1_07_ALT1 0x00000002 // select GPIO_AD_B1_07 for mode: ALT1
    #define IOMUXC_LPI2C3_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04e0) // LPI2C3_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C3_SDA_SELECT_INPUT_GPIO_EMC_21_ALT2   0x00000000 // select GPIO_EMC_21 for mode: ALT2
        #define IOMUXC_LPI2C3_SDA_SELECT_INPUT_GPIO_SD_B0_01_ALT2 0x00000001 // select GPIO_SD_B0_01 for mode: ALT2
        #define IOMUXC_LPI2C3_SDA_SELECT_INPUT_GPIO_AD_B1_06_ALT1 0x00000002 // select GPIO_AD_B1_06 for mode: ALT1
    #define IOMUXC_LPI2C4_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04e4) // LPI2C4_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C4_SCL_SELECT_INPUT_GPIO_EMC_12_ALT2   0x00000000 // select GPIO_EMC_12 for mode: ALT2
        #define IOMUXC_LPI2C4_SCL_SELECT_INPUT_GPIO_AD_B0_12_ALT0 0x00000001 // select GPIO_AD_B0_12 for mode: ALT0
    #define IOMUXC_LPI2C4_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04e8) // LPI2C4_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C4_SDA_SELECT_INPUT_GPIO_EMC_11_ALT2   0x00000000 // select GPIO_EMC_11 for mode: ALT2
        #define IOMUXC_LPI2C4_SDA_SELECT_INPUT_GPIO_AD_B0_13_ALT0 0x00000001 // select GPIO_AD_B0_13 for mode: ALT0
    #define IOMUXC_LPSPI1_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04ec) // LPSPI1_PCS0_SELECT_INPUT DAISY register
        #define IOMUXC_LPSPI1_PCS0_SELECT_INPUT_GPIO_SD_B0_01_ALT4 0x00000000 // select GPIO_SD_B0_01 for mode: ALT4
        #define IOMUXC_LPSPI1_PCS0_SELECT_INPUT_GPIO_EMC_30_ALT3   0x00000001 // select GPIO_EMC_30 for mode: ALT3
    #define IOMUXC_LPSPI1_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04f0) // LPSPI1_SCK_SELECT_INPUT DAISY register
        #define IOMUXC_LPSPI1_SCK_SELECT_INPUT_GPIO_EMC_27_ALT3   0x00000000 // select GPIO_EMC_27 for mode: ALT3
        #define IOMUXC_LPSPI1_SCK_SELECT_INPUT_GPIO_SD_B0_00_ALT4 0x00000001 // select GPIO_SD_B0_00 for mode: ALT4
    #define IOMUXC_LPSPI1_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04f4) // LPSPI1_SDI_SELECT_INPUT DAISY register
        #define IOMUXC_LPSPI1_SDI_SELECT_INPUT_GPIO_EMC_29_ALT3   0x00000000 // select GPIO_EMC_29 for mode: ALT3
        #define IOMUXC_LPSPI1_SDI_SELECT_INPUT_GPIO_SD_B0_03_ALT4 0x00000001 // select GPIO_SD_B0_03 for mode: ALT4
    #define IOMUXC_LPSPI1_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04f8) // LPSPI1_SDO_SELECT_INPUT DAISY register
        #define IOMUXC_LPSPI1_SDO_SELECT_INPUT_GPIO_EMC_28_ALT3   0x00000000 // select GPIO_EMC_28 for mode: ALT3
        #define IOMUXC_LPSPI1_SDO_SELECT_INPUT_GPIO_SD_B0_02_ALT4 0x00000001 // select GPIO_SD_B0_02 for mode: ALT4
    #define IOMUXC_LPSPI2_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04fc) // LPSPI2_PCS0_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0500) // LPSPI2_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0504) // LPSPI2_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0508) // LPSPI2_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI3_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x050c) // LPSPI3_PCS0_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI3_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0510) // LPSPI3_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI3_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0514) // LPSPI3_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI3_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0518) // LPSPI3_SDO_SELECT_INPUT register
    #define IOMUXC_LPSPI4_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x051c) // LPSPI4_PCS0_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0520) // LPSPI4_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0524) // LPSPI4_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0528) // LPSPI4_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPUART2_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x052c) // LPUART2_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART2_RX_SELECT_INPUT_GPIO_SD_B1_10_ALT2 0x00000000 // select GPIO_SD_B1_10 for mode: ALT2
        #define IOMUXC_LPUART2_RX_SELECT_INPUT_GPIO_AD_B1_03_ALT2 0x00000001 // select GPIO_AD_B1_03 for mode: ALT2
    #define IOMUXC_LPUART2_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0530) // LPUART2_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART2_TX_SELECT_INPUT_GPIO_SD_B1_11_ALT2 0x00000000 // select GPIO_SD_B1_11 for mode: ALT2
        #define IOMUXC_LPUART2_TX_SELECT_INPUT_GPIO_AD_B1_02_ALT2 0x00000001 // select GPIO_AD_B1_02 for mode: ALT2
    #define IOMUXC_LPUART3_CTS_B_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0534) // LPUART3_CTS_B_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_CTS_B_SELECT_INPUT_GPIO_EMC_15_ALT2   0x00000000 // select GPIO_EMC_15 for mode: ALT2
        #define IOMUXC_LPUART3_CTS_B_SELECT_INPUT_GPIO_AD_B1_04_ALT2 0x00000001 // select GPIO_AD_B1_04 for mode: ALT2
    #define IOMUXC_LPUART3_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0538) // LPUART3_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_RX_SELECT_INPUT_GPIO_AD_B1_07_ALT2    0x00000000 // select GPIO_AD_B1_07 for mode: ALT2
        #define IOMUXC_LPUART3_RX_SELECT_INPUT_GPIO_EMC_14_ALT2      0x00000001 // select GPIO_EMC_14 for mode: ALT2
        #define IOMUXC_LPUART3_RX_SELECT_INPUT_GPIO_B0_09_ALT3       0x00000002 // select GPIO_B0_09 for mode: ALT3
    #define IOMUXC_LPUART3_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x053c) // LPUART3_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_TX_SELECT_INPUT_GPIO_EMC_13_ALT2      0x00000000 // select GPIO_EMC_13 for mode: ALT2
        #define IOMUXC_LPUART3_TX_SELECT_INPUT_GPIO_AD_B1_06_ALT2    0x00000001 // select GPIO_AD_B1_06 for mode: ALT2
        #define IOMUXC_LPUART3_TX_SELECT_INPUT_GPIO_B0_08_ALT3       0x00000002 // select GPIO_B0_08 for mode: ALT3
    #define IOMUXC_LPUART4_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0540) // LPUART4_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_SD_B1_01_ALT4    0x00000000 // select GPIO_SD_B1_01 for mode: ALT4
        #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_EMC_20_ALT2      0x00000001 // select GPIO_EMC_20 for mode: ALT2
        #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_B1_01_ALT2       0x00000002 // select GPIO_B1_01 for mode: ALT2
    #define IOMUXC_LPUART4_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0544) // LPUART4_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_SD_B1_00_ALT4    0x00000000 // select GPIO_SD_B1_00 for mode: ALT4
        #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_EMC_19_ALT2      0x00000001 // select GPIO_EMC_19 for mode: ALT2
        #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_B1_00_ALT2       0x00000002 // select GPIO_B1_00 for mode: ALT2
    #define IOMUXC_LPUART5_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0548) // LPUART5_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART5_RX_SELECT_INPUT_GPIO_EMC_24_ALT2      0x00000000 // select GPIO_EMC_24 for mode: ALT2
        #define IOMUXC_LPUART5_RX_SELECT_INPUT_GPIO_B1_13_ALT1       0x00000001 // select GPIO_B1_13 for mode: ALT1
    #define IOMUXC_LPUART5_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x054c) // LPUART5_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART5_TX_SELECT_INPUT_GPIO_EMC_23_ALT2      0x00000000 // select GPIO_EMC_23 for mode: ALT2
        #define IOMUXC_LPUART5_TX_SELECT_INPUT_GPIO_B1_12_ALT1       0x00000001 // select GPIO_B1_12 for mode: ALT1
    #define IOMUXC_LPUART6_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0550) // LPUART6_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART6_RX_SELECT_INPUT_GPIO_EMC_26_ALT2      0x00000000 // select GPIO_EMC_26 for mode: ALT2
        #define IOMUXC_LPUART6_RX_SELECT_INPUT_GPIO_AD_B0_03_ALT2    0x00000001 // select GPIO_AD_B0_03 for mode: ALT2
    #define IOMUXC_LPUART6_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0554) // LPUART6_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART6_TX_SELECT_INPUT_GPIO_EMC_25_ALT2      0x00000000 // select GPIO_EMC_25 for mode: ALT2
        #define IOMUXC_LPUART6_TX_SELECT_INPUT_GPIO_AD_B0_02_ALT2    0x00000001 // select GPIO_AD_B0_02 for mode: ALT2
    #define IOMUXC_LPUART7_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0558) // LPUART7_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART7_RX_SELECT_INPUT_GPIO_SD_B1_09_ALT2    0x00000000 // select GPIO_SD_B1_09 for mode: ALT2
        #define IOMUXC_LPUART7_RX_SELECT_INPUT_GPIO_EMC_32_ALT2      0x00000001 // select GPIO_EMC_32 for mode: ALT2
    #define IOMUXC_LPUART7_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x055c) // LPUART7_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART7_TX_SELECT_INPUT_GPIO_SD_B1_08_ALT2    0x00000000 // select GPIO_SD_B1_08 for mode: ALT2
        #define IOMUXC_LPUART7_TX_SELECT_INPUT_GPIO_EMC_31_ALT2      0x00000001 // select GPIO_EMC_31 for mode: ALT2
    #define IOMUXC_LPUART8_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0560) // LPUART8_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART8_RX_SELECT_INPUT_GPIO_SD_B0_05_ALT2    0x00000000 // select GPIO_SD_B0_05 for mode: ALT2
        #define IOMUXC_LPUART8_RX_SELECT_INPUT_GPIO_AD_B1_11_ALT2    0x00000001 // select GPIO_AD_B1_11 for mode: ALT2
        #define IOMUXC_LPUART8_RX_SELECT_INPUT_GPIO_EMC_39_ALT2      0x00000002 // select GPIO_EMC_39 for mode: ALT2
    #define IOMUXC_LPUART8_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0564) // LPUART8_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART8_TX_SELECT_INPUT_GPIO_SD_B0_04_ALT2    0x00000000 // select GPIO_SD_B0_04 for mode: ALT2
        #define IOMUXC_LPUART8_TX_SELECT_INPUT_GPIO_AD_B1_10_ALT2    0x00000001 // select GPIO_AD_B1_10 for mode: ALT2
        #define IOMUXC_LPUART8_TX_SELECT_INPUT_GPIO_EMC_38_ALT2      0x00000002 // select GPIO_EMC_38 for mode: ALT2
    #define IOMUXC_NMI_SELECT_INPUT                    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0568) // NMI_SELECT_INPUT DAISY register
        #define IOMUXC_NMI_SELECT_INPUT_GPIO_AD_B0_12_ALT7  0x00000000   // select GPIO_AD_B0_12 for mode: ALT7
        #define IOMUXC_NMI_SELECT_INPUT_WAKEUP_ALT7         0x00000001   // select WAKEUP for mode: ALT7
    #define IOMUXC_QTIMER2_TIMER0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x056c) // QTIMER2_TIMER0_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0570) // QTIMER2_TIMER1_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0574) // QTIMER2_TIMER2_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0578) // QTIMER2_TIMER3_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER3_TIMER0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x057c) // QTIMER3_TIMER0_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER3_TIMER1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0580) // QTIMER3_TIMER1_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER3_TIMER2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0584) // QTIMER3_TIMER2_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER3_TIMER3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0588) // QTIMER3_TIMER3_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_MCLK2_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x058c) // SAI1_MCLK2_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0590) // SAI1_RX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA0_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0594) // SAI1_RX_DATA0_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA1_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0598) // SAI1_RX_DATA1_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA2_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x059c) // SAI1_RX_DATA2_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA3_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05a0) // SAI1_RX_DATA3_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05a4) // SAI1_RX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_TX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05a8) // SAI1_TX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_TX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05ac) // SAI1_TX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_MCLK2_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05b0) // SAI2_MCLK2_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_RX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05b4) // SAI2_RX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_RX_DATA0_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05b8) // SAI2_RX_DATA0_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_RX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05bc) // SAI2_RX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_TX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05c0) // SAI2_TX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_TX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05c4) // SAI2_TX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SPDIF_IN_SELECT_INPUT               *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05c8) // SPDIF_IN_SELECT_INPUT DAISY register
    #define IOMUXC_USB_OTG2_OC_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05cc) // USB_OTG2_OC_SELECT_INPUT DAISY register
    #define IOMUXC_USB_OTG1_OC_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05d0) // USB_OTG1_OC_SELECT_INPUT DAISY register
    #define IOMUXC_USDHC1_CD_B_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05d4) // USDHC1_CD_B_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_EMC_35_ALT6     0x00000000 // select GPIO_EMC_35 for mode: ALT6
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_AD_B1_02_ALT6   0x00000001 // select GPIO_AD_B1_02 for mode: ALT6
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_B1_12_ALT6      0x00000002 // select GPIO_B1_12 for mode: ALT6
    #define IOMUXC_USDHC1_WP_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05d8) // USDHC1_WP_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_WP_SELECT_INPUT_GPIO_EMC_12_ALT3       0x00000000 // select GPIO_EMC_12 for mode: ALT3
        #define IOMUXC_USDHC2_WP_SELECT_INPUT_GPIO_AD_B1_00_ALT6     0x00000001 // select GPIO_AD_B1_00 for mode: ALT6
        #define IOMUXC_USDHC2_WP_SELECT_INPUT_GPIO_EMC_36_ALT6       0x00000002 // select GPIO_EMC_36 for mode: ALT6
        #define IOMUXC_USDHC2_WP_SELECT_INPUT_GPIO_B1_13_ALT6        0x00000003 // select GPIO_B1_13_ALT6 for mode: ALT6
    #define IOMUXC_USDHC2_CLK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05dc) // USDHC2_CLK_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_CLK_SELECT_INPUT_GPIO_SD_B1_04_ALT0    0x00000000 // select GPIO_SD_B1_04 for mode: ALT0
        #define IOMUXC_USDHC2_CLK_SELECT_INPUT_GPIO_AD_B1_09_ALT6    0x00000001 // select GPIO_AD_B1_09 for mode: ALT6
    #define IOMUXC_USDHC2_CD_B_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05e0) // USDHC2_CD_B_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_CD_B_SELECT_INPUT_GPIO_AD_B1_03_ALT6   0x00000000 // select GPIO_AD_B1_03 for mode: ALT6
        #define IOMUXC_USDHC2_CD_B_SELECT_INPUT_GPIO_EMC_39_ALT6     0x00000001 // select GPIO_EMC_39 for mode: ALT6
    #define IOMUXC_USDHC2_CMD_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05e4) // USDHC2_CMD_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_CMD_SELECT_INPUT_GPIO_SD_B1_05_ALT0    0x00000000 // select GPIO_SD_B1_05 for mode: ALT0
        #define IOMUXC_USDHC2_CMD_SELECT_INPUT_GPIO_AD_B1_08_ALT6    0x00000001 // select GPIO_AD_B1_08 for mode: ALT6
    #define IOMUXC_USDHC2_DATA0_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05e8) // USDHC2_DATA0_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA0_SELECT_INPUT_GPIO_SD_B1_03_ALT0  0x00000000 // select GPIO_SD_B1_03 for mode: ALT0
        #define IOMUXC_USDHC2_DATA0_SELECT_INPUT_GPIO_AD_B1_04_ALT6  0x00000001 // select GPIO_AD_B1_04 for mode: ALT6
    #define IOMUXC_USDHC2_DATA1_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05ec) // USDHC2_DATA1_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA1_SELECT_INPUT_GPIO_SD_B1_02_ALT0  0x00000000 // select GPIO_SD_B1_02 for mode: ALT0
        #define IOMUXC_USDHC2_DATA1_SELECT_INPUT_GPIO_AD_B1_05_ALT6  0x00000001 // select GPIO_AD_B1_05 for mode: ALT6
    #define IOMUXC_USDHC2_DATA2_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05f0) // USDHC2_DATA2_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA2_SELECT_INPUT_GPIO_SD_B1_01_ALT0  0x00000000 // select GPIO_SD_B1_01 for mode: ALT0
        #define IOMUXC_USDHC2_DATA2_SELECT_INPUT_GPIO_AD_B1_06_ALT6  0x00000001 // select GPIO_AD_B1_06 for mode: ALT6
    #define IOMUXC_USDHC2_DATA3_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05f4) // USDHC2_DATA3_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA3_SELECT_INPUT_GPIO_SD_B1_00_ALT0  0x00000000 // select GPIO_SD_B1_00 for mode: ALT0
        #define IOMUXC_USDHC2_DATA3_SELECT_INPUT_GPIO_AD_B1_07_ALT6  0x00000001 // select GPIO_AD_B1_07 for mode: ALT6
    #define IOMUXC_USDHC2_DATA4_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05f8) // USDHC2_DATA4_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA4_SELECT_INPUT_GPIO_SD_B1_08_ALT0  0x00000000 // select GPIO_SD_B1_08 for mode: ALT0
        #define IOMUXC_USDHC2_DATA4_SELECT_INPUT_GPIO_AD_B1_12_ALT6  0x00000001 // select GPIO_AD_B1_12 for mode: ALT6
    #define IOMUXC_USDHC2_DATA5_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x05fc) // USDHC2_DATA5_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA5_SELECT_INPUT_GPIO_SD_B1_09_ALT0  0x00000000 // select GPIO_SD_B1_09 for mode: ALT0
        #define IOMUXC_USDHC2_DATA5_SELECT_INPUT_GPIO_AD_B1_13_ALT6  0x00000001 // select GPIO_AD_B1_13 for mode: ALT6
    #define IOMUXC_USDHC2_DATA6_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0600) // USDHC2_DATA6_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA6_SELECT_INPUT_GPIO_SD_B1_10_ALT0  0x00000000 // select GPIO_SD_B1_10 for mode: ALT0
        #define IOMUXC_USDHC2_DATA6_SELECT_INPUT_GPIO_AD_B1_14_ALT6  0x00000001 // select GPIO_AD_B1_14 for mode: ALT6
    #define IOMUXC_USDHC2_DATA7_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0604) // USDHC2_DATA7_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_DATA7_SELECT_INPUT_GPIO_SD_B1_11_ALT0  0x00000000 // select GPIO_SD_B1_11 for mode: ALT0
        #define IOMUXC_USDHC2_DATA7_SELECT_INPUT_GPIO_AD_B1_15_ALT6  0x00000001 // select GPIO_AD_B1_15 for mode: ALT6
    #define IOMUXC_USDHC2_WP_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0608) // USDHC2_WP_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC2_WP_SELECT_INPUT_GPIO_AD_B1_10_ALT6     0x00000000 // select GPIO_AD_B1_10 for mode: ALT6
        #define IOMUXC_USDHC2_WP_SELECT_INPUT_GPIO_EMC_37_ALT6       0x00000001 // select GPIO_EMC_37 for mode: ALT6
    #if defined iMX_RT105X || defined iMX_RT106X
        #define IOMUXC_XBAR1_IN02_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x060c) // XBAR1_IN02_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN02_SELECT_INPUT_GPIO_EMC_01_ALT3      0x00000000 // select GPIO_EMC_01 for mode: ALT3
            #define IOMUXC_XBAR1_IN02_SELECT_INPUT_GPIO_B1_15_ALT3       0x00000001 // select GPIO_B1_15 for mode: ALT3
        #define IOMUXC_XBAR1_IN03_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0610) // XBAR1_IN03_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN03_SELECT_INPUT_GPIO_EMC_00_ALT3      0x00000000 // select GPIO_EMC_00 for mode: ALT3
            #define IOMUXC_XBAR1_IN03_SELECT_INPUT_GPIO_B1_14_ALT3       0x00000001 // select GPIO_B1_14 for mode: ALT3
        #define IOMUXC_XBAR1_IN04_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0614) // XBAR1_IN04_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN04_SELECT_INPUT_GPIO_EMC_02_ALT3      0x00000000 // select GPIO_EMC_02 for mode: ALT3
            #define IOMUXC_XBAR1_IN04_SELECT_INPUT_GPIO_SD_B0_00_ALT3    0x00000001 // select GPIO_SD_B0_00 for mode: ALT3
        #define IOMUXC_XBAR1_IN05_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0618) // XBAR1_IN05_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN05_SELECT_INPUT_GPIO_EMC_03_ALT3      0x00000000 // select GPIO_EMC_03 for mode: ALT3
            #define IOMUXC_XBAR1_IN05_SELECT_INPUT_GPIO_SD_B0_01_ALT3    0x00000001 // select GPIO_SD_B0_01 for mode: ALT3
        #define IOMUXC_XBAR1_IN06_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x061c) // XBAR1_IN06_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN06_SELECT_INPUT_GPIO_EMC_04_ALT3      0x00000000 // select GPIO_EMC_04 for mode: ALT3
            #define IOMUXC_XBAR1_IN06_SELECT_INPUT_GPIO_SD_B0_02_ALT3    0x00000001 // select GPIO_SD_B0_02 for mode: ALT3
        #define IOMUXC_XBAR1_IN07_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0620) // XBAR1_IN07_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN07_SELECT_INPUT_GPIO_EMC_05_ALT3      0x00000000 // select GPIO_EMC_05 for mode: ALT3
            #define IOMUXC_XBAR1_IN07_SELECT_INPUT_GPIO_SD_B0_03_ALT3    0x00000001 // select GPIO_SD_B0_03 for mode: ALT3
        #define IOMUXC_XBAR1_IN08_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0624) // XBAR1_IN08_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN08_SELECT_INPUT_GPIO_EMC_06_ALT3      0x00000000 // select GPIO_EMC_06 for mode: ALT3
            #define IOMUXC_XBAR1_IN08_SELECT_INPUT_GPIO_SD_B0_04_ALT3    0x00000001 // select GPIO_SD_B0_04 for mode: ALT3
        #define IOMUXC_XBAR1_IN09_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0628) // XBAR1_IN09_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN09_SELECT_INPUT_GPIO_EMC_07_ALT3      0x00000000 // select GPIO_EMC_07 for mode: ALT3
            #define IOMUXC_XBAR1_IN09_SELECT_INPUT_GPIO_SD_B0_05_ALT3    0x00000001 // select GPIO_SD_B0_05 for mode: ALT3
        #define IOMUXC_XBAR1_IN17_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x062c) // XBAR1_IN17_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN17_SELECT_INPUT_GPIO_EMC_08_ALT3      0x00000000 // select GPIO_EMC_08 for mode: ALT3
            #define IOMUXC_XBAR1_IN17_SELECT_INPUT_GPIO_AD_B0_03_ALT1    0x00000001 // select GPIO_AD_B0_03 for mode: ALT1
            #define IOMUXC_XBAR1_IN17_SELECT_INPUT_GPIO_AD_B0_05_ALT6    0x00000002 // select GPIO_AD_B0_05 for mode: ALT6
            #define IOMUXC_XBAR1_IN17_SELECT_INPUT_GPIO_B1_03_ALT1       0x00000003 // select GPIO_B1_03 for mode: ALT1
        #define IOMUXC_XBAR1_IN18_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0630) // XBAR1_IN18_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN18_SELECT_INPUT_GPIO_EMC_35_ALT1      0x00000000 // select GPIO_EMC_35 for mode: ALT1
            #define IOMUXC_XBAR1_IN18_SELECT_INPUT_GPIO_AD_B0_06_ALT6    0x00000001 // select GPIO_AD_B0_06 for mode: ALT6
        #define IOMUXC_XBAR1_IN20_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0634) // XBAR1_IN20_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN20_SELECT_INPUT_GPIO_EMC_15_ALT1      0x00000000 // select GPIO_EMC_15 for mode: ALT1
            #define IOMUXC_XBAR1_IN20_SELECT_INPUT_GPIO_AD_B0_08_ALT6    0x00000001 // select GPIO_AD_B0_08 for mode: ALT6
        #define IOMUXC_XBAR1_IN22_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0638) // XBAR1_IN22_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN22_SELECT_INPUT_GPIO_EMC_36_ALT1      0x00000000 // select GPIO_EMC_36 for mode: ALT1
            #define IOMUXC_XBAR1_IN22_SELECT_INPUT_GPIO_AD_B0_10_ALT6    0x00000001 // select GPIO_AD_B0_10 for mode: ALT6
        #define IOMUXC_XBAR1_IN23_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x063c) // XBAR1_IN23_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN23_SELECT_INPUT_GPIO_EMC_37_ALT1      0x00000000 // select GPIO_EMC_37 for mode: ALT1
            #define IOMUXC_XBAR1_IN23_SELECT_INPUT_GPIO_AD_B0_11_ALT6    0x00000001 // select GPIO_AD_B0_11 for mode: ALT6
        #define IOMUXC_XBAR1_IN24_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0640) // XBAR1_IN24_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN24_SELECT_INPUT_GPIO_EMC_12_ALT1      0x00000000 // select GPIO_EMC_12 for mode: ALT1
            #define IOMUXC_XBAR1_IN24_SELECT_INPUT_GPIO_AD_B0_14_ALT6    0x00000001 // select GPIO_AD_B0_14 for mode: ALT6
        #define IOMUXC_XBAR1_IN14_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0644) // XBAR1_IN14_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN14_SELECT_INPUT_GPIO_AD_B0_00_ALT1    0x00000000 // select GPIO_AD_B0_00 for mode: ALT1
            #define IOMUXC_XBAR1_IN14_SELECT_INPUT_GPIO_B1_00_ALT1       0x00000001 // select GPIO_B1_00 for mode: ALT1
        #define IOMUXC_XBAR1_IN15_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0648) // XBAR1_IN15_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN15_SELECT_INPUT_GPIO_AD_B0_01_ALT1    0x00000000 // select GPIO_AD_B0_01 for mode: ALT1
            #define IOMUXC_XBAR1_IN15_SELECT_INPUT_GPIO_B1_01_ALT1       0x00000001 // select GPIO_B1_01 for mode: ALT1
        #define IOMUXC_XBAR1_IN16_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x064c) // XBAR1_IN16_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN16_SELECT_INPUT_GPIO_AD_B0_02_ALT1    0x00000000 // select GPIO_AD_B0_02 for mode: ALT1
            #define IOMUXC_XBAR1_IN16_SELECT_INPUT_GPIO_B1_02_ALT1       0x00000001 // select GPIO_B1_02 for mode: ALT1
        #define IOMUXC_XBAR1_IN25_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0650) // XBAR1_IN25_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN25_SELECT_INPUT_GPIO_AD_B0_15_ALT1    0x00000000 // select GPIO_AD_B0_15 for mode: ALT1
            #define IOMUXC_XBAR1_IN25_SELECT_INPUT_GPIO_EMC_13_ALT1      0x00000001 // select GPIO_EMC_13 for mode: ALT1
        #define IOMUXC_XBAR1_IN19_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0654) // XBAR1_IN19_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN19_SELECT_INPUT_GPIO_EMC_14_ALT1      0x00000000 // select GPIO_EMC_14 for mode: ALT1
            #define IOMUXC_XBAR1_IN19_SELECT_INPUT_GPIO_AD_B0_07_ALT6    0x00000001 // select GPIO_AD_B0_07 for mode: ALT6
        #define IOMUXC_XBAR1_IN21_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0658) // XBAR1_IN21_SELECT_INPUT DAISY register
            #define IOMUXC_XBAR1_IN21_SELECT_INPUT_GPIO_EMC_16_ALT1      0x00000000 // select GPIO_EMC_16 for mode: ALT1
            #define IOMUXC_XBAR1_IN21_SELECT_INPUT_GPIO_AD_B0_09_ALT6    0x00000001 // select GPIO_AD_B0_09 for mode: ALT6
        #if defined iMX_RT1064
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_00 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x065c) // SW_MUX_CTL_PAD_GPIO_SPI_B0_00 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_01 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0660) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_02 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0664) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_03 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0668) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_04 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x066c) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_05 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0670) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_06 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0674) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_07 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0678) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_08 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x067c) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_09 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0680) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_10 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0684) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_11 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0688) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_12 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x068c) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B0_13 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0690) // SW_MUX_CTL_PAD_GPIO_SPI_B0_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_00 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0694) // SW_MUX_CTL_PAD_GPIO_SPI_B1_00 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_01 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0698) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_02 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x069c) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_03 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06a0) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_04 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06a4) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_05 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06a8) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_06 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06ac) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SPI_B1_07 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06b0) // SW_MUX_CTL_PAD_GPIO_SPI_B1_01 SW MUX control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_00   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06b4) // SW_PAD_CTL_PAD_GPIO_SPI_B0_00 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_01   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06b8) // SW_PAD_CTL_PAD_GPIO_SPI_B0_01 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_02   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06bc) // SW_PAD_CTL_PAD_GPIO_SPI_B0_02 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_03   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06c0) // SW_PAD_CTL_PAD_GPIO_SPI_B0_03 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_04   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06c4) // SW_PAD_CTL_PAD_GPIO_SPI_B0_04 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_05   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06c8) // SW_PAD_CTL_PAD_GPIO_SPI_B0_05 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_06   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06cc) // SW_PAD_CTL_PAD_GPIO_SPI_B0_06 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_07   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06d0) // SW_PAD_CTL_PAD_GPIO_SPI_B0_07 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_08   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06d4) // SW_PAD_CTL_PAD_GPIO_SPI_B0_08 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_09   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06d8) // SW_PAD_CTL_PAD_GPIO_SPI_B0_09 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_10   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06dc) // SW_PAD_CTL_PAD_GPIO_SPI_B0_10 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_11   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06e0) // SW_PAD_CTL_PAD_GPIO_SPI_B0_11 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_12   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06e4) // SW_PAD_CTL_PAD_GPIO_SPI_B0_12 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B0_13   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06e8) // SW_PAD_CTL_PAD_GPIO_SPI_B0_13 SW pad control register

            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_00   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06ec) // SW_PAD_CTL_PAD_GPIO_SPI_B1_00 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_01   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06f0) // SW_PAD_CTL_PAD_GPIO_SPI_B1_01 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_02   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06f4) // SW_PAD_CTL_PAD_GPIO_SPI_B1_02 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_03   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06f8) // SW_PAD_CTL_PAD_GPIO_SPI_B1_03 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_04   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x06fc) // SW_PAD_CTL_PAD_GPIO_SPI_B1_04 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_05   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0700) // SW_PAD_CTL_PAD_GPIO_SPI_B1_05 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_06   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0704) // SW_PAD_CTL_PAD_GPIO_SPI_B1_06 SW pad control register
            #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SPI_B1_07   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0708) // SW_PAD_CTL_PAD_GPIO_SPI_B1_07 SW pad control register
        #endif
        #if !defined iMX_RT105X
            #define IOMUXC_ENET2_IPG_CLK_RMII_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x070c) // ENET2_IPG_CLK_RMII_SELECT_INPUT DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0710) // ENET2_IPP_IND_MAC0_MDIO_SELECT_INPUT DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0714) // ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_0 DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1 *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0718) // ENET2_IPP_IND_MAC0_RXDATA_SELECT_INPUT_1 DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x071c) // ENET2_IPP_IND_MAC0_RXEN_SELECT_INPUT DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0720) // ENET2_IPP_IND_MAC0_RXERR_SELECT_INPUT DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0  *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0724) // ENET2_IPP_IND_MAC0_TIMER_SELECT_INPUT_0 DAISY register
            #define IOMUXC_ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0728) // ENET2_IPP_IND_MAC0_TXCLK_SELECT_INPUT DAISY register

            #define IOMUXC_GPT1_IPP_IND_CAPIN1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0758) // GPT1_IPP_IND_CAPIN1_SELECT_INPUT DAISY register
            #define IOMUXC_GPT1_IPP_IND_CAPIN2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x075c) // GPT1_IPP_IND_CAPIN2_SELECT_INPUT DAISY register
            #define IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0760) // GPT1_IPP_IND_CLKIN_SELECT_INPUT DAISY register
                #define IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_GPIO_AD_B0_13_ALT1 0x00000000 // select GPIO_AD_B0_13 for mode: ALT1
                #define IOMUXC_GPT1_IPP_IND_CLKIN_SELECT_INPUT_GPIO_B1_04_ALT8    0x00000001 // select GPIO_B1_04 for mode: ALT8
            #define IOMUXC_GPT2_IPP_IND_CAPIN1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0764) // GPT2_IPP_IND_CAPIN1_SELECT_INPUT DAISY register
            #define IOMUXC_GPT2_IPP_IND_CAPIN2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0768) // GPT2_IPP_IND_CAPIN2_SELECT_INPUT DAISY register
            #define IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x076c) // GPT2_IPP_IND_CLKIN_SELECT_INPUT DAISY register
                #define IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_GPIO_AD_B0_09_ALT7 0x00000000 // select GPIO_AD_B0_09 for mode: ALT7
                #define IOMUXC_GPT2_IPP_IND_CLKIN_SELECT_INPUT_GPIO_AD_B1_02_ALT8 0x00000001 // select GPIO_AD_B1_02_ALT8 for mode: ALT8
            #define IOMUXC_SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0770) // SAI3_IPG_CLK_SAI_MCLK_SELECT_INPUT_2 DAISY register
            #define IOMUXC_SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0774) // SAI3_IPP_IND_SAI_RXBCLK_SELECT_INPUT DAISY register
            #define IOMUXC_SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0778) // SAI3_IPP_IND_SAI_RXDATA_SELECT_INPUT_0 DAISY register
            #define IOMUXC_SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x077c) // SAI3_IPP_IND_SAI_RXSYNC_SELECT_INPUT DAISY register
            #define IOMUXC_SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0780) // SAI3_IPP_IND_SAI_TXBCLK_SELECT_INPUT DAISY register
            #define IOMUXC_SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT     *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0784) // SAI3_IPP_IND_SAI_TXSYNC_SELECT_INPUT DAISY register
            #define IOMUXC_SEMC_I_IPP_IND_DQS4_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0788) // SEMC_I_IPP_IND_DQS4_SELECT_INPUT DAISY register
            #define IOMUXC_CANFD_IPP_IND_CANRX_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x078c) // CANFD_IPP_IND_CANRX_SELECT_INPUT DAISY register
        #endif
    #else
        #define IOMUXC_XBAR_INOUT02_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x060c) // XBAR_INOUT02_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT03_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0610) // XBAR_INOUT03_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT04_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0614) // XBAR_INOUT04_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT05_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0618) // XBAR_INOUT05_SELECT_INPUT register
        #define IOMUXC_XBAR_INOUT06_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x061c) // XBAR_INOUT06_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT07_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0620) // XBAR_INOUT07_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT08_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0624) // XBAR_INOUT08_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT09_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0628) // XBAR_INOUT09_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT17_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x062c) // XBAR_INOUT17_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT18_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0630) // XBAR_INOUT18_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT20_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0634) // XBAR_INOUT20_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT22_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0638) // XBAR_INOUT22_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT23_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x063c) // XBAR_INOUT23_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT24_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0640) // XBAR_INOUT24_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT14_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0644) // XBAR_INOUT14_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT15_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0648) // XBAR_INOUT15_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT16_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x064c) // XBAR_INOUT16_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT25_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0650) // XBAR_INOUT25_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT19_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0654) // XBAR_INOUT19_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR_INOUT21_SELECT_INPUT       *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0658) // XBAR_INOUT21_SELECT_INPUT DAISY register
    #endif
#else
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x013c)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x013c) // SW_MUX_CTL_PAD_GPIO_SD_B0_00 SW MUX control register [GPIO3-13]
        #define GPIO_SD_B0_00_USDHC1_DATA2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_00_QTIMER1_TIMER0           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_00_SAI1_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_00_SAI2_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_00_LPI2C3_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_00_GPIO3_IO13               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_00_FLEXSPI_A_SS1_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_SD_B0_00_XBAR1_INOUT14            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0140) // SW_MUX_CTL_PAD_GPIO_SD_B0_01 SW MUX control register [GPIO3-14]
        #define GPIO_SD_B0_01_USDHC1_DATA3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_01_QTIMER1_TIMER1           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_01_REF_24M_OUT              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_01_SAI2_RX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_01_LPI2C3_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_01_GPIO3_IO14               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_01_FLEXSPI_B_SS1_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_SD_B0_01_XBAR1_INOUT15            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
#if defined iMX_RT1011
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_10              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0144) // IOMUXC_SW_PAD_CTL_PAD_GPIO_10 SW PAD control register [GPIO1-10]
#else
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0144) // SW_MUX_CTL_PAD_GPIO_SD_B0_02 SW MUX control register [GPIO3-15]
        #define GPIO_SD_B0_02_USDHC1_CMD               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_02_QTIMER1_TIMER2           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_02_LPUART7_CTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_02_SAI2_RX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_02_LPSPI1_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_02_GPIO3_IO15               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_02_ENET0_MDIO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
        #define GPIO_SD_B0_02_XBAR1_INOUT16            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT7)
#endif
#if defined iMX_RT1011
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_09              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0148) // IOMUXC_SW_PAD_CTL_PAD_GPIO_09 SW PAD control register [GPIO1-09]
#else
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0148) // SW_MUX_CTL_PAD_GPIO_SD_B0_04 SW MUX control register [GPIO3-16]
        #define GPIO_SD_B0_03_USDHC1_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_03_QTIMER1_TIMER3           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_03_LPUART7_RTS_B            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_03_SAI2_RX_DATA             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_03_LPSPI1_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_03_GPIO3_IO16               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_03_ENET0_MDC                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
#endif
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x014c) // SW_MUX_CTL_PAD_GPIO_SD_B0_04 SW MUX control register [GPIO3-17]
        #define GPIO_SD_B0_04_USDHC1_DATA0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_04_FLEXCAN2_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_04_LPUART7_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_04_SAI2_TX_DATA             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_04LPSPI1_SDO                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_04_GPIO3_IO17               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_04_FLEXSPI_B_SS0_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0150) // SW_MUX_CTL_PAD_GPIO_SD_B0_05 SW MUX control register [GPIO3-18]
        #define GPIO_SD_B0_05_USDHC1_DATA1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_05_FLEXCAN2_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_05_LPUART7_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_05_SAI2_TX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_05_LPSPI1_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_05_GPIO3_IO18               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_05_FLEXSPI_B_DQS            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0154) // SW_MUX_CTL_PAD_GPIO_SD_B0_06 SW MUX control register [GPIO3-19]
        #define GPIO_SD_B0_06_USDHC1_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B0_06_USDHC1_RESET_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B0_06_REF_32K_OUT              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B0_06_SAI2_TX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B0_06_WDOG1_B                  (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B0_06_GPIO3_IO19               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B0_06_XBAR1_INOUT17            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0158) // SW_MUX_CTL_PAD_GPIO_AD_B1_00 SW MUX control register [GPIO3-20]
        #define GPIO_SD_B1_00_USDHC2_DATA2             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_00_FLEXSPI_B_DATA03         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_00_LPUART6_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_00_XBAR1_INOUT10            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_00_FLEXCAN1_TX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_00_GPIO3_IO20               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x015c) // SW_MUX_CTL_PAD_GPIO_AD_B1_01 SW MUX control register [GPIO3-21]
        #define GPIO_SD_B1_01_USDHC2_DATA3             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_01_FLEXSPI_B_SCLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_01_LPUART6_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_01_FLEXSPI_A_SS1_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_01_FLEXCAN1_RX              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_01_GPIO3_IO21               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0160) // SW_MUX_CTL_PAD_GPIO_AD_B1_02 SW MUX control register [GPIO3-22]
        #define GPIO_SD_B1_02_USDHC2_CMD               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_02_FLEXSPI_B_DATA00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_02_LPUART8_TX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_02_LPI2C4_SCL               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_02_ENET_1588_EVENT1_OUT     (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_02_GPIO3_IO22               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_02_CCM_CLKO1                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0164) // SW_MUX_CTL_PAD_GPIO_AD_B1_03 SW MUX control register [GPIO3-23]
        #define GPIO_SD_B1_03_USDHC2_CLK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_03_FLEXSPI_B_DATA02         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_03_LPUART8_RX               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_03_LPI2C4_SDA               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_03_ENET_1588_EVENT1_IN      (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_03_GPIO3_IO23               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_03_CCM_CLKO2                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0168) // SW_MUX_CTL_PAD_GPIO_AD_B1_04 SW MUX control register [GPIO3-24]
        #define GPIO_SD_B1_04_USDHC2_DATA0             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_04_FLEXSPI_B_DATA01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_04_ENET_TX_CLK              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_04_ENET_REF_CLK1            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_04_EWM_OUT_B                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_04_GPIO3_IO24               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_04_CCM_WAIT                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x016c) // SW_MUX_CTL_PAD_GPIO_AD_B1_05 SW MUX control register [GPIO3-25]
        #define GPIO_SD_B1_05_USDHC2_DATA1             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_05_FLEXSPI_A_DQS            (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_05_ENET_RDATA01             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_05_SAI3_MCLK                (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_05_FLEXSPI_B_SS0_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_05_GPIO3_IO25               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_05_CCM_PMIC_RDY             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0170) // SW_MUX_CTL_PAD_GPIO_AD_B1_06 SW MUX control register [GPIO3-26]
        #define GPIO_SD_B1_06_USDHC2_CD_B              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_06_FLEXSPI_A_DATA03         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_06_ENET_RDATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_06_SAI3_TX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_06_LPSPI2_PCS0              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_06_GPIO3_IO26               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
        #define GPIO_SD_B1_06_CCM_STOP                 (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT6)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0174) // SW_MUX_CTL_PAD_GPIO_AD_B1_07 SW MUX control register [GPIO3-27]
        #define GPIO_SD_B1_07_USDHC2_RESET_B           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_07_FLEXSPI_A_SCLK           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_07_ENET_RX_EN               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_07_SAI3_TX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_07_LPSPI2_SCK               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_07_GPIO3_IO27               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0178) // SW_MUX_CTL_PAD_GPIO_AD_B1_08 SW MUX control register [GPIO3-28]
        #define GPIO_SD_B1_08_USDHC2_DATA4             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_08_FLEXSPI_A_DATA00         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_08_ENET_RX_ER               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_08_SAI3_TX_DATA             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_08_LPSPI2_SDO               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_08_GPIO3_IO28               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x017c) // SW_MUX_CTL_PAD_GPIO_AD_B1_09 SW MUX control register [GPIO3-29]
        #define GPIO_SD_B1_09_USDHC2_DATA5             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_09_FLEXSPI_A_DATA02         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_09_ENET_TX_EN               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_09_SAI3_RX_BCLK             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_09_LPSPI2_SDI               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_09_GPIO3_IO29               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0180) // SW_MUX_CTL_PAD_GPIO_AD_B1_10 SW MUX control register [GPIO3-30]
        #define GPIO_SD_B1_10_USDHC2_DATA6             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_10_FLEXSPI_A_DATA01         (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_10_ENET_TDATA00             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_10_SAI3_RX_SYNC             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_10_LPSPI2_PCS2              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_10_GPIO3_IO30               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0184) // SW_MUX_CTL_PAD_GPIO_AD_B1_11 SW MUX control register [GPIO3-31]
        #define GPIO_SD_B1_11_USDHC2_DATA7             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT0)
        #define GPIO_SD_B1_11_FLEXSPI_A_SS0_B          (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT1)
        #define GPIO_SD_B1_11_ENET_TDATA01             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT2)
        #define GPIO_SD_B1_11_SAI3_RX_DATA             (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT3)
        #define GPIO_SD_B1_11_LPSPI2_PCS3              (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT4)
        #define GPIO_SD_B1_11_GPIO3_IO31               (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0188)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_00          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0188) // SW_PAD_CTL_PAD_GPIO_EMC_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_01          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x018c) // SW_PAD_CTL_PAD_GPIO_EMC_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_02          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0190) // SW_PAD_CTL_PAD_GPIO_EMC_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_03          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0194) // SW_PAD_CTL_PAD_GPIO_EMC_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_04          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0198) // SW_PAD_CTL_PAD_GPIO_EMC_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_05          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x019c) // SW_PAD_CTL_PAD_GPIO_EMC_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_06          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a0) // SW_PAD_CTL_PAD_GPIO_EMC_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_07          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a4) // SW_PAD_CTL_PAD_GPIO_EMC_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_08          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01a8) // SW_PAD_CTL_PAD_GPIO_EMC_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_09          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01ac) // SW_PAD_CTL_PAD_GPIO_EMC_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_10          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b0) // SW_PAD_CTL_PAD_GPIO_EMC_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_11          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b4) // SW_PAD_CTL_PAD_GPIO_EMC_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_12          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01b8) // SW_PAD_CTL_PAD_GPIO_EMC_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_13          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01bc) // SW_PAD_CTL_PAD_GPIO_EMC_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_14          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c0) // SW_PAD_CTL_PAD_GPIO_EMC_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_15          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c4) // SW_PAD_CTL_PAD_GPIO_EMC_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_16          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01c8) // SW_PAD_CTL_PAD_GPIO_EMC_16 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_17          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01cc) // SW_PAD_CTL_PAD_GPIO_EMC_17 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_18          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d0) // SW_PAD_CTL_PAD_GPIO_EMC_18 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_19          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d4) // SW_PAD_CTL_PAD_GPIO_EMC_19 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_20          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01d8) // SW_PAD_CTL_PAD_GPIO_EMC_20 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_21          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01dc) // SW_PAD_CTL_PAD_GPIO_EMC_21 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e0) // SW_PAD_CTL_PAD_GPIO_EMC_22 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e4) // SW_PAD_CTL_PAD_GPIO_EMC_23 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01e8) // SW_PAD_CTL_PAD_GPIO_EMC_24 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01ec) // SW_PAD_CTL_PAD_GPIO_EMC_25 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f0) // SW_PAD_CTL_PAD_GPIO_EMC_26 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f4) // SW_PAD_CTL_PAD_GPIO_EMC_27 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01f8) // SW_PAD_CTL_PAD_GPIO_EMC_28 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x01fc) // SW_PAD_CTL_PAD_GPIO_EMC_29 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_30          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0200) // SW_PAD_CTL_PAD_GPIO_EMC_30 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_31          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0204) // SW_PAD_CTL_PAD_GPIO_EMC_31 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32_ADD      (unsigned long *)(IOMUXC_SW_BLOCK + 0x0208)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_32          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0208) // SW_PAD_CTL_PAD_GPIO_EMC_32 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_33          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x020c) // SW_PAD_CTL_PAD_GPIO_EMC_33 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_34          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0210) // SW_PAD_CTL_PAD_GPIO_EMC_34 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_35          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0214) // SW_PAD_CTL_PAD_GPIO_EMC_35 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_36          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0218) // SW_PAD_CTL_PAD_GPIO_EMC_36 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_37          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x021c) // SW_PAD_CTL_PAD_GPIO_EMC_37 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_38          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0220) // SW_PAD_CTL_PAD_GPIO_EMC_38 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_39          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0224) // SW_PAD_CTL_PAD_GPIO_EMC_39 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_40          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0228) // SW_PAD_CTL_PAD_GPIO_EMC_40 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_41          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x022c) // SW_PAD_CTL_PAD_GPIO_EMC_41 SW PAD control register

    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x0230)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0230) // SW_PAD_CTL_PAD_GPIO_AD_B0_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0234) // SW_PAD_CTL_PAD_GPIO_AD_B0_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0238) // SW_PAD_CTL_PAD_GPIO_AD_B0_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x023c) // SW_PAD_CTL_PAD_GPIO_AD_B0_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0240) // SW_PAD_CTL_PAD_GPIO_AD_B0_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0244) // SW_PAD_CTL_PAD_GPIO_AD_B0_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0248) // SW_PAD_CTL_PAD_GPIO_AD_B0_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x024c) // SW_PAD_CTL_PAD_GPIO_AD_B0_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0250) // SW_PAD_CTL_PAD_GPIO_AD_B0_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0254) // SW_PAD_CTL_PAD_GPIO_AD_B0_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0258) // SW_PAD_CTL_PAD_GPIO_AD_B0_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x025c) // SW_PAD_CTL_PAD_GPIO_AD_B0_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_12        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0260) // SW_PAD_CTL_PAD_GPIO_AD_B0_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_13        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0264) // SW_PAD_CTL_PAD_GPIO_AD_B0_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_14        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0268) // SW_PAD_CTL_PAD_GPIO_AD_B0_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B0_15        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x026c) // SW_PAD_CTL_PAD_GPIO_AD_B0_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0270) // SW_PAD_CTL_PAD_GPIO_AD_B1_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0274) // SW_PAD_CTL_PAD_GPIO_AD_B1_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0278) // SW_PAD_CTL_PAD_GPIO_AD_B1_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x027c) // SW_PAD_CTL_PAD_GPIO_AD_B1_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0280) // SW_PAD_CTL_PAD_GPIO_AD_B1_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0284) // SW_PAD_CTL_PAD_GPIO_AD_B1_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0288) // SW_PAD_CTL_PAD_GPIO_AD_B1_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x028c) // SW_PAD_CTL_PAD_GPIO_AD_B1_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0290) // SW_PAD_CTL_PAD_GPIO_AD_B1_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0294) // SW_PAD_CTL_PAD_GPIO_AD_B1_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0298) // SW_PAD_CTL_PAD_GPIO_AD_B1_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x029c) // SW_PAD_CTL_PAD_GPIO_AD_B1_11 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_12        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02a0) // SW_PAD_CTL_PAD_GPIO_AD_B1_12 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_13        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02a4) // SW_PAD_CTL_PAD_GPIO_AD_B1_13 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_14        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02a8) // SW_PAD_CTL_PAD_GPIO_AD_B1_14 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_AD_B1_15        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02ac) // SW_PAD_CTL_PAD_GPIO_AD_B1_15 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00_ADD    (unsigned long *)(IOMUXC_SW_BLOCK + 0x02b0)
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02b0) // SW_PAD_CTL_PAD_GPIO_SD_B0_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02b4) // SW_PAD_CTL_PAD_GPIO_SD_B0_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02b8) // SW_PAD_CTL_PAD_GPIO_SD_B0_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02bc) // SW_PAD_CTL_PAD_GPIO_SD_B0_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02c0) // SW_PAD_CTL_PAD_GPIO_SD_B0_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02c4) // SW_PAD_CTL_PAD_GPIO_SD_B0_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02c8) // SW_PAD_CTL_PAD_GPIO_SD_B0_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_00        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02cc) // SW_PAD_CTL_PAD_GPIO_SD_B1_00 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_01        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02d0) // SW_PAD_CTL_PAD_GPIO_SD_B1_01 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_02        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02d4) // SW_PAD_CTL_PAD_GPIO_SD_B1_02 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_03        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02d8) // SW_PAD_CTL_PAD_GPIO_SD_B1_03 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_04        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02dc) // SW_PAD_CTL_PAD_GPIO_SD_B1_04 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_05        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02e0) // SW_PAD_CTL_PAD_GPIO_SD_B1_05 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_06        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02e4) // SW_PAD_CTL_PAD_GPIO_SD_B1_06 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_07        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02e8) // SW_PAD_CTL_PAD_GPIO_SD_B1_07 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_08        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02ec) // SW_PAD_CTL_PAD_GPIO_SD_B1_08 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_09        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02f0) // SW_PAD_CTL_PAD_GPIO_SD_B1_09 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_10        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02f4) // SW_PAD_CTL_PAD_GPIO_SD_B1_10 SW PAD control register
    #define IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B1_11        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02f8) // SW_PAD_CTL_PAD_GPIO_SD_B1_11 SW PAD control register
    #define IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT      *(unsigned long *)(IOMUXC_SW_BLOCK + 0x02fc) // ANATOP_USB_OTG_ID_SELECT_INPUT DAISY register
    #define IOMUXC_CCM_PMIC_READY_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0300) // CCM_PMIC_READY_SELECT_INPUT DAISY register
    #define IOMUXC_ENET_RMII_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0304) // ENET_RMII_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RMII_SELECT_INPUT_GPIO_SD_B1_04_ALT3 0x00000000 // select GPIO_SD_B1_04 for mode: ALT3
        #define IOMUXC_ENET_RMII_SELECT_INPUT_GPIO_AD_B0_08_ALT4 0x00000001 // select GPIO_AD_B0_08 for mode: ALT4
    #define IOMUXC_ENET_MDIO_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0308) // ENET_MDIO_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_MDIO_SELECT_INPUT_GPIO_SD_AD_B0_02_ALT6 0x00000000 // select GPIO_SD_AD_B0_02 for ALT6
        #define IOMUXC_ENET_MDIO_SELECT_INPUT_GPIO_AD_B0_04_ALT4    0x00000001 // select GPIO_AD_B0_04 for ALT4
        #define IOMUXC_ENET_MDIO_SELECT_INPUT_GPIO_EMC_40_ALT4      0x00000002 // select GPIO_EMC_40 for ALT4
    #define IOMUXC_ENET_RX_DATA0_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x030c) // ENET_RX_DATA0_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RX_DATA0_SELECT_INPUT_GPIO_SD_B1_06_ALT2 0x00000000 // select GPIO_SD_B1_06 for mode: ALT2
        #define IOMUXC_ENET_RX_DATA0_SELECT_INPUT_GPIO_AD_B0_10_ALT0 0x00000001 // select GPIO_AD_B0_10 for mode: ALT0
    #define IOMUXC_ENET_RX_DATA1_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0310) // ENET_RX_DATA1_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RX_DATA1_SELECT_INPUT_GPIO_SD_B1_05_ALT2 0x00000000 // select GPIO_SD_B1_05 for mode: ALT2
        #define IOMUXC_ENET_RX_DATA1_SELECT_INPUT_GPIO_AD_B0_09_ALT0 0x00000001 // select GPIO_AD_B0_09 for mode: ALT0
    #define IOMUXC_ENET_RX_EN_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0314) // ENET_RX_EN_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RX_EN_SELECT_INPUT_GPIO_SD_B1_07_ALT2 0x00000000 // select GPIO_SD_B1_07 for mode: ALT2
        #define IOMUXC_ENET_RX_EN_SELECT_INPUT_GPIO_AD_B0_11_ALT0 0x00000001 // select GPIO_AD_B0_11 for mode: ALT0
    #define IOMUXC_ENET_RX_ERR_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0318) // ENET_RX_ERR_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_RX_ERR_SELECT_INPUT_GPIO_SD_B1_08_ALT2 0x00000000 // select GPIO_SD_B1_09 for mode: ALT2
        #define IOMUXC_ENET_RX_ERR_SELECT_INPUT_GPIO_AD_B0_12_ALT0 0x00000001 // select GPIO_AD_B0_12 for mode: ALT0
    #define IOMUXC_ENET_TX_CLK_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x031c) // ENET_TX_CLK_SELECT_INPUT DAISY register
        #define IOMUXC_ENET_TX_CLK_SELECT_INPUT_GPIO_SD_B1_04_ALT2 0x00000000 // select GPIO_SD_B1_04 for mode: ALT2
        #define IOMUXC_ENET_TX_CLK_SELECT_INPUT_GPIO_AD_B0_08_ALT0 0x00000001 // select GPIO_AD_B0_08 for mode: ALT0
    #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0320) // FLEXCAN1_RX_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_EMC_01_ALT6   0x00000000 // select GPIO_EMC_01 for mode: ALT6
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_SD_B1_01_ALT4 0x00000001 // select GPIO_SD_B1_01 for mode: ALT4
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_AD_B0_05_ALT1 0x00000002 // select GPIO_AD_B0_05 for mode: ALT1
        #define IOMUXC_FLEXCAN1_RX_SELECT_INPUT_GPIO_EMC_15_ALT6   0x00000003 // select GPIO_EMC_15 for mode: ALT6
    #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0324) // FLEXCAN2_RX_SELECT_INPUT DAISY register
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_SD_B0_05_ALT1 0x00000000 // select GPIO_SD_B0_05 for mode: ALT1
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_EMC_09_ALT2   0x00000001 // select GPIO_EMC_09 for mode: ALT2
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_AD_B0_15_ALT1 0x00000002 // select GPIO_AD_B0_15 for mode: ALT1
        #define IOMUXC_FLEXCAN2_RX_SELECT_INPUT_GPIO_AD_B1_01_ALT2 0x00000003 // select GPIO_AD_B1_01 for mode: ALT2
    #define IOMUXC_FLEXPWM1_PWMA0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0328) // FLEXPWM1_PWMA0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMA1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x032c) // FLEXPWM1_PWMA1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMA2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0330) // FLEXPWM1_PWMA2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMA3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0334) // FLEXPWM1_PWMA3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0338) // FLEXPWM1_PWMB0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x033c) // FLEXPWM1_PWMB1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0340) // FLEXPWM1_PWMB2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM1_PWMB3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0344) // FLEXPWM1_PWMB3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0348) // FLEXPWM2_PWMA0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x034c) // FLEXPWM2_PWMA1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0350) // FLEXPWM2_PWMA2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMA3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0354) // FLEXPWM2_PWMA3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB0_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0358) // FLEXPWM2_PWMB0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB1_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x035c) // FLEXPWM2_PWMB1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB2_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0360) // FLEXPWM2_PWMB2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXPWM2_PWMB3_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0364) // FLEXPWM2_PWMB3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXSPI_A_DATA0_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0368) // FLEXSPI_A_DATA0_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXSPI_A_DATA1_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x036c) // FLEXSPI_A_DATA1_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXSPI_A_DATA2_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0370) // FLEXSPI_A_DATA2_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXSPI_A_DATA3_SELECT_INPUT        *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0374) // FLEXSPI_A_DATA3_SELECT_INPUT DAISY register
    #define IOMUXC_FLEXSPI_A_SCLK_SELECT_INPUT         *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0378) // FLEXSPI_A_SCLK_SELECT_INPUT DAISY register
    #define IOMUXC_LPI2C1_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x037c) // LPI2C1_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_EMC_02_ALT6   0x00000000 // select GPIO_EMC_02 for mode: ALT6
        #define IOMUXC_LPI2C1_SCL_SELECT_INPUT_GPIO_AD_B1_14_ALT0 0x00000001 // select GPIO_AD_B1_14 for mode: ALT0
    #define IOMUXC_LPI2C1_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0380) // LPI2C1_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_EMC_03_ALT6   0x00000000 // select GPIO_EMC_03 for mode: ALT6
        #define IOMUXC_LPI2C1_SDA_SELECT_INPUT_GPIO_AD_B1_15_ALT0 0x00000001 // select GPIO_AD_B1_15 for mode: ALT0
    #define IOMUXC_LPI2C2_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0384) // LPI2C2_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_AD_B1_08_ALT0 0x00000000 // select GPIO_AD_B1_08 for mode: ALT0
        #define IOMUXC_LPI2C2_SCL_SELECT_INPUT_GPIO_EMC_19_ALT2   0x00000001 // select GPIO_EMC_19 for mode: ALT2
    #define IOMUXC_LPI2C2_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0388) // LPI2C2_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_AD_B1_09_ALT0 0x00000000 // select GPIO_AD_B1_09 for mode: ALT0
        #define IOMUXC_LPI2C2_SDA_SELECT_INPUT_GPIO_EMC_18_ALT2   0x00000001 // select GPIO_EMC_18 for mode: ALT2
    #define IOMUXC_LPI2C3_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x038c) // LPI2C3_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C3_SCL_SELECT_INPUT_GPIO_SD_B0_00_ALT4 0x00000000 // select GPIO_SD_B0_00 for mode: ALT4
        #define IOMUXC_LPI2C3_SCL_SELECT_INPUT_GPIO_AD_B0_09_ALT1 0x00000001 // select GPIO_AD_B0_09 for mode: ALT1
    #define IOMUXC_LPI2C3_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0390) // LPI2C3_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C3_SDA_SELECT_INPUT_GPIO_SD_B0_01_ALT4 0x00000000 // select GPIO_SD_B0_01 for mode: ALT4
        #define IOMUXC_LPI2C3_SDA_SELECT_INPUT_GPIO_AD_B0_08_ALT1 0x00000001 // select GPIO_AD_B0_08 for mode: ALT1
    #define IOMUXC_LPI2C4_SCL_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0394) // LPI2C4_SCL_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C4_SCL_SELECT_INPUT_GPIO_EMC_11_ALT2   0x00000000 // select GPIO_EMC_11 for mode: ALT2
        #define IOMUXC_LPI2C4_SCL_SELECT_INPUT_GPIO_SD_B1_02_ALT3 0x00000001 // select GPIO_SD_B1_02 for mode: ALT3
    #define IOMUXC_LPI2C4_SDA_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0398) // LPI2C4_SDA_SELECT_INPUT DAISY register
        #define IOMUXC_LPI2C4_SDA_SELECT_INPUT_GPIO_EMC_10_ALT2   0x00000000 // select GPIO_EMC_10 for mode: ALT2
        #define IOMUXC_LPI2C4_SDA_SELECT_INPUT_GPIO_SD_B1_03_ALT3 0x00000001 // select GPIO_SD_B1_03 for mode: ALT3
    #define IOMUXC_LPSPI1_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x039c) // LPSPI1_PCS0_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI1_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03a0) // LPSPI1_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI1_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03a4) // LPSPI1_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI1_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03a8) // LPSPI1_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03ac) // LPSPI2_PCS0_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03b0) // LPSPI2_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03b4) // LPSPI2_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI2_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03b8) // LPSPI2_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_PCS0_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03bc) // LPSPI4_PCS0_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_SCK_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03c0) // LPSPI4_SCK_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_SDI_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03c4) // LPSPI4_SDI_SELECT_INPUT DAISY register
    #define IOMUXC_LPSPI4_SDO_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03c8) // LPSPI4_SDO_SELECT_INPUT DAISY register
    #define IOMUXC_LPUART2_CTS_B_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03cc) // LPUART2_CTS_B_SELECT_INPUT DAISY register
    #define IOMUXC_LPUART2_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03d0) // LPUART2_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART2_RX_SELECT_INPUT_GPIO_AD_B1_09_ALT2 0x00000000 // select GPIO_AD_B1_09 for mode: ALT2
        #define IOMUXC_LPUART2_RX_SELECT_INPUT_GPIO_EMC_23_ALT2   0x00000001 // select GPIO_EMC_23 for mode: ALT2
    #define IOMUXC_LPUART2_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03d4) // LPUART2_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART2_TX_SELECT_INPUT_GPIO_AD_B1_08_ALT2 0x00000000 // select GPIO_AD_B1_08 for mode: ALT2
        #define IOMUXC_LPUART2_TX_SELECT_INPUT_GPIO_EMC_22_ALT2   0x00000001 // select GPIO_EMC_22 for mode: ALT2
    #define IOMUXC_LPUART3_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03d8) // LPUART3_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_RX_SELECT_INPUT_GPIO_EMC_07_ALT2   0x00000000 // select GPIO_EMC_07 for mode: ALT2
        #define IOMUXC_LPUART3_RX_SELECT_INPUT_GPIO_AD_B0_15_ALT2 0x00000001 // select GPIO_AD_B0_15 for mode: ALT2
    #define IOMUXC_LPUART3_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03dc) // LPUART3_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART3_TX_SELECT_INPUT_GPIO_EMC_06_ALT2   0x00000000 // select GPIO_EMC_06 for mode: ALT2
        #define IOMUXC_LPUART3_TX_SELECT_INPUT_GPIO_AD_B0_14_ALT2 0x00000001 // select GPIO_AD_B0_14 for mode: ALT2
    #define IOMUXC_LPUART4_CTS_B_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03e0) // LPUART4_CTS_B_SELECT_INPUT DAISY register
    #define IOMUXC_LPUART4_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03e4) // LPUART4_RX_SELECT_INPUT DAISY register
        #if defined iMX_RT102X
            #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_EMC_03_ALT2   0x00000000 // select GPIO_EMC_03 for mode: ALT2
            #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_AD_B1_11_ALT2 0x00000001 // select GPIO_AD_B1_11 for mode: ALT2
            #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_EMC_33_ALT2   0x00000002 // select GPIO_EMC_33 for mode: ALT2
        #else
            #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_AD_B1_11_ALT2 0x00000000 // select GPIO_AD_B1_11 for mode: ALT2
            #define IOMUXC_LPUART4_RX_SELECT_INPUT_GPIO_EMC_33_ALT2   0x00000001 // select GPIO_EMC_33 for mode: ALT2
        #endif
    #define IOMUXC_LPUART4_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03e8) // LPUART4_TX_SELECT_INPUT DAISY register
        #if defined iMX_RT102X
            #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_EMC_02_ALT2   0x00000000 // select GPIO_EMC_02 for mode: ALT2
            #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_AD_B1_10_ALT2 0x00000001 // select GPIO_AD_B1_10 for mode: ALT2
            #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_EMC_32_ALT2   0x00000002 // select GPIO_EMC_32 for mode: ALT2
        #else
            #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_AD_B1_10_ALT2 0x00000000 // select GPIO_AD_B1_10 for mode: ALT2
            #define IOMUXC_LPUART4_TX_SELECT_INPUT_GPIO_EMC_32_ALT2   0x00000001 // select GPIO_EMC_32 for mode: ALT2
        #endif
  #if LPUARTS_AVAILABLE > 4
    #define IOMUXC_LPUART5_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03ec) // LPUART5_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART5_RX_SELECT_INPUT_GPIO_AD_B0_11_ALT2 0x00000000 // select GPIO_AD_B0_11 for mode: ALT2
        #define IOMUXC_LPUART5_RX_SELECT_INPUT_GPIO_EMC_39_ALT2   0x00000001 // select GPIO_EMC_39 for mode: ALT2
    #define IOMUXC_LPUART5_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03f0) // LPUART5_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART5_TX_SELECT_INPUT_GPIO_AD_B0_10_ALT2 0x00000000 // select GPIO_AD_B0_10 for mode: ALT2
        #define IOMUXC_LPUART5_TX_SELECT_INPUT_GPIO_EMC_38_ALT2   0x00000001 // select GPIO_EMC_38 for mode: ALT2
    #define IOMUXC_LPUART6_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03f4) // LPUART6_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART6_RX_SELECT_INPUT_GPIO_EMC_13_ALT2   0x00000000 // select GPIO_EMC_13 for mode: ALT2
        #define IOMUXC_LPUART6_RX_SELECT_INPUT_GPIO_SD_B1_01_ALT2 0x00000001 // select GPIO_SD_B1_01 for mode: ALT2
    #define IOMUXC_LPUART6_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03f8) // LPUART6_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART6_TX_SELECT_INPUT_GPIO_EMC_12_ALT2   0x00000000 // select GPIO_EMC_12 for mode: ALT2
        #define IOMUXC_LPUART6_TX_SELECT_INPUT_GPIO_SD_B1_00_ALT2 0x00000001 // select GPIO_SD_B1_00 for mode: ALT2
    #define IOMUXC_LPUART7_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x03fc) // LPUART7_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART7_RX_SELECT_INPUT_GPIO_SD_B0_05_ALT2 0x00000000 // select GPIO_SD_B0_05 for mode: ALT2
        #define IOMUXC_LPUART7_RX_SELECT_INPUT_GPIO_EMC_35_ALT2   0x00000001 // select GPIO_EMC_35 for mode: ALT2
    #define IOMUXC_LPUART7_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0400) // LPUART7_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART7_TX_SELECT_INPUT_GPIO_SD_B0_04_ALT2 0x00000000 // select GPIO_SD_B0_04 for mode: ALT2
        #define IOMUXC_LPUART7_TX_SELECT_INPUT_GPIO_EMC_34_ALT2   0x00000001 // select GPIO_EMC_34 for mode: ALT2
    #define IOMUXC_LPUART8_RX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0404) // LPUART8_RX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART8_RX_SELECT_INPUT_GPIO_SD_B1_03_ALT2 0x00000000 // select GPIO_SD_B1_03 for mode: ALT2
        #define IOMUXC_LPUART8_RX_SELECT_INPUT_GPIO_EMC_27_ALT2   0x00000001 // select GPIO_EMC_27 for mode: ALT2
    #define IOMUXC_LPUART8_TX_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0408) // LPUART8_TX_SELECT_INPUT DAISY register
        #define IOMUXC_LPUART8_TX_SELECT_INPUT_GPIO_SD_B1_02_ALT2 0x00000000 // select GPIO_SD_B1_02 for mode: ALT2
        #define IOMUXC_LPUART8_TX_SELECT_INPUT_GPIO_EMC_26_ALT2   0x00000001 // select GPIO_EMC_26 for mode: ALT2
  #endif
    #define IOMUXC_NMI_SELECT_INPUT                    *(unsigned long *)(IOMUXC_SW_BLOCK + 0x040c) // NMI_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER1_TIMER0_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0410) // QTIMER1_TIMER0_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER1_TIMER1_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0414) // QTIMER1_TIMER1_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER1_TIMER2_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0418) // QTIMER1_TIMER2_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER1_TIMER3_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x041c) // QTIMER1_TIMER3_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER0_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0420) // QTIMER2_TIMER0_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER1_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0424) // QTIMER2_TIMER1_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER2_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0428) // QTIMER2_TIMER2_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_QTIMER2_TIMER3_INPUT_SELECT_INPUT   *(unsigned long *)(IOMUXC_SW_BLOCK + 0x042c) // QTIMER2_TIMER3_INPUT_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_MCLK_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0430) // SAI1_MCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0434) // SAI1_RX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA0_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0438) // SAI1_RX_DATA0_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA1_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x043c) // SAI1_RX_DATA1_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA2_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0440) // SAI1_RX_DATA2_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_DATA3_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0444) // SAI1_RX_DATA3_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_RX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0448) // SAI1_RX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_TX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x044c) // SAI1_TX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI1_TX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0450) // SAI1_TX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_MCLK_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0454) // SAI2_MCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_RX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0458) // SAI2_RX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_RX_DATA0_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x045c) // SAI2_RX_DATA0_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_RX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0460) // SAI2_RX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_TX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0464) // SAI2_TX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI2_TX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0468) // SAI2_TX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI3_MCLK_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x046c) // SAI3_MCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI3_RX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0470) // SAI3_RX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI3_RX_DATA0_SELECT_INPUT          *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0474) // SAI3_RX_DATA0_SELECT_INPUT DAISY register
    #define IOMUXC_SAI3_RX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0478) // SAI3_RX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SAI3_TX_BCLK_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x047c) // SAI3_TX_BCLK_SELECT_INPUT DAISY register
    #define IOMUXC_SAI3_TX_SYNC_SELECT_INPUT           *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0480) // SAI3_TX_SYNC_SELECT_INPUT DAISY register
    #define IOMUXC_SEMC_READY_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0484) // SEMC_READY_SELECT_INPUT DAISY register
    #define IOMUXC_SPDIF_IN_SELECT_INPUT               *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0488) // SPDIF_IN_SELECT_INPUT DAISY register
    #define IOMUXC_USB_OTG_OC_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x048c) // USB_OTG_OC_SELECT_INPUT DAISY register
    #define IOMUXC_USDHC1_CD_B_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0490) // USDHC1_CD_B_SELECT_INPUT DAISY register
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_SD_B0_06_ALT0 0x00000000 // select GPIO_SD_B0_06 for mode: ALT0
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_AD_B0_05_ALT2 0x00000001 // select GPIO_AD_B0_05 for mode: ALT2
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_AD_B1_10_ALT3 0x00000002 // select GPIO_AD_B1_10 for mode: ALT3
        #define IOMUXC_USDHC1_CD_B_SELECT_INPUT_GPIO_EMC_38_ALT7   0x00000003 // select GPIO_EMC_38 for mode: ALT7
    #define IOMUXC_USDHC1_WP_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0494) // USDHC1_WP_SELECT_INPUT DAISY register
    #define IOMUXC_USDHC2_CD_B_SELECT_INPUT            *(unsigned long *)(IOMUXC_SW_BLOCK + 0x0498) // USDHC2_CD_B_SELECT_INPUT DAISY register
    #define IOMUXC_USDHC2_WP_SELECT_INPUT              *(unsigned long *)(IOMUXC_SW_BLOCK + 0x049c) // USDHC2_WP_SELECT_INPUT DAISY register
    #define IOMUXC_XBAR1_IN14_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04a0) // XBAR1_IN14_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN14_SELECT_INPUT_GPIO_SD_B0_00_ALT7 0x00000000 // select GPIO_SD_B0_00 for mode: ALT7
        #define IOMUXC_XBAR1_IN14_SELECT_INPUT_GPIO_EMC_14_ALT1   0x00000001 // select GPIO_EMC_14 for mode: ALT1
    #define IOMUXC_XBAR1_IN15_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04a4) // XBAR1_IN15_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN15_SELECT_INPUT_GPIO_SD_B0_01_ALT7 0x00000000 // select GPIO_SD_B0_01 for mode: ALT7
        #define IOMUXC_XBAR1_IN15_SELECT_INPUT_GPIO_EMC_15_ALT1   0x00000001 // select GPIO_EMC_15 for mode: ALT1
    #define IOMUXC_XBAR1_IN16_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04a8) // XBAR1_IN16_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN16_SELECT_INPUT_GPIO_SD_B0_02_ALT7 0x00000000 // select GPIO_SD_B0_02 for mode: ALT7
        #define IOMUXC_XBAR1_IN16_SELECT_INPUT_GPIO_EMC_18_ALT1   0x00000001 // select GPIO_EMC_18 for mode: ALT1
    #define IOMUXC_XBAR1_IN17_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04ac) // XBAR1_IN17_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN17_SELECT_INPUT_GPIO_SD_B0_06_ALT6 0x00000000 // select GPIO_SD_B0_06 for mode: ALT6
        #define IOMUXC_XBAR1_IN17_SELECT_INPUT_GPIO_EMC_19_ALT1   0x00000001 // select GPIO_EMC_19 for mode: ALT1
    #define IOMUXC_XBAR1_IN10_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04b0) // XBAR1_IN10_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN10_SELECT_INPUT_GPIO_EMC_10_ALT1   0x00000000 // select GPIO_EMC_10 for mode: ALT1
        #define IOMUXC_XBAR1_IN10_SELECT_INPUT_GPIO_SD_B1_00_ALT3 0x00000001 // select GPIO_SD_B1_00 for mode: ALT3
    #define IOMUXC_XBAR1_IN12_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04b4) // XBAR1_IN12_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN12_SELECT_INPUT_GPIO_EMC_12_ALT1   0x00000000 // select GPIO_EMC_12 for mode: ALT1
        #define IOMUXC_XBAR1_IN12_SELECT_INPUT_GPIO_SD_B1_08_ALT7 0x00000001 // select GPIO_SD_B1_08 for mode: ALT7
    #define IOMUXC_XBAR1_IN13_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04b8) // XBAR1_IN13_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN13_SELECT_INPUT_GPIO_EMC_13_ALT1   0x00000000 // select GPIO_EMC_13 for mode: ALT1
        #define IOMUXC_XBAR1_IN13_SELECT_INPUT_GPIO_SD_B1_09_ALT7 0x00000001 // select GPIO_SD_B1_09 for mode: ALT7
    #define IOMUXC_XBAR1_IN18_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04bc) // XBAR1_IN18_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN18_SELECT_INPUT_GPIO_EMC_28_ALT2   0x00000000 // select GPIO_EMC_28 for mode: ALT2
        #define IOMUXC_XBAR1_IN18_SELECT_INPUT_GPIO_EMC_40_ALT1   0x00000001 // select GPIO_EMC_40 for mode: ALT1
    #define IOMUXC_XBAR1_IN19_SELECT_INPUT             *(unsigned long *)(IOMUXC_SW_BLOCK + 0x04c0) // XBAR1_IN19_SELECT_INPUT DAISY register
        #define IOMUXC_XBAR1_IN19_SELECT_INPUT_GPIO_EMC_29_ALT2   0x00000000 // select GPIO_EMC_29 for mode: ALT2
        #define IOMUXC_XBAR1_IN19_SELECT_INPUT_GPIO_EMC_41_ALT1   0x00000001 // select GPIO_EMC_41 for mode: ALT1
#endif
#endif

    #define PAD_MUX_MODE_GPIO           (IOMUXC_SW_MUX_CTL_PAD_MUX_MODE_ALT5) // GPIO mode is always this value

// i.MX GPIO
//
#define GPIO1_DR                        *(volatile unsigned long *)(GPIO1_BLOCK + 0x0000) // GPIO1 data register
#define GPIO1_GDIR                      *(volatile unsigned long *)(GPIO1_BLOCK + 0x0004) // GPIO1 direction register
#define GPIO1_PSR                       *(volatile unsigned long *)(GPIO1_BLOCK + 0x0008) // GPIO1 pad status register
#define GPIO1_ICR1                      *(volatile unsigned long *)(GPIO1_BLOCK + 0x000c) // GPIO1 interrupt configuration 1 register
    #define PORT_ICR1_0_LOW_LEVEL       0x00000000                       // IRQ 0 low level sensitive
    #define PORT_ICR1_0_RISING          0x00000002                       // IRQ 0 rising edge sensitive
    #define PORT_ICR1_0_FALLING         0x00000003                       // IRQ 0 falling edge sensitive
    #define PORT_ICR1_0_HIGH_LEVEL      0x00000001                       // IRQ 0 high level sensitive
    #define PORT_ICR1_0_INT_MASK        0x00000003
    #define PORT_ICR1_1_LOW_LEVEL       0x00000000                       // IRQ 1 low level sensitive
    #define PORT_ICR1_1_RISING          0x00000008                       // IRQ 1 rising edge sensitive
    #define PORT_ICR1_1_FALLING         0x0000000c                       // IRQ 1 falling edge sensitive
    #define PORT_ICR1_1_HIGH_LEVEL      0x00000004                       // IRQ 1 high level sensitive
    #define PORT_ICR1_1_INT_MASK        0x0000000c
    #define PORT_ICR1_2_LOW_LEVEL       0x00000000                       // IRQ 2 low level sensitive
    #define PORT_ICR1_2_RISING          0x00000020                       // IRQ 2 rising edge sensitive
    #define PORT_ICR1_2_FALLING         0x00000030                       // IRQ 2 falling edge sensitive
    #define PORT_ICR1_2_HIGH_LEVEL      0x00000010                       // IRQ 2 high level sensitive
    #define PORT_ICR1_2_INT_MASK        0x00000030
    #define PORT_ICR1_3_LOW_LEVEL       0x00000000                       // IRQ 3 low level sensitive
    #define PORT_ICR1_3_RISING          0x00000080                       // IRQ 3 rising edge sensitive
    #define PORT_ICR1_3_FALLING         0x000000c0                       // IRQ 3 falling edge sensitive
    #define PORT_ICR1_3_HIGH_LEVEL      0x00000040                       // IRQ 3 high level sensitive
    #define PORT_ICR1_3_INT_MASK        0x0000000c
    #define PORT_ICR1_4_LOW_LEVEL       0x00000000                       // IRQ 4 low level sensitive
    #define PORT_ICR1_4_RISING          0x00000200                       // IRQ 4 rising edge sensitive
    #define PORT_ICR1_4_FALLING         0x00000300                       // IRQ 4 falling edge sensitive
    #define PORT_ICR1_4_HIGH_LEVEL      0x00000100                       // IRQ 4 high level sensitive
    #define PORT_ICR1_4_INT_MASK        0x00000300
    #define PORT_ICR1_5_LOW_LEVEL       0x00000000                       // IRQ 5 low level sensitive
    #define PORT_ICR1_5_RISING          0x00000800                       // IRQ 5 rising edge sensitive
    #define PORT_ICR1_5_FALLING         0x00000c00                       // IRQ 5 falling edge sensitive
    #define PORT_ICR1_5_HIGH_LEVEL      0x00000400                       // IRQ 5 high level sensitive
    #define PORT_ICR1_5_INT_MASK        0x00000c00
    #define PORT_ICR1_6_LOW_LEVEL       0x00000000                       // IRQ 6 low level sensitive
    #define PORT_ICR1_6_RISING          0x00002000                       // IRQ 6 rising edge sensitive
    #define PORT_ICR1_6_FALLING         0x00003000                       // IRQ 6 falling edge sensitive
    #define PORT_ICR1_6_HIGH_LEVEL      0x00001000                       // IRQ 6 high level sensitive
    #define PORT_ICR1_6_INT_MASK        0x00003000
    #define PORT_ICR1_7_LOW_LEVEL       0x00000000                       // IRQ 7 low level sensitive
    #define PORT_ICR1_7_RISING          0x00008000                       // IRQ 7 rising edge sensitive
    #define PORT_ICR1_7_FALLING         0x0000c000                       // IRQ 7 falling edge sensitive
    #define PORT_ICR1_7_HIGH_LEVEL      0x00004000                       // IRQ 7 high level sensitive
    #define PORT_ICR1_7_INT_MASK        0x0000c000
    #define PORT_ICR1_8_LOW_LEVEL       0x00000000                       // IRQ 8 low level sensitive
    #define PORT_ICR1_8_RISING          0x00020000                       // IRQ 8 rising edge sensitive
    #define PORT_ICR1_8_FALLING         0x00030000                       // IRQ 8 falling edge sensitive
    #define PORT_ICR1_8_HIGH_LEVEL      0x00010000                       // IRQ 8 high level sensitive
    #define PORT_ICR1_8_INT_MASK        0x00030000
    #define PORT_ICR1_9_LOW_LEVEL       0x00000000                       // IRQ 9 low level sensitive
    #define PORT_ICR1_9_RISING          0x00080000                       // IRQ 9 rising edge sensitive
    #define PORT_ICR1_9_FALLING         0x000c0000                       // IRQ 9 falling edge sensitive
    #define PORT_ICR1_9_HIGH_LEVEL      0x00040000                       // IRQ 9 high level sensitive
    #define PORT_ICR1_9_INT_MASK        0x000c0000
    #define PORT_ICR1_10_LOW_LEVEL      0x00000000                       // IRQ 10 low level sensitive
    #define PORT_ICR1_10_RISING         0x00200000                       // IRQ 10 rising edge sensitive
    #define PORT_ICR1_10_FALLING        0x00300000                       // IRQ 10 falling edge sensitive
    #define PORT_ICR1_10_HIGH_LEVEL     0x00100000                       // IRQ 10 high level sensitive
    #define PORT_ICR1_10_INT_MASK       0x00300000
    #define PORT_ICR1_11_LOW_LEVEL      0x00000000                       // IRQ 11 low level sensitive
    #define PORT_ICR1_11_RISING         0x00800000                       // IRQ 11 rising edge sensitive
    #define PORT_ICR1_11_FALLING        0x00c00000                       // IRQ 11 falling edge sensitive
    #define PORT_ICR1_11_HIGH_LEVEL     0x00400000                       // IRQ 11 high level sensitive
    #define PORT_ICR1_11_INT_MASK       0x000c0000
    #define PORT_ICR1_12_LOW_LEVEL      0x00000000                       // IRQ 12 low level sensitive
    #define PORT_ICR1_12_RISING         0x02000000                       // IRQ 12 rising edge sensitive
    #define PORT_ICR1_12_FALLING        0x03000000                       // IRQ 12 falling edge sensitive
    #define PORT_ICR1_12_HIGH_LEVEL     0x01000000                       // IRQ 12 high level sensitive
    #define PORT_ICR1_12_INT_MASK       0x03000000
    #define PORT_ICR1_13_LOW_LEVEL      0x00000000                       // IRQ 13 low level sensitive
    #define PORT_ICR1_13_RISING         0x08000000                       // IRQ 13 rising edge sensitive
    #define PORT_ICR1_13_FALLING        0x0c000000                       // IRQ 13 falling edge sensitive
    #define PORT_ICR1_13_HIGH_LEVEL     0x04000000                       // IRQ 13 high level sensitive
    #define PORT_ICR1_13_INT_MASK       0x0c000000
    #define PORT_ICR1_14_LOW_LEVEL      0x00000000                       // IRQ 14 low level sensitive
    #define PORT_ICR1_14_RISING         0x20000000                       // IRQ 14 rising edge sensitive
    #define PORT_ICR1_14_FALLING        0x30000000                       // IRQ 14 falling edge sensitive
    #define PORT_ICR1_14_HIGH_LEVEL     0x10000000                       // IRQ 14 high level sensitive
    #define PORT_ICR1_14_INT_MASK       0x30000000
    #define PORT_ICR1_15_LOW_LEVEL      0x00000000                       // IRQ 15 low level sensitive
    #define PORT_ICR1_15_RISING         0x80000000                       // IRQ 15 rising edge sensitive
    #define PORT_ICR1_15_FALLING        0xc0000000                       // IRQ 15 falling edge sensitive
    #define PORT_ICR1_15_HIGH_LEVEL     0x40000000                       // IRQ 15 high level sensitive
    #define PORT_ICR1_15_INT_MASK       0xc0000000
#define GPIO1_ICR2                      *(volatile unsigned long *)(GPIO1_BLOCK + 0x0010) // GPIO1 interrupt configuration 2 register
    #define PORT_ICR2_16_LOW_LEVEL      0x00000000                       // IRQ 16 low level sensitive
    #define PORT_ICR2_16_RISING         0x00000002                       // IRQ 16 rising edge sensitive
    #define PORT_ICR2_16_FALLING        0x00000003                       // IRQ 16 falling edge sensitive
    #define PORT_ICR2_16_HIGH_LEVEL     0x00000001                       // IRQ 16 high level sensitive
    #define PORT_ICR2_16_INT_MASK       0x00000003
    #define PORT_ICR2_17_LOW_LEVEL      0x00000000                       // IRQ 17 low level sensitive
    #define PORT_ICR2_17_RISING         0x00000008                       // IRQ 17 rising edge sensitive
    #define PORT_ICR2_17_FALLING        0x0000000c                       // IRQ 17 falling edge sensitive
    #define PORT_ICR2_17_HIGH_LEVEL     0x00000004                       // IRQ 17 high level sensitive
    #define PORT_ICR2_17_INT_MASK       0x0000000c
    #define PORT_ICR2_18_LOW_LEVEL      0x00000000                       // IRQ 18 low level sensitive
    #define PORT_ICR2_18_RISING         0x00000020                       // IRQ 18 rising edge sensitive
    #define PORT_ICR2_18_FALLING        0x00000030                       // IRQ 18 falling edge sensitive
    #define PORT_ICR2_18_HIGH_LEVEL     0x00000010                       // IRQ 18 high level sensitive
    #define PORT_ICR2_18_INT_MASK       0x00000030
    #define PORT_ICR2_19_LOW_LEVEL      0x00000000                       // IRQ 19 low level sensitive
    #define PORT_ICR2_19_RISING         0x00000080                       // IRQ 19 rising edge sensitive
    #define PORT_ICR2_19_FALLING        0x000000c0                       // IRQ 19 falling edge sensitive
    #define PORT_ICR2_19_HIGH_LEVEL     0x00000040                       // IRQ 19 high level sensitive
    #define PORT_ICR2_19_INT_MASK       0x0000000c
    #define PORT_ICR2_20_LOW_LEVEL      0x00000000                       // IRQ 20 low level sensitive
    #define PORT_ICR2_20_RISING         0x00000200                       // IRQ 20 rising edge sensitive
    #define PORT_ICR2_20_FALLING        0x00000300                       // IRQ 20 falling edge sensitive
    #define PORT_ICR2_20_HIGH_LEVEL     0x00000100                       // IRQ 20 high level sensitive
    #define PORT_ICR2_20_INT_MASK       0x00000300
    #define PORT_ICR2_21_LOW_LEVEL      0x00000000                       // IRQ 21 low level sensitive
    #define PORT_ICR2_21_RISING         0x00000800                       // IRQ 21 rising edge sensitive
    #define PORT_ICR2_21_FALLING        0x00000c00                       // IRQ 21 falling edge sensitive
    #define PORT_ICR2_21_HIGH_LEVEL     0x00000400                       // IRQ 21 high level sensitive
    #define PORT_ICR2_21_INT_MASK       0x00000c00
    #define PORT_ICR2_22_LOW_LEVEL      0x00000000                       // IRQ 22 low level sensitive
    #define PORT_ICR2_22_RISING         0x00002000                       // IRQ 22 rising edge sensitive
    #define PORT_ICR2_22_FALLING        0x00003000                       // IRQ 22 falling edge sensitive
    #define PORT_ICR2_22_HIGH_LEVEL     0x00001000                       // IRQ 22 high level sensitive
    #define PORT_ICR2_22_INT_MASK       0x00003000
    #define PORT_ICR2_23_LOW_LEVEL      0x00000000                       // IRQ 23 low level sensitive
    #define PORT_ICR2_23_RISING         0x00008000                       // IRQ 23 rising edge sensitive
    #define PORT_ICR2_23_FALLING        0x0000c000                       // IRQ 23 falling edge sensitive
    #define PORT_ICR2_23_HIGH_LEVEL     0x00004000                       // IRQ 23 high level sensitive
    #define PORT_ICR2_23_INT_MASK       0x0000c000
    #define PORT_ICR2_24_LOW_LEVEL      0x00000000                       // IRQ 24 low level sensitive
    #define PORT_ICR2_24_RISING         0x00020000                       // IRQ 24 rising edge sensitive
    #define PORT_ICR2_24_FALLING        0x00030000                       // IRQ 24 falling edge sensitive
    #define PORT_ICR2_24_HIGH_LEVEL     0x00010000                       // IRQ 24 high level sensitive
    #define PORT_ICR2_24_INT_MASK       0x00030000
    #define PORT_ICR2_25_LOW_LEVEL      0x00000000                       // IRQ 25 low level sensitive
    #define PORT_ICR2_25_RISING         0x00080000                       // IRQ 25 rising edge sensitive
    #define PORT_ICR2_25_FALLING        0x000c0000                       // IRQ 25 falling edge sensitive
    #define PORT_ICR2_25_HIGH_LEVEL     0x00040000                       // IRQ 25 high level sensitive
    #define PORT_ICR2_25_INT_MASK       0x000c0000
    #define PORT_ICR2_26_LOW_LEVEL      0x00000000                       // IRQ 26 low level sensitive
    #define PORT_ICR2_26_RISING         0x00200000                       // IRQ 26 rising edge sensitive
    #define PORT_ICR2_26_FALLING        0x00300000                       // IRQ 26 falling edge sensitive
    #define PORT_ICR2_26_HIGH_LEVEL     0x00100000                       // IRQ 26 high level sensitive
    #define PORT_ICR2_26_INT_MASK       0x00300000
    #define PORT_ICR2_27_LOW_LEVEL      0x00000000                       // IRQ 27 low level sensitive
    #define PORT_ICR2_27_RISING         0x00800000                       // IRQ 27 rising edge sensitive
    #define PORT_ICR2_27_FALLING        0x00c00000                       // IRQ 27 falling edge sensitive
    #define PORT_ICR2_27_HIGH_LEVEL     0x00400000                       // IRQ 27 high level sensitive
    #define PORT_ICR2_27_INT_MASK       0x000c0000
    #define PORT_ICR2_28_LOW_LEVEL      0x00000000                       // IRQ 28 low level sensitive
    #define PORT_ICR2_28_RISING         0x02000000                       // IRQ 28 rising edge sensitive
    #define PORT_ICR2_28_FALLING        0x03000000                       // IRQ 28 falling edge sensitive
    #define PORT_ICR2_28_HIGH_LEVEL     0x01000000                       // IRQ 28 high level sensitive
    #define PORT_ICR2_28_INT_MASK       0x03000000
    #define PORT_ICR2_29_LOW_LEVEL      0x00000000                       // IRQ 29 low level sensitive
    #define PORT_ICR2_29_RISING         0x08000000                       // IRQ 29 rising edge sensitive
    #define PORT_ICR2_29_FALLING        0x0c000000                       // IRQ 29 falling edge sensitive
    #define PORT_ICR2_29_HIGH_LEVEL     0x04000000                       // IRQ 29 high level sensitive
    #define PORT_ICR2_29_INT_MASK       0x0c000000
    #define PORT_ICR2_30_LOW_LEVEL      0x00000000                       // IRQ 30 low level sensitive
    #define PORT_ICR2_30_RISING         0x20000000                       // IRQ 30 rising edge sensitive
    #define PORT_ICR2_30_FALLING        0x30000000                       // IRQ 30 falling edge sensitive
    #define PORT_ICR2_30_HIGH_LEVEL     0x10000000                       // IRQ 30 high level sensitive
    #define PORT_ICR2_30_INT_MASK       0x30000000
    #define PORT_ICR2_31_LOW_LEVEL      0x00000000                       // IRQ 31 low level sensitive
    #define PORT_ICR2_31_RISING         0x80000000                       // IRQ 31 rising edge sensitive
    #define PORT_ICR2_31_FALLING        0xc0000000                       // IRQ 31 falling edge sensitive
    #define PORT_ICR2_31_HIGH_LEVEL     0x40000000                       // IRQ 31 high level sensitive
    #define PORT_ICR2_31_INT_MASK       0xc0000000
#define GPIO1_IMR                       *(volatile unsigned long *)(GPIO1_BLOCK + 0x0014) // GPIO1 interrupt mask register
    #define GPIO_IMR_IMR_0              0x00000001                       // IRQ0 enabled
    #define GPIO_IMR_IMR_1              0x00000002                       // IRQ1 enabled
    #define GPIO_IMR_IMR_2              0x00000004                       // IRQ2 enabled
    #define GPIO_IMR_IMR_3              0x00000008                       // IRQ3 enabled
    #define GPIO_IMR_IMR_4              0x00000010                       // IRQ4 enabled
    #define GPIO_IMR_IMR_5              0x00000020                       // IRQ5 enabled
    #define GPIO_IMR_IMR_6              0x00000040                       // IRQ6 enabled
    #define GPIO_IMR_IMR_7              0x00000080                       // IRQ7 enabled
    #define GPIO_IMR_IMR_8              0x00000100                       // IRQ8 enabled
    #define GPIO_IMR_IMR_9              0x00000200                       // IRQ9 enabled
    #define GPIO_IMR_IMR_10             0x00000400                       // IRQ10 enabled
    #define GPIO_IMR_IMR_11             0x00000800                       // IRQ11 enabled
    #define GPIO_IMR_IMR_12             0x00001000                       // IRQ12 enabled
    #define GPIO_IMR_IMR_13             0x00002000                       // IRQ13 enabled
    #define GPIO_IMR_IMR_14             0x00004000                       // IRQ14 enabled
    #define GPIO_IMR_IMR_15             0x00008000                       // IRQ15 enabled
    #define GPIO_IMR_IMR_16             0x00010000                       // IRQ16 enabled
    #define GPIO_IMR_IMR_17             0x00020000                       // IRQ17 enabled
    #define GPIO_IMR_IMR_18             0x00040000                       // IRQ18 enabled
    #define GPIO_IMR_IMR_19             0x00080000                       // IRQ19 enabled
    #define GPIO_IMR_IMR_20             0x00100000                       // IRQ20 enabled
    #define GPIO_IMR_IMR_21             0x00200000                       // IRQ21 enabled
    #define GPIO_IMR_IMR_22             0x00400000                       // IRQ22 enabled
    #define GPIO_IMR_IMR_23             0x00800000                       // IRQ23 enabled
    #define GPIO_IMR_IMR_24             0x01000000                       // IRQ24 enabled
    #define GPIO_IMR_IMR_25             0x02000000                       // IRQ25 enabled
    #define GPIO_IMR_IMR_26             0x04000000                       // IRQ26 enabled
    #define GPIO_IMR_IMR_27             0x08000000                       // IRQ27 enabled
    #define GPIO_IMR_IMR_28             0x10000000                       // IRQ28 enabled
    #define GPIO_IMR_IMR_29             0x20000000                       // IRQ29 enabled
    #define GPIO_IMR_IMR_30             0x40000000                       // IRQ30 enabled
    #define GPIO_IMR_IMR_31             0x80000000                       // IRQ31 enabled
#define GPIO1_ISR                       *(volatile unsigned long *)(GPIO1_BLOCK + 0x0018) // GPIO1 interrupt status register
    #define GPIO_ISR_ISR_0              0x00000001                       // IRQ0 pending (write '1' to clear)
    #define GPIO_ISR_ISR_1              0x00000002                       // IRQ1 pending (write '1' to clear)
    #define GPIO_ISR_ISR_2              0x00000004                       // IRQ2 pending (write '1' to clear)
    #define GPIO_ISR_ISR_3              0x00000008                       // IRQ3 pending (write '1' to clear)
    #define GPIO_ISR_ISR_4              0x00000010                       // IRQ4 pending (write '1' to clear)
    #define GPIO_ISR_ISR_5              0x00000020                       // IRQ5 pending (write '1' to clear)
    #define GPIO_ISR_ISR_6              0x00000040                       // IRQ6 pending (write '1' to clear)
    #define GPIO_ISR_ISR_7              0x00000080                       // IRQ7 pending (write '1' to clear)
    #define GPIO_ISR_ISR_8              0x00000100                       // IRQ8 pending (write '1' to clear)
    #define GPIO_ISR_ISR_9              0x00000200                       // IRQ9 pending (write '1' to clear)
    #define GPIO_ISR_ISR_10             0x00000400                       // IRQ10 pending (write '1' to clear)
    #define GPIO_ISR_ISR_11             0x00000800                       // IRQ11 pending (write '1' to clear)
    #define GPIO_ISR_ISR_12             0x00001000                       // IRQ12 pending (write '1' to clear)
    #define GPIO_ISR_ISR_13             0x00002000                       // IRQ13 pending (write '1' to clear)
    #define GPIO_ISR_ISR_14             0x00004000                       // IRQ14 pending (write '1' to clear)
    #define GPIO_ISR_ISR_15             0x00008000                       // IRQ15 pending (write '1' to clear)
    #define GPIO_ISR_ISR_16             0x00010000                       // IRQ16 pending (write '1' to clear)
    #define GPIO_ISR_ISR_17             0x00020000                       // IRQ17 pending (write '1' to clear)
    #define GPIO_ISR_ISR_18             0x00040000                       // IRQ18 pending (write '1' to clear)
    #define GPIO_ISR_ISR_19             0x00080000                       // IRQ19 pending (write '1' to clear)
    #define GPIO_ISR_ISR_20             0x00100000                       // IRQ20 pending (write '1' to clear)
    #define GPIO_ISR_ISR_21             0x00200000                       // IRQ21 pending (write '1' to clear)
    #define GPIO_ISR_ISR_22             0x00400000                       // IRQ22 pending (write '1' to clear)
    #define GPIO_ISR_ISR_23             0x00800000                       // IRQ23 pending (write '1' to clear)
    #define GPIO_ISR_ISR_24             0x01000000                       // IRQ24 pending (write '1' to clear)
    #define GPIO_ISR_ISR_25             0x02000000                       // IRQ25 pending (write '1' to clear)
    #define GPIO_ISR_ISR_26             0x04000000                       // IRQ26 pending (write '1' to clear)
    #define GPIO_ISR_ISR_27             0x08000000                       // IRQ27 pending (write '1' to clear)
    #define GPIO_ISR_ISR_28             0x10000000                       // IRQ28 pending (write '1' to clear)
    #define GPIO_ISR_ISR_29             0x20000000                       // IRQ29 pending (write '1' to clear)
    #define GPIO_ISR_ISR_30             0x40000000                       // IRQ30 pending (write '1' to clear)
    #define GPIO_ISR_ISR_31             0x80000000                       // IRQ31 pending (write '1' to clear)
#define GPIO1_EDGE_SEL                  *(volatile unsigned long *)(GPIO1_BLOCK + 0x001c) // GPIO1 edge select register (overrides GPIO1_ICR1 and GPIO1_ICR2 when enabled)
    #define GPIO_EDGE_SEL_0             0x00000001                       // IRQ0 on falling and rising edge
    #define GPIO_EDGE_SEL_1             0x00000002                       // IRQ1 on falling and rising edge
    #define GPIO_EDGE_SEL_2             0x00000004                       // IRQ2 on falling and rising edge
    #define GPIO_EDGE_SEL_3             0x00000008                       // IRQ3 on falling and rising edge
    #define GPIO_EDGE_SEL_4             0x00000010                       // IRQ4 on falling and rising edge
    #define GPIO_EDGE_SEL_5             0x00000020                       // IRQ5 on falling and rising edge
    #define GPIO_EDGE_SEL_6             0x00000040                       // IRQ6 on falling and rising edge
    #define GPIO_EDGE_SEL_7             0x00000080                       // IRQ7 on falling and rising edge
    #define GPIO_EDGE_SEL_8             0x00000100                       // IRQ8 on falling and rising edge
    #define GPIO_EDGE_SEL_9             0x00000200                       // IRQ9 on falling and rising edge
    #define GPIO_EDGE_SEL_10            0x00000400                       // IRQ10 on falling and rising edge
    #define GPIO_EDGE_SEL_11            0x00000800                       // IRQ11 on falling and rising edge
    #define GPIO_EDGE_SEL_12            0x00001000                       // IRQ12 on falling and rising edge
    #define GPIO_EDGE_SEL_13            0x00002000                       // IRQ13 on falling and rising edge
    #define GPIO_EDGE_SEL_14            0x00004000                       // IRQ14 on falling and rising edge
    #define GPIO_EDGE_SEL_15            0x00008000                       // IRQ15 on falling and rising edge
    #define GPIO_EDGE_SEL_16            0x00010000                       // IRQ16 on falling and rising edge
    #define GPIO_EDGE_SEL_17            0x00020000                       // IRQ17 on falling and rising edge
    #define GPIO_EDGE_SEL_18            0x00040000                       // IRQ18 on falling and rising edge
    #define GPIO_EDGE_SEL_19            0x00080000                       // IRQ19 on falling and rising edge
    #define GPIO_EDGE_SEL_20            0x00100000                       // IRQ20 on falling and rising edge
    #define GPIO_EDGE_SEL_21            0x00200000                       // IRQ21 on falling and rising edge
    #define GPIO_EDGE_SEL_22            0x00400000                       // IRQ22 on falling and rising edge
    #define GPIO_EDGE_SEL_23            0x00800000                       // IRQ23 on falling and rising edge
    #define GPIO_EDGE_SEL_24            0x01000000                       // IRQ24 on falling and rising edge
    #define GPIO_EDGE_SEL_25            0x02000000                       // IRQ25 on falling and rising edge
    #define GPIO_EDGE_SEL_26            0x04000000                       // IRQ26 on falling and rising edge
    #define GPIO_EDGE_SEL_27            0x08000000                       // IRQ27 on falling and rising edge
    #define GPIO_EDGE_SEL_28            0x10000000                       // IRQ28 on falling and rising edge
    #define GPIO_EDGE_SEL_29            0x20000000                       // IRQ29 on falling and rising edge
    #define GPIO_EDGE_SEL_30            0x40000000                       // IRQ30 on falling and rising edge
    #define GPIO_EDGE_SEL_31            0x80000000                       // IRQ31 on falling and rising edge

    // Used for configuring interrupt sensitivity and pin characteristics
    //
    #define PORT_ICR_LOW_LEVEL        (PORT_ICR1_0_LOW_LEVEL)
    #define PORT_ICR_HIGH_LEVEL       (PORT_ICR1_0_HIGH_LEVEL)
    #define PORT_ICR_RISING           (PORT_ICR1_0_RISING)
    #define PORT_ICR_FALLING          (PORT_ICR1_0_FALLING)
    #define PORT_ICR_PULL_UP_ENABLE   (0x04)
    #define PORT_ICR_PULL_DOWN_ENABLE (0x08)
    #define PORT_ICR_BOTH             (0x10)
    #define PORT_ICR_DISABLE          (0x20)

#define GPIO1_DR_SET                    *(volatile unsigned long *)(GPIO1_BLOCK + 0x0084) // GPIO1 data register set - write-only (reads always 0)
#define GPIO1_DR_CLEAR                  *(volatile unsigned long *)(GPIO1_BLOCK + 0x0088) // GPIO1 data register clear - write-only (reads always 0)
#define GPIO1_DR_TOGGLE                 *(volatile unsigned long *)(GPIO1_BLOCK + 0x008c) // GPIO1 data register toggle - write-only (reads always 0)
#if defined PORT2
    #define GPIO2_DR                    *(volatile unsigned long *)(GPIO2_BLOCK + 0x0000) // GPIO2 data register
    #define GPIO2_GDIR                  *(volatile unsigned long *)(GPIO2_BLOCK + 0x0004) // GPIO2 direction register
    #define GPIO2_PSR                   *(volatile unsigned long *)(GPIO2_BLOCK + 0x0008) // GPIO2 pad status register
    #define GPIO2_ICR1                  *(volatile unsigned long *)(GPIO2_BLOCK + 0x000c) // GPIO2 interrupt configuration 1 register
    #define GPIO2_ICR2                  *(volatile unsigned long *)(GPIO2_BLOCK + 0x0010) // GPIO2 interrupt configuration 2 register
    #define GPIO2_IMR                   *(volatile unsigned long *)(GPIO2_BLOCK + 0x0014) // GPIO2 interrupt mask register
    #define GPIO2_ISR                   *(volatile unsigned long *)(GPIO2_BLOCK + 0x0018) // GPIO2 interrupt status register
    #define GPIO2_EDGE_SEL              *(volatile unsigned long *)(GPIO2_BLOCK + 0x001c) // GPIO2 edge select register

    #define GPIO2_DR_SET                *(volatile unsigned long *)(GPIO2_BLOCK + 0x0084) // GPIO2 data register set - write-only (reads always 0)
    #define GPIO2_DR_CLEAR              *(volatile unsigned long *)(GPIO2_BLOCK + 0x0088) // GPIO2 data register clear - write-only (reads always 0)
    #define GPIO2_DR_TOGGLE             *(volatile unsigned long *)(GPIO2_BLOCK + 0x008c) // GPIO2 data register toggle - write-only (reads always 0)
#endif
#if defined PORT3
    #define GPIO3_DR                    *(volatile unsigned long *)(GPIO3_BLOCK + 0x0000) // GPIO3 data register
    #define GPIO3_GDIR                  *(volatile unsigned long *)(GPIO3_BLOCK + 0x0004) // GPIO3 direction register
    #define GPIO3_PSR                   *(volatile unsigned long *)(GPIO3_BLOCK + 0x0008) // GPIO3 pad status register
    #define GPIO3_ICR1                  *(volatile unsigned long *)(GPIO3_BLOCK + 0x000c) // GPIO3 interrupt configuration 1 register
    #define GPIO3_ICR2                  *(volatile unsigned long *)(GPIO3_BLOCK + 0x0010) // GPIO3 interrupt configuration 2 register
    #define GPIO3_IMR                   *(volatile unsigned long *)(GPIO3_BLOCK + 0x0014) // GPIO3 interrupt mask register
    #define GPIO3_ISR                   *(volatile unsigned long *)(GPIO3_BLOCK + 0x0018) // GPIO3 interrupt status register
    #define GPIO3_EDGE_SEL              *(volatile unsigned long *)(GPIO3_BLOCK + 0x001c) // GPIO3 edge select register

    #define GPIO3_DR_SET                *(volatile unsigned long *)(GPIO3_BLOCK + 0x0084) // GPIO3 data register set - write-only (reads always 0)
    #define GPIO3_DR_CLEAR              *(volatile unsigned long *)(GPIO3_BLOCK + 0x0088) // GPIO3 data register clear - write-only (reads always 0)
    #define GPIO3_DR_TOGGLE             *(volatile unsigned long *)(GPIO3_BLOCK + 0x008c) // GPIO3 data register toggle - write-only (reads always 0)
#endif
#if defined PORT4
    #define GPIO4_DR                    *(volatile unsigned long *)(GPIO4_BLOCK + 0x0000) // GPIO4 data register
    #define GPIO4_GDIR                  *(volatile unsigned long *)(GPIO4_BLOCK + 0x0004) // GPIO4 direction register
    #define GPIO4_PSR                   *(volatile unsigned long *)(GPIO4_BLOCK + 0x0008) // GPIO4 pad status register
    #define GPIO4_ICR1                  *(volatile unsigned long *)(GPIO4_BLOCK + 0x000c) // GPIO4 interrupt configuration 1 register
    #define GPIO4_ICR2                  *(volatile unsigned long *)(GPIO4_BLOCK + 0x0010) // GPIO4 interrupt configuration 2 register
    #define GPIO4_IMR                   *(volatile unsigned long *)(GPIO4_BLOCK + 0x0014) // GPIO4 interrupt mask register
    #define GPIO4_ISR                   *(volatile unsigned long *)(GPIO4_BLOCK + 0x0018) // GPIO4 interrupt status register
    #define GPIO4_EDGE_SEL              *(volatile unsigned long *)(GPIO4_BLOCK + 0x001c) // GPIO4 edge select register

    #define GPIO4_DR_SET                *(volatile unsigned long *)(GPIO4_BLOCK + 0x0084) // GPIO4 data register set - write-only (reads always 0)
    #define GPIO4_DR_CLEAR              *(volatile unsigned long *)(GPIO4_BLOCK + 0x0088) // GPIO4 data register clear - write-only (reads always 0)
    #define GPIO4_DR_TOGGLE             *(volatile unsigned long *)(GPIO4_BLOCK + 0x008c) // GPIO4 data register toggle - write-only (reads always 0)
#endif
#if defined PORT5
    #define GPIO5_DR                    *(volatile unsigned long *)(GPIO5_BLOCK + 0x0000) // GPIO5 data register
    #define GPIO5_GDIR                  *(volatile unsigned long *)(GPIO5_BLOCK + 0x0004) // GPIO5 direction register
    #define GPIO5_PSR                   *(volatile unsigned long *)(GPIO5_BLOCK + 0x0008) // GPIO5 pad status register
    #define GPIO5_ICR1                  *(volatile unsigned long *)(GPIO5_BLOCK + 0x000c) // GPIO5 interrupt configuration 1 register
    #define GPIO5_ICR2                  *(volatile unsigned long *)(GPIO5_BLOCK + 0x0010) // GPIO5 interrupt configuration 2 register
    #define GPIO5_IMR                   *(volatile unsigned long *)(GPIO5_BLOCK + 0x0014) // GPIO5 interrupt mask register
    #define GPIO5_ISR                   *(volatile unsigned long *)(GPIO5_BLOCK + 0x0018) // GPIO5 interrupt status register
    #define GPIO5_EDGE_SEL              *(volatile unsigned long *)(GPIO5_BLOCK + 0x001c) // GPIO5 edge select register

    #define GPIO5_DR_SET                *(volatile unsigned long *)(GPIO5_BLOCK + 0x0084) // GPIO5 data register set - write-only (reads always 0)
    #define GPIO5_DR_CLEAR              *(volatile unsigned long *)(GPIO5_BLOCK + 0x0088) // GPIO5 data register clear - write-only (reads always 0)
    #define GPIO5_DR_TOGGLE             *(volatile unsigned long *)(GPIO5_BLOCK + 0x008c) // GPIO5 data register toggle - write-only (reads always 0)
#endif
#if defined PORT6
    #define GPIO6_DR                    *(volatile unsigned long *)(GPIO6_BLOCK + 0x0000) // GPIO6 data register
    #define GPIO6_GDIR                  *(volatile unsigned long *)(GPIO6_BLOCK + 0x0004) // GPIO6 direction register
    #define GPIO6_PSR                   *(volatile unsigned long *)(GPIO6_BLOCK + 0x0008) // GPIO6 pad status register
    #define GPIO6_ICR1                  *(volatile unsigned long *)(GPIO6_BLOCK + 0x000c) // GPIO6 interrupt configuration 1 register
    #define GPIO6_ICR2                  *(volatile unsigned long *)(GPIO6_BLOCK + 0x0010) // GPIO6 interrupt configuration 2 register
    #define GPIO6_IMR                   *(volatile unsigned long *)(GPIO6_BLOCK + 0x0014) // GPIO6 interrupt mask register
    #define GPIO6_ISR                   *(volatile unsigned long *)(GPIO6_BLOCK + 0x0018) // GPIO6 interrupt status register
    #define GPIO6_EDGE_SEL              *(volatile unsigned long *)(GPIO6_BLOCK + 0x001c) // GPIO6 edge select register

    #define GPIO6_DR_SET                *(volatile unsigned long *)(GPIO6_BLOCK + 0x0084) // GPIO6 data register set - write-only (reads always 0)
    #define GPIO6_DR_CLEAR              *(volatile unsigned long *)(GPIO6_BLOCK + 0x0088) // GPIO6 data register clear - write-only (reads always 0)
    #define GPIO6_DR_TOGGLE             *(volatile unsigned long *)(GPIO6_BLOCK + 0x008c) // GPIO6 data register toggle - write-only (reads always 0)
#endif
#if defined PORT7
    #define GPIO7_DR                    *(volatile unsigned long *)(GPIO7_BLOCK + 0x0000) // GPIO7 data register
    #define GPIO7_GDIR                  *(volatile unsigned long *)(GPIO7_BLOCK + 0x0004) // GPIO7 direction register
    #define GPIO7_PSR                   *(volatile unsigned long *)(GPIO7_BLOCK + 0x0008) // GPIO7 pad status register
    #define GPIO7_ICR1                  *(volatile unsigned long *)(GPIO7_BLOCK + 0x000c) // GPIO7 interrupt configuration 1 register
    #define GPIO7_ICR2                  *(volatile unsigned long *)(GPIO7_BLOCK + 0x0010) // GPIO7 interrupt configuration 2 register
    #define GPIO7_IMR                   *(volatile unsigned long *)(GPIO7_BLOCK + 0x0014) // GPIO7 interrupt mask register
    #define GPIO7_ISR                   *(volatile unsigned long *)(GPIO7_BLOCK + 0x0018) // GPIO7 interrupt status register
    #define GPIO7_EDGE_SEL              *(volatile unsigned long *)(GPIO7_BLOCK + 0x001c) // GPIO7 edge select register

    #define GPIO7_DR_SET                *(volatile unsigned long *)(GPIO7_BLOCK + 0x0084) // GPIO7 data register set - write-only (reads always 0)
    #define GPIO7_DR_CLEAR              *(volatile unsigned long *)(GPIO7_BLOCK + 0x0088) // GPIO7 data register clear - write-only (reads always 0)
    #define GPIO7_DR_TOGGLE             *(volatile unsigned long *)(GPIO7_BLOCK + 0x008c) // GPIO7 data register toggle - write-only (reads always 0)
#endif
#if defined PORT8
    #define GPIO8_DR                    *(volatile unsigned long *)(GPIO8_BLOCK + 0x0000) // GPIO8 data register
    #define GPIO8_GDIR                  *(volatile unsigned long *)(GPIO8_BLOCK + 0x0004) // GPIO8 direction register
    #define GPIO8_PSR                   *(volatile unsigned long *)(GPIO8_BLOCK + 0x0008) // GPIO8 pad status register
    #define GPIO8_ICR1                  *(volatile unsigned long *)(GPIO8_BLOCK + 0x000c) // GPIO8 interrupt configuration 1 register
    #define GPIO8_ICR2                  *(volatile unsigned long *)(GPIO8_BLOCK + 0x0010) // GPIO8 interrupt configuration 2 register
    #define GPIO8_IMR                   *(volatile unsigned long *)(GPIO8_BLOCK + 0x0014) // GPIO8 interrupt mask register
    #define GPIO8_ISR                   *(volatile unsigned long *)(GPIO8_BLOCK + 0x0018) // GPIO8 interrupt status register
    #define GPIO8_EDGE_SEL              *(volatile unsigned long *)(GPIO8_BLOCK + 0x001c) // GPIO8 edge select register

    #define GPIO8_DR_SET                *(volatile unsigned long *)(GPIO8_BLOCK + 0x0084) // GPIO8 data register set - write-only (reads always 0)
    #define GPIO8_DR_CLEAR              *(volatile unsigned long *)(GPIO8_BLOCK + 0x0088) // GPIO8 data register clear - write-only (reads always 0)
    #define GPIO8_DR_TOGGLE             *(volatile unsigned long *)(GPIO8_BLOCK + 0x008c) // GPIO8 data register toggle - write-only (reads always 0)
#endif
#if defined PORT9
    #define GPIO9_DR                    *(volatile unsigned long *)(GPIO9_BLOCK + 0x0000) // GPIO9 data register
    #define GPIO9_GDIR                  *(volatile unsigned long *)(GPIO9_BLOCK + 0x0004) // GPIO9 direction register
    #define GPIO9_PSR                   *(volatile unsigned long *)(GPIO9_BLOCK + 0x0008) // GPIO9 pad status register
    #define GPIO9_ICR1                  *(volatile unsigned long *)(GPIO9_BLOCK + 0x000c) // GPIO9 interrupt configuration 1 register
    #define GPIO9_ICR2                  *(volatile unsigned long *)(GPIO9_BLOCK + 0x0010) // GPIO9 interrupt configuration 2 register
    #define GPIO9_IMR                   *(volatile unsigned long *)(GPIO9_BLOCK + 0x0014) // GPIO9 interrupt mask register
    #define GPIO9_ISR                   *(volatile unsigned long *)(GPIO9_BLOCK + 0x0018) // GPIO9 interrupt status register
    #define GPIO9_EDGE_SEL              *(volatile unsigned long *)(GPIO9_BLOCK + 0x001c) // GPIO9 edge select register

    #define GPIO9_DR_SET                *(volatile unsigned long *)(GPIO9_BLOCK + 0x0084) // GPIO9 data register set - write-only (reads always 0)
    #define GPIO9_DR_CLEAR              *(volatile unsigned long *)(GPIO9_BLOCK + 0x0088) // GPIO9 data register clear - write-only (reads always 0)
    #define GPIO9_DR_TOGGLE             *(volatile unsigned long *)(GPIO9_BLOCK + 0x008c) // GPIO9 data register toggle - write-only (reads always 0)
#endif


// System Reset Controller (SRC)
//
#define SRC_SCR                         *(unsigned long *)(SRC_BLOCK + 0x00) // SRC control register
#define SRC_SBMR1                       *(volatile unsigned long *)(SRC_BLOCK + 0x04) // SRC boot mode register 1 (read-only)
#define SRC_SRSR                        *(volatile unsigned long *)(SRC_BLOCK + 0x08) // SRC reset status register (write '1' to clear)
    #define SRC_SRSR_IPP_RESET_B        0x00000001                       // reset due to ipp_reset_b pin
    #define SRC_SRSR_LOCKUP_SYSRESETREQ 0x00000002                       // reset due to CPU lockup
    #define SRC_SRSR_CSU_RESET_B        0x00000004                       // reset due to csu_reset_b event
    #define SRC_SRSR_IPP_USER_RESET_B   0x00000008                       // reset due to ipp_user_reset_b qualified as cold reset
    #define SRC_SRSR_WDG_RST_B          0x00000010                       // reset due watchdog time-out reset
    #define SRC_SRSR_JTAG_RST_B         0x00000020                       // reset due to high-z reset from jtag
    #define SRC_SRSR_JTAG_SW_RST        0x00000040                       // reset due to software reset from JTAG
    #define SRC_SRSR_WDOG3_RST_B        0x00000080                       // reset due to watchdog3 time-out event
    #define SRC_SRSR_TEMPSENSE_RST_B    0x00000100                       // reset due to software reset from temperature sensor
#define SRC_SBMR2                       *(volatile unsigned long *)(SRC_BLOCK + 0x1c) // SRC boot mode register 2 (read-only)
#define SRC_GPR1                        *(unsigned long *)(SRC_BLOCK + 0x20) // SRC general purpose register 1
#define SRC_GPR2                        *(unsigned long *)(SRC_BLOCK + 0x24) // SRC general purpose register 2
#define SRC_GPR3                        *(unsigned long *)(SRC_BLOCK + 0x28) // SRC general purpose register 3
#define SRC_GPR4                        *(unsigned long *)(SRC_BLOCK + 0x2c) // SRC general purpose register 4
#define SRC_GPR5                        *(unsigned long *)(SRC_BLOCK + 0x30) // SRC general purpose register 5
#define SRC_GPR6                        *(unsigned long *)(SRC_BLOCK + 0x34) // SRC general purpose register 6
#define SRC_GPR7                        *(unsigned long *)(SRC_BLOCK + 0x38) // SRC general purpose register 7
#define SRC_GPR8                        *(unsigned long *)(SRC_BLOCK + 0x3c) // SRC general purpose register 8
#define SRC_GPR9                        *(unsigned long *)(SRC_BLOCK + 0x40) // SRC general purpose register 9
#define SRC_GPR10                       *(unsigned long *)(SRC_BLOCK + 0x44) // SRC general purpose register 10

// Clock Control Module (CCM)
//
#define CCM_CCR                         *(unsigned long *)(CCM_BLOCK + 0x0000) // CCM control register
    #define CCM_CCR_RBC_EN              0x08000000                       // REG_BYPASS_COUNTER enable
    #define CCM_CCR_REG_BYPASS_COUNT_MASK 0x07e00000                     // 0..63 clock period delay after standy voltage request by PMIC_STRY_REQ (default 32)
    #define CCM_CCR_COSC_EN             0x00001000                       // on-chip oscillator enable bit (default enabled)
    #define CCM_CCR_OSCNT_MASK          0x000000ff                       // 0..255 oscillator ready count value (32kHz) (default 127 - 4ms)
#define CCM_CSR                         *(volatile unsigned long *)(CCM_BLOCK + 0x0008) // CCM status register (read-only)
    #define CCM_CSR_COSC_READY          0x00000020                       // on board oscillator is ready
    #define CCM_CSR_CAMP2_READY         0x00000008                       // CAMP2 is ready
    #define CCM_CSR_REF_EN_B            0x00000001                       // value of CCM_REF_EN_B is '1'
#define CCM_CCSR                        *(unsigned long *)(CCM_BLOCK + 0x000c) // CCM clock switcher register
    #define CCM_CSSR_PLL3_MAIN_CLOCK    0x00000000                       // pll3_main_clk
    #define CCM_CSSR_PLL3_SW_CLK_SL     0x00000001                       // pll3 bypass clock
#if !defined iMX_RT1011
    #define CCM_CACRR                       *(unsigned long *)(CCM_BLOCK + 0x0010) // CCM arm clock root register
        #define CCM_CACRR_ARM_PODF_DIV1     0x00000000                   // divider for ARM clock root - divide by 1
        #define CCM_CACRR_ARM_PODF_DIV2     0x00000001                   // divider for ARM clock root - divide by 2
        #define CCM_CACRR_ARM_PODF_DIV3     0x00000002                   // divider for ARM clock root - divide by 3
        #define CCM_CACRR_ARM_PODF_DIV4     0x00000003                   // divider for ARM clock root - divide by 4
        #define CCM_CACRR_ARM_PODF_DIV5     0x00000004                   // divider for ARM clock root - divide by 5
        #define CCM_CACRR_ARM_PODF_DIV6     0x00000005                   // divider for ARM clock root - divide by 6
        #define CCM_CACRR_ARM_PODF_DIV7     0x00000006                   // divider for ARM clock root - divide by 7
        #define CCM_CACRR_ARM_PODF_DIV8     0x00000007                   // divider for ARM clock root - divide by 8
#endif
#define CCM_CBCDR_ADD                   (volatile unsigned long *)(CCM_BLOCK + 0x0014)
#define CCM_CBCDR                       *(volatile unsigned long *)(CCM_BLOCK + 0x0014) // CCM bus clock divider register
    #if !defined iMX_RT1011
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV1 0x00000000               // divider for periph_clk2_podf - divide by 1
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV2 0x08000000               // divider for periph_clk2_podf - divide by 2
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV3 0x10000000               // divider for periph_clk2_podf - divide by 3
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV4 0x18000000               // divider for periph_clk2_podf - divide by 4
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV5 0x20000000               // divider for periph_clk2_podf - divide by 5
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV6 0x28000000               // divider for periph_clk2_podf - divide by 6
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV7 0x30000000               // divider for periph_clk2_podf - divide by 7
        #define CCM_CBCDR_PERIPH_CLK2_PODF_DIV8 0x38000000               // divider for periph_clk2_podf - divide by 8
        #define CCM_CBCDR_PERIPH_CLK2_PODF_MASK 0x38000000
    #endif
    #define CCM_CBCDR_PERIPH_CLK2_SEL_PRE_PERIPH_CLK  0x00000000         // derive peripheral main clock from pre_periph_clk_sel
    #define CCM_CBCDR_PERIPH_CLK2_SEL_PERIPH_CLK2_CLK 0x02000000         // derive peripheral main clock from periph_clk2_clk_divided rather than from pre_periph_clk_sel
    #if !defined iMX_RT1011
        #define CCM_CBCDR_SEMC_PODF_DIV1    0x00000000                   // post divider for SEMC clock - divide by 1
        #define CCM_CBCDR_SEMC_PODF_DIV2    0x00010000                   // post divider for SEMC clock - divide by 2
        #define CCM_CBCDR_SEMC_PODF_DIV3    0x00020000                   // post divider for SEMC clock - divide by 3
        #define CCM_CBCDR_SEMC_PODF_DIV4    0x00030000                   // post divider for SEMC clock - divide by 4
        #define CCM_CBCDR_SEMC_PODF_DIV5    0x00040000                   // post divider for SEMC clock - divide by 5
        #define CCM_CBCDR_SEMC_PODF_DIV6    0x00050000                   // post divider for SEMC clock - divide by 6
        #define CCM_CBCDR_SEMC_PODF_DIV7    0x00060000                   // post divider for SEMC clock - divide by 7
        #define CCM_CBCDR_SEMC_PODF_DIV8    0x00070000                   // post divider for SEMC clock - divide by 8
    #endif
    #define CCM_CBCDR_AHB_PODF_DIV1     0x00000000                       // divider for AHB PODF - divide by 1
    #define CCM_CBCDR_AHB_PODF_DIV2     0x00000400                       // divider for AHB PODF - divide by 2
    #define CCM_CBCDR_AHB_PODF_DIV3     0x00000800                       // divider for AHB PODF - divide by 3
    #define CCM_CBCDR_AHB_PODF_DIV4     0x00000c00                       // divider for AHB PODF - divide by 4
    #define CCM_CBCDR_AHB_PODF_DIV5     0x00001000                       // divider for AHB PODF - divide by 5
    #define CCM_CBCDR_AHB_PODF_DIV6     0x00001400                       // divider for AHB PODF - divide by 6
    #define CCM_CBCDR_AHB_PODF_DIV7     0x00001800                       // divider for AHB PODF - divide by 7
    #define CCM_CBCDR_AHB_PODF_DIV8     0x00001c00                       // divider for AHB PODF - divide by 8
    #define CCM_CBCDR_AHB_PODF_MASK     0x00001c00
    #if !defined AHB_CLK_ROOT_DIVIDE
        #define AHB_CLK_ROOT_DIVIDE 1
    #elif ((AHB_CLK_ROOT_DIVIDE == 0) || (AHB_CLK_ROOT_DIVIDE > 8))
        #error "AHB_CLK_ROOT_DIVIDE must be 1,2,3,4,5,6,7 or 8"
    #endif
    #define CCM_CBCDR_IPG_PODF_DIV1     0x00000000                       // divider for ipg podf - divide by 1
    #define CCM_CBCDR_IPG_PODF_DIV2     0x00000100                       // divider for ipg podf - divide by 2
    #define CCM_CBCDR_IPG_PODF_DIV3     0x00000200                       // divider for ipg podf - divide by 3
    #define CCM_CBCDR_IPG_PODF_DIV4     0x00000300                       // divider for ipg podf - divide by 4
    #define CCM_CBCDR_IPG_PODF_MASK     0x00000300
    #define CCM_CBCDR_SEMC_ALT_CLK_SEL_PLL2_PFD2  0x00000000             // SEMC alternative clock selected as PLL2 PFD2
    #define CCM_CBCDR_SEMC_ALT_CLK_SEL_PLL3_PFD1  0x00000080             // SEMC alternative clock selected as PLL3 PFD1
    #define CCM_CBCDR_SEMC_CLK_SEL_PERIPH_CLK     0x00000000             // Periph_clk is used as SEMC clock root
    #define CCM_CBCDR_SEMC_CLK_SEL_SEMC 0x00000040                       // SEMC alternative clock is used as SEMC clock root
#define CCM_CBCMR                       *(unsigned long *)(CCM_BLOCK + 0x0018) // CCM bus clock multiplexer register
    #define CCM_CBCMR_LPSPI_CLK_SEL_PLL3_PFD1         0x00000000         // derive LPSPI clock from pll3 pfd1 output
    #define CCM_CBCMR_LPSPI_CLK_SEL_PLL3_PFD0         0x00000010         // derive LPSPI clock from pll3 pfd0 output
    #define CCM_CBCMR_LPSPI_CLK_SEL_PLL2              0x00000020         // derive LPSPI clock from pll2 output
    #define CCM_CBCMR_LPSPI_CLK_SEL_PLL2_PFD2         0x00000030         // derive LPSPI clock from pll2 pfd2 output
    #define CCM_CBCMR_LPSPI_CLK_SEL_MASK              0x00000030
    #if FLEX_SPI_INTERFACES > 1
        #define CCM_CBCMR_FLEXSPI2_CLK_SEL_PLL2_PFD2  0x00000000
        #define CCM_CBCMR_FLEXSPI2_CLK_SEL_PLL2_PFD0  0x00000100
        #define CCM_CBCMR_FLEXSPI2_CLK_SEL_PLL3_PFD1  0x00000200
        #define CCM_CBCMR_FLEXSPI2_CLK_SEL_PLL2       0x00000300
        #define CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK       0x00000300
    #endif
    #define CCM_CBCMR_PERIPH_CLK2_SEL_PLL3_SW_CLK     0x00000000         // derive PERIPH_CLK2 from pll3_sw_clk
    #define CCM_CBCMR_PERIPH_CLK2_SEL_OSC_CLK         0x00001000         // derive PERIPH_CLK2 from osc_clk
    #define CCM_CBCMR_PERIPH_CLK2_SEL_PLL2_BYPASS_CLK 0x00002000         // derive PERIPH_CLK2 from pll2_bypass_clk
    #define CCM_CBCMR_PERIPH_CLK2_SEL_MASK            0x00003000
    #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL2         0x00000000         // PRE_PERIPH clock derived from PLL2
    #if defined ARM_PLL_AVAILABLE
        #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL2_PFD2    0x00040000     // PRE_PERIPH clock derived from PLL2 PFD2
        #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL2_PFD0    0x00080000     // PRE_PERIPH clock derived from PLL2 PFD0
        #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL1         0x000c0000     // PRE_PERIPH clock derived from divided PLL1 (ARM PLL)
    #else
        #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL3_PFD3    0x00040000     // PRE_PERIPH clock derived from PLL3 PFD3
        #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL2_PFD3    0x00080000     // PRE_PERIPH clock derived from PLL2 PFD3
        #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_PLL6         0x000c0000     // PRE_PERIPH clock derived from divided PLL6
    #endif
    #define CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK             0x000c0000
    #if FLEX_SPI_INTERFACES > 1
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV1          0x00000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV2          0x20000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV3          0x40000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV4          0x60000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV5          0x80000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV6          0xa0000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV7          0xc0000000
        #define CCM_CBCMR_FLEXSPI2_PODF_DIV8          0xe0000000
    #endif
    #if defined ENHANCED_LCD_INTERFACE
        #define CCM_CBCMR_LCDIF_PODF_DIV1             0x00000000         // post divider for LCDIF clock - divide by 1
        #define CCM_CBCMR_LCDIF_PODF_DIV2             0x00800000         // post divider for LCDIF clock - divide by 2
        #define CCM_CBCMR_LCDIF_PODF_DIV3             0x01000000         // post divider for LCDIF clock - divide by 3
        #define CCM_CBCMR_LCDIF_PODF_DIV4             0x01800000         // post divider for LCDIF clock - divide by 4
        #define CCM_CBCMR_LCDIF_PODF_DIV5             0x02000000         // post divider for LCDIF clock - divide by 5
        #define CCM_CBCMR_LCDIF_PODF_DIV6             0x02800000         // post divider for LCDIF clock - divide by 6
        #define CCM_CBCMR_LCDIF_PODF_DIV7             0x03000000         // post divider for LCDIF clock - divide by 7
        #define CCM_CBCMR_LCDIF_PODF_DIV8             0x03800000         // post divider for LCDIF clock - divide by 8
        #define CCM_CBCMR_LCDIF_PODF_MASK             0x03800000
    #endif
    #define CCM_CBCMR_LPSPI_PODF_DIV1                 0x00000000         // divider for lpspi podf - divide by 1
    #define CCM_CBCMR_LPSPI_PODF_DIV2                 0x04000000         // divider for lpspi podf - divide by 2
    #define CCM_CBCMR_LPSPI_PODF_DIV3                 0x08000000         // divider for lpspi podf - divide by 3
    #define CCM_CBCMR_LPSPI_PODF_DIV4                 0x0c000000         // divider for lpspi podf - divide by 4
    #define CCM_CBCMR_LPSPI_PODF_DIV5                 0x10000000         // divider for lpspi podf - divide by 5
    #define CCM_CBCMR_LPSPI_PODF_DIV6                 0x14000000         // divider for lpspi podf - divide by 6
    #define CCM_CBCMR_LPSPI_PODF_DIV7                 0x18000000         // divider for lpspi podf - divide by 7
    #define CCM_CBCMR_LPSPI_PODF_DIV8                 0x1c000000         // divider for lpspi podf - divide by 8
    #define CCM_CBCMR_LPSPI_PODF_MASK                 0x1c000000

    #if !defined LPSPI_CLK_ROOT_DIVIDE
        #define LPSPI_CLK_ROOT_DIVIDE 1
    #elif ((LPSPI_CLK_ROOT_DIVIDE > 8) || (LPSPI_CLK_ROOT_DIVIDE == 0))
        #error "LPSPI CLK must have a division value between 1 and 8"
    #endif
    #if defined LPSPI_CLK_FROM_PLL3_PDF0
        #define LPSPI_CLK_ROOT_FREQUENCY (((((iMX_PLL3 / 10) * 18) / PLL3_PFD0_FRACTION) * 10) / LPSPI_CLK_ROOT_DIVIDE)
    #elif defined LPSPI_CLK_FROM_PLL3_PDF1
        #define LPSPI_CLK_ROOT_FREQUENCY (((((iMX_PLL3 / 10) * 18) / PLL3_PFD1_FRACTION) * 10) / LPSPI_CLK_ROOT_DIVIDE)
    #elif defined LPSPI_CLK_FROM_PLL2_PDF2
        #define LPSPI_CLK_ROOT_FREQUENCY (((((iMX_PLL2 / 10) * 18) / PLL2_PFD2_FRACTION) * 10) / LPSPI_CLK_ROOT_DIVIDE)
    #else                                                                // LPSPI_CLK_FROM_PLL2
        #define LPSPI_CLK_ROOT_FREQUENCY (iMX_PLL2/LPSPI_CLK_ROOT_DIVIDE)
    #endif
    #if LPSPI_CLK_ROOT_FREQUENCY > LPSPI_CLK_ROOT_MAX
        #error "LPSPI_CLK_ROOT_FREQUENCY is too high - increase LPSPI_CLK_ROOT_DIVIDE accordingly!!"
    #endif
#define CCM_CSCMR1                      *(volatile unsigned long *)(CCM_BLOCK + 0x001c) // CCM serial clock multiplexer register 1
    #define CCM_CSCMR1_PERCLK_PODF_MASK               0x0000003f         // PERCLK divider mask (1..64)
    #define CCM_CSCMR1_PERCLK_SEL_IPG_CLK_ROOT        0x00000000         // derive PERCLK from IPG_CLK root
    #define CCM_CSCMR1_PERCLK_SEL_OSC_CLK             0x00000040         // derive PERCLK from OSC_CLK instead of from IPG_CLK root
    #define CCM_CSCMR1_USDHC1_CLK_SEL_PLL2_PFD2       0x00000000         // derive usdhc1 clock from PLL2 PFD2
    #define CCM_CSCMR1_USDHC1_CLK_SEL_PLL2_PFD0       0x00010000         // derive usdhc1 clock from PLL2 PFD0
    #define CCM_CSCMR1_USDHC2_CLK_SEL_PLL2_PFD2       0x00000000         // derive usdhc2 clock from PLL2 PFD2
    #define CCM_CSCMR1_USDHC2_CLK_SEL_PLL2_PFD0       0x00020000         // derive usdhc2 clock from PLL2 PFD0
    #define CCM_CSCMR1_FLEXSPI_PODF_1                 0x00000000         // FLEXSPI clock divide by 1
    #define CCM_CSCMR1_FLEXSPI_PODF_2                 0x00800000         // FLEXSPI clock divide by 2
    #define CCM_CSCMR1_FLEXSPI_PODF_3                 0x01000000         // FLEXSPI clock divide by 3
    #define CCM_CSCMR1_FLEXSPI_PODF_4                 0x01800000         // FLEXSPI clock divide by 4
    #define CCM_CSCMR1_FLEXSPI_PODF_5                 0x02000000         // FLEXSPI clock divide by 5
    #define CCM_CSCMR1_FLEXSPI_PODF_6                 0x02800000         // FLEXSPI clock divide by 6
    #define CCM_CSCMR1_FLEXSPI_PODF_7                 0x03000000         // FLEXSPI clock divide by 7
    #define CCM_CSCMR1_FLEXSPI_PODF_8                 0x03800000         // FLEXSPI clock divide by 8
    #define CCM_CSCMR1_FLEXSPI_PODF_MASK              0x03800000         // FLEXSPI clock divider mask
    #if !defined FLEXSPI_CLK_ROOT_DIVIDE
        #define FLEXSPI_CLK_ROOT_DIVIDE 1
    #elif ((FLEXSPI_CLK_ROOT_DIVIDE > 8) || (FLEXSPI_CLK_ROOT_DIVIDE == 0))
        #error "FLEXSPI CLK must have a division value between 1 and 8"
    #endif
    #if defined FLEXSPI_CLK_FROM_PLL3_PFD0
        #define FLEXSPI_CLK_ROOT_FREQUENCY (((((iMX_PLL3 / 10) * 18) / PLL3_PFD0_FRACTION) * 10) / FLEXSPI_CLK_ROOT_DIVIDE)
    #elif defined FLEXSPI_CLK_FROM_PLL2_PFD2
        #define FLEXSPI_CLK_ROOT_FREQUENCY (((((iMX_PLL2 / 10) * 18) / PLL2_PFD2_FRACTION) * 10) / FLEXSPI_CLK_ROOT_DIVIDE)
    #elif defined FLEXSPI_CLK_FROM_PLL3_SW_CLK
        #define FLEXSPI_CLK_ROOT_FREQUENCY (iMX_PLL3/FLEXSPI_CLK_ROOT_DIVIDE)
    #elif defined iMX_RT1011                                             // FLEXSPI_CLK_FROM_PLL2
        #define FLEXSPI_CLK_ROOT_FREQUENCY (iMX_PLL2/FLEXSPI_CLK_ROOT_DIVIDE)
    #else                                                                // FLEXSPI_CLK_FROM_SEMC_CLK
        #define FLEXSPI_CLK_ROOT_FREQUENCY (SEMC_CLK_ROOT_FREQUENCY/FLEXSPI_CLK_ROOT_DIVIDE)
    #endif
    #if FLEXSPI_CLK_ROOT_FREQUENCY > FLEXSPI_CLK_ROOT_MAX
        #error "FLEXSPI_CLK_ROOT is too high - increase FLEXSPI_CLK_ROOT_DIVIDE accordingly!!"
    #endif
    #if defined iMX_RT1011
        #define CCM_CSCMR1_FLEXSPI_CLK_SEL_PLL2     0x00000000           // FLEXSPI clock route is sourced from PLL2 (528MHz)
    #else
        #define CCM_CSCMR1_FLEXSPI_CLK_SEL_SEMC     0x00000000           // FLEXSPI clock route is sourced from SEMC_CLK_ROOT
    #endif
    #define CCM_CSCMR1_FLEXSPI_CLK_SEL_PLL3_SW_CLK  0x20000000           // FLEXSPI clock route is sourced from pll3_sw_clk
    #define CCM_CSCMR1_FLEXSPI_CLK_SEL_PLL2_PFD2    0x40000000           // FLEXSPI clock route is sourced from PLL2-PDF2
    #define CCM_CSCMR1_FLEXSPI_CLK_SEL_PLL3_PFD0    0x60000000           // FLEXSPI clock route is sourced from PLL3-PDF0
    #if defined iMX_RT101X
        #define CCM_CSCMR1_FLEXSPI_CLK_SRC_FLEXSPI_CLK_SEL  0x00000000   // FLEXSPI clock route source selected in this register by FLEXSPI_CLK_SEL field
        #define CCM_CSCMR1_FLEXSPI_CLK_SRC_PERIPH_CLK2_SEL  0x80000000   // FLEXSPI clock route source selected in CCM_CBCMR by PERIPH_CLK2_SEL field
    #endif
    #define PIT_CLOCK                    PERCLK_CLK_ROOT_FREQUENCY
    #define BUS_CLOCK PIT_CLOCK // temp
#define CCM_CSCMR2                      *(unsigned long *)(CCM_BLOCK + 0x0020) // CCM serial clock multiplexer register 2
    #define CCM_CSCMR2_CAN_CLK_PODF                 0x000000fc
    #define CCM_CSCMR2_CAN_CLK_SEL_PLL3_SW_CLK_8    0x00000000           // derive CAN clock from pll3_sw_clk/8 (60MHz)
    #define CCM_CSCMR2_CAN_CLK_SEL_OSC_CLK          0x00000100           // derive CAN clock from OSC_CLK (24MHz)
    #define CCM_CSCMR2_CAN_CLK_SEL_PLL3_SW_CLK_6    0x00000200           // derive CAN clock from pll3_sw_clk/6 (80MHz)
    #define CCM_CSCMR2_CAN_CLK_SEL_MASK             0x00000300
    #define CCM_CSCMR2_FLEXIO1_CLK_SEL_PLL4         0x00000000
    #define CCM_CSCMR2_FLEXIO1_CLK_SEL_PLL3_PFD2    0x00080000
    #define CCM_CSCMR2_FLEXIO1_CLK_SEL_PLL3_SW_CLK  0x00180000
    #define CCM_CSCMR2_FLEXIO1_CLK_SEL_MASK         0x00180000
#define CCM_CSCDR1                      *(unsigned long *)(CCM_BLOCK + 0x0024) // CCM serial clock divider register 1
    #define CCM_CSCDR1_TRACE_PODF_1     0x00000000                       // trace clock divide by 1
    #define CCM_CSCDR1_TRACE_PODF_2     0x02000000                       // trace clock divide by 2
    #define CCM_CSCDR1_TRACE_PODF_3     0x04000000                       // trace clock divide by 3
    #define CCM_CSCDR1_TRACE_PODF_4     0x06000000                       // trace clock divide by 4
    #define CCM_CSCDR1_USDHC2_PODF_1    0x00000000                       // usdhc2 clock divide by 1
    #define CCM_CSCDR1_USDHC2_PODF_2    0x00010000                       // usdhc2 clock divide by 2
    #define CCM_CSCDR1_USDHC2_PODF_3    0x00020000                       // usdhc2 clock divide by 3
    #define CCM_CSCDR1_USDHC2_PODF_4    0x00030000                       // usdhc2 clock divide by 4
    #define CCM_CSCDR1_USDHC2_PODF_5    0x00040000                       // usdhc2 clock divide by 5
    #define CCM_CSCDR1_USDHC2_PODF_6    0x00050000                       // usdhc2 clock divide by 6
    #define CCM_CSCDR1_USDHC2_PODF_7    0x00060000                       // usdhc2 clock divide by 7
    #define CCM_CSCDR1_USDHC2_PODF_8    0x00070000                       // usdhc2 clock divide by 8
    #define CCM_CSCDR1_USDHC1_PODF_1    0x00000000                       // usdhc1 clock divide by 1
    #define CCM_CSCDR1_USDHC1_PODF_2    0x00000800                       // usdhc1 clock divide by 2
    #define CCM_CSCDR1_USDHC1_PODF_3    0x00001000                       // usdhc1 clock divide by 3
    #define CCM_CSCDR1_USDHC1_PODF_4    0x00001800                       // usdhc1 clock divide by 4
    #define CCM_CSCDR1_USDHC1_PODF_5    0x00002000                       // usdhc1 clock divide by 5
    #define CCM_CSCDR1_USDHC1_PODF_6    0x00001800                       // usdhc1 clock divide by 6
    #define CCM_CSCDR1_USDHC1_PODF_7    0x00003000                       // usdhc1 clock divide by 7
    #define CCM_CSCDR1_USDHC1_PODF_8    0x00003800                       // usdhc1 clock divide by 8
    #define CCM_CSCDR1_UART_CLK_SEL_PLL3_80M 0x00000000                  // UART clock selected from pll3_80m
    #define CCM_CSCDR1_UART_CLK_SEL_OSC_CLK  0x00000040                  // UART clock selected from osc_clk
    #define CCM_CSCDR1_UART_CLK_PODF    0x0000003f                       // uart clock divider [1..64]
#define CCM_CS1CDR                      *(unsigned long *)(CCM_BLOCK + 0x0028) // CCM clock divider register 1
#define CCM_CS2CDR                      *(unsigned long *)(CCM_BLOCK + 0x002c) // CCM clock divider register 2
#define CCM_CDCDR                       *(unsigned long *)(CCM_BLOCK + 0x0030) // CCM D1 clock divider register
#define CCM_CSCDR2                      *(unsigned long *)(CCM_BLOCK + 0x0038) // CCM serial clock divider register 2
  #if defined ENHANCED_LCD_INTERFACE
    #define CCM_CSCDR2_LCDIF_PRED_1     0x00000000                       // pre-divider for lcdif clock 1 (should be updated only when output clock is gated)
    #define CCM_CSCDR2_LCDIF_PRED_2     0x00001000                       // pre-divider for lcdif clock 2
    #define CCM_CSCDR2_LCDIF_PRED_3     0x00002000                       // pre-divider for lcdif clock 3
    #define CCM_CSCDR2_LCDIF_PRED_4     0x00003000                       // pre-divider for lcdif clock 4
    #define CCM_CSCDR2_LCDIF_PRED_5     0x00004000                       // pre-divider for lcdif clock 5
    #define CCM_CSCDR2_LCDIF_PRED_6     0x00005000                       // pre-divider for lcdif clock 6
    #define CCM_CSCDR2_LCDIF_PRED_7     0x00006000                       // pre-divider for lcdif clock 7
    #define CCM_CSCDR2_LCDIF_PRED_8     0x00007000                       // pre-divider for lcdif clock 8
    #define CCM_CSCDR2_LCDIF_PRED_MASK  0x00007000
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_PLL2      0x00000000            // select lcdif root clock pre-multiplexer from PLL2 (system PLL)
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_PLL3_PFD3 0x00008000            // select lcdif root clock pre-multiplexer from PLL3-PFD3 (USB1 PLL)
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_PLL5      0x00010000            // select lcdif root clock pre-multiplexer from PLL5 (video PLL)
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_PLL2_PFD0 0x00018000            // select lcdif root clock pre-multiplexer from PLL2-PFD0 (system PLL)
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_PLL2_PFD1 0x00020000            // select lcdif root clock pre-multiplexer from PLL2-PFD1 (system PLL)
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_PLL3_PFD1 0x00028000            // select lcdif root clock pre-multiplexer from PLL3-PFD1 (USB1 PLL)
    #define CCM_CSCDR2_LCDIF_PRE_CLK_SEL_MASK      0x00038000
  #endif
    #define CCM_CSCDR2_LPI2C_CLK_SEL_PLL3_60M 0x00000000                 // LPI2C clock selected from pll3_60m
    #define CCM_CSCDR2_LPI2C_CLK_SEL_OSC_CLK  0x00400000                 // LPI2C clock selected from osc_clk
    #define CCM_CSCDR2_LPI2C_CLK_PODF    0x01f80000                      // LPI2C clock divider [1..64]
#define CCM_CSCDR3                      *(unsigned long *)(CCM_BLOCK + 0x003c) // CCM serial clock divider register 3
#define CCM_CDHIPR                      *(volatile unsigned long *)(CCM_BLOCK + 0x0048) // CCM divider handshake in process register (read-only)
    #define CCM_CDHIPR_SEMC_PODF_BUSY       0x00000001                   // SEMC divider is busy with handshake process with module
    #define CCM_CDHIPR_AHB_PODF_BUSY        0x00000002                   // AHB divider is busy with handshake process with module
    #define CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY 0x00000008                   // PERIPH2_CLK mux is busy with handshake process with module
    #define CCM_CDHIPR_PERIPH_CLK_SEL_BUSY  0x00000020                   // PERIPH CLK mux is busy with handshake process with module
    #define CCM_CDHIPR_ARM_PODF_BUSY        0x00010000                   // ARM divider is busy with handshake process with module
#define CCM_CLPCR                       *(unsigned long *)(CCM_BLOCK + 0x0054) // CCM low power control register
#define CCM_CISR                        *(volatile unsigned long *)(CCM_BLOCK + 0x0058) // CCM interrupt status register (write '1' to clear)
#define CCM_CIMR                        *(unsigned long *)(CCM_BLOCK + 0x005c) // CCM interrupt mask register
#define CCM_CCOSR                       *(unsigned long *)(CCM_BLOCK + 0x0060) // CCM clock output source register
    #define CCM_CCOSR_CLKO2_EN          0x01000000                       // enable CCM_CLKO2 clock
    #define CCM_CCOSR_CLKO2_DIV1        0x00000000                       // CCM_CLKO2 divide - divide by 1
    #define CCM_CCOSR_CLKO2_DIV2        0x00200000                       // CCM_CLKO2 divide - divide by 2
    #define CCM_CCOSR_CLKO2_DIV3        0x00400000                       // CCM_CLKO2 divide - divide by 3
    #define CCM_CCOSR_CLKO2_DIV4        0x00600000                       // CCM_CLKO2 divide - divide by 4
    #define CCM_CCOSR_CLKO2_DIV5        0x00800000                       // CCM_CLKO2 divide - divide by 5
    #define CCM_CCOSR_CLKO2_DIV6        0x00a00000                       // CCM_CLKO2 divide - divide by 6
    #define CCM_CCOSR_CLKO2_DIV7        0x00c00000                       // CCM_CLKO2 divide - divide by 7
    #define CCM_CCOSR_CLKO2_DIV8        0x00e00000                       // CCM_CLKO2 divide - divide by 8
    #define CCM_CCOSR_CLKO2_SEL_USDHC1_CLK_ROOT    0x00030000            // selection of clock on CCM_CLKO2 - usdhc1_clk_root
    #define CCM_CCOSR_CLKO2_SEL_LPI2C_CLK_ROOT     0x00060000            // selection of clock on CCM_CLKO2 - lpi2c_clk_root
    #define CCM_CCOSR_CLKO2_SEL_OSC_CLK_ROOT       0x000e0000            // selection of clock on CCM_CLKO2 - osc_clk
    #define CCM_CCOSR_CLKO2_SEL_LPSPI_CLK_ROOT     0x00100000            // selection of clock on CCM_CLKO2 - lpspi_clk_root
    #define CCM_CCOSR_CLKO2_SEL_USDHC2_CLK_ROOT    0x00110000            // selection of clock on CCM_CLKO2 - usdhc2_clk_root
    #define CCM_CCOSR_CLKO2_SEL_SAI1_CLK_ROOT      0x00120000            // selection of clock on CCM_CLKO2 - sai1_clk_root
    #define CCM_CCOSR_CLKO2_SEL_SAI2_CLK_ROOT      0x00130000            // selection of clock on CCM_CLKO2 - sai2_clk_root
    #define CCM_CCOSR_CLKO2_SEL_SAI3_CLK_ROOT      0x00140000            // selection of clock on CCM_CLKO2 - sai3_clk_root
    #define CCM_CCOSR_CLKO2_SEL_TRACE_CLK_ROOT     0x00160000            // selection of clock on CCM_CLKO2 - trace_clk_root
    #define CCM_CCOSR_CLKO2_SEL_CAN_CLK_ROOT       0x00170000            // selection of clock on CCM_CLKO2 - can_clk_root
    #define CCM_CCOSR_CLKO2_SEL_FLEXSPI_CLK_ROOT   0x001b0000            // selection of clock on CCM_CLKO2 - flexspi_clk_root
    #define CCM_CCOSR_CLKO2_SEL_UART_CLK_ROOT      0x001c0000            // selection of clock on CCM_CLKO2 - uart_clk_root
    #define CCM_CCOSR_CLKO2_SEL_SPDIF0_CLK_ROOT    0x001d0000            // selection of clock on CCM_CLKO2 - spdif0_clk_root
    #define CCM_CCOSR_CLKO2_SEL_MASK               0x001f0000
    #define CCM_CCOSR_CLKOUT_SEL_CLKO1  0x00000000                       // CCM_CLKO1 output drives CCM_CLKO1 clock
    #define CCM_CCOSR_CLKOUT_SEL_CLKO2  0x00000100                       // CCM_CLKO1 output drives CCM_CLKO2 clock
    #define CCM_CCOSR_CLKO1_EN          0x00000080                       // CCM_CLKO1 enable
    #define CCM_CCOSR_CLKO1_DIV1        0x00000000                       // CCM_CLKO1 divide - divide by 1
    #define CCM_CCOSR_CLKO1_DIV2        0x00000010                       // CCM_CLKO1 divide - divide by 2
    #define CCM_CCOSR_CLKO1_DIV3        0x00000020                       // CCM_CLKO1 divide - divide by 3
    #define CCM_CCOSR_CLKO1_DIV4        0x00000030                       // CCM_CLKO1 divide - divide by 4
    #define CCM_CCOSR_CLKO1_DIV5        0x00000040                       // CCM_CLKO1 divide - divide by 5
    #define CCM_CCOSR_CLKO1_DIV6        0x00000050                       // CCM_CLKO1 divide - divide by 6
    #define CCM_CCOSR_CLKO1_DIV7        0x00000060                       // CCM_CLKO1 divide - divide by 7
    #define CCM_CCOSR_CLKO1_DIV8        0x00000070                       // CCM_CLKO1 divide - divide by 8
#if defined iMX_RT105X || defined iMX_RT106X
    #define CCM_CCOSR_CLKO1_SEL_USB1_PLL_DIV2       0x00000000           // selection of clock on CCM_CLKO1 - pll3 (divided by 2)
    #define CCM_CCOSR_CLKO1_SEL_SYS_PLL_DIV2        0x00000001           // selection of clock on CCM_CLKO1 - PLL2 (divided by 2)
    #define CCM_CCOSR_CLKO1_SEL_VIDEO_PLL_DIV2      0x00000002           // selection of clock on CCM_CLKO1 - ENET PLL5 (divided by 2)
#else
    #define CCM_CCOSR_CLKO1_SEL_PLL3_SW_CLK_DIV2    0x00000000           // selection of clock on CCM_CLKO1 - pll3_sw_clk (divided by 2)
    #define CCM_CCOSR_CLKO1_SEL_PLL2_DIV2           0x00000001           // selection of clock on CCM_CLKO1 - PLL2 (divided by 2)
    #define CCM_CCOSR_CLKO1_SEL_ENET_PLL_DIV2       0x00000002           // selection of clock on CCM_CLKO1 - ENET PLL6 (divided by 2)
#endif
#if defined SEMC_CLK_AVAILABLE && !defined iMX_RT1015
    #define CCM_CCOSR_CLKO1_SEL_SEMC_CLK_ROOT       0x00000005           // selection of clock on CCM_CLKO1 - semc_clk_root
#endif
#if defined iMX_RT1052 || defined iMX_RT1062 || defined iMX_RT1064
    #define CCM_CCOSR_CLKO1_SEL_LCDIF_PIX_CLK_ROOT  0x0000000a           // selection of clock on CCM_CLKO1 - lcdif_pix_clk_root
#endif
    #define CCM_CCOSR_CLKO1_SEL_AHB_CLK_ROOT        0x0000000b           // selection of clock on CCM_CLKO1 - ahb_clk_root
    #define CCM_CCOSR_CLKO1_SEL_IPG_CLK_ROOT        0x0000000c           // selection of clock on CCM_CLKO1 - ipg_clk_root
    #define CCM_CCOSR_CLKO1_SEL_PERCLK_ROOT         0x0000000d           // selection of clock on CCM_CLKO1 - perclk_root
#if defined iMX_RT105X || defined iMX_RT106X
    #define CCM_CCOSR_CLKO1_SEL_CKIL_SYNC_CLK_ROOT  0x0000000e           // selection of clock on CCM_CLKO1 - ckil_sync_clk_root
#endif
    #define CCM_CCOSR_CLKO1_SEL_PLL4_MAIN_CLK       0x0000000f           // selection of clock on CCM_CLKO1 - pll4_main_clk
    #define fnSetClock1Output(CLK, div) _fnSetClock1Output(CCM_CCOSR_CLKO1_SEL_##CLK, div) // macros for configuring outputs
    #define fnSetClock2Output(CLK, div) _fnSetClock2Output(CCM_CCOSR_CLKO2_SEL_##CLK, div)
#define CCM_CGPR                        *(unsigned long *)(CCM_BLOCK + 0x0064) // CCM general purpose register
    #define CCM_CGPR_PMIC_DELAY_SCALER           0x00000001              // stby_count (pmic delay counter) divided by 8
    #define CCM_CGPR_FIXED_1                     0x00003e62              // keep '1' for correct operation
    #define CCM_CGPR_EFUSE_PROG_SUPPLY_GATE      0x00000010              // allow fuse programming
    #define CCM_CGPR_SYS_MEM_DS_CTRL_DISABLE                     0x00000000
    #define CCM_CGPR_SYS_MEM_DS_CTRL_ENABLE_IN_STOP_WITHOUT_PLL  0x00004000
    #define CCM_CGPR_SYS_MEM_DS_CTRL_ENABLE_IN_STOP              0x0000c000
    #define CCM_CGPR_FPL                         0x00010000              // fast PLL enable (used only if 24MHz OSC was active in low power mode)
    #define CCM_CGPR_INT_MEM_CLK_LPM             0x00020000              // keep clocks enabled to the ARM platform memories only if an interrupt is pending when opening low power modes
#define CCM_CCGR0_ADD                   (unsigned long *)(CCM_BLOCK + 0x0068)
#define CCM_CCGR0                       *(volatile unsigned long *)(CCM_BLOCK + 0x0068) // CCM clock gating register 0
    #define CCM_CCGR0_GPIO2_CLOCK_MASK           0xc0000000
    #define CCM_CCGR0_GPIO2_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_GPIO2_CLOCK_RUN            0x40000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_GPIO2_CLOCK_STOP           0xc0000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_LPUART2_CLOCK_MASK         0x30000000
    #define CCM_CCGR0_LPUART2_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_LPUART2_CLOCK_RUN          0x10000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_LPUART2_CLOCK_STOP         0x30000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_GPT2_SERIAL_CLOCK_MASK     0x0c000000
    #define CCM_CCGR0_GPT2_SERIAL_CLOCK_OFF      0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_GPT2_SERIAL_CLOCK_RUN      0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_GPT2_SERIAL_CLOCK_STOP     0x0c000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_GPT2_BUS_CLOCK_MASK        0x03000000
    #define CCM_CCGR0_GPT2_BUS_CLOCK_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_GPT2_BUS_CLOCK_RUN         0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_GPT2_BUS_CLOCK_STOP        0x03000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_TRACE_CLOCK_MASK           0x00c00000
    #define CCM_CCGR0_TRACE_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_TRACE_CLOCK_RUN            0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_TRACE_CLOCK_STOP           0x00c00000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_CAN2_SERIAL_CLOCK_MASK     0x00300000
    #define CCM_CCGR0_CAN2_SERIAL_CLOCK_OFF      0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_CAN2_SERIAL_CLOCK_RUN      0x00100000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_CAN2_SERIAL_CLOCK_STOP     0x00300000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_CAN2_CLOCK_MASK            0x000c0000
    #define CCM_CCGR0_CAN2_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_CAN2_CLOCK_RUN             0x00040000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_CAN2_CLOCK_STOP            0x000c0000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_CAN1_SERIAL_CLOCK_MASK     0x00030000
    #define CCM_CCGR0_CAN1_SERIAL_CLOCK_OFF      0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_CAN1_SERIAL_CLOCK_RUN      0x00010000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_CAN1_SERIAL_CLOCK_STOP     0x00030000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_CAN1_CLOCK_MASK            0x0000c000
    #define CCM_CCGR0_CAN1_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_CAN1_CLOCK_RUN             0x00004000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_CAN1_CLOCK_STOP            0x0000c000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_LPUART3_CLOCK_MASK         0x00003000
    #define CCM_CCGR0_LPUART3_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_LPUART3_CLOCK_RUN          0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_LPUART3_CLOCK_STOP         0x00003000              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_DCP_CLOCK_MASK             0x00000c00
    #define CCM_CCGR0_DCP_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_DCP_CLOCK_RUN              0x00000400              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_DCP_CLOCK_STOP             0x00000c00              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_SIM_M_CLK_R_CLK_MASK       0x00000300
    #define CCM_CCGR0_SIM_M_CLK_R_CLK_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_SIM_M_CLK_R_CLK_RUN        0x00000100              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_SIM_M_CLK_R_CLK_STOP       0x00000300              // clock is on during all modes except STOP mode
  #if !defined iMX_RT106X
    #define CCM_CCGR0_FLEXSPI_EXSC_CLOCK_MASK    0x000000c0
    #define CCM_CCGR0_FLEXSPI_EXSC_CLOCK_OFF     0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_FLEXSPI_EXSC_CLOCK_RUN     0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_FLEXSPI_EXSC_CLOCK_STOP    0x000000c0              // clock is on during all modes except STOP mode
  #endif
    #define CCM_CCGR0_MQS_CLOCK_MASK             0x00000030
    #define CCM_CCGR0_MQS_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_MQS_CLOCK_RUN              0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_MQS_CLOCK_STOP             0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_AIPS_TZ2_CLOCK2_MASK       0x0000000c
    #define CCM_CCGR0_AIPS_TZ2_CLOCK2_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_AIPS_TZ2_CLOCK2_RUN        0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_AIPS_TZ2_CLOCK2_STOP       0x0000000c              // clock is on during all modes except STOP mode
    #define CCM_CCGR0_AIPS_TZ1_CLOCK2_MASK       0x00000003
    #define CCM_CCGR0_AIPS_TZ1_CLOCK2_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR0_AIPS_TZ1_CLOCK2_RUN        0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR0_AIPS_TZ1_CLOCK2_STOP       0x00000003              // clock is on during all modes except STOP mode
#define CCM_CCGR1_ADD                   (unsigned long *)(CCM_BLOCK + 0x006c)
#define CCM_CCGR1                       *(volatile unsigned long *)(CCM_BLOCK + 0x006c) // CCM clock gating register 1
    #define CCM_CCGR1_CSU_CLOCK_MASK             0x30000000
    #define CCM_CCGR1_CSU_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_CSU_CLOCK_RUN              0x10000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_CSU_CLOCK_STOP             0x30000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_GPIO1_CLOCK_MASK           0x0c000000
    #define CCM_CCGR1_GPIO1_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_GPIO1_CLOCK_RUN            0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_GPIO1_CLOCK_STOP           0x0c000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_LPUART4_CLOCK_MASK         0x03000000
    #define CCM_CCGR1_LPUART4_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_LPUART4_CLOCK_RUN          0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_LPUART4_CLOCK_STOP         0x03000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_GPT1_SERIAL_CLOCK_MASK     0x00c00000
    #define CCM_CCGR1_GPT1_SERIAL_CLOCK_OFF      0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_GPT1_SERIAL_CLOCK_RUN      0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_GPT1_SERIAL_CLOCK_STOP     0x00c00000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_GPT1_BUS_CLOCK_MASK        0x00300000
    #define CCM_CCGR1_GPT1_BUS_CLOCK_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_GPT1_BUS_CLOCK_RUN         0x00100000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_GPT1_BUS_CLOCK_STOP        0x00300000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_SEMC_EXSC_CLOCK_MASK       0x000c0000
    #define CCM_CCGR1_SEMC_EXSC_CLOCK_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_SEMC_EXSC_CLOCK_RUN        0x00040000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_SEMC_EXSC_CLOCK_STOP       0x000c0000              // clock is on during all modes except STOP mode
  #if defined iMX_RT105X || defined iMX_RT106X
    #define CCM_CCGR1_ADC1_CLOCK_MASK            0x00030000
    #define CCM_CCGR1_ADC1_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_ADC1_CLOCK_RUN             0x00010000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_ADC1_CLOCK_STOP            0x00030000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_AOI2_CLOCKS_MASK           0x0000c000
    #define CCM_CCGR1_AOI2_CLOCKS_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_AOI2_CLOCKS_RUN            0x00004000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_AIO2_CLOCK_STOP            0x0000c000              // clock is on during all modes except STOP mode
  #else
    #define CCM_CCGR1_ADC1_CLOCK_MASK            0x0000c000
    #define CCM_CCGR1_ADC1_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_ADC1_CLOCK_RUN             0x00004000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_ADC1_CLOCK_STOP            0x0000c000              // clock is on during all modes except STOP mode
  #endif
    #define CCM_CCGR1_PIT_CLOCKS_MASK            0x00003000
    #define CCM_CCGR1_PIT_CLOCKS_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_PIT_CLOCKS_RUN             0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_PIT_CLOCKS_STOP            0x00003000              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_ENET_CLOCK_MASK            0x00000c00
    #define CCM_CCGR1_ENET_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_ENET_CLOCK_RUN             0x00000400              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_ENET_CLOCK_STOP            0x00000c00              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_ADC2_CLOCK_MASK            0x00000300
    #define CCM_CCGR1_ADC2_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_ADC2_CLOCK_RUN             0x00000100              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_ADC2_CLOCK_STOP            0x00000300              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_LPSPI4_CLOCKS_MASK         0x000000c0
    #define CCM_CCGR1_LPSPI4_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_LPSPI4_CLOCKS_RUN          0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_LPSPI4_CLOCKS_STOP         0x000000c0              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_LPSPI3_CLOCKS_MASK         0x00000030
    #define CCM_CCGR1_LPSPI3_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_LPSPI3_CLOCKS_RUN          0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_LPSPI3_CLOCKS_STOP         0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_LPSPI2_CLOCKS_MASK         0x0000000c
    #define CCM_CCGR1_LPSPI2_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_LPSPI2_CLOCKS_RUN          0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_LPSPI2_CLOCKS_STOP         0x0000000c              // clock is on during all modes except STOP mode
    #define CCM_CCGR1_LPSPI1_CLOCKS_MASK         0x00000003
    #define CCM_CCGR1_LPSPI1_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR1_LPSPI1_CLOCKS_RUN          0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR1_LPSPI1_CLOCKS_STOP         0x00000003              // clock is on during all modes except STOP mode
#define CCM_CCGR2_ADD                   (unsigned long *)(CCM_BLOCK + 0x0070)
#define CCM_CCGR2                       *(volatile unsigned long *)(CCM_BLOCK + 0x0070) // CCM clock gating register 2
  #if defined iMX_RT105X || defined iMX_RT106X
    #define CCM_CCGR2_PXP_CLOCKS_MASK            0xc0000000
    #define CCM_CCGR2_PXP_CLOCKS_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_PXP_CLOCKS_RUN             0x40000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_PXP_CLOCKS_STOP            0xc0000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_LCD_CLOCKS_MASK            0x30000000
    #define CCM_CCGR2_LCD_CLOCKS_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_LCD_CLOCKS_RUN             0x10000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_LCD_CLOCKS_STOP            0x30000000              // clock is on during all modes except STOP mode
  #endif
  #if defined PORT3
    #define CCM_CCGR2_GPIO3_CLOCK_MASK           0x0c000000
    #define CCM_CCGR2_GPIO3_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_GPIO3_CLOCK_RUN            0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_GPIO3_CLOCK_STOP           0x0c000000              // clock is on during all modes except STOP mode
#endif
    #define CCM_CCGR2_XBAR2_CLOCK_MASK           0x03000000
    #define CCM_CCGR2_XBAR2_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_XBAR2_CLOCK_RUN            0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_XBAR2_CLOCK_STOP           0x03000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_XBAR1_CLOCK_MASK           0x00c00000
    #define CCM_CCGR2_XBAR1_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_XBAR1_CLOCK_RUN            0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_XBAR1_CLOCK_STOP           0x00c00000              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_OCOTP_CTRL_CLOCK_MASK      0x00003000
    #define CCM_CCGR2_OCOTP_CTRL_CLOCK_OFF       0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_OCOTP_CTRL_CLOCK_RUN       0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_OCOTP_CTRL_CLOCK_STOP      0x00003000              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_LPI2C3_CLOCK_MASK          0x00000c00
    #define CCM_CCGR2_LPI2C3_CLOCK_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_LPI2C3_CLOCK_RUN           0x00000400              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_LPI2C3_CLOCK_STOP          0x00000c00              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_LPI2C2_CLOCK_MASK          0x00000300
    #define CCM_CCGR2_LPI2C2_CLOCK_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_LPI2C2_CLOCK_RUN           0x00000100              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_LPI2C2_CLOCK_STOP          0x00000300              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_LPI2C1_CLOCK_MASK          0x000000c0
    #define CCM_CCGR2_LPI2C1_CLOCK_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_LPI2C1_CLOCK_RUN           0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_LPI2C1_CLOCK_STOP          0x000000c0              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_IMUX_SNVS_CLOCK_MASK       0x00000030
    #define CCM_CCGR2_IMUX_SNVS_CLOCK_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_IMUX_SNVS_CLOCK_RUN        0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_IMUX_SNVS_CLOCK_STOP       0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR2_OCRAM_EXSC_CLOCK_MASK      0x00000003
    #define CCM_CCGR2_OCRAM_EXSC_CLOCK_OFF       0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR2_OCRAM_EXSC_CLOCK_RUN       0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR2_OCRAM_EXSC_CLOCK_STOP      0x00000003              // clock is on during all modes except STOP mode
#define CCM_CCGR3_ADD                   (unsigned long *)(CCM_BLOCK + 0x0074)
#define CCM_CCGR3                       *(volatile unsigned long *)(CCM_BLOCK + 0x0074) // CCM clock gating register 3
    #define CCM_CCGR3_IMUX_SNVS_GRP_CLOCK_MASK   0xc0000000
    #define CCM_CCGR3_IMUX_SNVS_GRP_CLOCK_OFF    0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_IMUX_SNVS_GRP_CLOCK_RUN    0x40000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_IMUX_SNVS_GRP_CLOCK_STOP   0xc0000000              // clock is on during all modes except STOP mode
    // Note that the OCRAM clock cannot be turned off when the CM cache is running on this device
    //
    #define CCM_CCGR3_OCRAM_CLOCK_MASK           0x30000000
    #define CCM_CCGR3_OCRAM_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_OCRAM_CLOCK_RUN            0x10000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_OCRAM_CLOCK_STOP           0x30000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_ACMP4_CLOCKS_MASK          0x0c000000
    #define CCM_CCGR3_ACMP4_CLOCKS_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_ACMP4_CLOCKS_RUN           0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_ACMP4_CLOCKS_STOP          0x0c000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_ACMP3_CLOCKS_MASK          0x03000000
    #define CCM_CCGR3_ACMP3_CLOCKS_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_ACMP3_CLOCKS_RUN           0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_ACMP3_CLOCKS_STOP          0x03000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_ACMP2_CLOCKS_MASK          0x00c00000
    #define CCM_CCGR3_ACMP2_CLOCKS_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_ACMP2_CLOCKS_RUN           0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_ACMP2_CLOCKS_STOP          0x00c00000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_ACMP1_CLOCKS_MASK          0x00300000
    #define CCM_CCGR3_ACMP1_CLOCKS_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_ACMP1_CLOCKS_RUN           0x00100000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_ACMP1_CLOCKS_STOP          0x00300000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_FLEXRAM1_CLOCK_MASK        0x000c0000
    #define CCM_CCGR3_FLEXRAM1_CLOCK_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_FLEXRAM1_CLOCK_RUN         0x00040000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_FLEXRAM1_CLOCK_STOP        0x000c0000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_WDOG1_CLOCK_MASK           0x00030000
    #define CCM_CCGR3_WDOG1_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_WDOG1_CLOCK_RUN            0x00010000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_WDOG1_CLOCK_STOP           0x00030000              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_EWM_CLOCK_MASK             0x0000c000
    #define CCM_CCGR3_EWM_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_EWM_CLOCK_RUN              0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_EWM_CLOCK_STOP             0x0000c000              // clock is on during all modes except STOP mode
  #if defined iMX_RT105X || defined iMX_RT106X
    #define CCM_CCGR3_GPIO4_CLOCK_MASK           0x00003000
    #define CCM_CCGR3_GPIO4_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_GPIO4_CLOCK_RUN            0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_GPIO4_CLOCK_STOP           0x00003000              // clock is on during all modes except STOP mode
  #endif
  #if defined ENHANCED_LCD_INTERFACE
    #define CCM_CCGR3_LCDIF_PIX_CLOCK_MASK       0x00000c00
    #define CCM_CCGR3_LCDIF_PIX_CLOCK_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_LCDIF_PIX_CLOCK_RUN        0x00000400              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_LCDIF_PIX_CLOCK_STOP       0x00000c00              // clock is on during all modes except STOP mode
  #endif
    #define CCM_CCGR3_AOI1_CLOCK_MASK            0x00000300
    #define CCM_CCGR3_AOI1_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_AOI1_CLOCK_RUN             0x00000100              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_AOI1_CLOCK_STOP            0x00000300              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_LPUART6_CLOCK_MASK         0x000000c0
    #define CCM_CCGR3_LPUART6_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_LPUART6_CLOCK_RUN          0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_LPUART6_CLOCK_STOP         0x000000c0              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_SEMC_CLOCKS_MASK           0x00000030
    #define CCM_CCGR3_SEMC_CLOCKS_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_SEMC_CLOCKS_RUN            0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_SEMC_CLOCKS_STOP           0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR3_LPUART5_CLOCK_MASK         0x0000000c
    #define CCM_CCGR3_LPUART5_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_LPUART5_CLOCK_RUN          0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_LPUART5_CLOCK_STOP         0x0000000c              // clock is on during all modes except STOP mode
  #if defined iMX_RT105X || defined iMX_RT106X
    #define CCM_CCGR3_FLEXIO2_CLOCKS_MASK        0x00000003
    #define CCM_CCGR3_FLEXIO2_CLOCKS_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR3_FLEXIO2_CLOCKS_RUN         0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR3_FLEXIO2_CLOCKS_STOP        0x00000003              // clock is on during all modes except STOP mode
  #endif
#define CCM_CCGR4_ADD                   (unsigned long *)(CCM_BLOCK + 0x0078)
#define CCM_CCGR4                       *(volatile unsigned long *)(CCM_BLOCK + 0x0078) // CCM clock gating register 4
    #define CCM_CCGR4_ENC2_CLOCKS_MASK           0x0c000000
    #define CCM_CCGR4_ENC2_CLOCKS_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_ENC2_CLOCKS_RUN            0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_ENC2_CLOCKS_STOP           0x0c000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_ENC1_CLOCKS_MASK           0x03000000
    #define CCM_CCGR4_ENC1_CLOCKS_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_ENC1_CLOCKS_RUN            0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_ENC1_CLOCKS_STOP           0x03000000              // clock is on during all modes except STOP mode
    #if FLEXPWM_AVAILABLE > 3
        #define CCM_CCGR4_PWM4_CLOCKS_MASK       0x00c00000
        #define CCM_CCGR4_PWM4_CLOCKS_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
        #define CCM_CCGR4_PWM4_CLOCKS_RUN        0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
        #define CCM_CCGR4_PWM4_CLOCKS_STOP       0x00c00000              // clock is on during all modes except STOP mode
    #endif
    #if FLEXPWM_AVAILABLE > 2
        #define CCM_CCGR4_PWM3_CLOCKS_MASK       0x00300000
        #define CCM_CCGR4_PWM3_CLOCKS_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
        #define CCM_CCGR4_PWM3_CLOCKS_RUN        0x00200000              // clock is on in RUN mode but off in WAIT and STOP modes
        #define CCM_CCGR4_PWM3_CLOCKS_STOP       0x00300000              // clock is on during all modes except STOP mode
    #endif
    #if FLEXPWM_AVAILABLE > 1
        #define CCM_CCGR4_PWM2_CLOCKS_MASK       0x000c0000
        #define CCM_CCGR4_PWM2_CLOCKS_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
        #define CCM_CCGR4_PWM2_CLOCKS_RUN        0x00040000              // clock is on in RUN mode but off in WAIT and STOP modes
        #define CCM_CCGR4_PWM2_CLOCKS_STOP       0x000c0000              // clock is on during all modes except STOP mode
    #endif
    #define CCM_CCGR4_PWM1_CLOCKS_MASK           0x00030000
    #define CCM_CCGR4_PWM1_CLOCKS_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_PWM1_CLOCKS_RUN            0x00010000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_PWM1_CLOCKS_STOP           0x00030000              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_SIM_EMS_CLOCKS_MASK        0x0000c000
    #define CCM_CCGR4_SIM_EMS_CLOCKS_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_SIM_EMS_CLOCKS_RUN         0x00004000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_SIM_EMS_CLOCKS_STOP        0x0000c000              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_SIM_M_CLOCKS_MASK          0x00003000
    #define CCM_CCGR4_SIM_M_CLOCKS_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_SIM_M_CLOCKS_RUN           0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_SIM_M_CLOCKS_STOP          0x00003000              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_SIM_M7_CLOCK_MASK          0x00000300
    #define CCM_CCGR4_SIM_M7_CLOCK_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_SIM_M7_CLOCK_RUN           0x00000100              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_SIM_M7_CLOCK_STOP          0x00000300              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_BEE_CLOCK_MASK             0x000000c0
    #define CCM_CCGR4_BEE_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_BEE_CLOCK_RUN              0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_BEE_CLOCK_STOP             0x000000c0              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_IOMUX_GRP_CLOCK_MASK       0x00000030
    #define CCM_CCGR4_IOMUX_GRP_CLOCK_OFF        0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_IOMUX_GRP_CLOCK_RUN        0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_IOMUX_GRP_CLOCK_STOP       0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_IOMUX_CLOCK_MASK           0x0000000c
    #define CCM_CCGR4_IOMUX_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_IOMUX_CLOCK_RUN            0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_IOMUX_CLOCK_STOP           0x0000000c              // clock is on during all modes except STOP mode
    #define CCM_CCGR4_SIM_M7_CLK_R_MASK          0x00000003
    #define CCM_CCGR4_SIM_M7_CLK_R_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR4_SIM_M7_CLK_R_RUN           0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR4_SIM_M7_CLK_R_STOP          0x00000003              // clock is on during all modes except STOP mode
#define CCM_CCGR5_ADD                   (unsigned long *)(CCM_BLOCK + 0x007c)
#define CCM_CCGR5                       *(volatile unsigned long *)(CCM_BLOCK + 0x007c) // CCM clock gating register 5
    #define CCM_CCGR5_SNVS_LP_CLOCK_MASK         0xc0000000
    #define CCM_CCGR5_SNVS_LP_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_SNVS_LP_CLOCK_RUN          0x40000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_SNVS_LP_CLOCK_STOP         0xc0000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_SNVS_HP_CLOCK_MASK         0x30000000
    #define CCM_CCGR5_SNVS_HP_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_SNVS_HP_CLOCK_RUN          0x10000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_SNVS_HP_CLOCK_STOP         0x30000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_LPUART7_CLOCK_MASK         0x0c000000
    #define CCM_CCGR5_LPUART7_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_LPUART7_CLOCK_RUN          0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_LPUART7_CLOCK_STOP         0x0c000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_LPUART1_CLOCK_MASK         0x03000000
    #define CCM_CCGR5_LPUART1_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_LPUART1_CLOCK_RUN          0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_LPUART1_CLOCK_STOP         0x03000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_SAI3_CLOCK_MASK            0x00c00000
    #define CCM_CCGR5_SAI3_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_SAI3_CLOCK_RUN             0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_SAI3_CLOCK_STOP            0x00c00000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_SAI2_CLOCK_MASK            0x00300000
    #define CCM_CCGR5_SAI2_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_SAI2_CLOCK_RUN             0x00100000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_SAI2_CLOCK_STOP            0x00300000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_SAI1_CLOCK_MASK            0x000c0000
    #define CCM_CCGR5_SAI1_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_SAI1_CLOCK_RUN             0x00040000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_SAI1_CLOCK_STOP            0x000c0000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_SPDIF_CLOCK_MASK           0x0000c000
    #define CCM_CCGR5_SPDIF_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_SPDIF_CLOCK_RUN            0x00004000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_SPDIF_CLOCK_STOP           0x0000c000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_AIPSTZ4_CLOCKS_MASK        0x00003000
    #define CCM_CCGR5_AIPSTZ4_CLOCKS_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_AIPSTZ4_CLOCKS_RUN         0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_AIPSTZ4_CLOCKS_STOP        0x00003000              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_WDOG2_CLOCK_MASK           0x00000c00
    #define CCM_CCGR5_WDOG2_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_WDOG2_CLOCK_RUN            0x00000400              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_WDOG2_CLOCK_STOP           0x00000c00              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_KPP_CLOCK_MASK             0x00000300
    #define CCM_CCGR5_KPP_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_KPP_CLOCK_RUN              0x00000100              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_KPP_CLOCK_STOP             0x00000300              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_DMA_CLOCK_MASK             0x000000c0
    #define CCM_CCGR5_DMA_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_DMA_CLOCK_RUN              0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_DMA_CLOCK_STOP             0x000000c0              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_WDOG3_CLOCK_MASK           0x00000030
    #define CCM_CCGR5_WDOG3_CLOCK_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_WDOG3_CLOCK_RUN            0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_WDOG3_CLOCK_STOP           0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_FLEXIO1_CLOCK_MASK         0x0000000c
    #define CCM_CCGR5_FLEXIO1_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_FLEXIO1_CLOCK_RUN          0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_FLEXIO1_CLOCK_STOP         0x0000000c              // clock is on during all modes except STOP mode
    #define CCM_CCGR5_ROM_CLOCK_MASK             0x00000003
    #define CCM_CCGR5_ROM_CLOCK_OFF              0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR5_ROM_CLOCK_RUN              0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR5_ROM_CLOCK_STOP             0x00000003              // clock is on during all modes except STOP mode
#define CCM_CCGR6_ADD                   (unsigned long *)(CCM_BLOCK + 0x0080)
#define CCM_CCGR6                       *(volatile unsigned long *)(CCM_BLOCK + 0x0080) // CCM clock gating register 6
    #define CCM_CCGR6_TIMER2_CLOCKS_MASK         0x30000000
    #define CCM_CCGR6_TIMER2_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_TIMER2_CLOCKS_RUN          0x10000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_TIMER2_CLOCKS_STOP         0x30000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_TIMER1_CLOCKS_MASK         0x0c000000
    #define CCM_CCGR6_TIMER1_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_TIMER1_CLOCKS_RUN          0x04000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_TIMER1_CLOCKS_STOP         0x0c000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_LPI2C4_SERIAL_CLOCK_MASK   0x03000000
    #define CCM_CCGR6_LPI2C4_SERIAL_CLOCK_OFF    0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_LPI2C4_SERIAL_CLOCK_RUN    0x01000000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_LPI2C4_SERIAL_CLOCK_STOP   0x03000000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_ANADIG_CLOCKS_MASK         0x00c00000
    #define CCM_CCGR6_ANADIG_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_ANADIG_CLOCKS_RUN          0x00400000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_ANADIG_CLOCKS_STOP         0x00c00000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_SIM_PER_CLOCK_MASK         0x00300000
    #define CCM_CCGR6_SIM_PER_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_SIM_PER_CLOCK_RUN          0x00100000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_SIM_PER_CLOCK_STOP         0x00300000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_AIPS_TZ3_CLOCK_MASK        0x000c0000
    #define CCM_CCGR6_AIPS_TZ3_CLOCK_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_AIPS_TZ3_CLOCK_RUN         0x00040000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_AIPS_TZ3_CLOCK_STOP        0x000c0000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_LPUART8_CLOCK_MASK         0x0000c000
    #define CCM_CCGR6_LPUART8_CLOCK_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_LPUART8_CLOCK_RUN          0x00004000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_LPUART8_CLOCK_STOP         0x0000c000              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_TRNG_CLOCK_MASK            0x00003000
    #define CCM_CCGR6_TRNG_CLOCK_OFF             0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_TRNG_CLOCK_RUN             0x00001000              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_TRNG_CLOCK_STOP            0x00003000              // clock is on during all modes except STOP mode
    // Note that SIM_EMS_CLK_ENABLE must also be cleared when flexspi_clk_enable is cleared
    //
    #define CCM_CCGR6_FLEXSPI_CLOCKS_MASK        0x00000c00
    #define CCM_CCGR6_FLEXSPI_CLOCKS_OFF         0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_FLEXSPI_CLOCKS_RUN         0x00000400              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_FLEXSPI_CLOCKS_STOP        0x00000c00              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_DCDC_CLOCKS_MASK           0x000000c0
    #define CCM_CCGR6_DCDC_CLOCKS_OFF            0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_DCDC_CLOCKS_RUN            0x00000040              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_DCDC_CLOCKS_STOP           0x000000c0              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_USDHC2_CLOCKS_MASK         0x00000030
    #define CCM_CCGR6_USDHC2_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_USDHC2_CLOCKS_RUN          0x00000010              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_USDHC2_CLOCKS_STOP         0x00000030              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_USDHC1_CLOCKS_MASK         0x0000000c
    #define CCM_CCGR6_USDHC1_CLOCKS_OFF          0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_USDHC1_CLOCKS_RUN          0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_USDHC1_CLOCKS_STOP         0x0000000c              // clock is on during all modes except STOP mode
    #define CCM_CCGR6_USBOH3_CLOCK_MASK          0x00000003
    #define CCM_CCGR6_USBOH3_CLOCK_OFF           0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
    #define CCM_CCGR6_USBOH3_CLOCK_RUN           0x00000001              // clock is on in RUN mode but off in WAIT and STOP modes
    #define CCM_CCGR6_USBOH3_CLOCK_STOP          0x00000003              // clock is on during all modes except STOP mode
    #if defined iMX_RT106X
        #define CCM_CCGR7                        *(volatile unsigned long *)(CCM_BLOCK + 0x0084) // CCM clock gating register 7
            #define CCM_CCGR7_ENET2_CLOCK_MASK   0x0000000c
            #define CCM_CCGR7_ENET2_CLOCK_OFF    0x00000000              // clock is off during all modes (stop enter hardware handshake disabled)
            #define CCM_CCGR7_ENET2_CLOCK_RUN    0x00000004              // clock is on in RUN mode but off in WAIT and STOP modes
            #define CCM_CCGR7_ENET2_CLOCK_STOP   0x0000000c              // clock is on during all modes except STOP mode
    #endif
#define CCM_CMEOR                       *(unsigned long *)(CCM_BLOCK + 0x0088) // CCM module enable overide register
    #define CCM_CMEOR_MOD_EN_OV_CAN1_CPI         0x40000000              // override clock enable signal from CAN1 (enable_clk_cpi)
    #define CCM_CMEOR_MOD_EN_OV_CAN2_CPI         0x10000000              // override clock enable signal from CAN2 (enable_clk_cpi)
    #define CCM_CMEOR_MOD_EN_OV_TRNG             0x00000200              // override clock enable signal from TRNG
    #define CCM_CMEOR_MOD_EN_USDHC               0x00000080              // override clock enable signal from USDHC
    #define CCM_CMEOR_MOD_EN_OV_PIT              0x00000040              // override clock enable signal from PIT (ipg_enable_clk)
    #define CCM_CMEOR_MOD_EN_OV_GPT              0x00000020              // override clock enable signal from GPT (ipg_enable_clk)

// SNVS
//
#define SNVS_HPLR                       *(volatile unsigned long *)(SNVS_BLOCK + 0x000) // SNVS_HP lock register (privileged write)
    #define SNVS_HPLR_GPR_SL            0x00000020                       // general purpose register soft lock (once set can only be reset by the system reset)
    #define SNVS_HPLR_MC_SL             0x00000010                       // monotonic counter soft lock (once set can only be reset by the system reset)
#define SNVS_HPCOMR                     *(volatile unsigned long *)(SNVS_BLOCK + 0x004) // SNVS_HP command register (privileged write)
    #define SNVS_HPCOMR_LP_SWR          0x00000010                       // reset registers in the SNVS_LP section (reads always as '0')
    #define SNVS_HPCOMR_LP_SWR_DIS      0x00000020                       // disable reset of SNVS_LP section (can only be cleared by a system reset)
    #define SNVS_HPCOMR_NPSWA_EN        0x80000000                       // any software can access privileged registers
#define SNVS_HPCR                       *(volatile unsigned long *)(SNVS_BLOCK + 0x008) // SNVS_HP control register
    #define SNVS_HPCR_RTC_EN            0x00000001                       // HP RTC enable (syncs with the 32kHz clock)
    #define SNVS_HPCR_HPTA_EN           0x00000002                       // HP time alarm interrupt enable
    #define SNVS_HPCR_DIS_PI            0x00000004                       // disable periodic interrupt in the function interrupt
    #define SNVS_HPCR_PI_EN             0x00000008                       // HP periodic interrupt enable
    #define SNVS_HPCR_PI_FREQ           0x000000f0                       // periodic interrupt frequency 
    #define SNVS_HPCR_HPCALB_EN         0x00000100                       // HP real time counter calibration enable
    #define SNVS_HPCR_HPCALB_VAL        0x00007c00                       // HP real time counter calibration value mask (can only be programmed when SNVS_HPCR_HPCALB_EN is 0)
    #define SNVS_HPCR_BTN_CONFIG_HIGH   0x00000000                       // button active high
    #define SNVS_HPCR_BTN_CONFIG_LOW    0x01000000                       // button active low
    #define SNVS_HPCR_BTN_CONFIG_FALL   0x02000000                       // button active on falling edge
    #define SNVS_HPCR_BTN_CONFIG_RISE   0x03000000                       // button active on rising edge
    #define SNVS_HPCR_BTN_CONFIG_BOTH   0x04000000                       // button active on both edges
    #define SNVS_HPCR_BTN_CONFIG_MASK   0x07000000
    #define SNVS_HPCR_BTN_MASK          0x08000000                       // pi_snvs_btn_int_b button interrupt enabled
#define SNVS_HPSR                       *(volatile unsigned long *)(SNVS_BLOCK + 0x014) // SNVS_HP status register
    #define SNVS_HPSR_HPTA              0x00000001                       // a time alarm interrupt occurred since this bit was last cleared (write '1' to clear)
    #define SNVS_HPSR_PI                0x00000002                       // a periodic interrupt occurred since this bit was last cleared (write '1' to clear)
    #define SNVS_HPSR_LPDIS             0x00000010                       // low power section has been disabled by means of an input signal to SNVS
    #define SNVS_HPSR_BTN               0x00000040                       // PMIC control button pressed
    #define SNVS_HPSR_BI                0x00000080                       // button interrupt was asserted (write '1' to clear)
#define SNVS_HPRTCMR                    *(volatile unsigned long *)(SNVS_BLOCK + 0x024) // SNVS_HP real time counter MSB register
#define SNVS_HPRTCLR                    *(volatile unsigned long *)(SNVS_BLOCK + 0x028) // SNVS_HP real time counter LSB register
#define SNVS_HPTAMR                     *(volatile unsigned long *)(SNVS_BLOCK + 0x02c) // SNVS_HP time alarm MSB register
#define SNVS_HPTALR                     *(volatile unsigned long *)(SNVS_BLOCK + 0x030) // SNVS_HP time alarm LSB register
#define SNVS_LPLR                       *(volatile unsigned long *)(SNVS_BLOCK + 0x034) // SNVS_LP lock register (privileged write)
    #define SNVS_LPLR_GPR_SL            0x00000020                       // general purpose register soft lock (once set can only be reset by the system reset)
    #define SNVS_LPLR_MC_SL             0x00000010                       // monotonic counter soft lock (once set can only be reset by the system reset)
#define SNVS_LPCR                       *(volatile unsigned long *)(SNVS_BLOCK + 0x038) // SNVS_LP control register (privileged write)
    #define SNVS_LPCR_MC_ENV            0x00000004                       // monotonic counter enabled and valid (once set can only be reset by the system reset)
    #define SNVS_LPCR_LPWUI_EN          0x00000008                       // low power wakeup interrupt enable
    #define SNVS_LPCR_DP_EN             0x00000020                       // dumb PMIC enabled
    #define SNVS_LPCR_TOP               0x00000040                       // turn off system power (valid only when dumb PMIC is enabled)
    #define SNVS_LPCR_PWR_GLITCH_EN     0x00000080                       // power glitch enable
    #define SNVS_LPCR_BTN_PRESS_TIME_5  0x00000000                       // PMIC press time of 5s
    #define SNVS_LPCR_BTN_PRESS_TIME_10 0x00010000                       // PMIC press time of 10s
    #define SNVS_LPCR_BTN_PRESS_TIME_15 0x00020000                       // PMIC press time of 15s
    #define SNVS_LPCR_BTN_PRESS_OFF     0x00030000                       // PMIC press time disabled
    #define SNVS_LPCR_DEBOUNCE_50ms     0x00000000                       // BTN input debounced by 50ms
    #define SNVS_LPCR_DEBOUNCE_100ms    0x00040000                       // BTN input debounced by 100ms
    #define SNVS_LPCR_DEBOUNCE_500ms    0x00080000                       // BTN input debounced by 500ms
    #define SNVS_LPCR_DEBOUNCE_OFF      0x000c0000                       // BTN input debounce disabled
    #define SNVS_LPCR_ON_TIME_500ms     0x00000000                       // 500ms off->on transition time
    #define SNVS_LPCR_ON_TIME_50ms      0x00100000                       // 50ms off->on transition time
    #define SNVS_LPCR_ON_TIME_100ms     0x00200000                       // 100ms off->on transition time
    #define SNVS_LPCR_ON_TIME_0ms       0x00300000                       // 0ms off->on transition time
    #define SNVS_LPCR_PK_EN             0x00400000                       // PMIC on request enable
    #define SNVS_LPCR_PK_OVERRIDE       0x00800000                       // PMIC on request override
    #define SNVS_LPCR_GPR_Z_DIS         0x01000000                       // disable zeroisation of GPR registers on tamper detection
#define SNVS_LPSR                       *(volatile unsigned long *)(SNVS_BLOCK + 0x04c) // SNVS_LP status register (privileged write)
    #define SNVS_LPSR_MCR               0x00000004                       // monotonic counter rollover (write '1' to clear)
    #define SNVS_LPSR_EO                0x00020000                       // emergency off was detected (write '1' to clear)
    #define SNVS_LPSR_SPO               0x00040000                       // set power off was detected (write '1' to clear)
#define SNVS_LPSMCMR                    *(volatile unsigned long *)(SNVS_BLOCK + 0x05c) // SNVS_LP secure monotonic counter MSB register (read-only) - can only be reset by LP software reset or LP POR
#define SNVS_LPSMCLR                    *(volatile unsigned long *)(SNVS_BLOCK + 0x060) // SNVS_LP secure monotonic counter LSB register (read-only) - can only be reset by LP software reset or LP POR
#define SNVS_LPGPR0_legacy_alias        *(volatile unsigned long *)(SNVS_BLOCK + 0x068) // SNVS_LP general purpose register 0 (legacy alias)
#define SNVS_LPGPR0_alias               *(volatile unsigned long *)(SNVS_BLOCK + 0x090) // SNVS_LP general purpose register 0 - alias
#define SNVS_LPGPR1_alias               *(volatile unsigned long *)(SNVS_BLOCK + 0x094) // SNVS_LP general purpose register 1 - alias
#define SNVS_LPGPR2_alias               *(volatile unsigned long *)(SNVS_BLOCK + 0x098) // SNVS_LP general purpose register 2 - alias
#define SNVS_LPGPR3_alias               *(volatile unsigned long *)(SNVS_BLOCK + 0x09c) // SNVS_LP general purpose register 3 - alias
#define SNVS_LPGPR0                     *(volatile unsigned long *)(SNVS_BLOCK + 0x100) // SNVS_LP general purpose register 0
#define SNVS_LPGPR1                     *(volatile unsigned long *)(SNVS_BLOCK + 0x104) // SNVS_LP general purpose register 1
#define SNVS_LPGPR2                     *(volatile unsigned long *)(SNVS_BLOCK + 0x108) // SNVS_LP general purpose register 2
#define SNVS_LPGPR3                     *(volatile unsigned long *)(SNVS_BLOCK + 0x10c) // SNVS_LP general purpose register 3

#define SNVS_HPVIDR1                    *(volatile unsigned long *)(SNVS_BLOCK + 0xbf8) // SNVS_LP version ID register 1
#define SNVS_HPVIDR2                    *(volatile unsigned long *)(SNVS_BLOCK + 0xbfc) // SNVS_LP version ID register 2

#if defined ARM_PLL_AVAILABLE
    #define CCM_ANALOG_PLL_ARM          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0000) // analog ARM PLL control register
    #define CCM_ANALOG_PLL_ARM_SET      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0004) // analog ARM PLL control set register
    #define CCM_ANALOG_PLL_ARM_CLR      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0008) // analog ARM PLL control clear register
    #define CCM_ANALOG_PLL_ARM_TOG      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x000c) // analog ARM PLL control toggle register
        #define CCM_ANALOG_PLL_ARM_LOCK    0x80000000                       // PLL is currently locked (read-only)
        #define CCM_ANALOG_PLL_ARM_NOT_BYPASSED  0x00000000                 // don't bypass the PLL
        #define CCM_ANALOG_PLL_ARM_BYPASS  0x00010000                       // bypass the PLL
        #define CCM_ANALOG_PLL_ARM_BYPASS_CLK_SRC_REF_CLK_24M  0x00000000   // PLL source is the 24MHz oscillator
        #define CCM_ANALOG_PLL_ARM_ENABLE  0x00002000                       // enable the PLL output
        #define CCM_ANALOG_PLL_ARM_NOT_POWERDOWN  0x00000000                // now powered down
        #define CCM_ANALOG_PLL_ARM_POWERDOWN  0x00001000                    // power down the PLL
        #define CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK 0x0000007f               // PLL output frequency is (reference * value / 2) [54..108 possible]
#endif
#define CCM_ANALOG_PLL_USB1             *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0010) // analog USB1 480MHz PLL control register
#define CCM_ANALOG_PLL_USB1_SET         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0014) // analog USB1 480MHz PLL control set register
#define CCM_ANALOG_PLL_USB1_CLR         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0018) // analog USB1 480MHz PLL control clear register
#define CCM_ANALOG_PLL_USB1_TOG         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x001c) // analog USB1 480MHz PLL control toggle register
    #define CCM_ANALOG_PLL_USB1_LOCK    0x80000000                       // PLL is currently locked (read-only)
    #define CCM_ANALOG_PLL_USB1_NOT_BYPASSED  0x00000000                 // don't bypass the PLL
    #define CCM_ANALOG_PLL_USB1_BYPASS  0x00010000                       // bypass the PLL
    #define CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_REF_CLK_24M  0x00000000   // PLL source is the 24MHz oscillator
    #define CCM_ANALOG_PLL_USB1_BYPASS_CLK_SRC_CLK1         0x00004000   // PLL source is CLK1
    #define CCM_ANALOG_PLL_USB1_ENABLE  0x00002000                       // enable the PLL output
    #define CCM_ANALOG_PLL_USB1_POWER   0x00001000                       // power up the PLL
    #define CCM_ANALOG_PLL_USB1_EN_USB_CLKS                 0x00000040   // supply 9-phase PLL outputs for USBPHY2
  //#define CCM_ANALOG_PLL_USB1_DIV_SELECT 0x00000002                    // PLL output frequency is 22 x reference (528MHz) - this PLL should always use x20 mode for 480MHz
#if HSUSB_CONTROLLERS > 1
#define CCM_ANALOG_PLL_USB2             *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0020) // analog USB2 480MHz PLL control register
#define CCM_ANALOG_PLL_USB2_SET         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0024) // analog USB2 480MHz PLL control set register
#define CCM_ANALOG_PLL_USB2_CLR         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0028) // analog USB2 480MHz PLL control clear register
#define CCM_ANALOG_PLL_USB2_TOG         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x002c) // analog USB2 480MHz PLL control toggle register
    #define CCM_ANALOG_PLL_USB2_LOCK    0x80000000                       // PLL is currently locked (read-only)
    #define CCM_ANALOG_PLL_USB2_NOT_BYPASSED  0x00000000                 // don't bypass the PLL
    #define CCM_ANALOG_PLL_USB2_BYPASS  0x00010000                       // bypass the PLL
    #define CCM_ANALOG_PLL_USB2_BYPASS_CLK_SRC_REF_CLK_24M  0x00000000   // PLL source is the 24MHz oscillator
    #define CCM_ANALOG_PLL_USB2_BYPASS_CLK_SRC_CLK1         0x00004000   // PLL source is CLK1
    #define CCM_ANALOG_PLL_USB2_ENABLE  0x00002000                       // enable the PLL output
    #define CCM_ANALOG_PLL_USB2_POWER   0x00001000                       // power up the PLL
    #define CCM_ANALOG_PLL_USB2_EN_USB_CLKS                 0x00000040   // supply 9-phase PLL outputs for USBPHY2
  //#define CCM_ANALOG_PLL_USB2_DIV_SELECT 0x00000002                    // PLL output frequency is 22 x reference (528MHz) - this PLL should always use x20 mode for 480MHz
#endif
#define CCM_ANALOG_PLL_SYS_ADD          (volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0030)
#define CCM_ANALOG_PLL_SYS              *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0030) // analog system PLL2 (528MHz) control register
    #define CCM_ANALOG_PLL_SYS_LOCK     0x80000000                       // PLL is currently locked (read-only)
    #define CCM_ANALOG_PLL_SYS_NOT_BYPASSED  0x00000000                  // don't bypass the PLL
    #define CCM_ANALOG_PLL_SYS_BYPASS   0x00010000                       // bypass the PLL
    #define CCM_ANALOG_PLL_SYS_BYPASS_CLK_SRC_REF_CLK_24M  0x00000000    // PLL source is the 24MHz oscillator
    #define CCM_ANALOG_PLL_SYS_ENABLE   0x00002000                       // enable the PLL output
    #define CCM_ANALOG_PLL_SYS_POWERDOWN 0x00010000                      // PLL powered down
    #define CCM_ANALOG_PLL_SYS_POWERUP  0x00000000                       // power up the PLL
    #define CCM_ANALOG_PLL_SYS_DIV_SELECT 0x00000001                     // PLL output frequency is 22x reference (528MHz) - this PLL should always use this setting [x20 mode were for 480MHz]
#define CCM_ANALOG_PLL_SYS_SET          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0034) // analog system PLL control set register
#define CCM_ANALOG_PLL_SYS_CLR          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0038) // analog system PLL control clear register
#define CCM_ANALOG_PLL_SYS_TOG          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x003c) // analog system PLL control toggle register
#define CCM_ANALOG_PLL_SYS_SS           *(unsigned long *)(CCM_ANALOG_BLOCK + 0x0040) // analog 528MHz system PLL spread spectrum register
    #define CCM_ANALOG_PLL_SYS_SS_STOP_MASK  0xffff0000
    #define CCM_ANALOG_PLL_SYS_SS_ENABLE     0x00008000
    #define CCM_ANALOG_PLL_SYS_SS_ISTEP_MASK 0x00007fff
#define CCM_ANALOG_PLL_SYS_NUM          *(unsigned long *)(CCM_ANALOG_BLOCK + 0x0050) // numerator of 528MHz system PLL fractional loop divider register (should be less than the denominator)
#define CCM_ANALOG_PLL_SYS_DENOM        *(unsigned long *)(CCM_ANALOG_BLOCK + 0x0060) // denominator of 528MHz system PLL fractional loop divider register
#define CCM_ANALOG_PLL_AUDIO            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0070) // analog audio PLL control register
#define CCM_ANALOG_PLL_AUDIO_SET        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0074) // analog audio PLL control set register
#define CCM_ANALOG_PLL_AUDIO_CLR        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0078) // analog audio PLL control clear register
#define CCM_ANALOG_PLL_AUDIO_TOG        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x007c) // analog audio PLL control toggle register
#define CCM_ANALOG_PLL_AUDIO_NUM        *(unsigned long *)(CCM_ANALOG_BLOCK + 0x0080) // numerator of audio PLL fractional loop divider register
#define CCM_ANALOG_PLL_AUDIO_DENOM      *(unsigned long *)(CCM_ANALOG_BLOCK + 0x0090) // denominator of audio PLL fractional loop divider register
#if defined ENHANCED_LCD_INTERFACE
    #define CCM_ANALOG_PLL_VIDEO        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00a0) // analog video PLL control register
        #define CCM_ANALOG_PLL_VIDEO_DIV_SELECT_MASK           0x0000007f // PLL loop divider - valid range for 27~54
        #define CCM_ANALOG_PLL_VIDEO_POWERDOWN                 0x00001000 // power down the PLL
        #define CCM_ANALOG_PLL_VIDEO_ENABLE                    0x00002000 // enable PLL output
        #define CCM_ANALOG_PLL_VIDEO_BYPASS_CLKSRC_REF_CLK_24M 0x00000000 // bypass clock source selected from 24MHz reference
        #define CCM_ANALOG_PLL_VIDEO_BYPASS_CLKSRC_CLK1        0x00004000 // bypass clock source selected from CLK1_N/CLK1_P
        #define CCM_ANALOG_PLL_VIDEO_BYPASS_CLKSRC             0x0000c000 // bypass clock source mask
        #define CCM_ANALOG_PLL_VIDEO_BYPASS                    0x00010000 // bypass the PLL
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_4         0x00000000
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2         0x00080000
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_1         0x00100000
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT           0x00180000 // post PLL divider (before enable and bypass mux)
        #define CCM_ANALOG_PLL_VIDEO_LOCK                      0x80000000 // PLL is currently locked (read-only)
    #define CCM_ANALOG_PLL_VIDEO_SET    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00a4) // analog video PLL control set register
    #define CCM_ANALOG_PLL_VIDEO_CLR    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00a8) // analog video PLL control clear register
    #define CCM_ANALOG_PLL_VIDEO_TOG    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00ac) // analog video PLL control toggle register
    #define CCM_ANALOG_PLL_VIDEO_NUM    *(unsigned long *)(CCM_ANALOG_BLOCK + 0x00b0) // numerator of audio PLL fractional loop divider register (signed number whose absolute value should be less than denominator)
    #define CCM_ANALOG_PLL_VIDEO_NUM_MASK                      0x3fffffff
    #define CCM_ANALOG_PLL_VIDEO_DENOM  *(unsigned long *)(CCM_ANALOG_BLOCK + 0x00c0) // denominator of audio PLL fractional loop divider register (unsigned value)
    #define CCM_ANALOG_PLL_VIDEO_DENOM_MASK                    0x3fffffff
#endif
#define CCM_ANALOG_PLL_ENET             *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00e0) // analog ENET PLL control register
    #define CCM_ANALOG_PLL_ENET_LOCK         0x80000000                  // PLL lock state (read-only)
    #define CCM_ANALOG_PLL_ENET_500M_REF_EN  0x00400000                  // enable the PLL providing 500MHz reference clock
    #define CCM_ANALOG_PLL_ENET_25M_REF_EN   0x00200000                  // enable the PLL providing 25MHz reference clock
    #define CCM_ANALOG_PLL_ENET_NOT_BYPASSED 0x00000000                  // don't bypass the PLL
    #define CCM_ANALOG_PLL_ENET_BYPASS       0x00010000                  // bypass the PLL
    #define CCM_ANALOG_PLL_ENET_BYPASS_CLK_SRC_REF_CLK_24M  0x00000000   // select the external 24MHz oscillator as reference source
    #define CCM_ANALOG_PLL_ENET_ENABLE       0x00002000                  // enable PLL ouput
    #define CCM_ANALOG_PLL_ENET_POWERDOWN    0x00001000                  // power down the PLL
    #define CCM_ANALOG_PLL_ENET_NOT_POWEREDDOWN 0x00000000               // don't power down the PLL
    #define CCM_ANALOG_PLL_ENET_DIV_SELECT_25M  0x000000000              // ethernet reference clock - 25MHz
    #define CCM_ANALOG_PLL_ENET_DIV_SELECT_50M  0x000000001              // ethernet reference clock - 50MHz
    #define CCM_ANALOG_PLL_ENET_DIV_SELECT_100M 0x000000002              // ethernet reference clock - 100MHz (not 50% duty-cycle)
    #define CCM_ANALOG_PLL_ENET_DIV_SELECT_125M 0x000000003              // ethernet reference clock - 125MHz
#define CCM_ANALOG_PLL_ENET_SET         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00e4) // analog ENET PLL control set register
#define CCM_ANALOG_PLL_ENET_CLR         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00e8) // analog ENET PLL control clear register
#define CCM_ANALOG_PLL_ENET_TOG         *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00ec) // analog ENET PLL control toggle register
#define CCM_ANALOG_PFD_480              *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00f0) // 480MHz clock (PLL3) phase fractional divider control register
    #define CCM_ANALOG_PFD_480_PFD3_CLKGATE        0x80000000            // '1 disables the fractional divider clock 3
    #define CCM_ANALOG_PFD_480_PFD3_STABLE         0x40000000            // (read-only)
    #define CCM_ANALOG_PFD_480_PFD3_FRACT_MASK     0x3f000000            // fractional divide mask PFD3 (range 12..35)
    #define CCM_ANALOG_PFD_480_PFD2_CLKGATE        0x00800000            // '1 disables the fractional divider clock 2
    #define CCM_ANALOG_PFD_480_PFD2_STABLE         0x00400000            // (read-only)
    #define CCM_ANALOG_PFD_480_PFD2_FRACT_MASK     0x003f0000            // fractional divide mask PFD2 (range 12..35)
    #define CCM_ANALOG_PFD_480_PFD1_CLKGATE        0x00008000            // '1 disables the fractional divider clock 1
    #define CCM_ANALOG_PFD_480_PFD1_STABLE         0x00004000            // (read-only)
    #define CCM_ANALOG_PFD_480_PFD1_FRACT_MASK     0x00003f00            // fractional divide mask PFD1 (range 12..35)
    #define CCM_ANALOG_PFD_480_PFD0_CLKGATE        0x00000080            // '1 disables the fractional divider clock 0
    #define CCM_ANALOG_PFD_480_PFD0_STABLE         0x00000040            // (read-only)
    #define CCM_ANALOG_PFD_480_PFD0_FRACT_MASK     0x0000003f            // fractional divide mask PFD0 (range 12..35)

    #define CCM_ANALOG_PFD_480_PFD_FRACT_720       0x0000000c            // fractional divide (480*18/12) for 720MHz - default PFD0
    #define CCM_ANALOG_PFD_480_PFD_FRACT_664_615   0x0000000d            // fractional divide (480*18/13) for 664.6153846MHz - default PFD1
    #define CCM_ANALOG_PFD_480_PFD_FRACT_617_143   0x0000000e            // fractional divide (480*18/14) for 617.1428571MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_576       0x0000000f            // fractional divide (480*18/15) for 576MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_540       0x00000010            // fractional divide (480*18/16) for 540MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_508_235   0x00000011            // fractional divide (480*18/17) for 508.2352941MHz - default PFD2
    #define CCM_ANALOG_PFD_480_PFD_FRACT_480       0x00000012            // fractional divide (480*18/18) for 480MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_454_737   0x00000013            // fractional divide (480*18/19) for 454.7368421MHz - default PFD3
    #define CCM_ANALOG_PFD_480_PFD_FRACT_432       0x00000014            // fractional divide (480*18/20) for 432MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_411_429   0x00000015            // fractional divide (480*18/21) for 411.4285714MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_392_727   0x00000016            // fractional divide (480*18/22) for 392.7272727MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_375_652   0x00000017            // fractional divide (480*18/23) for 375.6521739MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_360       0x00000018            // fractional divide (480*18/24) for 360MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_345_6     0x00000019            // fractional divide (480*18/25) for 345.6MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_332_308   0x0000001a            // fractional divide (480*18/26) for 332.3076923MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_320       0x0000001b            // fractional divide (480*18/27) for 320MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_308_571   0x0000001c            // fractional divide (480*18/28) for 308.5714286MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_297_931   0x0000001d            // fractional divide (480*18/29) for 297.9310345MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_288       0x0000001e            // fractional divide (480*18/30) for 288MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_278_710   0x0000001f            // fractional divide (480*18/31) for 278.7096774MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_270       0x00000020            // fractional divide (480*18/32) for 270MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_262_818   0x00000021            // fractional divide (480*18/33) for 261.8181818MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_254_118   0x00000022            // fractional divide (480*18/34) for 254.1176471MHz
    #define CCM_ANALOG_PFD_480_PFD_FRACT_246_857   0x00000023            // fractional divide (480*18/35) for 246.8571429MHz
#define CCM_ANALOG_PFD_480_SET          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00f4) // 480MHz clock (PLL3) phase fractional divider set register
#define CCM_ANALOG_PFD_480_CLR          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00f8) // 480MHz clock (PLL3) phase fractional divider clear register
#define CCM_ANALOG_PFD_480_TOG          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x00fc) // 480MHz clock (PLL3) phase fractional divider toggle register
#define CCM_ANALOG_PFD_528_ADD          (volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0100)
#define CCM_ANALOG_PFD_528              *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0100) // 528MHz clock (PLL2) phase fractional divider control register
    #define CCM_ANALOG_PFD_528_PFD3_CLKGATE        0x80000000            // '1 disables the fractional divider clock 3
    #define CCM_ANALOG_PFD_528_PFD3_STABLE         0x40000000            // (read-only)
    #define CCM_ANALOG_PFD_528_PFD3_FRACT_MASK     0x3f000000            // fractional divide mask for PFD3 (range 12..35)
    #define CCM_ANALOG_PFD_528_PFD2_CLKGATE        0x00800000            // '1 disables the fractional divider clock 2
    #define CCM_ANALOG_PFD_528_PFD2_STABLE         0x00400000            // (read-only)
    #define CCM_ANALOG_PFD_528_PFD2_FRACT_MASK     0x003f0000            // fractional divide mask for PFD2 (range 12..35)
    #define CCM_ANALOG_PFD_528_PFD1_CLKGATE        0x00008000            // '1 disables the fractional divider clock 1
    #define CCM_ANALOG_PFD_528_PFD1_STABLE         0x00004000            // (read-only)
    #define CCM_ANALOG_PFD_528_PFD1_FRACT_MASK     0x00003f00            // fractional divide mask for PFD1 (range 12..35)
    #define CCM_ANALOG_PFD_528_PFD0_CLKGATE        0x00000080            // '1 disables the fractional divider clock 0
    #define CCM_ANALOG_PFD_528_PFD0_STABLE         0x00000040            // (read-only)
    #define CCM_ANALOG_PFD_528_PFD0_FRACT_MASK     0x0000003f            // fractional divide mask for PFD0 (range 12..35)

    #define CCM_ANALOG_PFD_528_PFD_FRACT_792       0x0000000c            // fractional divide (528*18/12) for 792MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_731_077   0x0000000d            // fractional divide (528*18/13) for 731.0769231MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_678_857   0x0000000e            // fractional divide (528*18/14) for 678.8571429MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_633_6     0x0000000f            // fractional divide (528*18/15) for 633.6MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_594       0x00000010            // fractional divide (528*18/16) for 594MHz - default PFD1 and 3
    #define CCM_ANALOG_PFD_528_PFD_FRACT_559_059   0x00000011            // fractional divide (528*18/17) for 559.0588235MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_528       0x00000012            // fractional divide (525*18/18) for 528MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_500_211   0x00000013            // fractional divide (528*18/19) for 500.2105263MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_475_2     0x00000014            // fractional divide (528*18/20) for 475.2MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_452_571   0x00000015            // fractional divide (528*18/21) for 452.5714285MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_432       0x00000016            // fractional divide (528*18/22) for 432MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_413_217   0x00000017            // fractional divide (528*18/23) for 413.2173913MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_396       0x00000018            // fractional divide (528*18/24) for 396MHz - default PFD2
    #define CCM_ANALOG_PFD_528_PFD_FRACT_380_16    0x00000019            // fractional divide (528*18/25) for 380.16MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_365_538   0x0000001a            // fractional divide (528*18/26) for 365.5384615MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_352       0x0000001b            // fractional divide (528*18/27) for 352MHz - default PFD0
    #define CCM_ANALOG_PFD_528_PFD_FRACT_339_429   0x0000001c            // fractional divide (528*18/28) for 339.4285714MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_327_724   0x0000001d            // fractional divide (528*18/29) for 327.7241379MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_316_8     0x0000001e            // fractional divide (528*18/30) for 316.8MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_306_581   0x0000001f            // fractional divide (528*18/31) for 306.58064524MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_297       0x00000020            // fractional divide (528*18/32) for 297MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_288       0x00000021            // fractional divide (528*18/33) for 288MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_279_529   0x00000022            // fractional divide (528*18/34) for 279.5294118MHz
    #define CCM_ANALOG_PFD_528_PFD_FRACT_271_543   0x00000023            // fractional divide (528*18/35) for 271.5428571MHz
#define CCM_ANALOG_PFD_528_SET          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0104) // 528MHz clock (PLL2) phase fractional divider set register
#define CCM_ANALOG_PFD_528_CLR          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0108) // 528MHz clock (PLL2) phase fractional divider clear register
#define CCM_ANALOG_PFD_528_TOG          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x010c) // 528MHz clock (PLL2) phase fractional divider toggle register
// PMU
// within the CCM_ANALOG_BLOCK
//
#define PMU_REG_1P1                     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0110) // regulator 1P1 register
#define PMU_REG_1P1_SET                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0114) // regulator 1P1 set register
#define PMU_REG_1P1_CLR                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0118) // regulator 1P1 clear register
#define PMU_REG_1P1_TOG                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x011c) // regulator 1P1 toggle register
#define PMU_REG_3P0                     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0120) // regulator 3P0 register
    #define PMU_REG_3P0_ENABLE_LINREG   0x00000001                       // enable the regulator output to be set by the programmed target voltage setting and internal bandgap reference
    #define PMU_REG_3P0_ENABLE_BO       0x00000002                       // enable the brownout circuit
    #define PMU_REG_3P0_ENABLE_ILIMIT   0x00000004                       // enable regulator current limit circuitry
    #define PMU_REG_3P0_BO_OFFSET_25mV  0x00000010                       // regulator brownout offset voltage 25mV below regulator output setting
    #define PMU_REG_3P0_BO_OFFSET_50mV  0x00000020
    #define PMU_REG_3P0_BO_OFFSET_75mV  0x00000030
    #define PMU_REG_3P0_BO_OFFSET_100mV 0x00000040
    #define PMU_REG_3P0_BO_OFFSET_125mV 0x00000050
    #define PMU_REG_3P0_BO_OFFSET_150mV 0x00000060
    #define PMU_REG_3P0_BO_OFFSET_175mV 0x00000070
    #define PMU_REG_3P0_BO_OFFSET_MASK  0x00000070
    #define PMU_REG_3P0_VBUS_SEL_1      0x00000000                       // select input voltage source for LDO_3P0 from, USB_OTG2_VBUS rather than USB_OTG1_VBUS
    #define PMU_REG_3P0_VBUS_SEL_2      0x00000080                       // select input voltage source for LDO_3P0 from, USB_OTG2_VBUS rather than USB_OTG1_VBUS
    #define PMU_REG_3P0_OUTPUT_TRG_2V625  0x00000000                     // regulator output voltage qdjustment
    #define PMU_REG_3P0_OUTPUT_TRG_2V650  0x00000100
    #define PMU_REG_3P0_OUTPUT_TRG_2V675  0x00000200
    #define PMU_REG_3P0_OUTPUT_TRG_2V700  0x00000300
    #define PMU_REG_3P0_OUTPUT_TRG_2V725  0x00000400
    #define PMU_REG_3P0_OUTPUT_TRG_2V750  0x00000500
    #define PMU_REG_3P0_OUTPUT_TRG_2V775  0x00000600
    #define PMU_REG_3P0_OUTPUT_TRG_2V800  0x00000700
    #define PMU_REG_3P0_OUTPUT_TRG_2V825  0x00000800
    #define PMU_REG_3P0_OUTPUT_TRG_2V850  0x00000900
    #define PMU_REG_3P0_OUTPUT_TRG_2V875  0x00000a00
    #define PMU_REG_3P0_OUTPUT_TRG_2V900  0x00000b00
    #define PMU_REG_3P0_OUTPUT_TRG_2V925  0x00000c00
    #define PMU_REG_3P0_OUTPUT_TRG_2V950  0x00000d00
    #define PMU_REG_3P0_OUTPUT_TRG_2V975  0x00000e00
    #define PMU_REG_3P0_OUTPUT_TRG_3V000  0x00000f00                     // default
    #define PMU_REG_3P0_OUTPUT_TRG_3V025  0x00001000
    #define PMU_REG_3P0_OUTPUT_TRG_3V050  0x00001100
    #define PMU_REG_3P0_OUTPUT_TRG_3V075  0x00001200
    #define PMU_REG_3P0_OUTPUT_TRG_3V100  0x00001300
    #define PMU_REG_3P0_OUTPUT_TRG_3V125  0x00001400
    #define PMU_REG_3P0_OUTPUT_TRG_3V150  0x00001500
    #define PMU_REG_3P0_OUTPUT_TRG_3V175  0x00001600
    #define PMU_REG_3P0_OUTPUT_TRG_3V200  0x00001700
    #define PMU_REG_3P0_OUTPUT_TRG_3V225  0x00001800
    #define PMU_REG_3P0_OUTPUT_TRG_3V250  0x00001900
    #define PMU_REG_3P0_OUTPUT_TRG_3V275  0x00001a00
    #define PMU_REG_3P0_OUTPUT_TRG_3V300  0x00001b00
    #define PMU_REG_3P0_OUTPUT_TRG_3V325  0x00001c00
    #define PMU_REG_3P0_OUTPUT_TRG_3V350  0x00001d00
    #define PMU_REG_3P0_OUTPUT_TRG_3V375  0x00001e00
    #define PMU_REG_3P0_OUTPUT_TRG_3V400  0x00001f00
    #define PMU_REG_3P0_OUTPUT_TRG_MASK   0x00001f00
    #define PMU_REG_3P0_BO_VDD3P0       0x00010000                       // brownout is detected on the regulator output (read-only)
    #define PMU_REG_3P0_OK_VDD3P0       0x00020000                       // regulator output is OK (read-only)
#define PMU_REG_3P0_SET                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0124) // regulator 3P0 set register
#define PMU_REG_3P0_CLR                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0128) // regulator 3P0 clear register
#define PMU_REG_3P0_TOG                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x012c) // regulator 3P0 toggle register
#define PMU_REG_2P5                     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0130) // regulator 2P5 register
#define PMU_REG_2P5_SET                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0134) // regulator 2P5 set register
#define PMU_REG_2P5_CLR                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0138) // regulator 2P5 clear register
#define PMU_REG_2P5_TOG                 *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x013c) // regulator 2P5 toggle register
#define PMU_REG_CORE                    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0140) // regulator core register
#define PMU_REG_CORE_SET                *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0144) // regulator core set register
#define PMU_REG_CORE_CLR                *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0148) // regulator core clear register
#define PMU_REG_CORE_TOG                *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x014c) // regulator core toggle register
#define CCM_ANALOG_MISC0                *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0150) // miscellaneous register 0
    #define CCM_ANALOG_MISC0_REFTOP_PWD            0x00000001            // power down the analog bandgap reference circuitry
    #define CCM_ANALOG_MISC0_REFTOP_SELFBIASOFF    0x00000002            // use bandgap based bias currents for best performance
    #define CCM_ANALOG_MISC0_REFTOP_VBGADJ_MASK    0x00000070
    #define CCM_ANALOG_MISC0_REFTOP_VBGUP          0x00000080            // flag indicating that the analog band-gap voltage is up and stable
    #define CCM_ANALOG_MISC0_STOP_MODE_ALL                0x00000000     // all analog (except RTC) powered down in STOP mode
    #define CCM_ANALOG_MISC0_STOP_MODE_AN_BANDGAP_REG     0x00000400     // additionally analog bandgap, 1p1 and2p5 regulators remain on in STOP mode
    #define CCM_ANALOG_MISC0_STOP_MODE_LP_BANDGAP_REG     0x00000800     // additionally low-power bandgap, 1p1 and2p5 regulators remain on in STOP mode
    #define CCM_ANALOG_MISC0_STOP_MODE_LP_BANDGAP         0x00000c00     // additionally low-power bandgap remains on in STOP mode
    #define CCM_ANALOG_MISC0_STOP_MODE_CONFIG_MASK 0x00000c00
    #define CCM_ANALOG_MISC0_DISCON_HIGH_SNVS      0x00001000            // turn off VDD_HIGH_IN to VDD_SNVS_IN switch
    #define CCM_ANALOG_MISC0_OSC_I_NORMAL          0x00000000            // 24MHz bias current not reduced
    #define CCM_ANALOG_MISC0_OSC_I_MINUS_12_5_PERCENT     0x00002000     // 24MHz bias current reduced by 12.5%
    #define CCM_ANALOG_MISC0_OSC_I_MINUS_25_PERCENT       0x00004000     // 24MHz bias current reduced by 25%
    #define CCM_ANALOG_MISC0_OSC_I_MINUS_37_5_PERCENT     0x00006000     // 24MHz bias current reduced by 37.5%
    #define CCM_ANALOG_MISC0_OSC_I_MASK            0x00006000
    #define CCM_ANALOG_MISC0_OSC_XTALOK            0x00008000            // 24MHz crystal oscillator is stable (read-only)
    #define CCM_ANALOG_MISC0_OSC_XTALOK_EN         0x00010000            // enable detector that signals when the 24MHz crystal oscillator is stable
    #define CCM_ANALOG_MISC0_CLKGATE_CTRL_ALLOW_AUTO_GATE 0x00000000     // allow the logic to automatically gate the 24MHz clock when the XTAL is powered down
    #define CCM_ANALOG_MISC0_CLKGATE_CTRL_NO_AUTO_GATE    0x02000000     // prevent the logic from ever gating off the clock
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_0_5MS   0x00000000            // 0.5ms delay between powering up the XTAL 24MHz clock and releasing it to the digital logic inside the analog block
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_1MS     0x04000000            // 1.0ms delay (default)
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_2MS     0x08000000            // 2.0ms delay
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_3MS     0x0c000000            // 3.0ms delay
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_4MS     0x10000000            // 4.0ms delay
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_5MS     0x14000000            // 5.0ms delay
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_6MS     0x18000000            // 6.0ms delay
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_7MS     0x1c000000            // 7.0ms delay
    #define CCM_ANALOG_MISC0_CLKGATE_DELAY_MASK    0x1c000000
    #define CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_RING_OSC     0x0000000      // RTC clock source from internal ring oscillator
    #define CCM_ANALOG_MISC0_RTC_XTAL_SOURCE_RTC_XTAL     0x2000000      // RTC clock source from 32kHz crystal
    #define CCM_ANALOG_MISC0_XTAL_24M_PWD          0x40000000            // power down 24MHz crystal oscillator
#define CCM_ANALOG_MISC0_SET            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0154) // miscellaneous register 0 set
#define CCM_ANALOG_MISC0_CLR            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0158) // miscellaneous register 0 clear
#define CCM_ANALOG_MISC0_TOG            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x015c) // miscellaneous register 0 toggle
#define XTALOSC24M_MISC0         CCM_ANALOG_MISC0
#define XTALOSC24M_MISC0_SET     CCM_ANALOG_MISC0_SET
#define XTALOSC24M_MISC0_CLR     CCM_ANALOG_MISC0_CLR
#define XTALOSC24M_MISC0_TOG     CCM_ANALOG_MISC0_TOG
#define PMU_MISC0                CCM_ANALOG_MISC0
#define PMU_MISC0_SET            CCM_ANALOG_MISC0_SET
#define PMU_MISC0_CLR            CCM_ANALOG_MISC0_CLR
#define PMU_MISC0_TOG            CCM_ANALOG_MISC0_TOG
#define CCM_ANALOG_MISC1                *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0160) // miscellaneous register 1
#define CCM_ANALOG_MISC1_SET            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0164) // miscellaneous register 1 set
#define CCM_ANALOG_MISC1_CLR            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0168) // miscellaneous register 1 clear
#define CCM_ANALOG_MISC1_TOG            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x016c) // miscellaneous register 1 toggle
#define PMU_MISC1                CCM_ANALOG_MISC1
#define PMU_MISC1_SET            CCM_ANALOG_MISC1_SET
#define PMU_MISC1_CLR            CCM_ANALOG_MISC1_CLR
#define PMU_MISC1_TOG            CCM_ANALOG_MISC1_TOG
#define CCM_ANALOG_MISC2                *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0170) // miscellaneous register 2
    #define CCM_ANALOG_MISC2_VIDEO_DIV_1    0x00000000
    #define CCM_ANALOG_MISC2_VIDEO_DIV_2    0x40000000
    #define CCM_ANALOG_MISC2_VIDEO_DIV_4    0xc0000000
    #define CCM_ANALOG_MISC2_VIDEO_DIV_MASK 0xc0000000
#define CCM_ANALOG_MISC2_SET            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0174) // miscellaneous register 2 set
#define CCM_ANALOG_MISC2_CLR            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0178) // miscellaneous register 2 clear
#define CCM_ANALOG_MISC2_TOG            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x017c) // miscellaneous register 2 toggle
#define PMU_MISC2                CCM_ANALOG_MISC2
#define PMU_MISC2_SET            CCM_ANALOG_MISC2_SET
#define PMU_MISC2_CLR            CCM_ANALOG_MISC2_CLR
#define PMU_MISC2_TOG            CCM_ANALOG_MISC2_TOG

#if defined PLL5_POST_DIVIDE
    #if PLL5_POST_DIVIDE == 1
        #define CCM_ANALOG_MISC2_VIDEO_DIV_VALUE                 CCM_ANALOG_MISC2_VIDEO_DIV_1
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2_VALUE     CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_1
    #elif PLL5_POST_DIVIDE == 2
        #define CCM_ANALOG_MISC2_VIDEO_DIV_VALUE                 CCM_ANALOG_MISC2_VIDEO_DIV_1
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2_VALUE     CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2
    #elif PLL5_POST_DIVIDE == 4
        #define CCM_ANALOG_MISC2_VIDEO_DIV_VALUE                 CCM_ANALOG_MISC2_VIDEO_DIV_1
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2_VALUE     CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_4
    #elif PLL5_POST_DIVIDE == 8
        #define CCM_ANALOG_MISC2_VIDEO_DIV_VALUE                 CCM_ANALOG_MISC2_VIDEO_DIV_2
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2_VALUE     CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_4
    #elif PLL5_POST_DIVIDE == 16
        #define CCM_ANALOG_MISC2_VIDEO_DIV_VALUE                 CCM_ANALOG_MISC2_VIDEO_DIV_4
        #define CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_2_VALUE     CCM_ANALOG_PLL_VIDEO_POST_DIV_SELECT_4
    #else
        #error "PLL5_POST_DIVIDE must be 1,2,4,8, or 16!!"
    #endif
#endif

// USB analog
//
#define USB_ANALOG_USB1_VBUS_DETECT     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01a0) // USB VBUS detect register
#define USB_ANALOG_USB1_VBUS_DETECT_SET *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01a4) // USB VBUS detect register set
#define USB_ANALOG_USB1_VBUS_DETECT_CLR *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01a8) // USB VBUS detect register clear
#define USB_ANALOG_USB1_VBUS_DETECT_TOG *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01ac) // USB VBUS detect register toggle
#define USB_ANALOG_USB1_CHRG_DETECT     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01b0) // USB charger detect register
    #define USB_ANALOG_USB1_CHRG_DETECT_CHK_CONTACT 0x00040000           // check whether the USB pulg is connected
    #define USB_ANALOG_USB1_CHRG_DETECT_CHK_CHRG_B  0x00080000           // do not check whether a charger is connected to the USB port
    #define USB_ANALOG_USB1_CHRG_DETECT_EN_B        0x00100000           // disable the charger detector
#define USB_ANALOG_USB1_CHRG_DETECT_SET *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01b4) // USB charger detect register set
#define USB_ANALOG_USB1_CHRG_DETECT_CLR *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01b8) // USB charger detect register clear
#define USB_ANALOG_USB1_CHRG_DETECT_TOG *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01bc) // USB charger detect register toggle
#define USB_ANALOG_USB1_VBUS_DETECT_STAT  *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01c0) // USB VBUS detect status register (read-only)
#define USB_ANALOG_USB1_CHRG_DETECT_STAT  *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01d0) // USB charger detect status register (read-only)
#define USB_ANALOG_USB1_LOOPBACK        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01e0) // USB loopback test register
#define USB_ANALOG_USB1_LOOPBACK_SET    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01e4) // USB loopback test register set
#define USB_ANALOG_USB1_LOOPBACK_CLR    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01e8) // USB loopback test register clear
#define USB_ANALOG_USB1_LOOPBACK_TOG    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01ec) // USB loopback test register toggle
#define USB_ANALOG_USB1_MISC            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01f0) // USB miscellaneous register
#define USB_ANALOG_USB1_MISC_SET        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01f4) // USB miscellaneous register set
#define USB_ANALOG_USB1_MISC_CLR        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01f8) // USB miscellaneous register clear
#define USB_ANALOG_USB1_MISC_TOG        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x01fc) // USB miscellaneous register toggle

#if HSUSB_CONTROLLERS > 1
    #define USB_ANALOG_USB2_VBUS_DETECT     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0200) // USB VBUS detect register
    #define USB_ANALOG_USB2_VBUS_DETECT_SET *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0204) // USB VBUS detect register set
    #define USB_ANALOG_USB2_VBUS_DETECT_CLR *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0208) // USB VBUS detect register clear
    #define USB_ANALOG_USB2_VBUS_DETECT_TOG *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x020c) // USB VBUS detect register toggle
    #define USB_ANALOG_USB2_CHRG_DETECT     *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0210) // USB charger detect register
    #define USB_ANALOG_USB2_CHRG_DETECT_SET *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0214) // USB charger detect register set
    #define USB_ANALOG_USB2_CHRG_DETECT_CLR *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0218) // USB charger detect register clear
    #define USB_ANALOG_USB2_CHRG_DETECT_TOG *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x021c) // USB charger detect register toggle
    #define USB_ANALOG_USB2_VBUS_DETECT_STAT  *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0220) // USB VBUS detect status register (read-only)
    #define USB_ANALOG_USB2_CHRG_DETECT_STAT  *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0230) // USB charger detect status register (read-only)
    #define USB_ANALOG_USB2_LOOPBACK        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0240) // USB loopback test register
    #define USB_ANALOG_USB2_LOOPBACK_SET    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0244) // USB loopback test register set
    #define USB_ANALOG_USB2_LOOPBACK_CLR    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0248) // USB loopback test register clear
    #define USB_ANALOG_USB2_LOOPBACK_TOG    *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x024c) // USB loopback test register toggle
    #define USB_ANALOG_USB2_MISC            *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0250) // USB miscellaneous register
    #define USB_ANALOG_USB2_MISC_SET        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0254) // USB miscellaneous register set
    #define USB_ANALOG_USB2_MISC_CLR        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0258) // USB miscellaneous register clear
    #define USB_ANALOG_USB2_MISC_TOG        *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x025c) // USB miscellaneous register toggle
    #define USB_ANALOG_DIGPROG              *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0260) // chip silicon version
#endif

#define XTALOSC24M_LOWPWR_CTRL          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0270) // XTAL OSC (LP) Control Register
    #define XTALOSC24M_LOWPWR_CTRL_RC_OSC_EN            0x00000001       //
    #define XTALOSC24M_LOWPWR_CTRL_OSC_SEL_XTAL         0x00000000       // select 24MHz source from 24MHz crystal oscillator
    #define XTALOSC24M_LOWPWR_CTRL_OSC_SEL_RC_OSC       0x00000010       // select 24MHz source from RC oscillator
    #define XTALOSC24M_LOWPWR_CTRL_LPBG_SEL             0x00000020       // low power bandgap select
    #define XTALOSC24M_LOWPWR_CTRL_LPBG_TEST            0x00000040       //
    #define XTALOSC24M_LOWPWR_CTRL_REFTOP_IBIAS_OFF     0x00000080       //
    #define XTALOSC24M_LOWPWR_CTRL_L1_PWRGATE           0x00000100       //
    #define XTALOSC24M_LOWPWR_CTRL_L2_PWRGATE           0x00000200       //
    #define XTALOSC24M_LOWPWR_CTRL_CPU_PWRGATE          0x00000400       //
    #define XTALOSC24M_LOWPWR_CTRL_DISPLAY_PWRGATE      0x00000800       //
    #define XTALOSC24M_LOWPWR_CTRL_RCOSC_CG_OVERRIDE    0x00002000       //
    #define XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_DELAY  0x0000c000       // 
    #define XTALOSC24M_LOWPWR_CTRL_XTALOSC_PWRUP_STAT   0x00010000       // 24MHz crystal oscillator stable and ready to use
    #define XTALOSC24M_LOWPWR_CTRL_MIX_PWRGATE          0x00020000       // display power gate gated
    #define XTALOSC24M_LOWPWR_CTRL_GPU_PWRGATE          0x00040000       // GPU power gate gated
#define XTALOSC24M_LOWPWR_CTRL_SET      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0274) // XTAL OSC (LP) Control Register set
#define XTALOSC24M_LOWPWR_CTRL_CLR      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x0278) // XTAL OSC (LP) Control Register clear
#define XTALOSC24M_LOWPWR_CTRL_TOG      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x027c) // XTAL OSC (LP) Control Register toggle

#define XTALOSC24M_OSC_CONFIG0          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02a0) // XTAL OSC Configuration 0 Register
#define XTALOSC24M_OSC_CONFIG0_SET      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02a4) // XTAL OSC Configuration 0 Register set
#define XTALOSC24M_OSC_CONFIG0_CLR      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02a8) // XTAL OSC Configuration 0 Register clear
#define XTALOSC24M_OSC_CONFIG0_TOG      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02ac) // XTAL OSC Configuration 0 Register toggle
#define XTALOSC24M_OSC_CONFIG1          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02b0) // XTAL OSC Configuration 1 Register
#define XTALOSC24M_OSC_CONFIG1_SET      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02b4) // XTAL OSC Configuration 1 Register set
#define XTALOSC24M_OSC_CONFIG1_CLR      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02b8) // XTAL OSC Configuration 1 Register clear
#define XTALOSC24M_OSC_CONFIG1_TOG      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02bc) // XTAL OSC Configuration 1 Register toggle
#define XTALOSC24M_OSC_CONFIG2          *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02c0) // XTAL OSC Configuration 2 Register
#define XTALOSC24M_OSC_CONFIG2_SET      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02c4) // XTAL OSC Configuration 2 Register set
#define XTALOSC24M_OSC_CONFIG2_CLR      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02c8) // XTAL OSC Configuration 2 Register clear
#define XTALOSC24M_OSC_CONFIG2_TOG      *(volatile unsigned long *)(CCM_ANALOG_BLOCK + 0x02cc) // XTAL OSC Configuration 2 Register toggle


/************************************************************************************************/

extern void fnEnterInterrupt(int iInterruptID, unsigned char ucPriority, void (*InterruptFunc)(void));
extern void fnMaskInterrupt(int iInterruptID);
extern void fnUnmaskInterrupt(int iInterruptID);
extern void fnClearPending(int iInterruptID);
extern int  fnIsPending(int iInterruptID);



// NIC-301
//
#if defined _WINDOWS
    #define SET_LCD_READ_ARBITRATION_PRIORITY(priority)
#else
    #define SIM_MAIN_LCD_READ_QOS                          *(unsigned long *)0x41044100
    #define SET_LCD_READ_ARBITRATION_PRIORITY(priority)    SIM_MAIN_LCD_READ_QOS = priority
#endif

// Cortex M7 private registers
//
// NVIC
//
#define INT_CONT_TYPE               *(const unsigned long *)(CORTEX_M7_BLOCK + 0x04)   // NVIC Interrupt Controller Type Register (read only)
    #define __NVIC_PRIORITY_SHIFT       4                                // 16 levels of priority so shifted by (8 - 4 (number of implemented bits))
    #define INTERRUPT_LOWEST_PRIORITY   15
#define CORTEX_ACTLR                *(unsigned long *)(CORTEX_M7_BLOCK + 0x008) // auxiliary control register
    #define CORTEX_ACTLR_DISMCYCINT 0x00000001                           // disable interruption of load multiple and store multiple instructions
    #define CORTEX_ACTLR_DISDEFWBUF 0x00000002                           // disable write buffer use during default memory map accesses
    #define CORTEX_ACTLR_DISFOLD    0x00000004                           // disable IT folding
    #define CORTEX_ACTLR_DISFPCA    0x00000010                           // disable automatic update of CONTROL.FPCA
    #define CORTEX_ACTLR_DISOOFP    0x00000020                           // disable FPU instructions competing out of order with respect to integer instructions

// SYSTICK
//
#if defined SYSTICK_EXTERNAL_CLOCK_SOURCE
    #define SYSTICK_CLOCK           (_EXTERNAL_CLOCK/240)                // 100kHz
#else
    #define SYSTICK_CLOCK           CORE_CLOCK
#endif
#define SYSTICK_CSR                 *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x010) // SYSTICK Control and Status Register
  #define SYSTICK_ENABLE            0x00000001                           // enable SYSTICK counter
  #define SYSTICK_TICKINT           0x00000002                           // interrupt on counter reload (reaching zero)
  #define SYSTICK_CORE_CLOCK        0x00000004                           // choose core clock as opposed to external reference clock
  #define SYSTICK_COUNTFLAG         0x00010000                           // '1' if the timer counted to 0 since the last time this register was read
#define SYSTICK_RELOAD              *(unsigned long *)(CORTEX_M7_BLOCK + 0x014) // SYSTICK Reload value (24 bits are valid)
#define SYSTICK_CURRENT             *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x018) // SYSTICK Current value - write any value to it to clear to 0
  #define SYSTICK_COUNT_MASK        0x00ffffff                           // valid count width in registers
#define SYSTICK_CALIB               *(const unsigned long *)(CORTEX_M7_BLOCK + 0x01c) // SYSTICK Calibration value (not available in Stellaris devices) (read-only)

// NVIC
//
#define IRQ0_31_SER_ADD             (unsigned long*)(CORTEX_M7_BLOCK + 0x100)
#define IRQ0_31_SER                 *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x100) // NVIC IRQ0..31    Set Enable Register
#define IRQ32_63_SER                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x104) // NVIC IRQ32..64   Set Enable Register
#define IRQ64_95_SER                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x108) // NVIC IRQ64..95   Set Enable Register
#define IRQ96_127_SER               *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x10c) // NVIC IRQ96..127  Set Enable Register
#define IRQ128_159_SER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x110) // NVIC IRQ128..159 Set Enable Register
#define IRQ160_191_SER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x114) // NVIC IRQ160..191 Set Enable Register
#define IRQ192_223_SER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x118) // NVIC IRQ192..223 Set Enable Register
#define IRQ224_239_SER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x11c) // NVIC IRQ224..239 Set Enable Register

#define IRQ0_31_CER_ADD             (unsigned long*)(CORTEX_M7_BLOCK + 0x180)
#define IRQ0_31_CER                 *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x180) // NVIC IRQ0..31    Clear Enable Register
#define IRQ32_63_CER                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x184) // NVIC IRQ32..64   Clear Enable Register
#define IRQ64_95_CER                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x188) // NVIC IRQ64..95   Clear Enable Register
#define IRQ96_127_CER               *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x18c) // NVIC IRQ96..127  Clear Enable Register
#define IRQ128_159_CER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x190) // NVIC IRQ128..159 Clear Enable Register
#define IRQ160_191_CER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x194) // NVIC IRQ160..191 Clear Enable Register
#define IRQ192_223_CER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x198) // NVIC IRQ192..223 Clear Enable Register
#define IRQ224_239_CER              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x19c) // NVIC IRQ224..239 Clear Enable Register

#define IRQ0_31_SPR                 *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x200) // NVIC IRQ0..31    Set Pending Register
#define IRQ32_63_SPR                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x204) // NVIC IRQ32..64   Set Pending Register
#define IRQ64_95_SPR                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x208) // NVIC IRQ64..95   Set Pending Register
#define IRQ96_127_SPR               *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x20c) // NVIC IRQ96..127  Set Pending Register
#define IRQ128_159_SPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x210) // NVIC IRQ128..159 Set Pending Register
#define IRQ160_191_SPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x214) // NVIC IRQ160..191 Set Pending Register
#define IRQ192_223_SPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x218) // NVIC IRQ192..223 Set Pending Register
#define IRQ224_239_SPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x21c) // NVIC IRQ224..239 Set Pending Register

#define IRQ0_31_CPR_ADD             (unsigned long*)(CORTEX_M7_BLOCK + 0x280)
#define IRQ0_31_CPR                 *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x280) // NVIC IRQ0..31    Clear Pending Register
#define IRQ32_63_CPR                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x284) // NVIC IRQ32..64   Clear Pending Register
#define IRQ64_95_CPR                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x288) // NVIC IRQ64..95   Clear Pending Register
#define IRQ96_127_CPR               *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x28c) // NVIC IRQ96..127  Clear Pending Register
#define IRQ128_159_CPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x290) // NVIC IRQ128..159 Clear Pending Register
#define IRQ160_191_CPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x294) // NVIC IRQ160..191 Clear Pending Register
#define IRQ192_223_CPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x298) // NVIC IRQ192..223 Clear Pending Register
#define IRQ224_239_CPR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x29c) // NVIC IRQ224..239 Clear Pending Register

#define IRQ0_31_ABR                 *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x300) // NVIC IRQ0..31    Active Bit Register (read only)
#define IRQ32_63_ABR                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x304) // NVIC IRQ32..64   Active Bit Register (read only)
#define IRQ64_95_ABR                *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x308) // NVIC IRQ64..95   Active Bit Register (read only)
#define IRQ96_127_ABR               *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x30c) // NVIC IRQ96..127  Active Bit Register (read only)
#define IRQ128_159_ABR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x310) // NVIC IRQ128..159 Active Bit Register (read only)
#define IRQ160_191_ABR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x314) // NVIC IRQ160..191 Active Bit Register (read only)
#define IRQ192_223_ABR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x318) // NVIC IRQ192..223 Active Bit Register (read only)
#define IRQ224_239_ABR              *(volatile unsigned long*)(CORTEX_M7_BLOCK + 0x31c) // NVIC IRQ224..239 Active Bit Register (read only)

#define IRQ0_3_PRIORITY_REGISTER_ADD (volatile unsigned char *)(CORTEX_M7_BLOCK + 0x400)
#define IRQ0_3_PRIORITY_REGISTER    *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x400) // NVIC IRQ0..3     Priority Register
#define IRQ4_7_PRIORITY_REGISTER    *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x404) // NVIC IRQ4..7     Priority Register
#define IRQ8_11_PRIORITY_REGISTER   *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x408) // NVIC IRQ8..11    Priority Register
#define IRQ12_15_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x40c) // NVIC IRQ12..15   Priority Register
#define IRQ16_19_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x410) // NVIC IRQ16..19   Priority Register
#define IRQ20_23_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x414) // NVIC IRQ20..23   Priority Register
#define IRQ24_27_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x418) // NVIC IRQ24..27   Priority Register
#define IRQ28_31_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x41c) // NVIC IRQ28..31   Priority Register
#define IRQ32_35_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x420) // NVIC IRQ32..35   Priority Register
#define IRQ36_39_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x424) // NVIC IRQ36..39   Priority Register
#define IRQ40_43_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x428) // NVIC IRQ40..43   Priority Register
#define IRQ44_47_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x42c) // NVIC IRQ44..47   Priority Register
#define IRQ48_51_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x430) // NVIC IRQ48..51   Priority Register
#define IRQ52_55_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x434) // NVIC IRQ52..55   Priority Register
#define IRQ56_59_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x438) // NVIC IRQ56..59   Priority Register
#define IRQ60_63_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x43c) // NVIC IRQ60..63   Priority Register
#define IRQ64_67_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x440) // NVIC IRQ64..67   Priority Register
#define IRQ68_71_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x444) // NVIC IRQ68..71   Priority Register
#define IRQ72_75_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x448) // NVIC IRQ72..75   Priority Register
#define IRQ76_79_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x44c) // NVIC IRQ76..79   Priority Register
#define IRQ80_83_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x450) // NVIC IRQ80..83   Priority Register
#define IRQ84_87_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x454) // NVIC IRQ84..87   Priority Register
#define IRQ88_91_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x458) // NVIC IRQ88..91   Priority Register
#define IRQ92_95_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x45c) // NVIC IRQ92..95   Priority Register
#define IRQ96_99_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x460) // NVIC IRQ96..99   Priority Register
#define IRQ100_103_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x464) // NVIC IRQ100..103   Priority Register
#define IRQ104_107_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x468) // NVIC IRQ104..107   Priority Register
#define IRQ108_111_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x46c) // NVIC IRQ108..111   Priority Register
#define IRQ112_115_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x470) // NVIC IRQ112..115   Priority Register
#define IRQ116_119_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x474) // NVIC IRQ116..119   Priority Register
#define IRQ120_123_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x478) // NVIC IRQ120..123   Priority Register
#define IRQ124_127_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x47c) // NVIC IRQ124..127   Priority Register
#define IRQ128_131_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x480) // NVIC IRQ128..131   Priority Register
#define IRQ132_135_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x484) // NVIC IRQ132..135   Priority Register
#define IRQ136_139_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x488) // NVIC IRQ136..139   Priority Register
#define IRQ140_143_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x48c) // NVIC IRQ140..143   Priority Register
#define IRQ144_147_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x490) // NVIC IRQ144..147   Priority Register
#define IRQ148_151_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x494) // NVIC IRQ148..151   Priority Register
#define IRQ152_155_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x498) // NVIC IRQ152..155   Priority Register
#define IRQ156_159_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x49c) // NVIC IRQ156..159   Priority Register
#define IRQ160_163_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4a0) // NVIC IRQ160..163   Priority Register
#define IRQ164_167_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4a4) // NVIC IRQ164..167   Priority Register
#define IRQ168_171_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4a8) // NVIC IRQ168..171   Priority Register
#define IRQ172_175_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4ac) // NVIC IRQ172..175   Priority Register
#define IRQ176_179_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4b0) // NVIC IRQ176..179   Priority Register
#define IRQ180_183_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4b4) // NVIC IRQ180..183   Priority Register
#define IRQ184_187_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4b8) // NVIC IRQ184..187   Priority Register
#define IRQ188_191_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4bc) // NVIC IRQ188..191   Priority Register
#define IRQ192_195_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4c0) // NVIC IRQ192..195   Priority Register
#define IRQ196_199_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4c4) // NVIC IRQ196..199   Priority Register
#define IRQ200_203_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4c8) // NVIC IRQ200..203   Priority Register
#define IRQ204_207_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4cc) // NVIC IRQ204..207   Priority Register
#define IRQ208_211_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4d0) // NVIC IRQ208..211   Priority Register
#define IRQ212_215_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4d4) // NVIC IRQ212..215   Priority Register
#define IRQ216_219_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4d8) // NVIC IRQ216..219   Priority Register
#define IRQ220_223_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4dc) // NVIC IRQ220..223   Priority Register
#define IRQ224_227_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4e0) // NVIC IRQ224..227   Priority Register
#define IRQ228_231_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4e4) // NVIC IRQ228..231   Priority Register
#define IRQ232_235_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4e8) // NVIC IRQ232..235   Priority Register
#define IRQ236_239_PRIORITY_REGISTER  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0x4ec) // NVIC IRQ236..239   Priority Register

// System Control Block
//
#define CPUID_BASE_REGISTER           *(unsigned long *)(CORTEX_M7_BLOCK + 0xd00)      // (read only)
#define INT_CONT_STATE_REG            *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd04) // interrupt control state register
  #define NMIPENDSET                  0x80000000                                       // set pending NMI bit
  #define PENDSVSET                   0x10000000                                       // set pending pendSV bit
  #define PENDSVCLR                   0x08000000                                       // clear pending pendSV bit
  #define PENDSTSET                   0x04000000                                       // set pending sysTick bit
  #define PENDSTCLR                   0x02000000                                       // clear pending sysTick bit
  #define ISRPREEMPT                  0x00800000                                       //
  #define ISRPENDING                  0x00400000                                       // interrupt pending flag
  #define VECT_PENDING_MASK           0x003ff000                                       // pending ISR number field
  #define RETTOBASE                   0x00000800                                       //
  #define VECT_ACTIVE_MASK            0x00000010                                       // active ISR number field
#define VECTOR_TABLE_OFFSET_REG       *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd08) // vector table offset register (note that this must be declared as volatile register since i.MX RT ITCM is located at 0x00000000 and if the compiler were to know that a NULL pointer is used it could behave unpredicatably)
  #define TBLBASE_IN_RAM              0x20000000                                       // vector table base is in RAM
  #define TBLBASE_IN_CODE             0x00000000
  #define TBLOFF_MASK                 0x1fffff80                                       // table offset from bottom of Code / RAM
#define APPLICATION_INT_RESET_CTR_REG_ADDR (volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd0c)
#define APPLICATION_INT_RESET_CTR_REG *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd0c) // application interrupt and reset control register
  #define VECTKEY                     0x05fa0000
  #define ENDIANESS_BIG               0x00008000
  #define ENDIANESS_LITTLE            0x00000000
  #define PRIGROUP_7_1                0x00000100
  #define PRIGROUP_6_2                0x00000200
  #define PRIGROUP_5_3                0x00000300
  #define PRIGROUP_4_4                0x00000400
  #define PRIGROUP_3_5                0x00000500
  #define PRIGROUP_2_6                0x00000600
  #define PRIGROUP_1_7                0x00000700
  #define PRIGROUP_0_8                0x00000800
  #define SYSRESETREQ                 0x00000004
  #define VECTCLRACTIVE               0x00000002
  #define VECTRESET                   0x00000001
#define SYSTEM_CONTROL_REGISTER       *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd10) // System Control Register
  #define SLEEPONEXIT                 0x00000002
  #define SLEEPDEEP                   0x00000004
  #define SEVONPEND                   0x00000010
#define CONFIGURATION_CONTROL_REGISTER *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd14) // Configuration Control Register
  #define CONFIGURATION_CONTROL_REGISTER_DC 0x00010000                   // enable L1 data cache
  #define CONFIGURATION_CONTROL_REGISTER_IC 0x00020000                   // enable L1 instruction cache
  #define CONFIGURATION_CONTROL_REGISTER_BP 0x00040000                   // branch prediction enabled (read-only)

#define SYSTEM_HANDLER_4_7_PRIORITY_REGISTER *(unsigned long *)(CORTEX_M7_BLOCK + 0xd18) // System Handler Priority Register 4..7
#define SYSTEM_HANDLER_8_11_PRIORITY_REGISTER *(unsigned long *)(CORTEX_M7_BLOCK + 0xd1c) // System Handler Priority Register 8..11
#define SYSTEM_HANDLER_12_15_PRIORITY_REGISTER *(unsigned long *)(CORTEX_M7_BLOCK + 0xd20) // System Handler Priority Register 12..15
#define SHCSR  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd24)      // system handler control and state register
    #define SHCSR_MEMFAULTACT      0x00000001
    #define SHCSR_BUSFAULTACT      0x00000002
    #define SHCSR_USGFAULTACT      0x00000008
    #define SHCSR_SVCALLACT        0x00000080
    #define SHCSR_MONITORACT       0x00000100
    #define SHCSR_PENDSVACT        0x00000400
    #define SHCSR_SYSTICKACT       0x00000800
    #define SHCSR_USGFAULTPENDED   0x00001000
    #define SHCSR_MEMFAULTPENDED   0x00002000
    #define SHCSR_BUSFAULTPENDED   0x00004000
    #define SHCSR_SVCALLPENDED     0x00008000
    #define SHCSR_MEMFAULTENA      0x00010000
    #define SHCSR_BUSFAULTENA      0x00020000
    #define SHCSR_USGFAULTENA      0x00040000

#define CSSIDR *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd80)      // cache size ID register (read-only)
  #define CSSIDR_LINE_SIZE_MASK    0x00000007
  #define CSSIDR_WAYS_MASK         0x00001ff8
  #define CSSIDR_WAYS_SHIFT        3
  #define CSSIDR_SETS_MASK         0x0fffe000
  #define CSSIDR_SETS_SHIFT        13
  #define CSSIDR_WA                0x10000000                            // write allocation support available
  #define CSSIDR_RA                0x20000000                            // read allocation support available
  #define CSSIDR_WB                0x40000000                            // write-back support available
  #define CSSIDR_WT                0x80000000                            // write-through support available
#define CSSELR *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd84)      // cache size select register
  #define CSSELR_LEVEL1_CACHE      0x00000000
  #define CSSELR_INSTRUCTION_CACHE 0x00000001                            // these defines are inverted to the bits in the ARM documentation (also done in NXP code and then matches with the expected ID)
  #define CSSELR_DATA_CACHE        0x00000000
#define CPACR  *(unsigned long *)(CORTEX_M7_BLOCK + 0xd88)               // Co-processor Access Control Register
    #define CPACR_CP10_ACCESS_DENIED          0x00000000
    #define CPACR_CP10_PRIVILEGED_ACCESS_ONLY 0x00100000
    #define CPACR_CP10_FULL_ACCESS            0x00300000
    #define CPACR_CP11_ACCESS_DENIED          0x00000000
    #define CPACR_CP11_PRIVILEGED_ACCESS_ONLY 0x00400000
    #define CPACR_CP11_FULL_ACCESS            0x00c00000

#define MPU_TYPE  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd90)   // MPU type register (read-only)
#define MPU_CTRL  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd94)   // MPU control register
    #define MPU_CTRL_ENABLE        0x00000001                            // enable the MPU
    #define MPU_CTRL_HFNMIENA      0x00000002                            // enable MPU operation during hard fault, NMI and faultmask handlers
    #define MPU_CTRL_PRIVDEFENA    0x00000004                            // enable privileged software access to the default memory map
#define MPU_RNR   *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd98)   // MPU region number register
#define MPU_RBAR  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xd9c)   // MPU region base address register
    #define MPU_RBAR_REGION_0      0x00000000
    #define MPU_RBAR_REGION_1      0x00000001
    #define MPU_RBAR_REGION_2      0x00000002
    #define MPU_RBAR_REGION_3      0x00000003
    #define MPU_RBAR_REGION_4      0x00000004
    #define MPU_RBAR_REGION_5      0x00000005
    #define MPU_RBAR_REGION_6      0x00000006
    #define MPU_RBAR_REGION_7      0x00000007
    #define MPU_RBAR_REGION_8      0x00000008
    #define MPU_RBAR_REGION_9      0x00000009
    #define MPU_RBAR_REGION_10     0x0000000a
    #define MPU_RBAR_REGION_11     0x0000000b
    #define MPU_RBAR_REGION_12     0x0000000c
    #define MPU_RBAR_REGION_13     0x0000000d
    #define MPU_RBAR_REGION_14     0x0000000e
    #define MPU_RBAR_REGION_15     0x0000000f
    #define MPU_RBAR_REGION_MASK   0x0000000f
    #define MPU_RBAR_VALID         0x00000010
#define MPU_RASR  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xda0)   // MPU region attribute and size register
    #define MPU_RASR_ENABLE        0x00000001
    #define MPU_RASR_SIZE_32B      0x00000008                            // smallest region size - N = 5
    #define MPU_RASR_SIZE_64B      0x0000000a                            // N = 6
    #define MPU_RASR_SIZE_128B     0x0000000c                            // N = 7
    #define MPU_RASR_SIZE_256B     0x0000000e                            // N = 8
    #define MPU_RASR_SIZE_512B     0x00000010                            // N = 9
    #define MPU_RASR_SIZE_1k       0x00000012                            // N = 10
    #define MPU_RASR_SIZE_2k       0x00000014                            // N = 11
    #define MPU_RASR_SIZE_4k       0x00000016                            // N = 12
    #define MPU_RASR_SIZE_8k       0x00000018                            // N = 13
    #define MPU_RASR_SIZE_16k      0x0000001a                            // N = 14
    #define MPU_RASR_SIZE_32k      0x0000001c                            // N = 15
    #define MPU_RASR_SIZE_64k      0x0000001e                            // N = 16
    #define MPU_RASR_SIZE_128k     0x00000020                            // N = 17
    #define MPU_RASR_SIZE_256k     0x00000022                            // N = 18
    #define MPU_RASR_SIZE_512k     0x00000024                            // N = 19
    #define MPU_RASR_SIZE_1M       0x00000026                            // N = 20
    #define MPU_RASR_SIZE_2M       0x00000028                            // N = 21
    #define MPU_RASR_SIZE_4M       0x0000002a                            // N = 22
    #define MPU_RASR_SIZE_8M       0x0000002c                            // N = 23
    #define MPU_RASR_SIZE_16M      0x0000002e                            // N = 24
    #define MPU_RASR_SIZE_32M      0x00000030                            // N = 25
    #define MPU_RASR_SIZE_64M      0x00000032                            // N = 26
    #define MPU_RASR_SIZE_128M     0x00000034                            // N = 27
    #define MPU_RASR_SIZE_256M     0x00000036                            // N = 28
    #define MPU_RASR_SIZE_512M     0x00000038                            // N = 29
    #define MPU_RASR_SIZE_1G       0x0000003a                            // N = 30
    #define MPU_RASR_SIZE_4G       0x0000003c                            // largest region size - N = 32
    #define MPU_RASR_SIZE_MASK     0x0000003e
    #define MPU_RASR_SRD_MASK      0x0000ff00
    #define MPU_RASR_B             0x00010000
    #define MPU_RASR_C             0x00020000
    #define MPU_RASR_S             0x00040000                            // shareable
    #define MPU_RASR_TEX_NOT_SHAREABLE_NOT_CACHEABLE_DEVICE                (0x00100000)
    #define MPU_RASR_TEX_NORMAL_NOT_SHAREABLE_OUTER_INNER_WRITEBACK        (0x00000000 | MPU_RASR_C | MPU_RASR_B)
    #define MPU_RASR_TEX_NORMAL_NOT_SHAREABLE_NON_CACHEABLE_MEMORY         (0x00080000)
    #define MPU_RASR_TEX_MASK      0x00380000
    #define MPU_RASR_AP_FULL       0x03000000                            // full RW access for priviledged and unpriviledged
    #define MPU_RASR_AP_READ_ONLY  0x06000000                            // read-only access for priviledged and unpriviledged
    #define MPU_RASR_AP_MASK       0x07000000
    #define MPU_RASR_XN            0x10000000                            // instruction fetches disabled
#define MPU_RBAR_A1  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xda4)// alias of RBAR register
#define MPU_RASR_A1  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xda8)// alias of RASR register
#define MPU_RBAR_A2  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xdac)// alias of RBAR register
#define MPU_RASR_A2  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xdb0)// alias of RASR register
#define MPU_RBAR_A3  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xdb4)// alias of RBAR register
#define MPU_RASR_A3  *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xdb8)// alias of RASR register

#define FPCCR  *(unsigned long *)(CORTEX_M7_BLOCK + 0xf34)               // floating point context control register
    #define __FPU_PRESENT  1
#define ICIALLU *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xf50)     // instruction cache invalidate (write-only)
#define DCISW   *(volatile unsigned long *)(CORTEX_M7_BLOCK + 0xf60)     // data cache invalidate by set/way (write-only)
    #define DCISW_SET_MASK         0x00003ffe
    #define DCISW_SET_SHIFT        5
    #define DCISW_WAY_MASK         0xc0000000
    #define DCISW_WAY_SHIFT        30

    // Cortex debug registers
    //
    #define DHCSR                     *(volatile unsigned long *)(CORTEX_M7_DEBUG + 0x0)
        #define DHCSR_TRCENA          0x01000000                         // trace enable
    #define DCRSR                     *(volatile unsigned long *)(CORTEX_M7_DEBUG + 0x4)
    #define DCRDR                     *(volatile unsigned long *)(CORTEX_M7_DEBUG + 0x8)
    #define DEMCR                     *(volatile unsigned long *)(CORTEX_M7_DEBUG + 0xc)

    // Cortex data watch and trace unit
    //
    #define DWT_CTRL                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0x00) // control register
        #define DWT_CTRL_CYCCNTENA    0x00000001                         // enable the cycle counter
    #define DWT_CYCCNT                *(volatile unsigned long *)(CORTEX_M7_DWT + 0x04) // cycle count register
    #define DWT_CPICNT                *(volatile unsigned long *)(CORTEX_M7_DWT + 0x08) // CPI count register
    #define DWT_EXCCNT                *(volatile unsigned long *)(CORTEX_M7_DWT + 0x0c) // exception overhead count register
    #define DWT_SLEEPVNT              *(volatile unsigned long *)(CORTEX_M7_DWT + 0x10) // sleep count register
    #define DWT_LSUCNT                *(volatile unsigned long *)(CORTEX_M7_DWT + 0x14) // LSU count register
    #define DWT_FOLDCNT               *(volatile unsigned long *)(CORTEX_M7_DWT + 0x18) // folder-instruction count register
    #define DWT_PCSR                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0x1c) // program counter sample regster - read-only
    #define DWT_COMP0                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x20) // compare register 0
    #define DWT_MASK0                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x24) // mask register 0
    #define DWT_FUNCTION0             *(volatile unsigned long *)(CORTEX_M7_DWT + 0x28) // function register 0
    #define DWT_COMP1                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x30) // compare register 1
    #define DWT_MASK1                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x34) // mask register 1
    #define DWT_FUNCTION1             *(volatile unsigned long *)(CORTEX_M7_DWT + 0x38) // function register 1
    #define DWT_COMP2                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x40) // compare register 2
    #define DWT_MASK2                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x44) // mask register 2
    #define DWT_FUNCTION2             *(volatile unsigned long *)(CORTEX_M7_DWT + 0x48) // function register 2
    #define DWT_COMP3                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x50) // compare register 3
    #define DWT_MASK3                 *(volatile unsigned long *)(CORTEX_M7_DWT + 0x54) // mask register 3
    #define DWT_FUNCTION3             *(volatile unsigned long *)(CORTEX_M7_DWT + 0x58) // function register 3
    #define DWT_LAR                   *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfb0) // lock access register - write-only
        #define DWT_LAR_UNLOCK        0xc5acce55                         // unlock code
    #define DWT_LSR                   *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfb4) // lock access register - read-only
    #define DWT_PID4                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfd0) // peripheral identification register 4 - read-only
    #define DWT_PID5                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfd4) // peripheral identification register 5 - read-only
    #define DWT_PID6                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfd8) // peripheral identification register 6 - read-only
    #define DWT_PID7                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfdc) // peripheral identification register 7 - read-only
    #define DWT_PID0                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfe0) // peripheral identification register 0 - read-only
    #define DWT_PID1                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfe4) // peripheral identification register 1 - read-only
    #define DWT_PID2                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfe8) // peripheral identification register 2 - read-only
    #define DWT_PID3                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xfec) // peripheral identification register 3 - read-only
    #define DWT_CID0                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xff0) // component identification register 0 - read-only
    #define DWT_CID1                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xff4) // component identification register 1 - read-only
    #define DWT_CID2                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xff8) // component identification register 2 - read-only
    #define DWT_CID3                  *(volatile unsigned long *)(CORTEX_M7_DWT + 0xffc) // component identification register 3 - read-only
