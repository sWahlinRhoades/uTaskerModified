/**********************************************************************
    Mark Butcher    Bsc (Hons) MPhil MIET

    M.J.Butcher Consulting
    Birchstrasse 20f,    CH-5406, RÃ¼tihof
    Switzerland

    www.uTasker.com    Skype: M_J_Butcher

    ---------------------------------------------------------------------
    File:      usb_Audio.h
    Project:   uTasker project
    ---------------------------------------------------------------------
    Copyright (C) M.J.Butcher Consulting 2004..2020
    *********************************************************************


*/

#if defined AUDIO_DEFINES
    
#endif

#if defined AUDIO_HOST_STRUCT

#endif

#if defined AUDIO_HOST_CONST

#endif

#if defined AUDIO_LOCAL_VARIABLES
    static int iMuteOff = 0;
    static unsigned short usSpeakerVolume = 0;
    static unsigned short usAudioCommand = 0;
    #if defined AUDIO_FFT                                                // {42}
        #define FFT_INPUT_SAMPLES 512                                    // collecting 512 sample
        #if FFT_INPUT_SAMPLES == 512
            #define ARM_CFFT_SR_F32_LENGTH    arm_cfft_sR_f32_len512
        #endif
    static signed short fft_buffer[FFT_INPUT_SAMPLES * 2] = { 0 };       // FFT ping-pong buffer (this buffer is filled by received isochronous data (samples)
    #endif
#endif

#if defined AUDIO_FUNCTIONS
    #if defined USE_USB_AUDIO || defined USE_HS_USB_AUDIO
        #if defined _WINDOWS
#define USB_WATCHDOG    (TICK_RESOLUTION * 32)                           // when simulating use longer timeout to avoid the time firing during tests
        #else
#define USB_WATCHDOG    (AUDIO_BUFFER_COUNT + 4)                         // this period (ms) without isochronous reception causes the monitor to fire in order to silence output and prepare form next synchronisation
        #endif
#define DRIFT_LIMIT_MAX (AUDIO_BUFFER_COUNT * (BUS_CLOCK/1000000))
#define DRIFT_LIMIT_MIN (-DRIFT_LIMIT_MAX)

// DMA interrupt after circular buffer completion - the DMA operation has wrapped around to continue reusing the buffer but 
// this interrupt is used to monitor the relationship between the USB reception (controlled by the USB host time-base) and the audio sink
//
static void buffer_wrap(void)
{
    #define _PLL_COMPENSATION  (PIT_FREERUN_FREQ(SAMPLING_FREQUENCY)/200)// 0.5% adjustment
    #if _PLL_COMPENSATION == 0
        #define PLL_COMPENSATION   1                                     // miniumum
    #else
        #define PLL_COMPENSATION   (_PLL_COMPENSATION)                   // use calculated value
    #endif
    slDelta = ((PIT_MS_DELAY(USB_WATCHDOG) - PIT_CVAL1) - ((PIT_MS_DELAY(USB_WATCHDOG) - PIT_MS_DELAY(USB_WATCHDOG - AUDIO_BUFFER_COUNT))/2)); // present delta between the USB reference interrupt and the DMA buffer interrupt (this should ideally remain close to zero)
    #if defined CLEAR_TEST_OUTPUT
    CLEAR_TEST_OUTPUT();                                                 // set output low as timing monitor
    #endif

    // Adjust the PIT time base to compensate for the deviation to ideal audio delay and so hold synchronision to the host time base
    //
    if (slDelta > DRIFT_LIMIT_MAX) {
        PIT_LDVAL0 = (PIT_FREERUN_FREQ(SAMPLING_FREQUENCY) - PLL_COMPENSATION); // speed up the PIT
    }
    else if (slDelta < DRIFT_LIMIT_MIN) {
        PIT_LDVAL0 = (PIT_FREERUN_FREQ(SAMPLING_FREQUENCY) + PLL_COMPENSATION); // slow down the PIT
    }
    else {
        PIT_LDVAL0 = PIT_FREERUN_FREQ(SAMPLING_FREQUENCY);               // set the exact frequency since the synchronisation is in the optimal region
    }
}

// PIT interrupt when USB isochronous reception stops
//
static void usb_watchdog(void)
{
    PIT_LDVAL0 = PIT_FREERUN_FREQ(SAMPLING_FREQUENCY);                   // ensure that the PIT's center frequency is valid
    PIT_TCTRL1 = 0;                                                      // stop the usb watchdog PIT, which will be started on next reception
    fnDMA_BufferReset(0, DMA_BUFFER_RESET);                              // reset the sink DMA buffer operation ready for next use (disabled)
    slDelta = 0;                                                         // without USB reception the delta value is zero
}

#if defined FRDM_K66F && defined SUPPORT_I2S_SAI && !defined MIC_ONLY
#define DA7212_WRITE_ADDRESS (0x1a << 1)
#define DA7212_READ_ADDRESS  (DA7212_WRITE_ADDRESS | 1)

/***************************************************************************************************/
/* * Register values. */

/******************Status registers*********************/
#define DIALOG7212_STATUS1 0x02
#define DIALOG7212_PLL_STATUS 0x03
#define DIALOG7212_AUX_L_GAIN_STATUS 0x04
#define DIALOG7212_AUX_R_GAIN_STATUS 0x05
#define DIALOG7212_MIC_1_GAIN_STATUS 0x06
#define DIALOG7212_MIC_2_GAIN_STATUS 0x07
#define DIALOG7212_MIXIN_L_GAIN_STATUS 0x08
#define DIALOG7212_MIXIN_R_GAIN_STATUS 0x09
#define DIALOG7212_ADC_L_GAIN_STATUS 0x0A
#define DIALOG7212_ADC_R_GAIN_STATUS 0x0B
#define DIALOG7212_DAC_L_GAIN_STATUS 0x0C
#define DIALOG7212_DAC_R_GAIN_STATUS 0x0D
#define DIALOG7212_HP_L_GAIN_STATUS 0x0E
#define DIALOG7212_HP_R_GAIN_STATUS 0x0F
#define DIALOG7212_LINE_GAIN_STATUS 0x10
/***************System Initialisation Registers************/
#define DIALOG7212_CIF_CTRL 0x1d
#define DIALOG7212_DIG_ROUTING_DAI 0x21
#define DIALOG7212_SR 0x22
#define DIALOG7212_REFERENCES 0x23
#define DIALOG7212_PLL_FRAC_TOP 0x24
#define DIALOG7212_PLL_FRAC_BOT 0x25
#define DIALOG7212_PLL_INTEGER 0x26
#define DIALOG7212_PLL_CTRL 0x27
#define DIALOG7212_DAI_CLK_MODE 0x28
#define DIALOG7212_DAI_CTRL 0x29
#define DIALOG7212_DIG_ROUTING_DAC 0x2A
#define DIALOG7212_ALC_CTRL1 0x2B
/************Input Gain/ Select Filter Registers**********/
#define DIALOG7212_AUX_L_GAIN 0x30
#define DIALOG7212_AUX_R_GAIN 0x31
#define DIALOG7212_MIXIN_L_SELECT 0x32
#define DIALOG7212_MIXIN_R_SELECT 0x33
#define DIALOG7212_MIXIN_L_GAIN 0x34
#define DIALOG7212_MIXIN_R_GAIN 0x35
#define DIALOG7212_ADC_L_GAIN 0x36
#define DIALOG7212_ADC_R_GAIN 0x37
#define DIALOG7212_ADC_FILTERS1 0x38
#define DIALOG7212_MIC_1_GAIN 0x39
#define DIALOG7212_MIC_2_GAIN 0x3A
/************Output Gain/ Select Filter Registers**********/
#define DIALOG7212_DAC_FILTERS5 0x40
#define DIALOG7212_DAC_FILTERS2 0x41
#define DIALOG7212_DAC_FILTERS3 0x42
#define DIALOG7212_DAC_FILTERS4 0x43
#define DIALOG7212_DAC_FILTERS1 0x44
#define DIALOG7212_DAC_L_GAIN 0x45
#define DIALOG7212_DAC_R_GAIN 0x46
#define DIALOG7212_CP_CTRL 0x47
#define DIALOG7212_HP_L_GAIN 0x48
#define DIALOG7212_HP_R_GAIN 0x49
#define DIALOG7212_LINE_GAIN 0x4A
#define DIALOG7212_MIXOUT_L_SELECT 0x4B
#define DIALOG7212_MIXOUT_R_SELECT 0x4C
/**************System Controller Registers(1)*************/
#define DIALOG7212_SYSTEM_MODES_INPUT 0x50
#define DIALOG7212_SYSTEM_MODES_OUTPUT 0x51
/*****************Control Registers(2)********************/
#define DIALOG7212_AUX_L_CTRL 0x60
#define DIALOG7212_AUX_R_CTRL 0x61
#define DIALOG7212_MICBIAS_CTRL 0x62
#define DIALOG7212_MIC_1_CTRL 0x63
#define DIALOG7212_MIC_2_CTRL 0x64
#define DIALOG7212_MIXIN_L_CTRL 0x65
#define DIALOG7212_MIXIN_R_CTRL 0x66
#define DIALOG7212_ADC_L_CTRL 0x67
#define DIALOG7212_ADC_R_CTRL 0x68
#define DIALOG7212_DAC_L_CTRL 0x69
#define DIALOG7212_DAC_R_CTRL 0x6A
#define DIALOG7212_HP_L_CTRL 0x6B
#define DIALOG7212_HP_R_CTRL 0x6C
#define DIALOG7212_LINE_CTRL 0x6D
#define DIALOG7212_MIXOUT_L_CTRL 0x6E
#define DIALOG7212_MIXOUT_R_CTRL 0x6F
/************ Registers**********/

/****************Configuration Registers*****************/
#define DIALOG7212_LDO_CTRL 0x90
#define DIALOG7212_GAIN_RAMP_CTRL 0x92
#define DIALOG7212_MIC_CONFIG 0x93
#define DIALOG7212_PC_COUNT 0x94
#define DIALOG7212_CP_VOL_THRESHOLD1 0x95
#define DIALOG7212_CP_DELAY 0x96
#define DIALOG7212_CP_DETECTOR 0x97
#define DIALOG7212_DAI_OFFSET 0x98
#define DIALOG7212_DIG_CTRL 0x99
#define DIALOG7212_ALC_CTRL2 0x9A
#define DIALOG7212_ALC_CTRL3 0x9B
#define DIALOG7212_ALC_NOISE 0x9C
#define DIALOG7212_ALC_TARGET_MIN 0x9D
#define DIALOG7212_ALC_TARGET_MAX 0x9E
#define DIALOG7212_ALC_GAIN_LIMITS 0x9F
#define DIALOG7212_ALC_ANA_GAIN_LIMITS 0xA0
#define DIALOG7212_ALC_ANTICLIP_CTRL 0xA1
#define DIALOG7212_ALC_ANTICLIP_LEVEL 0xA2
#define DIALOG7212_DAC_NG_SETUP_TIME 0xAF
#define DIALOG7212_DAC_NG_OFF_THRESH 0xB0
#define DIALOG7212_DAC_NG_ON_THRESH 0xB1
#define DIALOG7212_DAC_NG_CTRL 0xB2
//#define DIALOG7212_DAC_NG_SPARE                       0xB3
/************Tone Generation & Beep Registers************/
#define DIALOG7212_TONE_GEN_CFG1 0xB4
#define DIALOG7212_TONE_GEN_CFG2 0xB5
#define DIALOG7212_TONE_GEN_CYCLES 0xB6
#define DIALOG7212_TONE_GEN_FREQ1_L 0xB7
#define DIALOG7212_TONE_GEN_FREQ1_U 0xB8
#define DIALOG7212_TONE_GEN_FREQ2_L 0xB9
#define DIALOG7212_TONE_GEN_FREQ2_U 0xBA
#define DIALOG7212_TONE_GEN_ON_PER 0xBB
#define DIALOG7212_TONE_GEN_OFF_PER 0xBC

/************System Controller Registers(2)*************/
#define DIALOG7212_SYSTEM_STATUS 0xE0

#define DIALOG7212_SYSTEM_ACTIVE 0xFD

/******************Driver DA7212 Macros*****************/

/******************Status registers*********************/
/* DIALOG7212_PLL_STATUS                         0x03*/
#define DIALOG7212_PLL_STATUS_BYPASS_ACTIVE_MASK (1 << 3)
#define DIALOG7212_PLL_STATUS_MCLK_STATUS_MASK (1 << 2)
#define DIALOG7212_PLL_STATUS_SRM_LOCK_MASK (1 << 1)
#define DIALOG7212_PLL_STATUS_LOCK_MASK (1 << 0)

/* DIALOG7212_AUX_L_GAIN_STATUS                  0x04*/
#define DIALOG7212_AUX_L_AMP_GAIN_STATUS_MASK (0x3F)
#define DIALOG7212_AUX_L_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_AUX_L_AMP_GAIN_STATUS(x) (x << DIALOG7212_AUX_L_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_AUX_R_GAIN_STATUS                  0x05*/
#define DIALOG7212_AUX_R_AMP_GAIN_STATUS_MASK (0x3F)
#define DIALOG7212_AUX_R_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_AUX_R_AMP_GAIN_STATUS(x) (x << DIALOG7212_AUX_R_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_MIC_1_GAIN_STATUS                  0x06*/
#define DIALOG7212_MIC_1_AMP_GAIN_STATUS_MASK (0x07)
#define DIALOG7212_MIC_1_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_MIC_1_AMP_GAIN_STATUS(x) (x << DIALOG7212_MIC_1_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_MIC_2_GAIN_STATUS                  0x07*/
#define DIALOG7212_MIC_2_AMP_GAIN_STATUS_MASK (0x07)
#define DIALOG7212_MIC_2_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_MIC_2_AMP_GAIN_STATUS(x) (x << DIALOG7212_MIC_2_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_MIXIN_L_GAIN_STATUS                0x08*/
#define DIALOG7212_MIXIN_L_AMP_GAIN_STATUS_MASK (0x0F)
#define DIALOG7212_MIXIN_L_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_MIXIN_L_AMP_GAIN_STATUS(x) (x << DIALOG7212_MIXIN_L_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_MIXIN_R_GAIN_STATUS                0x09*/
#define DIALOG7212_MIXIN_R_AMP_GAIN_STATUS_MASK (0x0F)
#define DIALOG7212_MIXIN_R_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_MIXIN_R_AMP_GAIN_STATUS(x) (x << DIALOG7212_MIXIN_R_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_ADC_L_GAIN_STATUS                  0x0A*/
#define DIALOG7212_ADC_L_GAIN_STATUS_MASK (0x7F)
#define DIALOG7212_ADC_L_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_ADC_L_GAIN_STATUS_VAL(x) (x << DIALOG7212_ADC_L_GAIN_STATUS_SHIFT)

/* DIALOG7212_ADC_R_GAIN_STATUS                  0x0B*/
#define DIALOG7212_ADC_R_GAIN_STATUS_MASK (0x7F)
#define DIALOG7212_ADC_R_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_ADC_R_GAIN_STATUS_VAL(x) (x << DIALOG7212_ADC_R_GAIN_STATUS_SHIFT)

/* DIALOG7212_DAC_L_GAIN_STATUS                  0x0C*/
#define DIALOG7212_DAC_L_GAIN_STATUS_MASK (0x7F)
#define DIALOG7212_DAC_L_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_DAC_L_GAIN_STATUS_VAL(x) (x << DIALOG7212_DAC_L_GAIN_STATUS_SHIFT)

/* DIALOG7212_DAC_R_GAIN_STATUS                  0x0D*/
#define DIALOG7212_DAC_R_GAIN_STATUS_MASK (0x7F)
#define DIALOG7212_DAC_R_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_DAC_R_GAIN_STATUS_VAL(x) (x << DIALOG7212_DAC_R_GAIN_STATUS_SHIFT)

/* DIALOG7212_HP_L_GAIN_STATUS                   0x0E*/
#define DIALOG7212_HP_L_AMP_GAIN_STATUS_MASK (0x3F)
#define DIALOG7212_HP_L_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_HP_L_AMP_GAIN_STATUS(x) (x << DIALOG7212_HP_L_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_HP_R_GAIN_STATUS                   0x0F*/
#define DIALOG7212_HP_R_AMP_GAIN_STATUS_MASK (0x3F)
#define DIALOG7212_HP_R_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_HP_R_AMP_GAIN_STATUS(x) (x << DIALOG7212_HP_R_AMP_GAIN_STATUS_SHIFT)

/* DIALOG7212_LINE_GAIN_STATUS                   0x10*/
#define DIALOG7212_LINE_AMP_GAIN_STATUS_MASK (0x3F)
#define DIALOG7212_LINE_AMP_GAIN_STATUS_SHIFT (0)
#define DIALOG7212_LINE_AMP_GAIN_STATUS(x) (x << DIALOG7212_LINE_AMP_GAIN_STATUS_SHIFT)

/***************System Initialisation Registers************/

/* DIALOG7212_CIF_CTRL                           0x1d */
#define DIALOG7212_CIF_CTRL_CIF_REG_SOFT_RESET_MASK (1 << 7)
#define DIALOG7212_CIF_CTRL_CIF_I2C_WRITE_MODE_MASK (1 << 0)

/* DIALOG7212_DIG_ROUTING_DAI                    0x21 */
#define DIALOG7212_DIG_ROUTING_DAI_R_SRC_MASK (0x30)
#define DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT (4)
#define DIALOG7212_DIG_ROUTING_DAI_R_SRC_ADC_LEFT (0 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_R_SRC_ADC_RIGHT (1 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_R_SRC_DAI_LEFT (2 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_R_SRC_DAI_RIGHT (3 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_L_SRC_MASK (0x03)
#define DIALOG7212_DIG_ROUTING_DAI_L_SRC_SHIFT (4)
#define DIALOG7212_DIG_ROUTING_DAI_L_SRC_ADC_LEFT (0 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_L_SRC_ADC_RIGHT (1 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_L_SRC_DAI_LEFT (2 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAI_L_SRC_DAI_RIGHT (3 << DIALOG7212_DIG_ROUTING_DAI_R_SRC_SHIFT)

/* DIALOG7212_SR                                 0x22 */
#define DIALOG7212_SR_MASK (0x0F)
#define DIALOG7212_SR_SHIFT (0)
#define DIALOG7212_SR_8KHZ (1 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_11_025KHZ (2 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_12KHZ (3 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_16KHZ (5 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_22KHZ (6 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_24KHZ (7 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_32KHZ (9 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_44_1KHZ (10 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_48KHZ (11 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_88_2KHZ (14 << DIALOG7212_SR_SHIFT)
#define DIALOG7212_SR_96KHZ (15 << DIALOG7212_SR_SHIFT)

/* DIALOG7212_REFERENCES                         0x23 */
#define DIALOG7212_REFERENCES_VMID_FAST_DISCHARGE_MASK (1 << 5)
#define DIALOG7212_REFERENCES_VMID_FAST_CHARGE_MASK (1 << 4)
#define DIALOG7212_REFERENCES_BIAS_EN_MASK (1 << 3)

/* DIALOG7212_PLL_FRAC_TOP                       0x24 */
#define DIALOG7212_PLL_FBDIV_FRAC_TOP_MASK (0x1F)
#define DIALOG7212_PLL_FBDIV_FRAC_TOP_SHIFT (0)
#define DIALOG7212_PLL_FBDIV_FRAC_TOP(x) (x << DIALOG7212_PLL_FBDIV_FRAC_TOP_SHIFT)

/* DIALOG7212_PLL_FRAC_BOT                       0x25 */
#define DIALOG7212_PLL_FBDIV_FRAC_BOT_MASK (0xFF)
#define DIALOG7212_PLL_FBDIV_FRAC_BOT_SHIFT (0)
#define DIALOG7212_PLL_FBDIV_FRAC_BOT(x) (x << DIALOG7212_PLL_FBDIV_FRAC_BOT_SHIFT)

/* DIALOG7212_PLL_INTEGER                        0x26 */
#define DIALOG7212_PLL_FBDIV_INTEGER_MASK (0xFF)
#define DIALOG7212_PLL_FBDIV_INTEGER_SHIFT (0)
#define DIALOG7212_PLL_FBDIV_INTEGER_BOT(x) (x << DIALOG7212_PLL_FBDIV_INTEGER_SHIFT)

/* DIALOG7212_PLL_CTRL                           0x27 */
#define DIALOG7212_PLL_EN_MASK (1 << 7)
#define DIALOG7212_PLL_SRM_EN_MASK (1 << 6)
#define DIALOG7212_PLL_32K_MODE_MASK (1 << 5)
#define DIALOG7212_PLL_MCLKSQR_EN_MASK (1 << 4)
#define DIALOG7212_PLL_INDIV_MASK (0x06)
#define DIALOG7212_PLL_INDIV_SHIFT (2)
#define DIALOG7212_PLL_INDIV_2_10MHZ (0 << DIALOG7212_PLL_INDIV_SHIFT)
#define DIALOG7212_PLL_INDIV_10_20MHZ (1 << DIALOG7212_PLL_INDIV_SHIFT)
#define DIALOG7212_PLL_INDIV_20_40MHZ (2 << DIALOG7212_PLL_INDIV_SHIFT)
#define DIALOG7212_PLL_INDIV_40_80MHZ (3 << DIALOG7212_PLL_INDIV_SHIFT)

/* DIALOG7212_DAI_CLK_MODE                       0x28 */
#define DIALOG7212_DAI_CLK_EN_MASK (1 << 7)
#define DIALOG7212_DAI_WCLK_POL_MASK (1 << 3)
#define DIALOG7212_DAI_CLK_POL_MASK (1 << 2)
#define DIALOG7212_DAI_BCLKS_PER_WCLK_MASK (0x03)
#define DIALOG7212_DAI_BCLKS_PER_WCLK_SHIFT (0)
#define DIALOG7212_DAI_BCLKS_PER_WCLK_BCLK32 (0 << DIALOG7212_DAI_BCLKS_PER_WCLK_SHIFT)
#define DIALOG7212_DAI_BCLKS_PER_WCLK_BCLK64 (1 << DIALOG7212_DAI_BCLKS_PER_WCLK_SHIFT)
#define DIALOG7212_DAI_BCLKS_PER_WCLK_BCLK128 (2 << DIALOG7212_DAI_BCLKS_PER_WCLK_SHIFT)
#define DIALOG7212_DAI_BCLKS_PER_WCLK_BCLK256 (3 << DIALOG7212_DAI_BCLKS_PER_WCLK_SHIFT)

/* DIALOG7212_DAI_CTRL                           0x29 */
#define DIALOG7212_DAI_EN_MASK (1 << 7)
#define DIALOG7212_DAI_OE_MASK (1 << 6)
#define DIALOG7212_DAI_TDM_MODE_EN_MASK (1 << 5)
#define DIALOG7212_DAI_MONO_MODE_MASK (1 << 4)
#define DIALOG7212_DAI_WORD_LENGTH_MASK (0x06)
#define DIALOG7212_DAI_WORD_LENGTH_SHIFT (2)
#define DIALOG7212_DAI_WORD_LENGTH_16B (0 << DIALOG7212_DAI_WORD_LENGTH_SHIFT)
#define DIALOG7212_DAI_WORD_LENGTH_20B (1 << DIALOG7212_DAI_WORD_LENGTH_SHIFT)
#define DIALOG7212_DAI_WORD_LENGTH_24B (2 << DIALOG7212_DAI_WORD_LENGTH_SHIFT)
#define DIALOG7212_DAI_WORD_LENGTH_32B (3 << DIALOG7212_DAI_WORD_LENGTH_SHIFT)
#define DIALOG7212_DAI_FORMAT_MASK (0x03)
#define DIALOG7212_DAI_FORMAT_SHIFT (0)
#define DIALOG7212_DAI_FORMAT_I2S_MODE (0 << DIALOG7212_DAI_FORMAT_SHIFT)
#define DIALOG7212_DAI_FORMAT_LEFT_JUSTIFIED (1 << DIALOG7212_DAI_FORMAT_SHIFT)
#define DIALOG7212_DAI_FORMAT_RIGTH_JUSTIFIED (2 << DIALOG7212_DAI_FORMAT_SHIFT)
#define DIALOG7212_DAI_FORMAT_DSP_MODE (3 << DIALOG7212_DAI_FORMAT_SHIFT)

/* DIALOG7212_DIG_ROUTING_DAC                    0x2A */
#define DIALOG7212_DIG_ROUTING_DAC_R_MONO_MASK (1 << 7)
#define DIALOG7212_DIG_ROUTING_DAC_R_RSC_MASK (0x30)
#define DIALOG7212_DIG_ROUTING_DAC_R_RSC_SHIFT (4)
#define DIALOG7212_DIG_ROUTING_DAC_R_RSC_ADC_L_OUTPUT (0 << DIALOG7212_DIG_ROUTING_DAC_R_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_R_RSC_ADC_R_OUTPUT (1 << DIALOG7212_DIG_ROUTING_DAC_R_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_R_RSC_DAC_L (2 << DIALOG7212_DIG_ROUTING_DAC_R_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_R_RSC_DAC_R (3 << DIALOG7212_DIG_ROUTING_DAC_R_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_L_MONO_MASK (1 << 3)
#define DIALOG7212_DIG_ROUTING_DAC_L_RSC_MASK (0x03)
#define DIALOG7212_DIG_ROUTING_DAC_L_RSC_SHIFT (0)
#define DIALOG7212_DIG_ROUTING_DAC_L_RSC_ADC_L_OUTPUT (0 << DIALOG7212_DIG_ROUTING_DAC_L_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_L_RSC_ADC_R_OUTPUT (1 << DIALOG7212_DIG_ROUTING_DAC_L_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_L_RSC_DAC_L (2 << DIALOG7212_DIG_ROUTING_DAC_L_RSC_SHIFT)
#define DIALOG7212_DIG_ROUTING_DAC_L_RSC_DAC_R (3 << DIALOG7212_DIG_ROUTING_DAC_L_RSC_SHIFT)

/* DIALOG7212_ALC_CTRL1                          0x2B */
#define DIALOG7212_ALC_R_EN_MASK (1 << 7)
#define DIALOG7212_ALC_CALIB_OVERFLOW_MASK (1 << 5)
#define DIALOG7212_ALC_AUTO_CALIB_EN_MASK (1 << 4)
#define DIALOG7212_ALC_L_EN_MASK (1 << 3)
#define DIALOG7212_ALC_CALIB_MODE_MASK (1 << 2)
#define DIALOG7212_ALC_SYNC_MODE_MASK (1 << 1)
#define DIALOG7212_ALC_OFFSET_EN_MASK (1 << 0)

/************Input Gain/ Select Filter Registers**********/
/* DIALOG7212_AUX_L_GAIN                         0x30 */
#define DIALOG7212_AUX_L_AMP_GAIN_MASK (0x3F)
#define DIALOG7212_AUX_L_AMP_GAIN_SHIFT (0)
#define DIALOG7212_AUX_L_AMP_GAIN(x) (x << DIALOG7212_AUX_L_AMP_GAIN_SHIFT)

/* DIALOG7212_AUX_R_GAIN                         0x31 */
#define DIALOG7212_AUX_R_AMP_GAIN_MASK (0x3F)
#define DIALOG7212_AUX_R_AMP_GAIN_SHIFT (0)
#define DIALOG7212_AUX_R_AMP_GAIN(x) (x << DIALOG7212_AUX_R_AMP_GAIN_SHIFT)

/* DIALOG7212_MIXIN_L_SELECT                     0x32 */
#define DIALOG7212_MIXIN_L_SELECT_DMIC_L_EN_MASK (1 << 7)
#define DIALOG7212_MIXIN_L_SELECT_MIXING_R_MASK (1 << 3)
#define DIALOG7212_MIXIN_L_SELECT_MIC2_SEL_MASK (1 << 2)
#define DIALOG7212_MIXIN_L_SELECT_MIC1_SEL_MASK (1 << 1)
#define DIALOG7212_MIXIN_L_SELECT_AUX_L_SEL_MASK (1 << 0)

/* DIALOG7212_MIXIN_R_SELECT                     0x33 */
#define DIALOG7212_MIXIN_R_SELECT_DMIC_R_EN_MASK (1 << 7)
#define DIALOG7212_MIXIN_R_SELECT_MIXING_L_MASK (1 << 3)
#define DIALOG7212_MIXIN_R_SELECT_MIC2_SEL_MASK (1 << 2)
#define DIALOG7212_MIXIN_R_SELECT_MIC1_SEL_MASK (1 << 1)
#define DIALOG7212_MIXIN_R_SELECT_AUX_R_SEL_MASK (1 << 0)

/* DIALOG7212_MIXIN_L_GAIN                       0x34 */
#define DIALOG7212_MIXIN_L_AMP_GAIN_MASK (0x0F)
#define DIALOG7212_MIXIN_L_AMP_GAIN_SHIFT (0)
#define DIALOG7212_MIXIN_L_AMP_GAIN(x) (x << DIALOG7212_MIXIN_L_AMP_GAIN_SHIFT)

/* DIALOG7212_MIXIN_R_GAIN                       0x35 */
#define DIALOG7212_MIXIN_R_AMP_GAIN_MASK (0x0F)
#define DIALOG7212_MIXIN_R_AMP_GAIN_SHIFT (0)
#define DIALOG7212_MIXIN_R_AMP_GAIN(x) (x << DIALOG7212_MIXIN_R_AMP_GAIN_SHIFT)

/* DIALOG7212_ADC_L_GAIN                         0x36 */
#define DIALOG7212_ADC_L_DIGITAL_GAIN_MASK (0x7F)
#define DIALOG7212_ADC_L_DIGITAL_GAIN_SHIFT (0)
#define DIALOG7212_ADC_L_DIGITAL_GAIN(x) (x << DIALOG7212_ADC_L_DIGITAL_GAIN_SHIFT)

/* DIALOG7212_ADC_R_GAIN                         0x37 */
#define DIALOG7212_ADC_R_DIGITAL_GAIN_MASK (0x7F)
#define DIALOG7212_ADC_R_DIGITAL_GAIN_SHIFT (0)
#define DIALOG7212_ADC_R_DIGITAL_GAIN(x) (x << DIALOG7212_ADC_R_DIGITAL_GAIN_SHIFT)

/* DIALOG7212_ADC_FILTERS1                       0x38 */
#define DIALOG7212_ADC_FILTERS1_ADC_HPF_EN_MASK (1 << 7)
#define DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_MASK (0x30)
#define DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_SHIFT (5)
#define DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_2HZ (0 << DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_4HZ (1 << DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_8HZ (2 << DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_16HZ (3 << DIALOG7212_ADC_FILTERS1_ADC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_EN_MASK (1 << 3)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_MASK (0x07)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT (0)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_2_5HZ (0 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_25HZ (1 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_50HZ (2 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_100HZ (3 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_150HZ (4 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_200HZ (5 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_300HZ (6 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_400HZ (7 << DIALOG7212_ADC_FILTERS1_ADC_VOICE_HPF_CORNER_SHIFT)

/* DIALOG7212_MIC_1_GAIN                         0x39 */
#define DIALOG7212_MIC_1_AMP_GAIN_MASK (0x07)
#define DIALOG7212_MIC_1_AMP_GAIN_SHIFT (0)
#define DIALOG7212_MIC_1_AMP_GAIN_N6DB (0 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_0DB (1 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_P6DB (2 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_P12DB (3 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_P18DB (4 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_P24DB (5 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_P30DB (6 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_1_AMP_GAIN_P36DB (7 << DIALOG7212_MIC_1_AMP_GAIN_SHIFT)

/* DIALOG7212_MIC_2_GAIN                         0x3A */
#define DIALOG7212_MIC_2_AMP_GAIN_MASK (0x07)
#define DIALOG7212_MIC_2_AMP_GAIN_SHIFT (0)
#define DIALOG7212_MIC_2_AMP_GAIN_N6DB (0 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_0DB (1 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_P6DB (2 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_P12DB (3 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_P18DB (4 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_P24DB (5 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_P30DB (6 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)
#define DIALOG7212_MIC_2_AMP_GAIN_P36DB (7 << DIALOG7212_MIC_2_AMP_GAIN_SHIFT)

/************Output Gain/ Select Filter Registers**********/
/* DIALOG7212_DAC_FILTERS5                       0x40 */
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_EN_MASK (1 << 7)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_MASK (0x07)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT (4)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_1 (0 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_2 (1 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_4 (2 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_8 (3 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_16 (4 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_32 (5 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)
#define DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_64 (6 << DIALOG7212_DAC_FILTERS5_SOFTMUTE_RATE_SHIFT)

/* DIALOG7212_DAC_FILTERS2                       0x41 */
#define DIALOG7212_DAC_FILTERS2_EQ_BAND2_MASK (0xF0)
#define DIALOG7212_DAC_FILTERS2_EQ_BAND2_SHIFT (4)
#define DIALOG7212_DAC_FILTERS2_EQ_BAND2(x) (x << DIALOG7212_DAC_FILTERS2_EQ_BAND2_SHIFT)
#define DIALOG7212_DAC_FILTERS2_EQ_BAND1_MASK (0x0F)
#define DIALOG7212_DAC_FILTERS2_EQ_BAND1_SHIFT (0)
#define DIALOG7212_DAC_FILTERS2_EQ_BAND1(x) (x << DIALOG7212_DAC_FILTERS2_EQ_BAND1_SHIFT)

/* DIALOG7212_DAC_FILTERS3                       0x42 */
#define DIALOG7212_DAC_FILTERS3_EQ_BAND4_MASK (0xF0)
#define DIALOG7212_DAC_FILTERS3_EQ_BAND4_SHIFT (4)
#define DIALOG7212_DAC_FILTERS3_EQ_BAND4(x) (x << DIALOG7212_DAC_FILTERS2_EQ_BAND4_SHIFT)
#define DIALOG7212_DAC_FILTERS3_EQ_BAND3_MASK (0x0F)
#define DIALOG7212_DAC_FILTERS3_EQ_BAND3_SHIFT (0)
#define DIALOG7212_DAC_FILTERS3_EQ_BAND3(x) (x << DIALOG7212_DAC_FILTERS2_EQ_BAND3_SHIFT)

/* DIALOG7212_DAC_FILTERS4                       0x43 */
#define DIALOG7212_DAC_FILTERS4_EQ_EN_MASK (1 << 7)
#define DIALOG7212_DAC_FILTERS4_EQ_BAND5_MASK (0x0F)
#define DIALOG7212_DAC_FILTERS4_EQ_BAND5_SHIFT (0)
#define DIALOG7212_DAC_FILTERS4_EQ_BAND5(x) (x << DIALOG7212_DAC_FILTERS2_EQ_BAND5_SHIFT)

/* DIALOG7212_DAC_FILTERS1                       0x44 */
#define DIALOG7212_DAC_FILTERS1_HPF_EN_MASK (1 << 7)
#define DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_MASK (0x30)
#define DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_SHIFT (5)
#define DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_2HZ (0 << DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_4HZ (1 << DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_8HZ (2 << DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_16HZ (3 << DIALOG7212_DAC_FILTERS1_DAC_AUDIO_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_EN_MASK (1 << 3)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_MASK (0x07)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT (0)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_2_5HZ (0 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_25HZ (1 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_50HZ (2 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_100HZ (3 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_150HZ (4 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_200HZ (5 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_300HZ (6 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)
#define DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_400HZ (7 << DIALOG7212_DAC_FILTERS1_DAC_VOICE_HPF_CORNER_SHIFT)

/* DIALOG7212_DAC_L_GAIN                         0x45 */
#define DIALOG7212_DAC_L_DIGITAL_GAIN_MASK (0x7F)
#define DIALOG7212_DAC_L_DIGITAL_GAIN_SHIFT (0)
#define DIALOG7212_DAC_L_DIGITAL_GAIN(x) (x << DIALOG7212_DAC_L_DIGITAL_GAIN_SHIFT)

/* DIALOG7212_DAC_R_GAIN                         0x46 */
#define DIALOG7212_DAC_R_DIGITAL_GAIN_MASK (0x7F)
#define DIALOG7212_DAC_R_DIGITAL_GAIN_SHIFT (0)
#define DIALOG7212_DAC_R_DIGITAL_GAIN(x) (x << DIALOG7212_DAC_R_DIGITAL_GAIN_SHIFT)

/* DIALOG7212_CP_CTRL                            0x47 */
#define DIALOG7212_CP_CTRL_EN_MASK (1 << 7)
#define DIALOG7212_CP_CTRL_SMALL_SWIT_CH_FREQ_EN_MASK (1 << 6)
#define DIALOG7212_CP_CTRL_MCHANGE_MASK (0x30)
#define DIALOG7212_CP_CTRL_MCHANGE_SHIFT (4)
#define DIALOG7212_CP_CTRL_MCHANGE_CP_MOD (0 << DIALOG7212_CP_CTRL_MCHANGE_SHIFT)
#define DIALOG7212_CP_CTRL_MCHANGE_PGA (1 << DIALOG7212_CP_CTRL_MCHANGE_SHIFT)
#define DIALOG7212_CP_CTRL_MCHANGE_DAC (2 << DIALOG7212_CP_CTRL_MCHANGE_SHIFT)
#define DIALOG7212_CP_CTRL_MCHANGE_OUTPUT (3 << DIALOG7212_CP_CTRL_MCHANGE_SHIFT)
#define DIALOG7212_CP_CTRL_MOD_MASK (0x0C)
#define DIALOG7212_CP_CTRL_MOD_SHIFT (2)
#define DIALOG7212_CP_CTRL_MOD_STANDBY (0 << DIALOG7212_CP_CTRL_MOD_SHIFT)
#define DIALOG7212_CP_CTRL_MOD_CPVDD_2 (2 << DIALOG7212_CP_CTRL_MOD_SHIFT)
#define DIALOG7212_CP_CTRL_MOD_CPVDD_1 (3 << DIALOG7212_CP_CTRL_MOD_SHIFT)
#define DIALOG7212_CP_CTRL_ANALOG_VLL_MASK (0x03)
#define DIALOG7212_CP_CTRL_ANALOG_VLL_SHIFT (0)
#define DIALOG7212_CP_CTRL_ANALOG_VLL_NO_FEEDBACK (0 << DIALOG7212_CP_CTRL_ANALOG_VLL_SHIFT)
#define DIALOG7212_CP_CTRL_ANALOG_VLL_LV_BOOSTS_CP (1 << DIALOG7212_CP_CTRL_ANALOG_VLL_SHIFT)
#define DIALOG7212_CP_CTRL_ANALOG_VLL_LV_RESTART_CP (2 << DIALOG7212_CP_CTRL_ANALOG_VLL_SHIFT)

/* DIALOG7212_HP_L_GAIN                          0x48 */
#define DIALOG7212_HP_L_AMP_GAIN_MASK (0x3F)
#define DIALOG7212_HP_L_AMP_GAIN_SHIFT (0)
#define DIALOG7212_HP_L_AMP_GAIN(x) (x << DIALOG7212_HP_L_AMP_GAIN_SHIFT)

/* DIALOG7212_HP_R_GAIN                          0x49 */
#define DIALOG7212_HP_R_AMP_GAIN_MASK (0x3F)
#define DIALOG7212_HP_R_AMP_GAIN_SHIFT (0)
#define DIALOG7212_HP_R_AMP_GAIN(x) (x << DIALOG7212_HP_R_AMP_GAIN_SHIFT)

/* DIALOG7212_LINE_GAIN                          0x4A */
#define DIALOG7212_LINE_AMP_GAIN_MASK (0x3F)
#define DIALOG7212_LINE_AMP_GAIN_SHIFT (0)
#define DIALOG7212_LINE_AMP_GAIN(x) (x << DIALOG7212_LINE_AMP_GAIN_SHIFT)

/* DIALOG7212_MIXOUT_L_SELECT                    0x4B */
#define DIALOG7212_MIXOUT_L_SELECT_MIXIN_R_INV_MASK (1 << 6)
#define DIALOG7212_MIXOUT_L_SELECT_MIXIN_L_INV_MASK (1 << 5)
#define DIALOG7212_MIXOUT_L_SELECT_AUX_L_INV_MASK (1 << 4)
#define DIALOG7212_MIXOUT_L_SELECT_DAC_L_MASK (1 << 3)
#define DIALOG7212_MIXOUT_L_SELECT_MIXIN_R_MASK (1 << 2)
#define DIALOG7212_MIXOUT_L_SELECT_MIXIN_L_MASK (1 << 1)
#define DIALOG7212_MIXOUT_L_SELECT_AUX_L_MASK (1 << 0)

/* DIALOG7212_MIXOUT_R_SELECT                    0x4C */
#define DIALOG7212_MIXOUT_R_SELECT_MIXIN_L_INV_MASK (1 << 6)
#define DIALOG7212_MIXOUT_R_SELECT_MIXIN_R_INV_MASK (1 << 5)
#define DIALOG7212_MIXOUT_R_SELECT_AUX_R_INV_MASK (1 << 4)
#define DIALOG7212_MIXOUT_R_SELECT_DAC_R_MASK (1 << 3)
#define DIALOG7212_MIXOUT_R_SELECT_MIXIN_L_MASK (1 << 2)
#define DIALOG7212_MIXOUT_R_SELECT_MIXIN_R_MASK (1 << 1)
#define DIALOG7212_MIXOUT_R_SELECT_AUX_R_MASK (1 << 0)

/**************System Controller Registers(1)*************/
/* DIALOG7212_SYSTEM_MODES_INPUT                 0x50 */
#define DIALOG7212_SYSTEM_MODES_INPUT_ADC_R_MASK (1 << 7)
#define DIALOG7212_SYSTEM_MODES_INPUT_ADC_L_MASK (1 << 6)
#define DIALOG7212_SYSTEM_MODES_INPUT_MIXIN_R_MASK (1 << 5)
#define DIALOG7212_SYSTEM_MODES_INPUT_MIXIN_L_MASK (1 << 4)
#define DIALOG7212_SYSTEM_MODES_INPUT_MIC_2_MASK (1 << 3)
#define DIALOG7212_SYSTEM_MODES_INPUT_MIC_1_MASK (1 << 2)
#define DIALOG7212_SYSTEM_MODES_INPUT_MIC_BIAS_MASK (1 << 1)
#define DIALOG7212_SYSTEM_MODES_INPUT_MODE_SUBMIT_MASK (1 << 0)

/* DIALOG7212_SYSTEM_MODES_OUTPUT                0x51 */
#define DIALOG7212_SYSTEM_MODES_OUTPUT_DAC_R_MASK (1 << 7)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_DAC_L_MASK (1 << 6)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_HP_R_MASK (1 << 5)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_HP_L_MASK (1 << 4)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_LINE_MASK (1 << 3)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_AUX_R_MASK (1 << 2)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_AUX_L_MASK (1 << 1)
#define DIALOG7212_SYSTEM_MODES_OUTPUT_MODE_SUBMIT_MASK (1 << 0)

/*****************Control Registers(2)********************/
/* DIALOG7212_AUX_L_CTRL                         0x60 */
#define DIALOG7212_AUX_L_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_AUX_L_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_AUX_L_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_EN_MASK (1 << 4)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_MASK (0x0C)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_SHIFT (2)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_INPUT_AUX_L (0 << DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_SHIFT)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_INPUT_AUX_L_IF (1 << DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_SHIFT)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_NO_ZC_POSSBLE (2 << DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_SHIFT)
#define DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_OUTPUT_AUX_L (3 << DIALOG7212_AUX_L_CTRL_AMP_ZC_SEL_SHIFT)

/* DIALOG7212_AUX_R_CTRL                         0x61 */
#define DIALOG7212_AUX_R_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_AUX_R_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_AUX_R_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_EN_MASK (1 << 4)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_MASK (0x0C)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_SHIFT (2)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_INPUT_AUX_R (0 << DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_SHIFT)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_INPUT_AUX_R_IF (1 << DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_SHIFT)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_NO_ZC_POSSBLE (2 << DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_SHIFT)
#define DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_OUTPUT_AUX_R (3 << DIALOG7212_AUX_R_CTRL_AMP_ZC_SEL_SHIFT)

/* DIALOG7212_MICBIAS_CTRL                       0x62 */
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_EN_MASK (1 << 7)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_LEVEL_MASK (0x30)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_SHIFT (4)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_1_6V (0 << DIALOG7212_MICBIAS_CTRL_MICBIAS2_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_2_2V (1 << DIALOG7212_MICBIAS_CTRL_MICBIAS2_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_2_5V (2 << DIALOG7212_MICBIAS_CTRL_MICBIAS2_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS2_3_0V (3 << DIALOG7212_MICBIAS_CTRL_MICBIAS2_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_EN_MASK (1 << 3)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_LEVEL_MASK (0x03)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_SHIFT (0)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_1_6V (0 << DIALOG7212_MICBIAS_CTRL_MICBIAS1_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_2_2V (1 << DIALOG7212_MICBIAS_CTRL_MICBIAS1_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_2_5V (2 << DIALOG7212_MICBIAS_CTRL_MICBIAS1_SHIFT)
#define DIALOG7212_MICBIAS_CTRL_MICBIAS1_3_0V (3 << DIALOG7212_MICBIAS_CTRL_MICBIAS1_SHIFT)

/* DIALOG7212_MIC_1_CTRL                         0x63 */
#define DIALOG7212_MIC_1_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_MIC_1_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_MASK (0x0C)
#define DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_SHIFT (2)
#define DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_DIFFERENTIAL (0 << DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_SHIFT)
#define DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_MIC_1_P (1 << DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_SHIFT)
#define DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_MIC_1_N (2 << DIALOG7212_MIC_1_CTRL_AMP_IN_SEL_SHIFT)

/* DIALOG7212_MIC_2_CTRL                         0x64 */
#define DIALOG7212_MIC_2_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_MIC_2_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_MASK (0x0C)
#define DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_SHIFT (2)
#define DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_DIFFERENTIAL (0 << DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_SHIFT)
#define DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_MIC_2_P (1 << DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_SHIFT)
#define DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_MIC_2_N (2 << DIALOG7212_MIC_2_CTRL_AMP_IN_SEL_SHIFT)

/* DIALOG7212_MIXIN_L_CTRL                       0x65 */
#define DIALOG7212_MIXIN_L_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_MIXIN_L_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_MIXIN_L_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_MIXIN_L_CTRL_AMP_ZC_EN_MASK (1 << 4)
#define DIALOG7212_MIXIN_L_CTRL_AMP_MIX_EN_MASK (1 << 3)

/* DIALOG7212_MIXIN_R_CTRL                       0x66 */
#define DIALOG7212_MIXIN_R_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_MIXIN_R_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_MIXIN_R_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_MIXIN_R_CTRL_AMP_ZC_EN_MASK (1 << 4)
#define DIALOG7212_MIXIN_R_CTRL_AMP_MIX_EN_MASK (1 << 3)

/* DIALOG7212_ADC_L_CTRL                         0x67 */
#define DIALOG7212_ADC_L_CTRL_ADC_EN_MASK (1 << 7)
#define DIALOG7212_ADC_L_CTRL_ADC_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_ADC_L_CTRL_ADC_RAMP_EN_MASK (1 << 5)

/* DIALOG7212_ADC_R_CTRL                         0x68 */
#define DIALOG7212_ADC_R_CTRL_ADC_EN_MASK (1 << 7)
#define DIALOG7212_ADC_R_CTRL_ADC_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_ADC_R_CTRL_ADC_RAMP_EN_MASK (1 << 5)

/* DIALOG7212_DAC_L_CTRL                         0x69 */
#define DIALOG7212_DAC_L_CTRL_ADC_EN_MASK (1 << 7)
#define DIALOG7212_DAC_L_CTRL_ADC_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_DAC_L_CTRL_ADC_RAMP_EN_MASK (1 << 5)

/* DIALOG7212_DAC_R_CTRL                         0x6A */
#define DIALOG7212_DAC_R_CTRL_ADC_EN_MASK (1 << 7)
#define DIALOG7212_DAC_R_CTRL_ADC_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_DAC_R_CTRL_ADC_RAMP_EN_MASK (1 << 5)

/* DIALOG7212_HP_L_CTRL                          0x6B */
#define DIALOG7212_HP_L_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_HP_L_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_HP_L_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_HP_L_CTRL_AMP_ZC_EN_MASK (1 << 4)
#define DIALOG7212_HP_L_CTRL_AMP_OE_MASK (1 << 3)
#define DIALOG7212_HP_L_CTRL_AMP_MIN_GAIN_EN_MASK (1 << 2)

/* DIALOG7212_HP_R_CTRL                          0x6C */
#define DIALOG7212_HP_R_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_HP_R_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_HP_R_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_HP_R_CTRL_AMP_ZC_EN_MASK (1 << 4)
#define DIALOG7212_HP_R_CTRL_AMP_OE_MASK (1 << 3)
#define DIALOG7212_HP_R_CTRL_AMP_MIN_GAIN_EN_MASK (1 << 2)

/* DIALOG7212_LINE_CTRL                          0x6D */
#define DIALOG7212_LINE_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_LINE_CTRL_AMP_MUTE_EN_MASK (1 << 6)
#define DIALOG7212_LINE_CTRL_AMP_RAMP_EN_MASK (1 << 5)
#define DIALOG7212_LINE_CTRL_AMP_OE_MASK (1 << 3)
#define DIALOG7212_LINE_CTRL_AMP_MIN_GAIN_EN_MASK (1 << 2)

/* DIALOG7212_MIXOUT_L_CTRL                      0x6E */
#define DIALOG7212_MIXOUT_L_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_MIXOUT_L_CTRL_AMP_SOFT_MIX_EN_MASK (1 << 4)
#define DIALOG7212_MIXOUT_L_CTRL_AMP_MIX_EN_MASK (1 << 3)

/* DIALOG7212_MIXOUT_R_CTRL                      0x6F */
#define DIALOG7212_MIXOUT_R_CTRL_AMP_EN_MASK (1 << 7)
#define DIALOG7212_MIXOUT_R_CTRL_AMP_SOFT_MIX_EN_MASK (1 << 4)
#define DIALOG7212_MIXOUT_R_CTRL_AMP_MIX_EN_MASK (1 << 3)

/*****************Configuration Registers*****************/
/* DIALOG7212_LDO_CTRL                           0x90 */
#define DIALOG7212_LDO_CTRL_EN_MASK (1 << 7)
#define DIALOG7212_LDO_CTRL_LEVEL_SELECT_MASK (0x30)
#define DIALOG7212_LDO_CTRL_LEVEL_SELECT_SHIFT (4)
#define DIALOG7212_LDO_CTRL_LEVEL_SELECT_1_05V (0 << DIALOG7212_LDO_CTRL_LEVEL_SELECT_SHIFT)
#define DIALOG7212_LDO_CTRL_LEVEL_SELECT_1_10V (1 << DIALOG7212_LDO_CTRL_LEVEL_SELECT_SHIFT)
#define DIALOG7212_LDO_CTRL_LEVEL_SELECT_1_20V (2 << DIALOG7212_LDO_CTRL_LEVEL_SELECT_SHIFT)
#define DIALOG7212_LDO_CTRL_LEVEL_SELECT_1_40V (3 << DIALOG7212_LDO_CTRL_LEVEL_SELECT_SHIFT)

/* DIALOG7212_GAIN_RAMP_CTRL                     0x92 */
#define DIALOG7212_GAIN_RAMP_CTRL_RATE_MASK (0x03)
#define DIALOG7212_GAIN_RAMP_CTRL_RATE_SHIFT (0)
#define DIALOG7212_GAIN_RAMP_CTRL_RATE_NR_DIV_8 (0 << DIALOG7212_GAIN_RAMP_CTRL_RATE_SHIFT)
#define DIALOG7212_GAIN_RAMP_CTRL_RATE_NR_DIV_16 (1 << DIALOG7212_GAIN_RAMP_CTRL_RATE_SHIFT)
#define DIALOG7212_GAIN_RAMP_CTRL_RATE_NR_MUL_16 (2 << DIALOG7212_GAIN_RAMP_CTRL_RATE_SHIFT)
#define DIALOG7212_GAIN_RAMP_CTRL_RATE_NR_MUL_32 (3 << DIALOG7212_GAIN_RAMP_CTRL_RATE_SHIFT)

/* DIALOG7212_MIC_CONFIG                         0x93 */
#define DIALOG7212_MIC_CONFIG_DMIC_CLK_RATE_MASK (1 << 2)
#define DIALOG7212_MIC_CONFIG_DMIC_SAMPLEPHASE_MASK (1 << 1)
#define DIALOG7212_MIC_CONFIG_DMIC_DATA_SEL_MASK (1 << 0)

/* DIALOG7212_PC_COUNT                           0x94 */
#define DIALOG7212_PC_COUNT_RESYNC_MASK (1 << 1)
#define DIALOG7212_PC_COUNT_FREERU_MASK (1 << 0)

/* DIALOG7212_CP_VOL_THRESHOLD1                  0x95 */
#define DIALOG7212_CP_VOL_THRESHOLD1_VDD2_MASK (0x3F)
#define DIALOG7212_CP_VOL_THRESHOLD1_VDD2_SHIFT (0)
#define DIALOG7212_CP_VOL_THRESHOLD1_VDD2(x) (x << DIALOG7212_CP_VOL_THRESHOLD1_VDD2_SHIFT)

/* DIALOG7212_CP_DELAY                           0x96 */
#define DIALOG7212_CP_DELAY_ON_OFF_MASK (0xC0)
#define DIALOG7212_CP_DELAY_ON_OFF_SHIFT (6)
#define DIALOG7212_CP_DELAY_ON_OFF_LIMITER_ON (0 << DIALOG7212_CP_DELAY_ON_OFF_SHIFT)
#define DIALOG7212_CP_DELAY_ON_OFF_LIMITER_OFF (1 << DIALOG7212_CP_DELAY_ON_OFF_SHIFT)
#define DIALOG7212_CP_DELAY_ON_OFF_LIMITER_AUT (2 << DIALOG7212_CP_DELAY_ON_OFF_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_MASK (0x38)
#define DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT (3)
#define DIALOG7212_CP_DELAY_TAU_DELAY_0MS (0 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_2MS (1 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_4MS (2 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_16MS (3 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_64MS (4 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_128MS (5 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_256MS (6 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_TAU_DELAY_512MS (7 << DIALOG7212_CP_DELAY_TAU_DELAY_SHIFT)
#define DIALOG7212_CP_DELAY_FCONTROL_MASK (0x07)
#define DIALOG7212_CP_DELAY_FCONTROL_SHIFT (0)
#define DIALOG7212_CP_DELAY_FCONTROL_1MHZ (0 << DIALOG7212_CP_DELAY_FCONTROL_SHIFT)
#define DIALOG7212_CP_DELAY_FCONTROL_500KHZ (1 << DIALOG7212_CP_DELAY_FCONTROL_SHIFT)
#define DIALOG7212_CP_DELAY_FCONTROL_250KHZ (2 << DIALOG7212_CP_DELAY_FCONTROL_SHIFT)
#define DIALOG7212_CP_DELAY_FCONTROL_125KHZ (3 << DIALOG7212_CP_DELAY_FCONTROL_SHIFT)
#define DIALOG7212_CP_DELAY_FCONTROL_63KHZ (4 << DIALOG7212_CP_DELAY_FCONTROL_SHIFT)
#define DIALOG7212_CP_DELAY_FCONTROL_0HZ_OR_1MHZ (5 << DIALOG7212_CP_DELAY_FCONTROL_SHIFT)

/* DIALOG7212_CP_DETECTOR                        0x97 */
#define DIALOG7212_CP_DETECTOR_DROP_MASK (0x03)
#define DIALOG7212_CP_DETECTOR_DROP_SHIFT (0)
#define DIALOG7212_CP_DETECTOR_DROP_25MV (0 << DIALOG7212_CP_DETECTOR_DROP_SHIFT)
#define DIALOG7212_CP_DETECTOR_DROP_50MV (1 << DIALOG7212_CP_DETECTOR_DROP_SHIFT)
#define DIALOG7212_CP_DETECTOR_DROP_75MV (2 << DIALOG7212_CP_DETECTOR_DROP_SHIFT)
#define DIALOG7212_CP_DETECTOR_DROP_100MV (3 << DIALOG7212_CP_DETECTOR_DROP_SHIFT)

/* DIALOG7212_DAI_OFFSET                         0x98 */
#define DIALOG7212_DAI_OFFSET_MASK (0xFF)
#define DIALOG7212_DAI_OFFSET_SHIFT (0)
#define DIALOG7212_DAI_OFFSET_VAL(x) (x << DIALOG7212_DAI_OFFSET_SHIFT)

/* DIALOG7212_DIG_CTRL                           0x99 */
#define DIALOG7212_DIG_CTRL_R_INV_MASK (1 << 7)
#define DIALOG7212_DIG_CTRL_L_INV_MASK (1 << 3)

/* DIALOG7212_ALC_CTRL2                          0x9A */
#define DIALOG7212_ALC_CTRL2_RELEASE_MASK (0xF0)
#define DIALOG7212_ALC_CTRL2_RELEASE_SHIFT (4)
#define DIALOG7212_ALC_CTRL2_RELEASE(x) (x << DIALOG7212_ALC_CTRL2_RELEASE_SHIFT)
#define DIALOG7212_ALC_CTRL2_ATTACK_MASK (0x0F)
#define DIALOG7212_ALC_CTRL2_ATTACK_SHIFT (0)
#define DIALOG7212_ALC_CTRL2_ATTACK(x) (x << DIALOG7212_ALC_CTRL2_RELEASE_SHIFT)

/* DIALOG7212_ALC_CTRL3                          0x9B */
#define DIALOG7212_ALC_CTRL3_INTEG_RELEASE_MASK (0xC0)
#define DIALOG7212_ALC_CTRL3_INTEG_RELEASE_SHIFT (6)
#define DIALOG7212_ALC_CTRL3_INTEG_RELEASE_1DIV4 (0 << DIALOG7212_ALC_CTRL3_INTEG_RELEASE_SHIFT)
#define DIALOG7212_ALC_CTRL3_INTEG_RELEASE_1DIV16 (1 << DIALOG7212_ALC_CTRL3_INTEG_RELEASE_SHIFT)
#define DIALOG7212_ALC_CTRL3_INTEG_RELEASE_1DIV256 (2 << DIALOG7212_ALC_CTRL3_INTEG_RELEASE_SHIFT)
#define DIALOG7212_ALC_CTRL3_INTEG_ATTACK_MASK (0x30)
#define DIALOG7212_ALC_CTRL3_INTEG_ATTACK_SHIFT (4)
#define DIALOG7212_ALC_CTRL3_INTEG_ATTACK_1DIV4 (0 << DIALOG7212_ALC_CTRL3_INTEG_ATTACK_SHIFT)
#define DIALOG7212_ALC_CTRL3_INTEG_ATTACK_1DIV16 (1 << DIALOG7212_ALC_CTRL3_INTEG_ATTACK_SHIFT)
#define DIALOG7212_ALC_CTRL3_INTEG_ATTACK_1DIV256 (2 << DIALOG7212_ALC_CTRL3_INTEG_ATTACK_SHIFT)
#define DIALOG7212_ALC_CTRL3_HOLD_MASK (0x0F)
#define DIALOG7212_ALC_CTRL3_HOLD_SHIFT (0)
#define DIALOG7212_ALC_CTRL3_HOLD(x) (x << DIALOG7212_ALC_CTRL3_HOLD_SHIFT)

/* DIALOG7212_ALC_NOISE                          0x9C */
#define DIALOG7212_ALC_NOISE_MASK (0x3F)
#define DIALOG7212_ALC_NOISE_SHIFT (0)
#define DIALOG7212_ALC_NOISE_VAL(x) (x << DIALOG7212_ALC_NOISE_SHIFT)

/* DIALOG7212_ALC_TARGET_MIN                     0x9D */
#define DIALOG7212_ALC_TARGET_MIN_THRESHOLD_MIN_MASK (0x3F)
#define DIALOG7212_ALC_TARGET_MIN_THRESHOLD_MIN_SHIFT (0)
#define DIALOG7212_ALC_TARGET_MIN_THRESHOLD_MIN(x) (x << DIALOG7212_ALC_TARGET_MIN_THRESHOLD_MIN_SHIFT)

/* DIALOG7212_ALC_TARGET_MAX                     0x9E */
#define DIALOG7212_ALC_TARGET_MAX_THRESHOLD_MAX_MASK (0x3F)
#define DIALOG7212_ALC_TARGET_MAX_THRESHOLD_MAX_SHIFT (0)
#define DIALOG7212_ALC_TARGET_MAX_THRESHOLD_MAX(x) (x << DIALOG7212_ALC_TARGET_MAX_THRESHOLD_MIN_SHIFT)

/* DIALOG7212_ALC_GAIN_LIMITS                    0x9F */
#define DIALOG7212_ALC_GAIN_LIMITS_GAIN_MAX_MASK (0xF0)
#define DIALOG7212_ALC_GAIN_LIMITS_GAIN_MAX_SHIFT (4)
#define DIALOG7212_ALC_GAIN_LIMITS_GAIN_MAX(x) (x << DIALOG7212_ALC_GAIN_LIMITS_GAIN_MAX_SHIFT)
#define DIALOG7212_ALC_GAIN_LIMITS_ATTEN_MAX_MASK (0x0F)
#define DIALOG7212_ALC_GAIN_LIMITS_ATTEN_MAX_SHIFT (0)
#define DIALOG7212_ALC_GAIN_LIMITS_ATTEN_MAX(x) (x << DIALOG7212_ALC_GAIN_LIMITS_ATTEN_MAX_SHIFT)

/* DIALOG7212_ALC_ANA_GAIN_LIMITS                0xA0 */
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_MASK (0x70)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT (4)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_0DB (1 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_6DB (2 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_12DB (3 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_18DB (4 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_24DB (5 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_30DB (6 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_36DB (7 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MAX_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_MASK (0x07)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT (0)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_0DB (1 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_6DB (2 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_12DB (3 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_18DB (4 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_24DB (5 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_30DB (6 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)
#define DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_36DB (7 << DIALOG7212_ALC_ANA_GAIN_LIMITS_MIN_SHIFT)

/* DIALOG7212_ALC_ANTICLIP_CTRL                  0xA1 */
#define DIALOG7212_ALC_ANTICLIP_CTRL_EN_MASK (1 << 7)

/* DIALOG7212_ALC_ANTICLIP_LEVEL                 0xA2 */
#define DIALOG7212_ALC_ANTICLIP_LEVEL_MASK (0x7F)
#define DIALOG7212_ALC_ANTICLIP_LEVEL_SHIFT (0)
#define DIALOG7212_ALC_ANTICLIP_LEVEL_VAL(x) (x << DIALOG7212_ALC_ANTICLIP_LEVEL_SHIFT)

/* DIALOG7212_DAC_NG_SETUP_TIME                  0xAF */
#define DIALOG7212_DAC_NG_SETUP_TIME_RAMPDN_RATE_MASK (1 << 3)
#define DIALOG7212_DAC_NG_SETUP_TIME_RAMPUP_RATE_MASK (1 << 2)
#define DIALOG7212_DAC_NG_SETUP_TIME_MASK (0x03)
#define DIALOG7212_DAC_NG_SETUP_TIME_SHIFT (0)
#define DIALOG7212_DAC_NG_SETUP_TIME_256 (1 << DIALOG7212_DAC_NG_SETUP_TIME_SHIFT)
#define DIALOG7212_DAC_NG_SETUP_TIME_512 (2 << DIALOG7212_DAC_NG_SETUP_TIME_SHIFT)
#define DIALOG7212_DAC_NG_SETUP_TIME_1024 (3 << DIALOG7212_DAC_NG_SETUP_TIME_SHIFT)
#define DIALOG7212_DAC_NG_SETUP_TIME_2048 (4 << DIALOG7212_DAC_NG_SETUP_TIME_SHIFT)

/* DIALOG7212_DAC_NG_OFF_THRESH                  0xB0 */
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_MASK (0x07)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT (0)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N90DB (0 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N84DB (1 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N78DB (2 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N72DB (3 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N66DB (4 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N60DB (5 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N54DB (6 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_OFF_THRESHOLD_N48DB (7 << DIALOG7212_DAC_NG_OFF_THRESHOLD_SHIFT)

/* DIALOG7212_DAC_NG_ON_THRESH                   0xB1 */
#define DIALOG7212_DAC_NG_ON_THRESHOLD_MASK (0x07)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT (0)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N90DB (0 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N84DB (1 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N78DB (2 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N72DB (3 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N66DB (4 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N60DB (5 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N54DB (6 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)
#define DIALOG7212_DAC_NG_ON_THRESHOLD_N48DB (7 << DIALOG7212_DAC_NG_ON_THRESHOLD_SHIFT)

/* DIALOG7212_DAC_NG_CTRL                        0xB2 */
#define DIALOG7212_DAC_NG_CTRL_EN_MASK (1 << 7)

/*************Tone Generation & Beep Registers************/
/* DIALOG7212_TONE_GEN_CFG1                      0xB4 */
#define DIALOG7212_TONE_GEN_CFG1_START_STOPN_MASK (1 << 7)
#define DIALOG7212_TONE_GEN_CFG1_DMTF_EN_MASK (1 << 4)
#define DIALOG7212_TONE_GEN_CFG1_DMTF_REG_MASK (0x0F)
#define DIALOG7212_TONE_GEN_CFG1_DMTF_REG_SHIFT (0)
#define DIALOG7212_TONE_GEN_CFG1_DMTF_REG(x) (x << DIALOG7212_TONE_GEN_CFG1_DMTF_REG_SHIFT)

/* DIALOG7212_TONE_GEN_CFG2                      0xB5 */
#define DIALOG7212_TONE_GEN_CFG2_GAIN_MASK (0xF0)
#define DIALOG7212_TONE_GEN_CFG2_GAIN_SHIFT (4)
#define DIALOG7212_TONE_GEN_CFG2_GAIN(x) (x << DIALOG7212_TONE_GEN_CFG2_GAIN_SHIFT)
#define DIALOG7212_TONE_GEN_CFG2_SWG_SEL_MASK (0x03)
#define DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SHIFT (0)
#define DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SUM__BOTH (0 << DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SHIFT)
#define DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SWG1_ONLY (1 << DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SHIFT)
#define DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SWG2_ONLY (2 << DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SHIFT)
#define DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SUM_BOTH (3 << DIALOG7212_TONE_GEN_CFG2_SWG_SEL_SHIFT)

/* DIALOG7212_TONE_GEN_CYCLES                    0xB6 */
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_MASK (0x07)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT (0)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_1 (0 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_2 (1 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_4 (2 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_8 (3 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_16 (4 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_32 (5 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)
#define DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_INFINITE (6 << DIALOG7212_TONE_GEN_CYCLES_BEEP_CYCLES_SHIFT)

/* DIALOG7212_TONE_GEN_FREQ1_L                   0xB7 */
#define DIALOG7212_TONE_GEN_FREQ1_L_MASK (0xFF)
#define DIALOG7212_TONE_GEN_FREQ1_L_SHIFT (0)
#define DIALOG7212_TONE_GEN_FREQ1_L_VAL(x) (x << DIALOG7212_TONE_GEN_FREQ1_L_SHIFT)

/* DIALOG7212_TONE_GEN_FREQ1_U                   0xB8 */
#define DIALOG7212_TONE_GEN_FREQ1_U_MASK (0xFF)
#define DIALOG7212_TONE_GEN_FREQ1_U_SHIFT (0)
#define DIALOG7212_TONE_GEN_FREQ1_U_VAL(x) (x << DIALOG7212_TONE_GEN_FREQ1_U_SHIFT)

/* DIALOG7212_TONE_GEN_FREQ2_L                   0xB9 */
#define DIALOG7212_TONE_GEN_FREQ2_L_MASK (0xFF)
#define DIALOG7212_TONE_GEN_FREQ2_L_SHIFT (0)
#define DIALOG7212_TONE_GEN_FREQ2_L_VAL(x) (x << DIALOG7212_TONE_GEN_FREQ2_L_SHIFT)

/* DIALOG7212_TONE_GEN_FREQ2_U                   0xBA */
#define DIALOG7212_TONE_GEN_FREQ2_U_MASK (0xFF)
#define DIALOG7212_TONE_GEN_FREQ2_U_SHIFT (0)
#define DIALOG7212_TONE_GEN_FREQ2_U_VAL(x) (x << DIALOG7212_TONE_GEN_FREQ2_U_SHIFT)

/* DIALOG7212_TONE_GEN_ON_PER                    0xBB */
#define DIALOG7212_TONE_GEN_ON_PER_BEEP_ON_PER_MASK (0x3F)
#define DIALOG7212_TONE_GEN_ON_PER_BEEP_ON_PER_SHIFT (0)
#define DIALOG7212_TONE_GEN_ON_PER_BEEP_ON_PER(x) (x << DIALOG7212_TONE_GEN_ON_PER_BEEP_ON_PER_SHIFT)

/* DIALOG7212_TONE_GEN_OFF_PER                   0xBC */
#define DIALOG7212_TONE_GEN_OFF_PER_BEEP_OFF_PER_MASK (0x3F)
#define DIALOG7212_TONE_GEN_OFF_PER_BEEP_OFF_PER_SHIFT (0)
#define DIALOG7212_TONE_GEN_OFF_PER_BEEP_OFF_PER(x) (x << DIALOG7212_TONE_GEN_OFF_PER_BEEP_OFF_PER_SHIFT)

/*************System Controller Registers(2)*************/
/* DIALOG7212_SYSTEM_STATUS                      0xE0 */
#define DIALOG7212_SYSTEM_STATUS_SC2_BUSY_MASK (1 << 1)
#define DIALOG7212_SYSTEM_STATUS_SC1_BUSY_MASK (1 << 0)

/* DIALOG7212_SYSTEM_ACTIVE                      0xFD */
#define DIALOG7212_SYSTEM_ACTIVE_MASK (1 << 0)

#define CLEAR_REGISTER (0x00)

/*! @brief DA7212 volume */
typedef enum _da7212_volume
{
    kDA7212_DACGainMute = 0x7,   /*!< Mute DAC */
    kDA7212_DACGainM72DB = 0x17, /*!< DAC volume -72db */
    kDA7212_DACGainM60DB = 0x1F, /*!< DAC volume -60db */
    kDA7212_DACGainM54DB = 0x27, /*!< DAC volume -54db */
    kDA7212_DACGainM48DB = 0x2F, /*!< DAC volume -48db */
    kDA7212_DACGainM42DB = 0x37, /*!< DAC volume -42db */
    kDA7212_DACGainM36DB = 0x3F, /*!< DAC volume -36db */
    kDA7212_DACGainM30DB = 0x47, /*!< DAC volume -30db */
    kDA7212_DACGainM24DB = 0x4F, /*!< DAC volume -24db */
    kDA7212_DACGainM18DB = 0x57, /*!< DAC volume -18db */
    kDA7212_DACGainM12DB = 0x5F, /*!< DAC volume -12db */
    kDA7212_DACGainM6DB = 0x67,  /*!< DAC volume -6bb */
    kDA7212_DACGain0DB = 0x6F,   /*!< DAC volume +0db */
    kDA7212_DACGain6DB = 0x77,   /*!< DAC volume +6db */
    kDA7212_DACGain12DB = 0x7F   /*!< DAC volume +12db */
} da7212_volume_t;

static const unsigned char ucCommands[][2] = {
    {
        DIALOG7212_DIG_ROUTING_DAI, 0x10,
    },
    {
        DIALOG7212_SR, DIALOG7212_SR_16KHZ,
    },
    {
        DIALOG7212_REFERENCES, DIALOG7212_REFERENCES_BIAS_EN_MASK,
    },
    {
        DIALOG7212_PLL_FRAC_TOP, CLEAR_REGISTER,
    },
    {
        DIALOG7212_PLL_FRAC_BOT, CLEAR_REGISTER,
    },
    {
        DIALOG7212_PLL_INTEGER, 0x20,
    },
    {
        DIALOG7212_PLL_CTRL, (DIALOG7212_PLL_INDIV_10_20MHZ | DIALOG7212_PLL_EN_MASK),
    },
    {
        DIALOG7212_DAI_CLK_MODE, (DIALOG7212_DAI_BCLKS_PER_WCLK_BCLK64),
    },
    {
        DIALOG7212_DAI_CTRL, (DIALOG7212_DAI_EN_MASK | DIALOG7212_DAI_OE_MASK | DIALOG7212_DAI_WORD_LENGTH_16B |
        DIALOG7212_DAI_FORMAT_LEFT_JUSTIFIED),
    },
    {
        DIALOG7212_DIG_ROUTING_DAC, (DIALOG7212_DIG_ROUTING_DAC_R_RSC_DAC_R | DIALOG7212_DIG_ROUTING_DAC_L_RSC_DAC_L),
    },
    {
        DIALOG7212_CP_CTRL, (DIALOG7212_CP_CTRL_EN_MASK | DIALOG7212_CP_CTRL_SMALL_SWIT_CH_FREQ_EN_MASK |
        DIALOG7212_CP_CTRL_MCHANGE_OUTPUT | DIALOG7212_CP_CTRL_MOD_CPVDD_1 |
            DIALOG7212_CP_CTRL_ANALOG_VLL_LV_BOOSTS_CP),
    },
    {
        DIALOG7212_MIXOUT_L_SELECT, (DIALOG7212_MIXOUT_L_SELECT_DAC_L_MASK),
    },
    {
        DIALOG7212_MIXOUT_R_SELECT, (DIALOG7212_MIXOUT_R_SELECT_DAC_R_MASK),
    },
    {
        DIALOG7212_DAC_L_CTRL, (DIALOG7212_DAC_L_CTRL_ADC_EN_MASK | DIALOG7212_DAC_L_CTRL_ADC_RAMP_EN_MASK),
    },
    {
        DIALOG7212_DAC_R_CTRL, (DIALOG7212_DAC_R_CTRL_ADC_EN_MASK | DIALOG7212_DAC_R_CTRL_ADC_RAMP_EN_MASK),
    },
    {
        DIALOG7212_HP_L_CTRL, (DIALOG7212_HP_L_CTRL_AMP_EN_MASK | DIALOG7212_HP_L_CTRL_AMP_RAMP_EN_MASK |
        DIALOG7212_HP_L_CTRL_AMP_ZC_EN_MASK | DIALOG7212_HP_L_CTRL_AMP_OE_MASK),
    },
    {
        DIALOG7212_HP_R_CTRL, (DIALOG7212_HP_R_CTRL_AMP_EN_MASK | DIALOG7212_HP_R_CTRL_AMP_RAMP_EN_MASK |
        DIALOG7212_HP_R_CTRL_AMP_ZC_EN_MASK | DIALOG7212_HP_R_CTRL_AMP_OE_MASK),
    },
    {
        DIALOG7212_MIXOUT_L_CTRL,
        (DIALOG7212_MIXOUT_L_CTRL_AMP_EN_MASK | DIALOG7212_MIXOUT_L_CTRL_AMP_SOFT_MIX_EN_MASK |
        DIALOG7212_MIXOUT_L_CTRL_AMP_MIX_EN_MASK),
    },
    {
        DIALOG7212_MIXOUT_R_CTRL,
        (DIALOG7212_MIXOUT_R_CTRL_AMP_EN_MASK | DIALOG7212_MIXOUT_R_CTRL_AMP_SOFT_MIX_EN_MASK |
        DIALOG7212_MIXOUT_R_CTRL_AMP_MIX_EN_MASK),
    },
    {
        DIALOG7212_CP_VOL_THRESHOLD1, (DIALOG7212_CP_VOL_THRESHOLD1_VDD2(0x32)),
    },
    {
        DIALOG7212_SYSTEM_STATUS, CLEAR_REGISTER,
    },
    {
        DIALOG7212_DAC_L_GAIN, kDA7212_DACGain0DB,
    },
    {
        DIALOG7212_DAC_R_GAIN, kDA7212_DACGain0DB,
    },
    {
        DIALOG7212_MIXIN_L_SELECT, DIALOG7212_MIXIN_L_SELECT_AUX_L_SEL_MASK,
    },
    {
        DIALOG7212_MIXIN_R_SELECT, DIALOG7212_MIXIN_R_SELECT_AUX_R_SEL_MASK,
    },
    {
        DIALOG7212_MIXIN_L_GAIN, DIALOG7212_MIXIN_L_AMP_GAIN(0x03),
    },
    {
        DIALOG7212_MIXIN_R_GAIN, DIALOG7212_MIXIN_R_AMP_GAIN(0x03),
    },
    {
        DIALOG7212_ADC_L_GAIN, DIALOG7212_ADC_L_DIGITAL_GAIN(0x6F),
    },
    {
        DIALOG7212_ADC_R_GAIN, DIALOG7212_ADC_R_DIGITAL_GAIN(0x6F),
    },
    {
        DIALOG7212_AUX_L_CTRL, DIALOG7212_AUX_L_CTRL_AMP_EN_MASK | DIALOG7212_AUX_L_CTRL_AMP_RAMP_EN_MASK |
        DIALOG7212_AUX_L_CTRL_AMP_ZC_EN_MASK,
    },
    {
        DIALOG7212_AUX_R_CTRL, DIALOG7212_AUX_R_CTRL_AMP_EN_MASK | DIALOG7212_AUX_R_CTRL_AMP_RAMP_EN_MASK |
        DIALOG7212_AUX_R_CTRL_AMP_ZC_EN_MASK,
    },
    {
        DIALOG7212_MIXIN_L_CTRL, DIALOG7212_MIXIN_L_CTRL_AMP_EN_MASK | DIALOG7212_MIXIN_L_CTRL_AMP_MIX_EN_MASK,
    },
    {
        DIALOG7212_MIXIN_R_CTRL, DIALOG7212_MIXIN_R_CTRL_AMP_EN_MASK | DIALOG7212_MIXIN_R_CTRL_AMP_MIX_EN_MASK,
    },
    {
        DIALOG7212_ADC_L_CTRL, DIALOG7212_ADC_L_CTRL_ADC_EN_MASK | DIALOG7212_ADC_L_CTRL_ADC_RAMP_EN_MASK,
    },
    {
        DIALOG7212_ADC_R_CTRL, DIALOG7212_ADC_R_CTRL_ADC_EN_MASK | DIALOG7212_ADC_R_CTRL_ADC_RAMP_EN_MASK,
    },
};

static void fnStartApplication(void)
{
    static QUEUE_HANDLE DA7212_I2CPortID = NO_ID_ALLOCATED;
    I2CTABLE tI2CParameters;
    int i = 0;
    unsigned char ucCommand[3];
    tI2CParameters.Channel = 1;
    tI2CParameters.usSpeed = 100;                                        // 100k
    tI2CParameters.Rx_tx_sizes.TxQueueSize = (sizeof(ucCommands) * 2);   // transmit queue size
    tI2CParameters.Rx_tx_sizes.RxQueueSize = 8;                          // receive queue size
    #if defined I2C_DMA_SUPPORT && !defined DEVICE_WITHOUT_DMA
    tI2CParameters.ucDMAConfig = 0;
    #endif
    tI2CParameters.Task_to_wake = 0;                                     // no wake on transmission
    DA7212_I2CPortID = fnOpen(TYPE_I2C, FOR_I_O, &tI2CParameters);       // open the channel with defined configurations
    ucCommand[0] = DA7212_WRITE_ADDRESS;
    while (i < (sizeof(ucCommands)/2)) {                                 // write the configuration sequence
        ucCommand[1] = ucCommands[i][0];
        ucCommand[2] = ucCommands[i][1];
        fnWrite(DA7212_I2CPortID, ucCommand, 3);
        i++;
    }
}
#endif

#if !defined MIC_ONLY
static void fnAudioOut(QUEUE_HANDLE audioHandle, QUEUE_TRANSFER queue_size)
{
    // Configure audio output (DAC based on DMA transfer from USB buffer)
    //
    USBQUE *ptrUsbQueIn = (USBQUE *)(que_ids[audioHandle - 1].input_buffer_control); // usb input queue
    unsigned short *ptrBufIn = (unsigned short *)ptrUsbQueIn->USB_queue.QUEbuffer; // usb input queue buffer (assumed to be long word aligned)
    PIT_SETUP pit_setup;                                                 // PIT configuration 
        #if defined SUPPORT_I2S_SAI
    extern void fnStartApplication(void);
    #define SYNC_BITS     (16)
    I2S_SAI_SETUP I2S_setup;
    fnDebugMsg("Initialising I2S: ");
    I2S_setup.int_type = I2S_SAI_INTERRUPT;
    I2S_setup.int_handler = 0;                                           // no user interrupt callback
    I2S_setup.int_priority = 0;
    I2S_setup.ucSynchBits = SYNC_BITS;

    I2S_setup.ulI2S_SAI_buffer_length = queue_size;
    I2S_setup.ucDmaChannel = 0;                                          // use DMA channel 0
    I2S_setup.usDmaTriggerSource = DMAMUX0_CHCFG_SOURCE_I2S0_TX;         // trigger on I2S tx empty
    I2S_setup.int_handler = buffer_wrap;                                 // interrupt callback
    I2S_setup.ptrI2S_SAI_Buffer = ptrBufIn;                              // copy from the USB input buffer
    I2S_setup.I2S_SAI_mode = (I2S_SAI_CONFIG_TX | I2S_SAI_FULL_BUFFER_DMA | I2S_SAI_FULL_BUFFER_DMA_AUTO_REPEAT); // enable automatic KL DMA buffer restart using driver interrupt
    fnConfigureInterrupt((void *)&I2S_setup);                            // configure I2S transmitter

    I2S_setup.ucDmaChannel = 1;                                          // use DMA channel 1
    I2S_setup.int_handler = 0;                                           // no interrupt handler
    I2S_setup.usDmaTriggerSource = DMAMUX0_CHCFG_SOURCE_I2S0_RX;         // trigger on I2S rx availabe
    I2S_setup.ptrI2S_SAI_Buffer = ptrBufIn;                              // copy to the USB output buffer
    I2S_setup.I2S_SAI_mode = (I2S_SAI_ENABLE_TX | I2S_SAI_ENABLE_RX | I2S_SAI_CONFIG_RX | I2S_SAI_FULL_BUFFER_DMA | I2S_SAI_FULL_BUFFER_DMA_AUTO_REPEAT); // enable automatic KL DMA buffer restart using driver interrupt
    fnConfigureInterrupt((void *)&I2S_setup);                            // configure I2S receiver
    fnStartApplication();
        #else
    DAC_SETUP dac_setup;                                                 // DAC configuration parameters
    dac_setup.int_type = DAC_INTERRUPT;
    dac_setup.int_dac_controller = 0;                                    // DAC 0
    dac_setup.int_handler = buffer_wrap;                                 // DMA interrupt handler
    dac_setup.int_priority = 0;                                          // highest priority
    dac_setup.dac_mode = (DAC_ENABLE | DAC_OUTPUT_VALUE | DAC_CONFIGURE | DAC_REF_VDDA | DAC_NON_BUFFERED_MODE | DAC_FULL_BUFFER_DMA); // configure the DAC to use VDDA as reference voltage in non-buffered mode (using DMA, which is initially disabled)
            #if defined KINETIS_KL
    dac_setup.dac_mode |= DAC_FULL_BUFFER_DMA_AUTO_REPEAT;
            #endif
    dac_setup.ptrDAC_Buffer = (unsigned short *)ptrBufIn;                // copy from the USB buffer
    dac_setup.ulDAC_buffer_length = queue_size;                          // the buffer's physical length
    dac_setup.ucDmaChannel = 0;                                          // DMA channel 0 used
    dac_setup.usDmaTriggerSource = DMAMUX0_DMA0_CHCFG_SOURCE_PIT0;       // PIT0 triggers the channel mux
    dac_setup.dac_mode |= DAC_HW_TRIGGER_MODE;                           // use HW trigger mode rather than SW triggered mode (this requires PIT to trigger it)
    dac_setup.usOutputValue = 0x0800;                                    // prime first value to mid-voltage
    fnConfigureInterrupt((void *)&dac_setup);                            // configure DAC but don't start DMA operation yet
        #endif
    pit_setup.int_type = PIT_INTERRUPT;                                  // configure PIT(s)
    pit_setup.ucPIT = 1;                                                 // use PIT1 - for synchronisation measurement/USB watchdog
    pit_setup.int_handler = usb_watchdog;                                // interrupt handler when USB interrupts stop
    pit_setup.int_priority = PIT1_INTERRUPT_PRIORITY;                    // USB watchdog interrupt priority
    pit_setup.count_delay = PIT_MS_DELAY(USB_WATCHDOG);                  // USB watchdog cycle, which will not be reached when the USB is in use
    pit_setup.mode = (PIT_PERIODIC);                                     // periodic (DMA) trigger
    fnConfigureInterrupt((void *)&pit_setup);                            // configure PIT1 to free-run
    PIT_TCTRL1 = 0;                                                      // immediately stop the timer - it will be enabled on USB reception
        #if !defined SUPPORT_I2S_SAI
    pit_setup.ucPIT = 0;                                                 // use PIT0 - for DAC conversion trigger
    pit_setup.int_handler = 0;                                           // no interrupt since the PIT will be used for triggering DMA
    pit_setup.count_delay = PIT_FREERUN_FREQ(SAMPLING_FREQUENCY);
    fnConfigureInterrupt((void *)&pit_setup);                            // configure PIT 0 to free-run at 48MHz and trigger DMA copies to the DAC (DMA triggering not enabled initially)

  //_CONFIG_PERIPHERAL(C, 7, PC_7_audio_USB_SOF_OUT);                    // USB SOFs can be signalled on this pin
        #endif
}
#endif

#if defined MIC_ONLY && !defined SPEAKER_ONLY                            // {52}
    #if defined TEENSY_3_6
        #define SIGNAL_PING_1() _CLEARBITS(D, PORTD_BIT5)
        #define SIGNAL_PING_2() _SETBITS(D, PORTD_BIT5)
    #elif defined FRDM_K66F
        #define SIGNAL_PING_1() _CLEARBITS(A, PORTA_BIT1)
        #define SIGNAL_PING_2() _SETBITS(A, PORTA_BIT1)
    #else
        #define SIGNAL_PING_1()
        #define SIGNAL_PING_2()
    #endif

static QUEUE_TRANSFER mic_output_queue_size = 0;
static unsigned short *mic_buffer = 0;
static int iAudioADC_PingPong = 0;
#if defined MIC_STEREO
    static unsigned short *ADC_buffer0 = 0;
    static unsigned short *ADC_buffer1 = 0;
#endif

static void fnEnableAudio(int iChannel)
{
    uDisable_Interrupt();
        iAudioADC_PingPong &= ~2;                                        // allow operation to restart after a new enumeration has taken place
    uEnable_Interrupt();
}

// Interrupt when ADC has filled half the buffer
//
static void __callback_interrupt Mic_half_buffer_interrupt(void)
{
    int iHalfLength = (mic_output_queue_size / (2 * sizeof(unsigned short)));
    unsigned short *ptrSingleEnded;
    #if defined MIC_STEREO
    unsigned short *_ADC_buffer0;
    unsigned short *_ADC_buffer1;
    #endif
    iAudioADC_PingPong ^= 1;
    if ((iAudioADC_PingPong & 1) != 0) {                                 // first half of buffer has been filled
        SIGNAL_PING_1();
        LOAD_PIT(2, 0xffffffff);                                         // reset PIT counter
        PIT_TCTRL2 = (PIT_TCTRL_TEN);
        SIGNAL_PING_2();
        ptrSingleEnded = (mic_buffer);
    #if defined MIC_STEREO
        _ADC_buffer0 = ADC_buffer0;
        _ADC_buffer1 = ADC_buffer1;
        iHalfLength /= 2;
    #endif
        while (iHalfLength-- > 0) {
    #if defined MIC_STEREO
            unsigned short usValue = (*_ADC_buffer0++ - 0x7fff);         // convert to differential
            *ptrSingleEnded++ = usValue;                                 // insert first channel
            usValue = (*_ADC_buffer1++ - 0x7fff);                        // convert to differential
            *ptrSingleEnded++ = usValue;                                 // insert second channel
    #else
            *ptrSingleEnded++ -= 0x7fff;                                 // convert to differential
    #endif
        }
        SIGNAL_PING_1();
    }
    else {                                                               // second half of the buffer has been filled
        SIGNAL_PING_2();
        SIGNAL_PING_1();
        ptrSingleEnded = (mic_buffer + iHalfLength);
    #if defined MIC_STEREO
        iHalfLength /= 2;
        _ADC_buffer0 = (ADC_buffer0 + iHalfLength);
        _ADC_buffer1 = (ADC_buffer1 + iHalfLength);
    #endif
        while (iHalfLength-- > 0) {
    #if defined MIC_STEREO
            unsigned short usValue = (*_ADC_buffer0++ - 0x7fff);         // convert to differential
            *ptrSingleEnded++ = usValue;                                 // insert first channel
            usValue = (*_ADC_buffer1++ - 0x7fff);
            *ptrSingleEnded++ = usValue;                                 // insert second channel
    #else
            *ptrSingleEnded++ -= 0x7fff;                                 // convert to differential 
    #endif
        }
        SIGNAL_PING_2();
    }

    if (iAudioADC_PingPong == 1) {                                       // the first half of the buffer has been prepared but transmission has not yet been started
        if (fnWrite(USBPortID_Audio, 0, mic_output_queue_size) != 0) {   // release first half buffer synchronised to the time the ADC half buffer full ocurred
            fnDebugMsg("Microphone transmission started\r\n");
            iAudioADC_PingPong = 3;
        }
        else {
            fnDebugMsg(".");                                             // USB not yet ready to send
        }
    }
    else {                                                               // a complete buffer has been prepared and a buffer wrap is taking place

    }
}

#if defined IN_COMPLETE_CALLBACK
    #if defined TEENSY_3_6
        #define SIGNAL_COMPLETE_1() _CLEARBITS(D, PORTD_BIT6)
        #define SIGNAL_COMPLETE_2() _SETBITS(D, PORTD_BIT6)
    #else
        #define SIGNAL_COMPLETE_1() _CLEARBITS(A, PORTA_BIT9)
        #define SIGNAL_COMPLETE_2() _SETBITS(A, PORTA_BIT9)
    #endif

// USB callback when the last buffer half was sent to the host
//
static void __callback_interrupt mic_in_complete(unsigned char ucEndpoin)
{
    static int iTest = 0;
    static int iDrifet = 0;
    if (iTest == 0) {
        unsigned long ulSample = PIT_CVAL2;
        SIGNAL_COMPLETE_1();
        fnWrite(USBPortID_Audio, 0, 0);                           // release the first half of the ADC buffer
        iTest = 1;
        PIT_TCTRL2 = 0;
        if (++iDrifet >= 500) {
            iDrifet = 0;
            fnDebugMsg("Drift = ");
            ulSample = (0xffffffff - ulSample);
            fnDebugDec(ulSample, WITH_CR_LF);
        }
    }
    else if (iTest == 1) {
        SIGNAL_COMPLETE_2();
        fnWrite(USBPortID_Audio, 0, 0);                           // release the second half of the ADC buffer
        iTest = 0;
    }
}
#endif

static void fnAudioIn(QUEUE_HANDLE audioHandle, QUEUE_TRANSFER queue_size)
{
    // Configure audio input (ADC microphone input to USB buffer)
    //
    USBQUE *ptrUsbQueOut = (USBQUE *)(que_ids[audioHandle - 1].output_buffer_control); // usb output queue
    unsigned short *ptrBufIn = (unsigned short *)ptrUsbQueOut->USB_queue.QUEbuffer; // usb output queue buffer (assumed to be long word aligned)
    #if defined MIC_STEREO
    unsigned short *ptrDummy0 = (unsigned short *)uMalloc(queue_size/2); // ADC0 sample buffer
    unsigned short *ptrDummy1 = (unsigned short *)uMalloc(queue_size/2); // ADC1 sample buffer
    #endif
    PIT_SETUP pit_setup;                                                 // PIT configuration 
    #if defined SUPPORT_I2S_SAI
    // To do if required
    //
    #else
    ADC_SETUP adc_setup;                                                 // interrupt configuration parameters
        #if defined TEENSY_3_6
    #define CONFIG_TEST_OUTPUTS() _CONFIG_DRIVE_PORT_OUTPUT_VALUE(D, (PORTD_BIT5 | PORTD_BIT6), (PORTD_BIT5 | PORTD_BIT6),  (PORT_SRE_SLOW | PORT_DSE_HIGH))
        #elif defined FRDM_K66F
    #define CONFIG_TEST_OUTPUTS() _CONFIG_DRIVE_PORT_OUTPUT_VALUE(A, (PORTA_BIT1 | PORTA_BIT9), (PORTA_BIT1 | PORTA_BIT9),  (PORT_SRE_SLOW | PORT_DSE_HIGH))
        #else
    #define CONFIG_TEST_OUTPUTS()
        #endif
    CONFIG_TEST_OUTPUTS();
    // Configure ADC1 operation
    //
    adc_setup.int_type = ADC_INTERRUPT;                                  // identifier when configuring
        #if !defined DEVICE_WITHOUT_DMA
    adc_setup.dma_int_priority = 3;                                      // priority of DMA interrupt the user wants to set
    adc_setup.ucDmaChannel = 1;                                          // DMA channel 1 used
    adc_setup.dma_int_handler = Mic_half_buffer_interrupt;               // interrupt called when the buffer is half full
            #if defined MIC_STEREO
    adc_setup.ptrADC_Buffer = (short signed *)ptrDummy1;                 // ADC1 sample buffer to be used
    adc_setup.ulADC_buffer_length = (queue_size/2);                      // physical length of the buffer
            #else
    adc_setup.ptrADC_Buffer = (short signed *)ptrBufIn;                  // ADC sample buffer to be used
    adc_setup.ulADC_buffer_length = queue_size;                          // physical length of the buffer
            #endif
    adc_setup.usDmaTriggerSource = DMAMUX0_CHCFG_SOURCE_ADC1;            // trigger DMA when ADC1 sample completes
        #endif
        #if !defined KINETIS_KE
    adc_setup.pga_gain = PGA_GAIN_OFF;                                   // PGA gain can be specified for certain inputs
        #endif
    adc_setup.int_priority = PRIORITY_ADC;                               // ADC interrupt priority
    adc_setup.int_adc_controller = 1;                                    // ADC controller 1
    adc_setup.int_handler = 0;                                           // no interrupt used
    adc_setup.int_adc_int_type = (ADC_SINGLE_SHOT_TRIGGER_INT);          // interrupt type
    adc_setup.int_adc_offset = 0;                                        // no offset
        #if defined TEENSY_3_6
    adc_setup.int_adc_bit = ADC_SE9_SINGLE;
        #else
    adc_setup.int_adc_bit = ADC_SE14_SINGLE;
        #endif
        #if !defined _iMX
    adc_setup.int_adc_bit_b = ADC_TEMP_SENSOR;                           // input B is only valid when using HW triggered mode
        #endif
    adc_setup.int_adc_mode = (ADC_CALIBRATE | ADC_HALF_BUFFER_DMA | ADC_SELECT_INPUTS_A | ADC_CLOCK_BUS_DIV_2 | ADC_CLOCK_DIVIDE_2 | /*ADC_SAMPLE_ACTIVATE_LONG |*/ ADC_CONFIGURE_ADC | ADC_REFERENCE_VREF | ADC_CONFIGURE_CHANNEL | ADC_SINGLE_ENDED_INPUT | ADC_SINGLE_SHOT_MODE | ADC_16_BIT_MODE | ADC_HW_TRIGGERED); // hardware triggering example (DMA to buffer with interrupt on half-buffer completion) - requires PDB set up afterwards
    adc_setup.int_adc_sample = (ADC_SAMPLE_LONG_PLUS_2 | ADC_SAMPLE_AVERAGING_OFF); // no additional sampling clocks
        #if !defined DEVICE_WITH_eDMA
    adc_setup.int_adc_mode |= ADC_FULL_BUFFER_DMA_AUTO_REPEAT;           // automated DMA (using interrupt) restart when not using modulo repetitions
        #endif
    fnConfigureInterrupt((void *)&adc_setup);                            // configure ADC1 but don't start DMA operation yet

        #if defined MIC_STEREO
    // Configure ADC0 operation
    //
    adc_setup.int_adc_controller = 0;                                    // ADC controller 0
            #if !defined DEVICE_WITHOUT_DMA
    adc_setup.dma_int_priority = 3;                                      // priority of DMA interrupt the user wants to set
    adc_setup.ucDmaChannel = 2;                                          // DMA channel 2 used
    adc_setup.dma_int_handler = 0;                                       // no interrupt used because ADC1 and ADC0 are synchronised and the ADC1 half buffer interrupt is used for both
    adc_setup.usDmaTriggerSource = DMAMUX0_CHCFG_SOURCE_ADC0;            // trigger DMA when ADC0 sample completes
            #endif
    adc_setup.int_adc_bit = ADC_SE5_SINGLE;                              // ADC0_SE5b input
    adc_setup.int_adc_mode |= ADC_SELECT_INPUTS_B;
    adc_setup.ptrADC_Buffer = (short signed *)ptrDummy0;                 // ADC0 sample buffer to be used
    fnConfigureInterrupt((void *)&adc_setup);                            // configure ADC0 but don't start DMA operation yet
        #endif
    #endif

    pit_setup.int_type = PIT_INTERRUPT;                                  // configure PIT(s)
    pit_setup.ucPIT = 2;                                                 // use PIT2 - for synchronisation measurement/USB watchdog
  //pit_setup.int_handler = usb_watchdog;                                // interrupt handler when USB interrupts stop
    pit_setup.int_handler = 0;
    pit_setup.int_priority = PIT2_INTERRUPT_PRIORITY;                    // USB watchdog interrupt priority
    pit_setup.count_delay = PIT_MS_DELAY(USB_WATCHDOG);                  // USB watchdog cycle, which will not be reached when the USB is in use
    pit_setup.mode = (PIT_PERIODIC);                                     // periodic operation
    fnConfigureInterrupt((void *)&pit_setup);                            // configure PIT1 to free-run
    PIT_TCTRL2 = 0;                                                      // immediately stop the timer - it will be enabled on USB reception

    pit_setup.int_handler = 0;                                           // no interrupt since the PIT will be used for triggering DMA
    pit_setup.count_delay = PIT_FREERUN_FREQ(SAMPLING_FREQUENCY);        // the trigger frequency
    pit_setup.ucPIT = 1;                                                 // use PIT1 - for ADC1 conversion trigger
    pit_setup.mode = (PIT_PERIODIC | PIT_TRIGGER_ADC0_A | PIT_TRIGGER_ADC1_A); // periodic (ADC) trigger
    fnConfigureInterrupt((void *)&pit_setup);                            // configure PIT 1 to free-run at the sampling frequency and trigger ADC0 and ADC1 conversion
    mic_output_queue_size = queue_size;                                  // the size of the USB buffer
    mic_buffer = ptrBufIn;                                               // pointer to the location of the USB buffer
    #if defined MIC_STEREO
    ADC_buffer0 = ptrDummy0;                                             // location of ADC0 input buffer
    ADC_buffer1 = ptrDummy1;                                             // location of ADC1 input buffer
    #endif
}
#endif

#if defined AUDIO_FFT                                                    // {42}
static float windowing_buffer[FFT_INPUT_SAMPLES] = {0};                  // windowing coefficients
static float window_conversionFactor = 1.0;                              // scaling factor due to windowing

static void fnPerformFFT(int iBufferReference)
{
    int iInputSample;
    int iOutputSample = 0;
    int iInputOffset = 0;
    int iCopyLength = FFT_INPUT_SAMPLES;
    float fft_magnitude_buffer[(FFT_INPUT_SAMPLES/2)];                   // temporary fft frequency amplitude output
    signed short sRawInput[FFT_INPUT_SAMPLES];                           // temporary linear input buffer with original waveform
    switch (iBufferReference) {
    case EVENT_FFT_HALF_PONG:
        iInputOffset = (FFT_INPUT_SAMPLES/2);
        iInputSample = (FFT_INPUT_SAMPLES/4);
        break;
    case EVENT_FFT_PONG:
        iInputOffset = (FFT_INPUT_SAMPLES);
        iInputSample = (FFT_INPUT_SAMPLES/2);
        break;
    case EVENT_FFT_HALF_PING:
        iInputOffset = (2 *(3 * FFT_INPUT_SAMPLES/4));
        uMemcpy(&sRawInput[0], &fft_buffer[(3 * FFT_INPUT_SAMPLES / 4)], ((FFT_INPUT_SAMPLES / 2) * sizeof(signed short))); // handle the circular buffer wrap around in this case
        iOutputSample = (FFT_INPUT_SAMPLES / 2);
        iCopyLength = (FFT_INPUT_SAMPLES / 2);
        // Fall-through intentionally
        //
    case EVENT_FFT_PING:
    default:
        iInputSample = 0;
        break;
    }
    uMemcpy(&sRawInput[iOutputSample], &fft_buffer[iInputSample], (iCopyLength * sizeof(signed short)));
    fnFFT((void *)fft_buffer, (void *)fft_magnitude_buffer, FFT_INPUT_SAMPLES, iInputOffset, (FFT_INPUT_SAMPLES * sizeof(signed short)), windowing_buffer, window_conversionFactor, (FFT_INPUT_HALF_WORDS_SIGNED | FFT_OUTPUT_FLOATS | FFT_MAGNITUDE_RESULT)); // perform complex fast-fourier transform (the result is in the input buffer)
    #if defined BLAZE_K22
    fnDisplayFFT(fft_magnitude_buffer, sRawInput);                       // display FFT output on display
    #endif
}

// Collect each input sample into the fft buffer and trigger FFT processing each time there is a new window length available
//
static void fnCollectFFT(signed short *ptrData, unsigned short usLength)
{
    static unsigned long ulSampleCount = 0;
    while (usLength >= sizeof(unsigned short)) {
        usLength -= sizeof(unsigned short);
        fft_buffer[ulSampleCount++] = *ptrData++;                        // copy raw samples to FFT input buffer
        if (ulSampleCount == (FFT_INPUT_SAMPLES/2)) {                    // half ping buffer is full
            fnInterruptMessage(OWN_TASK, EVENT_FFT_HALF_PING);           // schedule input handling of ping buffer
        }
        else if (ulSampleCount == FFT_INPUT_SAMPLES) {                   // ping buffer is full
            fnInterruptMessage(OWN_TASK, EVENT_FFT_PING);                // schedule input handling of ping buffer
        }
        else if (ulSampleCount == ((6 * FFT_INPUT_SAMPLES)/4)) {         // half pong buffer is full
            fnInterruptMessage(OWN_TASK, EVENT_FFT_HALF_PONG);           // schedule input handling of ping buffer
        }
        else if (ulSampleCount >= (FFT_INPUT_SAMPLES * 2)) {             // pong buffer is full
            ulSampleCount = 0;                                           // set back to beginning of circular buffer
            fnInterruptMessage(OWN_TASK, EVENT_FFT_PONG);                // schedule input handling of pong buffer
        }
    }
}
#endif

        #if !defined MIC_ONLY
// An isochronous packet has just been received to the USB buffer
//
static int fnAudioPacket(unsigned char *ptrData, unsigned short usLength, int iCount, int iChannel)
{
    if (iCount == ((AUDIO_BUFFER_COUNT/2) - 1)) {                        // if the mid-packet has just been received
        // The mid-packet of the buffer has just been filled, which is the best time to start the audio output for maximum drift tolerance
        //
        #if defined SUPPORT_I2S_SAI
        if ((I2S0_TCR3 & I2S_TCR3_TCE) == 0) {                           // if the I2S is not yet operating
            I2S0_TCR3 |= (I2S_TCR3_TCE);                                 // enable rx and tx synchronously with the USB
            I2S0_RCR3 |= (I2S_RCR3_RCE);
        }
        #else
        fnDMA_BufferReset(0, DMA_BUFFER_START);                          // enable DMA buffer operation
        #endif
        SET_TEST_OUTPUT();                                               // set output high as timing reference
    }
    else if (iCount == 0) {                                              // first buffer filled
        LOAD_PIT(1, PIT_MS_DELAY(USB_WATCHDOG));                         // reset PIT counter when the reference USB frame has been received
        PIT_TCTRL1 = (PIT_TCTRL_TEN | PIT_TCTRL_TIE);                    // restart the timer with interrupt enabled
    }
        #if !defined SUPPORT_I2S_SAI
            #if defined AUDIO_FFT                                        // {42}
                #if defined _WINDOWS                                     // when simulating we can inject test signals here
    fnInjectSine(0, INJECT_SINE_HALF_WORDS_SIGNED, ptrData, usLength);   // when simulating we inject a sine wave for test purposes
                #endif
    fnCollectFFT((signed short *)ptrData, usLength);                     // collect the input to an FFT buffer (data is signed short and aligned)
            #endif
    while (usLength >= 2) {                                              // convert 16 bit PCM to 12 bit single-ended output value suitable for outputting to a 12 bit DAC
        *((unsigned short *)ptrData) ^= 0x8000;                          // signed to single-ended conversion
        *((unsigned short *)ptrData) >>= 4;                              // convert from 16 to 12 bits
        usLength -= (sizeof(unsigned short));
        ptrData += (sizeof(unsigned short));
    }
        #endif
    return BUFFER_CONSUMED;
}
        #endif
    #endif


    #if defined  TEST_PIT_SINE_TO_USB
extern void fnPrepareSignal(unsigned char *ptrBuffer, QUEUE_TRANSFER buf_length);

static QUEQUE *USB_queue = 0;

// Time base interrupt to send next buffer content (which has been prepared)
//
extern void fnUSB_TimeBase(void)
{
    #define CHUNK_SIZE (512)
    if (USB_queue != 0) {                                                // ignore if the USB is not connected or the operation has been stopped
        if (USB_queue->chars > (USB_queue->buf_length - CHUNK_SIZE)) {
            return;                                                      // if the output buffer is already full we don't add more data
        }
        USB_queue->put += CHUNK_SIZE;                                    // increment the put pointer and handle circular buffer overflow
        if (USB_queue->put >= USB_queue->buffer_end) {
            USB_queue->put = USB_queue->QUEbuffer;
        }
        USB_queue->chars += CHUNK_SIZE;                                  // the new amount of data waiting to be sent (the USB driver can start using this if it is already active)
        if ((ptrUsbCDC_TxQueue->endpoint_control->ucState & TX_ACTIVE) == 0) { // if transmission is already in progress don't initiate any more activity because the USB interrupt drier will do it
            fnStartUSB_send(ptrUsbCDC_TxQueue->endpoint_control->ucEndpointNumber, ptrUsbCDC_TxQueue, CHUNK_SIZE); // start sending message content since the USB driver was not active
        }
    }
}

// Start operation
//
static void fnUSB_stream_start(void)
{
    QUEQUE *_USB_queue = &(ptrUsbCDC_TxQueue->USB_queue);
    fnPrepareSignal(_USB_queue->QUEbuffer, _USB_queue->buf_length);       // request that the test signal be prepared into the USB output buffer
    USB_queue = _USB_queue;                                               // allow the USB transmission to take place
}

// Stop operation
//
static void fnUSB_stream_stop(int iFlush)
{
    USB_queue = 0;
    if (iFlush != 0) {
        fnFlush(USBPortID_comms[1], FLUSH_TX);
    }
}
    #endif
#endif

/********************************** keyboard timer event handling **********************************/
#if defined AUDIO_DEVICE_TIMER_EVENTS

#endif

#if defined AUDIO_INTERRUPT_EVENTS
            case EVENT_MUTE_CHANGE:
                if (iMuteOff != 0) {
                    fnDebugMsg("MUTE Off\r\n");
                }
                else {
                    fnDebugMsg("MUTE On\r\n");
                }
                break;
            case EVENT_VOLUME_CHANGE:
                fnDebugMsg("Volume: ");
                fnDebugHex(usSpeakerVolume, (sizeof(usSpeakerVolume) | WITH_CR_LF));
                break;
    #if defined AUDIO_FFT                                                // {42}
            case EVENT_FFT_HALF_PONG:                                    // input buffers are ready (and remain stable for another collection period)
            case EVENT_FFT_PONG:
            case EVENT_FFT_HALF_PING:
            case EVENT_FFT_PING:
                fnPerformFFT((int)ucInputMessage[MSG_INTERRUPT_EVENT]);  // perform an FFT transform on the buffer
                break;
    #endif
#endif

#if defined AUDIO_DEVICE_USB_EVENTS
    #if USB_AUDIO_DEVICE_REF == 1
            case E_USB_SET_INTERFACE_1:
    #else
            case E_USB_SET_INTERFACE:
    #endif
                {
                    unsigned short usAltSetting;
                    unsigned short usInterface;
                    uMemcpy(&usAltSetting, &ucInputMessage[MSG_CONTENT_DATA_START], sizeof(usAltSetting));
                    uMemcpy(&usInterface, &ucInputMessage[MSG_CONTENT_DATA_START + sizeof(usAltSetting)], sizeof(usInterface));
                    if (usInterface == AUDIO_SINK_INTERFACE) {
                        fnDebugMsg("Sink ");
                        if (usAltSetting == 1) {                         // active
                        }
                        else {                                           // zero bandwith
                        }
                    }
                    else if (usInterface == AUDIO_SOURCE_INTERFACE) {
                        fnDebugMsg("Source ");
                        if (usAltSetting == 1) {                         // active
                            fnDriver(USBPortID_Audio, (TX_ON), 0);       // enable continuous isochronous transmission
                        }
                        else {                                           // zero bandwith
                            fnDriver(USBPortID_Audio, (TX_OFF), 0);      // disable continuous transmission
                        }
                    }
                    if (usAltSetting == 1) {
                        fnDebugMsg("active\r\n");
                    }
                    else {
                        fnDebugMsg("zero-bandwith\r\n");
                    }
                }
                break;
#endif
